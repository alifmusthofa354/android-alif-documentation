## **7.9 Lifecycle Components** (2 hari) ⭐⭐⭐

### **Teknologi Modern:**
- lifecycleScope
- repeatOnLifecycle
- Lifecycle-aware components
- LifecycleObserver

### **Teknologi yang Ditinggalkan:**
- Manual lifecycle handling
- onStart/onStop boilerplate
- Memory leaks dari uncancelled operations

### **Sub-topik Detail:**

#### **1. Pengenalan Lifecycle Components**
- Apa itu Lifecycle
- Lifecycle states (CREATED, STARTED, RESUMED, DESTROYED)
- Lifecycle events (ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY)
- Lifecycle-aware components
- Automatic resource management

**Mengapa Lifecycle Components:**
✅ Prevent memory leaks
✅ Automatic cleanup
✅ Reactive to lifecycle changes
✅ Simplified code
✅ Crash prevention
✅ Better resource management

#### **2. lifecycleScope**

**Basic Usage:**
```kotlin
class MainActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Automatically cancelled when activity is destroyed
        lifecycleScope.launch {
            val data = repository.getData()
            updateUI(data)
        }
    }
}
```

**Fragment lifecycleScope:**
```kotlin
class UserFragment : Fragment() {
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // Use viewLifecycleOwner for fragments
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collect { state ->
                updateUI(state)
            }
        }
    }
}
```

#### **3. repeatOnLifecycle**

**Collect Flow Safely:**
```kotlin
class MainActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        lifecycleScope.launch {
            // Collect only when STARTED, cancel when STOPPED
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { state ->
                    updateUI(state)
                }
            }
        }
    }
}
```

**Multiple Collectors:**
```kotlin
class DashboardActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // Launch multiple collectors
                launch {
                    viewModel.users.collect { users ->
                        updateUsersList(users)
                    }
                }
                
                launch {
                    viewModel.notifications.collect { notifications ->
                        updateNotifications(notifications)
                    }
                }
                
                launch {
                    viewModel.stats.collect { stats ->
                        updateStats(stats)
                    }
                }
            }
        }
    }
}
```

**Different Lifecycle States:**
```kotlin
lifecycleScope.launch {
    // Collect when CREATED
    repeatOnLifecycle(Lifecycle.State.CREATED) {
        viewModel.initData.collect { /* ... */ }
    }
}

lifecycleScope.launch {
    // Collect when STARTED (recommended for UI updates)
    repeatOnLifecycle(Lifecycle.State.STARTED) {
        viewModel.uiState.collect { /* ... */ }
    }
}

lifecycleScope.launch {
    // Collect when RESUMED (use sparingly)
    repeatOnLifecycle(Lifecycle.State.RESUMED) {
        viewModel.activeState.collect { /* ... */ }
    }
}
```

#### **4. LifecycleObserver**

**Custom Lifecycle Observer:**
```kotlin
class LocationTracker(
    private val context: Context,
    private val onLocationUpdate: (Location) -> Unit
) : LifecycleObserver {
    
    private var locationManager: LocationManager? = null
    private val locationListener = object : LocationListener {
        override fun onLocationChanged(location: Location) {
            onLocationUpdate(location)
        }
        
        override fun onProviderEnabled(provider: String) {}
        override fun onProviderDisabled(provider: String) {}
    }
    
    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    fun startTracking() {
        locationManager = context.getSystemService<LocationManager>()
        locationManager?.requestLocationUpdates(
            LocationManager.GPS_PROVIDER,
            1000,
            0f,
            locationListener
        )
    }
    
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    fun stopTracking() {
        locationManager?.removeUpdates(locationListener)
        locationManager = null
    }
}

// Usage
class MapActivity : AppCompatActivity() {
    private val locationTracker = LocationTracker(this) { location ->
        updateMap(location)
    }
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(locationTracker)
    }
}
```

**DefaultLifecycleObserver (Recommended):**
```kotlin
class MyLifecycleObserver : DefaultLifecycleObserver {
    
    override fun onCreate(owner: LifecycleOwner) {
        super.onCreate(owner)
        Log.d("Lifecycle", "onCreate")
    }
    
    override fun onStart(owner: LifecycleOwner) {
        super.onStart(owner)
        Log.d("Lifecycle", "onStart")
    }
    
    override fun onResume(owner: LifecycleOwner) {
        super.onResume(owner)
        Log.d("Lifecycle", "onResume")
    }
    
    override fun onPause(owner: LifecycleOwner) {
        super.onPause(owner)
        Log.d("Lifecycle", "onPause")
    }
    
    override fun onStop(owner: LifecycleOwner) {
        super.onStop(owner)
        Log.d("Lifecycle", "onStop")
    }
    
    override fun onDestroy(owner: LifecycleOwner) {
        super.onDestroy(owner)
        Log.d("Lifecycle", "onDestroy")
    }
}

// Usage
class MainActivity : AppCompatActivity() {
    private val observer = MyLifecycleObserver()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(observer)
    }
}
```

#### **5. Lifecycle-Aware Components**

**Media Player:**
```kotlin
class AudioPlayer(private val context: Context) : DefaultLifecycleObserver {
    
    private var mediaPlayer: MediaPlayer? = null
    
    fun playAudio(url: String) {
        mediaPlayer?.release()
        mediaPlayer = MediaPlayer().apply {
            setDataSource(url)
            prepareAsync()
            setOnPreparedListener { start() }
        }
    }
    
    override fun onPause(owner: LifecycleOwner) {
        mediaPlayer?.pause()
    }
    
    override fun onResume(owner: LifecycleOwner) {
        mediaPlayer?.start()
    }
    
    override fun onDestroy(owner: LifecycleOwner) {
        mediaPlayer?.release()
        mediaPlayer = null
    }
}

// Usage
class AudioActivity : AppCompatActivity() {
    private val audioPlayer = AudioPlayer(this)
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(audioPlayer)
        
        audioPlayer.playAudio("https://example.com/audio.mp3")
    }
}
```

**Camera Controller:**
```kotlin
class CameraController(
    private val context: Context,
    private val previewView: PreviewView
) : DefaultLifecycleObserver {
    
    private var camera: Camera? = null
    private val cameraProvider: ProcessCameraProvider by lazy {
        ProcessCameraProvider.getInstance(context).get()
    }
    
    override fun onStart(owner: LifecycleOwner) {
        startCamera(owner)
    }
    
    override fun onStop(owner: LifecycleOwner) {
        cameraProvider.unbindAll()
    }
    
    private fun startCamera(lifecycleOwner: LifecycleOwner) {
        val preview = Preview.Builder().build()
        preview.setSurfaceProvider(previewView.surfaceProvider)
        
        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA
        
        camera = cameraProvider.bindToLifecycle(
            lifecycleOwner,
            cameraSelector,
            preview
        )
    }
    
    fun takePicture(onImageCaptured: (Bitmap) -> Unit) {
        // Capture logic
    }
}
```

#### **6. Flow with Lifecycle**

**flowWithLifecycle:**
```kotlin
class MyFragment : Fragment() {
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState
                .flowWithLifecycle(viewLifecycleOwner.lifecycle, Lifecycle.State.STARTED)
                .collect { state ->
                    updateUI(state)
                }
        }
    }
}
```

**stateIn with Lifecycle:**
```kotlin
class MyViewModel : ViewModel() {
    val uiState: StateFlow<UiState> = repository.getData()
        .map { UiState.Success(it) }
        .catch { emit(UiState.Error(it.message)) }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = UiState.Loading
        )
}
```

#### **7. Process Death Handling**

**State Restoration:**
```kotlin
class MyActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Restore state if process was killed
        if (savedInstanceState != null) {
            // State already restored via SavedStateHandle
        }
        
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { state ->
                    updateUI(state)
                }
            }
        }
    }
}
```

#### **8. Best Practices**

**DO:**
```kotlin
// ✅ Use repeatOnLifecycle untuk collecting Flows
lifecycleScope.launch {
    repeatOnLifecycle(Lifecycle.State.STARTED) {
        viewModel.uiState.collect { updateUI(it) }
    }
}

// ✅ Use viewLifecycleOwner dalam Fragment
viewLifecycleOwner.lifecycleScope.launch {
    // ...
}

// ✅ Create lifecycle-aware components
class MyComponent : DefaultLifecycleObserver {
    override fun onStart(owner: LifecycleOwner) {
        // Start work
    }
    
    override fun onStop(owner: LifecycleOwner) {
        // Stop work
    }
}
```

**DON'T:**
```kotlin
// ❌ Don't collect Flows without lifecycle awareness
lifecycleScope.launch {
    viewModel.uiState.collect { updateUI(it) }  // Continues in background!
}

// ❌ Don't use Fragment's lifecycle directly
lifecycleScope.launch {  // Wrong scope!
    // Use viewLifecycleOwner.lifecycleScope instead
}

// ❌ Don't forget to clean up
class BadComponent {
    fun start() {
        // Starts work but never stops
    }
}
```

#### **9. Hands-on Exercises**
- Create lifecycle-aware location tracker
- Build audio player dengan automatic pause/resume
- Implement camera controller
- Create sensor monitor dengan lifecycle awareness
- Build WebSocket connection manager
- Implement analytics tracker
- Create notification listener
- Build background task manager

---
