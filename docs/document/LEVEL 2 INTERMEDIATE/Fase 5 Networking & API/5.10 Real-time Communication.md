

# üé® Panduan Lengkap: Real-Time Communication di Android

## üöÄ Pengantar: Komunikasi Instan di Aplikasi Modern

Bayangkan kamu adalah seorang telepatis üß† - mampu berkomunikasi secara instan tanpa jeda, seperti sistem saraf yang menghubungkan seluruh tubuh aplikasi!

Dengan menguasai Real-Time Communication, kamu bisa membangun aplikasi yang responsif, interaktif, dan memberikan pengalaman pengguna yang luar biasa!

## üìö Daftar Isi Pembelajaran
1. [üåü Real-Time Communication Methods](#1Ô∏è‚É£-real-time-communication-methods-üåü)
2. [üîå WebSocket dengan OkHttp](#2Ô∏è‚É£-websocket-dengan-okhttp-üîå)
3. [üì° Server-Sent Events (SSE)](#3Ô∏è‚É£-server-sent-events-sse-üì°)
4. [üíì Heartbeat & Reconnection](#4Ô∏è‚É£-heartbeat--reconnection-üíì)
5. [üìÆ Message Queue untuk Offline Support](#5Ô∏è‚É£-message-queue-untuk-offline-support-üìÆ)
6. [üéØ Real-Time Use Cases](#6Ô∏è‚É£-real-time-use-cases-üéØ)
7. [‚úÖ Best Practices](#7Ô∏è‚É£-best-practices-‚úÖ)
8. [üî® Hands-on Project](#8Ô∏è‚É£-hands-on-project-üî®)

---

## 1Ô∏è‚É£ Real-Time Communication Methods üåü

### Konsep Dasar
Real-Time Communication Methods seperti berbagai cara berkomunikasi jarak jauh üì° - dari surat hingga telepati, masing-masing dengan kelebihan dan kekurangannya!

### Jenis-Jenis Metode Komunikasi Real-Time:

#### 1. Polling (Tradisional - Inefisien)
**Konsep:** Klien secara berkala menanyakan ke server apakah ada data baru.
**Kelemahan:** Banyak permintaan yang sia-sia jika tidak ada data baru, konsumsi baterai, dan tidak benar-benar real-time.

```kotlin
// ‚ùå Buruk: Polling konstan
fun startPolling() {
    viewModelScope.launch {
        while (true) {
            try {
                val data = apiService.getUpdates()
                updateUI(data)
                delay(5000) // Poll setiap 5 detik
            } catch (e: Exception) {
                // Tangani error
                delay(10000) // Tunggu lebih lama jika error
            }
        }
    }
}
```

#### 2. Long Polling (Lebih Baik tapi Masih Inefisien)
**Konsep:** Klien membuat permintaan ke server, dan server menahan respons sampai ada data baru atau timeout tercapai.
**Kelemahan:** Masih menggunakan model request-response, bukan koneksi persisten.

```kotlin
// Lebih baik tapi masih tidak ideal
suspend fun startLongPolling() {
    while (true) {
        try {
            // Server akan menahan respons ini sampai ada data baru
            val data = apiService.longPollUpdates()
            updateUI(data)
        } catch (e: Exception) {
            delay(1000) // Tunggu sebelum mencoba kembali
        }
    }
}
```

#### 3. WebSocket (Terbaik untuk Komunikasi Dua Arah)
**Konsep:** Membangun koneksi persisten antara klien dan server, memungkinkan pertukaran data dua arah secara real-time.
**Keunggulan:** Latensi rendah, efisien, dan server dapat mendorong data ke klien kapan saja.

#### 4. Server-Sent Events (SSE) (Terbaik untuk Server ke Klien)
**Konsep:** Koneksi satu arah dari server ke klien melalui HTTP, di mana server dapat mendorong data ke klien.
**Keunggulan:** Protokol sederhana, otomatis terhubung kembali, dan berbasis HTTP.

### Perbandingan Metode Komunikasi:

| Metode | Arah Komunikasi | Koneksi | Latensi | Efisiensi | Use Case |
|--------|------------------|----------|---------|-----------|----------|
| **Polling** | Klien ‚Üí Server | Sementara | Tinggi | Rendah | Data yang tidak sensitif waktu |
| **Long Polling** | Klien ‚Üí Server | Sementara | Sedang | Sedang | Update yang jarang terjadi |
| **WebSocket** | Klien ‚Üî Server | Persisten | Rendah | Tinggi | Chat, kolaborasi, game |
| **SSE** | Server ‚Üí Klien | Persisten | Rendah | Tinggi | Notifikasi, feed data |

### üéì Penjelasan Konsep:
**Metode Komunikasi seperti Cara Menghubungi Teman:**
- **Polling**: Menelepon setiap 5 menit untuk bertanya "Ada apa?" (mengganggu).
- **Long Polling**: Menelepon dan menunggu di telepon sampai teman punya kabar (lebih baik tapi tetap tidak efisien).
- **WebSocket**: Membuka saluran telepon terbuka dan berbicara kapan saja (ideal).
- **SSE**: Mendapatkan saluran radio yang hanya mengirimkan pengumuman penting (satu arah tapi efisien).

---

## 2Ô∏è‚É£ WebSocket dengan OkHttp üîå

### Konsep Dasar
WebSocket dengan OkHttp seperti saluran telepon terbuka üìû - sekali terhubung, kamu bisa berbicara dan mendengar kapan saja tanpa harus menelepon lagi!

### Pengertian WebSocket:
WebSocket adalah protokol komunikasi yang menyediakan saluran komunikasi dua arah (full-duplex) melalui satu koneksi TCP yang persisten. Ini ideal untuk:
- Aplikasi chat
- Kolaborasi real-time
- Game multi-pemain
- Dashboard monitoring

### Implementasi WebSocket Manager:
**network/WebSocketManager.kt**
```kotlin
package com.example.realtime.network

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import okhttp3.WebSocket
import okhttp3.WebSocketListener
import java.util.concurrent.TimeUnit
import kotlin.math.pow

/**
 * Manager untuk koneksi WebSocket
 */
class WebSocketManager(
    private val client: OkHttpClient = OkHttpClient.Builder()
        .readTimeout(0, TimeUnit.MILLISECONDS) // No timeout for read
        .writeTimeout(0, TimeUnit.MILLISECONDS) // No timeout for write
        .build()
) {
    private var webSocket: WebSocket? = null
    private var heartbeatJob: Job? = null
    
    private val _messages = MutableSharedFlow<String>()
    val messages: SharedFlow<String> = _messages
    
    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)
    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()
    
    private val reconnectionManager = ReconnectionManager()
    
    /**
     * Menghubungkan ke WebSocket
     */
    fun connect(url: String) {
        if (_connectionState.value == ConnectionState.CONNECTED || 
            _connectionState.value == ConnectionState.CONNECTING) {
            return
        }
        
        val request = Request.Builder()
            .url(url)
            .build()
        
        webSocket = client.newWebSocket(request, createWebSocketListener(url))
    }
    
    /**
     * Memutuskan koneksi WebSocket
     */
    fun disconnect() {
        reconnectionManager.stopReconnection()
        heartbeatJob?.cancel()
        webSocket?.close(1000, "Client disconnecting")
        webSocket = null
        _connectionState.value = ConnectionState.DISCONNECTED
    }
    
    /**
     * Mengirim pesan melalui WebSocket
     */
    fun send(message: String) {
        try {
            webSocket?.send(message)
        } catch (e: Exception) {
            // Handle error
        }
    }
    
    /**
     * Membuat WebSocketListener
     */
    private fun createWebSocketListener(url: String): WebSocketListener {
        return object : WebSocketListener() {
            override fun onOpen(webSocket: WebSocket, response: Response) {
                _connectionState.value = ConnectionState.CONNECTED
                startHeartbeat()
                reconnectionManager.reset()
            }
            
            override fun onMessage(webSocket: WebSocket, text: String) {
                CoroutineScope(Dispatchers.Default).launch {
                    _messages.emit(text)
                }
            }
            
            override fun onMessage(webSocket: WebSocket, bytes: ByteString) {
                onMessage(webSocket, bytes.utf8())
            }
            
            override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
                webSocket.close(1000, null)
                _connectionState.value = ConnectionState.DISCONNECTING
            }
            
            override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
                stopHeartbeat()
                _connectionState.value = ConnectionState.DISCONNECTED
            }
            
            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
                _connectionState.value = ConnectionState.ERROR
                
                // Coba hubungkan kembali
                CoroutineScope(Dispatchers.Default).launch {
                    reconnectionManager.attemptReconnect {
                        connect(url)
                    }
                }
            }
        }
    }
    
    /**
     * Memulai heartbeat untuk menjaga koneksi tetap hidup
     */
    private fun startHeartbeat() {
        heartbeatJob = CoroutineScope(Dispatchers.Default).launch {
            while (true) {
                try {
                    send("""{"type":"ping"}""")
                    delay(30_000) // Ping setiap 30 detik
                } catch (e: Exception) {
                    break
                }
            }
        }
    }
    
    /**
     * Menghentikan heartbeat
     */
    private fun stopHeartbeat() {
        heartbeatJob?.cancel()
    }
}

/**
 * Enum untuk status koneksi
 */
enum class ConnectionState {
    DISCONNECTED, CONNECTING, CONNECTED, DISCONNECTING, ERROR
}

/**
 * Manager untuk reconnection dengan exponential backoff
 */
class ReconnectionManager {
    private var reconnectAttempts = 0
    private val maxReconnectAttempts = 5
    private val baseDelay = 1000L // 1 detik
    private var reconnectJob: Job? = null
    
    /**
     * Mencoba menghubungkan kembali dengan exponential backoff
     */
    suspend fun attemptReconnect(connectAction: suspend () -> Unit) {
        reconnectJob = CoroutineScope(Dispatchers.Default).launch {
            while (reconnectAttempts < maxReconnectAttempts && isActive) {
                try {
                    val delay = baseDelay * (2.0.pow(reconnectAttempts.toDouble())).toLong()
                    delay(delay)
                    
                    connectAction()
                    reconnectAttempts = 0
                    break
                } catch (e: Exception) {
                    reconnectAttempts++
                }
            }
        }
    }
    
    /**
     * Menghentikan proses reconnection
     */
    fun stopReconnection() {
        reconnectJob?.cancel()
        reconnectAttempts = 0
    }
    
    /**
     * Reset counter reconnection
     */
    fun reset() {
        reconnectAttempts = 0
    }
}
```

### Implementasi Repository:
**repository/ChatRepository.kt**
```kotlin
package com.example.realtime.repository

import com.example.realtime.network.WebSocketManager
import com.example.realtime.data.model.ChatMessage
import com.google.gson.Gson
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository untuk chat dengan WebSocket
 */
@Singleton
class ChatRepository @Inject constructor(
    private val webSocketManager: WebSocketManager,
    private val gson: Gson
) {
    
    /**
     * Menghubungkan ke room chat
     */
    fun connectToChat(roomId: String) {
        webSocketManager.connect("wss://api.example.com/chat/$roomId")
    }
    
    /**
     * Mengirim pesan ke chat
     */
    fun sendMessage(message: String) {
        val json = gson.toJson(mapOf(
            "type" to "message",
            "content" to message,
            "timestamp" to System.currentTimeMillis()
        ))
        webSocketManager.send(json)
    }
    
    /**
     * Mengamati pesan yang masuk
     */
    fun observeMessages(): Flow<ChatMessage> {
        return webSocketManager.messages
            .filter { isValidMessage(it) }
            .map { json ->
                gson.fromJson(json, ChatMessage::class.java)
            }
    }
    
    /**
     * Mengamati status koneksi
     */
    fun observeConnectionState() = webSocketManager.connectionState
    
    /**
     * Memutuskan koneksi dari chat
     */
    fun disconnect() {
        webSocketManager.disconnect()
    }
    
    /**
     * Memvalidasi apakah pesan valid
     */
    private fun isValidMessage(json: String): Boolean {
        return try {
            val jsonObject = gson.fromJson(json, Map::class.java)
            jsonObject["type"] == "message"
        } catch (e: Exception) {
            false
        }
    }
}
```

### Implementasi ViewModel:
**presentation/viewmodel/ChatViewModel.kt**
```kotlin
package com.example.realtime.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.realtime.data.model.ChatMessage
import com.example.realtime.network.ConnectionState
import com.example.realtime.repository.ChatRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel untuk chat
 */
@HiltViewModel
class ChatViewModel @Inject constructor(
    private val chatRepository: ChatRepository
) : ViewModel() {
    
    private val _messages = MutableStateFlow<List<ChatMessage>>(emptyList())
    val messages: StateFlow<List<ChatMessage>> = _messages.asStateFlow()
    
    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)
    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()
    
    private val _isTyping = MutableStateFlow(false)
    val isTyping: StateFlow<Boolean> = _isTyping.asStateFlow()
    
    init {
        // Mengamati pesan yang masuk
        viewModelScope.launch {
            chatRepository.observeMessages().collect { message ->
                _messages.value = _messages.value + message
            }
        }
        
        // Mengamati status koneksi
        viewModelScope.launch {
            chatRepository.observeConnectionState().collect { state ->
                _connectionState.value = state
            }
        }
    }
    
    /**
     * Menghubungkan ke room chat
     */
    fun connectToChat(roomId: String) {
        chatRepository.connectToChat(roomId)
    }
    
    /**
     * Mengirim pesan
     */
    fun sendMessage(message: String) {
        if (message.isNotBlank()) {
            chatRepository.sendMessage(message)
        }
    }
    
    /**
     * Mengatur status typing
     */
    fun setTyping(isTyping: Boolean) {
        _isTyping.value = isTyping
        // Kirim status typing ke server
        chatRepository.sendMessage(
            gson.toJson(mapOf(
                "type" to "typing",
                "isTyping" to isTyping
            ))
        )
    }
    
    /**
     * Membersihkan resources saat ViewModel dihancurkan
     */
    override fun onCleared() {
        super.onCleared()
        chatRepository.disconnect()
    }
}
```

### Implementasi UI dengan Jetpack Compose:
**presentation/ui/chat/ChatScreen.kt**
```kotlin
package com.example.realtime.presentation.ui.chat

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Send
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.example.realtime.data.model.ChatMessage
import com.example.realtime.network.ConnectionState
import com.example.realtime.presentation.ui.component.ConnectionStatusBar
import com.example.realtime.presentation.ui.component.MessageBubble
import com.example.realtime.presentation.viewmodel.ChatViewModel
import kotlinx.coroutines.launch

/**
 * Layar chat dengan real-time communication
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ChatScreen(
    roomId: String,
    viewModel: ChatViewModel = hiltViewModel()
) {
    val messages by viewModel.messages.collectAsStateWithLifecycle()
    val connectionState by viewModel.connectionState.collectAsStateWithLifecycle()
    var messageText by remember { mutableStateOf("") }
    val listState = rememberLazyListState()
    val coroutineScope = rememberCoroutineScope()
    
    // Hubungkan ke chat saat layar dibuka
    LaunchedEffect(roomId) {
        viewModel.connectToChat(roomId)
    }
    
    // Scroll ke bawah saat ada pesan baru
    LaunchedEffect(messages) {
        if (messages.isNotEmpty()) {
            coroutineScope.launch {
                listState.animateScrollToItem(messages.size - 1)
            }
        }
    }
    
    Column(
        modifier = Modifier.fillMaxSize()
    ) {
        // Status bar koneksi
        ConnectionStatusBar(connectionState = connectionState)
        
        // Daftar pesan
        LazyColumn(
            modifier = Modifier
                .weight(1f)
                .fillMaxWidth(),
            state = listState,
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(messages) { message ->
                MessageBubble(message = message)
            }
        }
        
        // Input pesan
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            OutlinedTextField(
                value = messageText,
                onValueChange = { 
                    messageText = it
                    viewModel.setTyping(it.isNotBlank())
                },
                modifier = Modifier.weight(1f),
                placeholder = { Text("Ketik pesan...") }
            )
            
            Spacer(modifier = Modifier.width(8.dp))
            
            IconButton(
                onClick = {
                    if (messageText.isNotBlank()) {
                        viewModel.sendMessage(messageText)
                        messageText = ""
                        viewModel.setTyping(false)
                    }
                },
                enabled = messageText.isNotBlank() && connectionState == ConnectionState.CONNECTED
            ) {
                Icon(Icons.Default.Send, contentDescription = "Kirim")
            }
        }
    }
}
```

### üéì Penjelasan Konsep:
**WebSocket seperti Saluran Telepon Terbuka:**
- **Koneksi**: Menelepon dan membuka saluran komunikasi.
- **Listener**: Resepsionis yang menjawab telepon dan meneruskan pesan.
- **Messages**: Percakapan yang terjadi melalui saluran tersebut.
- **Heartbeat**: Mengecek "Halo, apakah kamu masih di sana?" secara berkala.
- **Reconnection**: Menelepon kembali jika sambungan terputus.

**Alur Kerja WebSocket:**
1. **Koneksi**: Klien membuka koneksi WebSocket ke server.
2. **Handshake**: Server merespons dengan upgrade ke protokol WebSocket.
3. **Komunikasi**: Klien dan server dapat saling mengirim pesan kapan saja.
4. **Heartbeat**: Klien mengirim pesan ping secara berkala untuk menjaga koneksi tetap hidup.
5. **Penutupan**: Klien atau server dapat menutup koneksi kapan saja.

**Best Practices:**
- Gunakan WebSocket untuk komunikasi dua arah yang membutuhkan latensi rendah.
- Implementasikan heartbeat untuk mendeteksi koneksi yang terputus.
- Gunakan exponential backoff untuk reconnection agar tidak membebani server.
- Selalu bersihkan koneksi saat tidak diperlukan lagi.

---

## 3Ô∏è‚É£ Server-Sent Events (SSE) üì°

### Konsep Dasar
Server-Sent Events (SSE) seperti berlangganan siaran radio üìª - kamu hanya mendengarkan, tetapi stasiun radio dapat mengirimkan berita kapan saja!

### Pengertian Server-Sent Events:
Server-Sent Events (SSE) adalah teknologi yang memungkinkan server mendorong data ke klien melalui koneksi HTTP tunggal. Ini ideal untuk:
- Notifikasi real-time
- Feed data (berita, update harga saham)
- Update status

### Implementasi SSE Manager:
**network/SSEManager.kt**
```kotlin
package com.example.realtime.network

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.launch
import okhttp3.Call
import okhttp3.Callback
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import java.io.BufferedReader
import java.io.IOException
import java.util.concurrent.TimeUnit

/**
 * Manager untuk Server-Sent Events (SSE)
 */
class SSEManager(
    private val client: OkHttpClient = OkHttpClient.Builder()
        .readTimeout(0, TimeUnit.SECONDS) // No timeout for SSE
        .build()
) {
    private var currentCall: Call? = null
    private var reconnectJob: Job? = null
    
    private val _events = MutableSharedFlow<ServerEvent>()
    val events: SharedFlow<ServerEvent> = _events.asSharedFlow()
    
    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)
    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()
    
    /**
     * Menghubungkan ke aliran SSE
     */
    fun connect(url: String) {
        if (_connectionState.value == ConnectionState.CONNECTED || 
            _connectionState.value == ConnectionState.CONNECTING) {
            return
        }
        
        val request = Request.Builder()
            .url(url)
            .header("Accept", "text/event-stream")
            .header("Cache-Control", "no-cache")
            .build()
        
        _connectionState.value = ConnectionState.CONNECTING
        currentCall = client.newCall(request)
        
        currentCall?.enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                _connectionState.value = ConnectionState.ERROR
                
                // Coba hubungkan kembali
                reconnectJob = CoroutineScope(Dispatchers.IO).launch {
                    delay(5000)
                    connect(url)
                }
            }
            
            override fun onResponse(call: Call, response: Response) {
                if (!response.isSuccessful) {
                    _connectionState.value = ConnectionState.ERROR
                    return
                }
                
                _connectionState.value = ConnectionState.CONNECTED
                
                try {
                    response.body?.byteStream()?.bufferedReader()?.use { reader ->
                        var eventType: String? = null
                        var data = StringBuilder()
                        var id: String? = null
                        var retry: Long? = null
                        
                        reader.lineSequence().forEach { line ->
                            when {
                                line.startsWith("event:") -> {
                                    eventType = line.substringAfter("event:").trim()
                                }
                                line.startsWith("data:") -> {
                                    data.append(line.substringAfter("data:").trim()).append("\n")
                                }
                                line.startsWith("id:") -> {
                                    id = line.substringAfter("id:").trim()
                                }
                                line.startsWith("retry:") -> {
                                    retry = line.substringAfter("retry:").trim().toLongOrNull()
                                }
                                line.isBlank() -> {
                                    // Akhir dari event
                                    if (data.isNotEmpty()) {
                                        val eventData = data.toString().trimEnd()
                                        _events.emit(
                                            ServerEvent(
                                                id = id,
                                                type = eventType ?: "message",
                                                data = eventData,
                                                retry = retry
                                            )
                                        )
                                        data.clear()
                                        eventType = null
                                        id = null
                                        retry = null
                                    }
                                }
                            }
                        }
                    }
                } catch (e: Exception) {
                    _connectionState.value = ConnectionState.ERROR
                }
            }
        })
    }
    
    /**
     * Memutuskan koneksi SSE
     */
    fun disconnect() {
        reconnectJob?.cancel()
        currentCall?.cancel()
        _connectionState.value = ConnectionState.DISCONNECTED
    }
}

/**
 * Model untuk event dari SSE
 */
data class ServerEvent(
    val id: String? = null,
    val type: String,
    val data: String,
    val retry: Long? = null
)
```

### Implementasi Repository:
**repository/NotificationRepository.kt**
```kotlin
package com.example.realtime.repository

import com.example.realtime.data.model.Notification
import com.example.realtime.network.SSEManager
import com.google.gson.Gson
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository untuk notifikasi dengan SSE
 */
@Singleton
class NotificationRepository @Inject constructor(
    private val sseManager: SSEManager,
    private val gson: Gson
) {
    
    /**
     * Menghubungkan ke aliran notifikasi
     */
    fun connectToNotifications(userId: String) {
        sseManager.connect("https://api.example.com/notifications/stream/$userId")
    }
    
    /**
     * Mengamati notifikasi yang masuk
     */
    fun observeNotifications(): Flow<Notification> {
        return sseManager.events
            .filter { it.type == "notification" }
            .map { event ->
                gson.fromJson(event.data, Notification::class.java)
            }
    }
    
    /**
     * Mengamati status koneksi
     */
    fun observeConnectionState() = sseManager.connectionState
    
    /**
     * Memutuskan koneksi dari aliran notifikasi
     */
    fun disconnect() {
        sseManager.disconnect()
    }
}
```

### Implementasi ViewModel:
**presentation/viewmodel/NotificationViewModel.kt**
```kotlin
package com.example.realtime.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.realtime.data.model.Notification
import com.example.realtime.network.ConnectionState
import com.example.realtime.repository.NotificationRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel untuk notifikasi
 */
@HiltViewModel
class NotificationViewModel @Inject constructor(
    private val notificationRepository: NotificationRepository
) : ViewModel() {
    
    private val _notifications = MutableStateFlow<List<Notification>>(emptyList())
    val notifications: StateFlow<List<Notification>> = _notifications.asStateFlow()
    
    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)
    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()
    
    private val _unreadCount = MutableStateFlow(0)
    val unreadCount: StateFlow<Int> = _unreadCount.asStateFlow()
    
    init {
        // Mengamati notifikasi yang masuk
        viewModelScope.launch {
            notificationRepository.observeNotifications().collect { notification ->
                _notifications.value = _notifications.value + notification
                _unreadCount.value = _unreadCount.value + 1
            }
        }
        
        // Mengamati status koneksi
        viewModelScope.launch {
            notificationRepository.observeConnectionState().collect { state ->
                _connectionState.value = state
            }
        }
    }
    
    /**
     * Menghubungkan ke aliran notifikasi
     */
    fun connectToNotifications(userId: String) {
        notificationRepository.connectToNotifications(userId)
    }
    
    /**
     * Menandai notifikasi sebagai dibaca
     */
    fun markAsRead(notificationId: String) {
        _unreadCount.value = (_unreadCount.value - 1).coerceAtLeast(0)
        // Implementasikan logika untuk menandai notifikasi sebagai dibaca di server
    }
    
    /**
     * Membersihkan resources saat ViewModel dihancurkan
     */
    override fun onCleared() {
        super.onCleared()
        notificationRepository.disconnect()
    }
}
```

### üéì Penjelasan Konsep:
**Server-Sent Events seperti Berlangganan Siaran Radio:**
- **Koneksi**: Memilih frekuensi radio dan mengatur volume.
- **Events**: Berita atau lagu yang diputar oleh stasiun radio.
- **Data**: Isi dari berita atau lirik lagu tersebut.
- **Reconnection**: Mencari frekuensi kembali jika sinyal hilang.

**Alur Kerja SSE:**
1. **Koneksi**: Klien membuat permintaan HTTP dengan header `Accept: text/event-stream`.
2. **Server Response**: Server merespons dengan status 200 OK dan header `Content-Type: text/event-stream`.
3. **Stream**: Server mempertahankan koneksi terbuka dan mengirim data dalam format khusus.
4. **Events**: Server mengirim event dengan format `event:`, `data:`, `id:`, dan `retry:`.
5. **Disconnection**: Klien atau server dapat menutup koneksi kapan saja.

**Kapan Menggunakan SSE vs WebSocket:**
- Gunakan **SSE** untuk komunikasi satu arah (server ke klien) yang membutuhkan update real-time.
- Gunakan **WebSocket** untuk komunikasi dua arah yang membutuhkan latensi rendah.

---

## 4Ô∏è‚É£ Heartbeat & Reconnection üíì

### Konsep Dasar
Heartbeat & Reconnection seperti sistem keamanan jaringan listrik üö® - mendeteksi ketika ada masalah dan secara otomatis mencoba memperbaikinya!

### Pengertian Heartbeat & Reconnection:
- **Heartbeat**: Mekanisme untuk memastikan koneksi tetap hidup dengan mengirim pesan kecil secara berkala.
- **Reconnection**: Proses untuk mencoba menghubungkan kembali ketika koneksi terputus.

### Implementasi Heartbeat:
**network/WebSocketManager.kt (Bagian Heartbeat)**
```kotlin
class WebSocketManager {
    private var heartbeatJob: Job? = null
    
    /**
     * Memulai heartbeat untuk menjaga koneksi tetap hidup
     */
    private fun startHeartbeat() {
        heartbeatJob = CoroutineScope(Dispatchers.Default).launch {
            while (true) {
                try {
                    send("""{"type":"ping"}""")
                    delay(30_000) // Ping setiap 30 detik
                } catch (e: Exception) {
                    // Jika gagal mengirim ping, hentikan heartbeat
                    break
                }
            }
        }
    }
    
    /**
     * Menghentikan heartbeat
     */
    private fun stopHeartbeat() {
        heartbeatJob?.cancel()
    }
    
    // ... bagian lain dari WebSocketManager
}
```

### Implementasi Reconnection dengan Exponential Backoff:
**network/ReconnectionManager.kt**
```kotlin
package com.example.realtime.network

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlin.math.pow

/**
 * Manager untuk reconnection dengan exponential backoff
 */
class ReconnectionManager {
    private var reconnectAttempts = 0
    private val maxReconnectAttempts = 5
    private val baseDelay = 1000L // 1 detik
    private var reconnectJob: Job? = null
    
    /**
     * Mencoba menghubungkan kembali dengan exponential backoff
     */
    suspend fun attemptReconnect(connectAction: suspend () -> Unit) {
        reconnectJob = CoroutineScope(Dispatchers.Default).launch {
            while (reconnectAttempts < maxReconnectAttempts && isActive) {
                try {
                    val delay = baseDelay * (2.0.pow(reconnectAttempts.toDouble())).toLong()
                    
                    // Log reconnection attempt
                    println("Attempting reconnect in ${delay}ms (attempt ${reconnectAttempts + 1})")
                    
                    delay(delay)
                    
                    connectAction()
                    
                    // Jika berhasil, reset counter
                    reconnectAttempts = 0
                    break
                } catch (e: Exception) {
                    reconnectAttempts++
                    
                    // Log error
                    println("Reconnection attempt $reconnectAttempts failed: ${e.message}")
                }
            }
        }
    }
    
    /**
     * Menghentikan proses reconnection
     */
    fun stopReconnection() {
        reconnectJob?.cancel()
        reconnectAttempts = 0
    }
    
    /**
     * Reset counter reconnection
     */
    fun reset() {
        reconnectAttempts = 0
    }
}
```

### Integrasi dengan WebSocket Manager:
**network/WebSocketManager.kt (Bagian Reconnection)**
```kotlin
class WebSocketManager {
    private val reconnectionManager = ReconnectionManager()
    
    /**
     * Membuat WebSocketListener dengan reconnection
     */
    private fun createWebSocketListener(url: String): WebSocketListener {
        return object : WebSocketListener() {
            override fun onOpen(webSocket: WebSocket, response: Response) {
                _connectionState.value = ConnectionState.CONNECTED
                startHeartbeat()
                reconnectionManager.reset()
            }
            
            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
                _connectionState.value = ConnectionState.ERROR
                
                // Coba hubungkan kembali
                CoroutineScope(Dispatchers.Default).launch {
                    reconnectionManager.attemptReconnect {
                        connect(url)
                    }
                }
            }
            
            // ... metode lain
        }
    }
    
    /**
     * Memutuskan koneksi WebSocket
     */
    fun disconnect() {
        reconnectionManager.stopReconnection()
        heartbeatJob?.cancel()
        webSocket?.close(1000, "Client disconnecting")
        webSocket = null
        _connectionState.value = ConnectionState.DISCONNECTED
    }
    
    // ... bagian lain dari WebSocketManager
}
```

### Implementasi UI untuk Status Koneksi:
**presentation/ui/component/ConnectionStatusBar.kt**
```kotlin
package com.example.realtime.presentation.ui.component

import androidx.compose.animation.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.example.realtime.network.ConnectionState

/**
 * Status bar untuk menampilkan status koneksi
 */
@Composable
fun ConnectionStatusBar(
    connectionState: ConnectionState,
    modifier: Modifier = Modifier
) {
    AnimatedVisibility(
        visible = connectionState != ConnectionState.CONNECTED,
        enter = slideInVertically(),
        exit = slideOutVertically(),
        modifier = modifier
    ) {
        Surface(
            color = when (connectionState) {
                ConnectionState.CONNECTING, ConnectionState.DISCONNECTING -> MaterialTheme.colorScheme.primaryContainer
                ConnectionState.ERROR -> MaterialTheme.colorScheme.errorContainer
                else -> MaterialTheme.colorScheme.surface
            }
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                when (connectionState) {
                    ConnectionState.CONNECTING, ConnectionState.DISCONNECTING -> {
                        CircularProgressIndicator(
                            modifier = Modifier.size(16.dp),
                            strokeWidth = 2.dp
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "Menghubungkan...",
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = FontWeight.Medium
                        )
                    }
                    ConnectionState.ERROR -> {
                        Icon(
                            imageVector = Icons.Default.Error,
                            contentDescription = "Error",
                            tint = MaterialTheme.colorScheme.error
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "Koneksi terputus. Mencoba menghubungkan kembali...",
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = FontWeight.Medium
                        )
                    }
                    else -> { /* Tidak ditampilkan */ }
                }
            }
        }
    }
}
```

### üéì Penjelasan Konsep:
**Heartbeat & Reconnection seperti Sistem Keamanan Jaringan Listrik:**
- **Heartbeat**: Sensor yang memeriksa apakah arus listrik masih mengalir.
- **Reconnection**: Generator cadangan yang otomatis menyala jika listrik padam.
- **Exponential Backoff**: Sistem yang menunggu semakin lama antara percobaan untuk mencegah overloading.

**Alur Kerja Heartbeat & Reconnection:**
1. **Koneksi**: Klien terhubung ke server.
2. **Heartbeat**: Klien mengirim ping ke server secara berkala.
3. **Server Response**: Server merespons ping untuk menegaskan koneksi masih hidup.
4. **Connection Lost**: Jika ping tidak berhasil atau koneksi terputus:
5. **Reconnection**: Klien mencoba menghubungkan kembali dengan exponential backoff.
6. **Success**: Jika berhasil, proses dimulai dari awal.
7. **Failure**: Jika gagal setelah beberapa percobaan, klien berhenti mencoba.

**Best Practices:**
- Gunakan heartbeat interval yang wajar (30-60 detik).
- Implementasikan exponential backoff untuk reconnection.
- Batasi jumlah percobaan reconnection untuk menghemat baterai.
- Berikan feedback visual kepada pengguna tentang status koneksi.

---

## 5Ô∏è‚É£ Message Queue untuk Offline Support üìÆ

### Konsep Dasar
Message Queue seperti antrian di kantor pos üìÆ - menyimpan pesan yang akan dikirim ketika pengantar (koneksi) tersedia!

### Pengertian Message Queue:
Message Queue adalah mekanisme untuk menyimpan pesan yang akan dikirim ketika aplikasi offline atau koneksi terputus. Ini penting untuk:
- Aplikasi chat
- Kolaborasi real-time
- Aplikasi dengan data kritis

### Implementasi Message Queue dengan Room:
**data/local/entity/PendingMessageEntity.kt**
```kotlin
package com.example.realtime.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Entity untuk pesan yang pending
 */
@Entity(tableName = "pending_messages")
data class PendingMessageEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val type: String, // "message", "typing", dll.
    val content: String,
    val recipientId: String, // Room ID, User ID, dll.
    val timestamp: Long = System.currentTimeMillis(),
    val retryCount: Int = 0
)
```

**data/local/dao/PendingMessageDao.kt**
```kotlin
package com.example.realtime.data.local.dao

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.example.realtime.data.local.entity.PendingMessageEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO untuk pesan yang pending
 */
@Dao
interface PendingMessageDao {
    @Query("SELECT * FROM pending_messages ORDER BY timestamp ASC")
    fun getAllPending(): Flow<List<PendingMessageEntity>>
    
    @Query("SELECT * FROM pending_messages WHERE recipientId = :recipientId ORDER BY timestamp ASC")
    fun getPendingByRecipient(recipientId: String): Flow<List<PendingMessageEntity>>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(message: PendingMessageEntity): Long
    
    @Delete
    suspend fun delete(message: PendingMessageEntity)
    
    @Query("DELETE FROM pending_messages WHERE id = :id")
    suspend fun deleteById(id: Long)
    
    @Query("DELETE FROM pending_messages")
    suspend fun deleteAll()
}
```

### Implementasi Message Queue Manager:
**data/MessageQueueManager.kt**
```kotlin
package com.example.realtime.data

import com.example.realtime.data.local.dao.PendingMessageDao
import com.example.realtime.data.local.entity.PendingMessageEntity
import com.example.realtime.network.WebSocketManager
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.launch
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Manager untuk antrian pesan pending
 */
@Singleton
class MessageQueueManager @Inject constructor(
    private val pendingMessageDao: PendingMessageDao,
    private val webSocketManager: WebSocketManager
) {
    
    /**
     * Menambahkan pesan ke antrian
     */
    suspend fun queueMessage(
        type: String,
        content: String,
        recipientId: String
    ) {
        val message = PendingMessageEntity(
            type = type,
            content = content,
            recipientId = recipientId
        )
        pendingMessageDao.insert(message)
    }
    
    /**
     * Memulai pengiriman pesan pending
     */
    fun startSendingPendingMessages() {
        CoroutineScope(Dispatchers.IO).launch {
            // Hanya kirim pesan jika terhubung
            webSocketManager.connectionState
                .filter { it == com.example.realtime.network.ConnectionState.CONNECTED }
                .collect {
                    sendPendingMessages()
                }
        }
    }
    
    /**
     * Mengirim semua pesan pending
     */
    private suspend fun sendPendingMessages() {
        val pendingMessages = pendingMessageDao.getAllPending()
        
        pendingMessages.collect { messages ->
            messages.forEach { message ->
                try {
                    webSocketManager.send(message.content)
                    // Jika berhasil, hapus dari antrian
                    pendingMessageDao.delete(message)
                } catch (e: Exception) {
                    // Jika gagal, increment retry count
                    val updatedMessage = message.copy(retryCount = message.retryCount + 1)
                    pendingMessageDao.insert(updatedMessage)
                    
                    // Jika retry count melebihi batas, hapus pesan
                    if (updatedMessage.retryCount > 3) {
                        pendingMessageDao.delete(message)
                    }
                }
            }
        }
    }
}
```

### Integrasi dengan Repository:
**repository/ChatRepository.kt (Bagian Message Queue)**
```kotlin
class ChatRepository @Inject constructor(
    private val webSocketManager: WebSocketManager,
    private val messageQueueManager: MessageQueueManager,
    private val gson: Gson
) {
    
    /**
     * Mengirim pesan (dengan antrian)
     */
    fun sendMessage(message: String, recipientId: String) {
        val json = gson.toJson(mapOf(
            "type" to "message",
            "content" to message,
            "recipientId" to recipientId,
            "timestamp" to System.currentTimeMillis()
        ))
        
        // Jika terhubung, kirim langsung
        if (webSocketManager.connectionState.value == ConnectionState.CONNECTED) {
            webSocketManager.send(json)
        } else {
            // Jika tidak terhubung, tambahkan ke antrian
            CoroutineScope(Dispatchers.IO).launch {
                messageQueueManager.queueMessage("message", json, recipientId)
            }
        }
    }
    
    /**
     * Menghubungkan ke room chat
     */
    fun connectToChat(roomId: String) {
        webSocketManager.connect("wss://api.example.com/chat/$roomId")
        // Mulai pengiriman pesan pending
        messageQueueManager.startSendingPendingMessages()
    }
    
    // ... metode lain
}
```

### üéì Penjelasan Konsep:
**Message Queue seperti Antrian di Kantor Pos:**
- **Pending Messages**: Surat-surat yang menunggu dikirim.
- **Queue**: Antrian tempat surat-surat disimpan.
- **WebSocket Manager**: Petugas pos yang mengirimkan surat.
- **Connection Status**: Status apakah petugas pos sedang bekerja.
- **Retry Mechanism**: Sistem untuk mencoba mengirim surat lagi jika gagal.

**Alur Kerja Message Queue:**
1. **User Action**: Pengguna mengirim pesan.
2. **Connection Check**: Aplikasi memeriksa status koneksi.
3. **Direct Send**: Jika terhubung, pesan dikirim langsung.
4. **Queue**: Jika tidak terhubung, pesan ditambahkan ke antrian.
5. **Reconnection**: Ketika koneksi tersedia kembali:
6. **Send Pending**: Aplikasi mengirim semua pesan dalam antrian.
7. **Success**: Jika berhasil, pesan dihapus dari antrian.
8. **Retry**: Jika gagal, aplikasi mencoba lagi beberapa kali.

**Best Practices:**
- Gunakan database lokal untuk antrian pesan yang persisten.
- Batasi jumlah percobaan ulang untuk mencegah pengulangan tak terbatas.
- Berikan feedback visual kepada pengguna tentang status pengiriman pesan.
- Pertimbangkan untuk menghapus pesan lama yang gagal dikirim.

---

## 6Ô∏è‚É£ Real-Time Use Cases üéØ

### Konsep Dasar
Real-Time Use Cases seperti berbagai aplikasi teknologi komunikasi üì± - dari chat hingga kolaborasi, semua memanfaatkan komunikasi real-time!

### Jenis-Jenis Use Case Real-Time:

#### 1. Live Location Tracking
**Konsep:** Melacak lokasi pengguna secara real-time, berguna untuk aplikasi pengiriman, transportasi, atau sosial.

```kotlin
// Repository untuk lokasi
class LocationRepository @Inject constructor(
    private val webSocketManager: WebSocketManager
) {
    /**
     * Memulai update lokasi
     */
    fun startLocationUpdates(locationFlow: Flow<Location>) {
        CoroutineScope(Dispatchers.IO).launch {
            locationFlow.collect { location ->
                val json = gson.toJson(mapOf(
                    "type" to "location_update",
                    "lat" to location.latitude,
                    "lng" to location.longitude,
                    "timestamp" to System.currentTimeMillis()
                ))
                webSocketManager.send(json)
            }
        }
    }
}
```

#### 2. Live Typing Indicator
**Konsep:** Menampilkan indikator ketika pengguna lain sedang mengetik, umum dalam aplikasi chat.

```kotlin
// ViewModel untuk chat
class ChatViewModel @Inject constructor(
    private val chatRepository: ChatRepository
) : ViewModel() {
    
    private val _typingUsers = MutableStateFlow<List<String>>(emptyList())
    val typingUsers: StateFlow<List<String>> = _typingUsers.asStateFlow()
    
    /**
     * Menangani event typing
     */
    private fun handleTypingEvent(json: String) {
        val event = gson.fromJson(json, Map::class.java)
        if (event["type"] == "typing") {
            val userId = event["userId"] as String
            val isTyping = event["isTyping"] as Boolean
            
            if (isTyping) {
                // Tambahkan user ke daftar typing
                _typingUsers.value = _typingUsers.value + userId
            } else {
                // Hapus user dari daftar typing
                _typingUsers.value = _typingUsers.value - userId
            }
        }
    }
    
    /**
     * Mengirim status typing
     */
    fun setTyping(isTyping: Boolean) {
        val json = gson.toJson(mapOf(
            "type" to "typing",
            "isTyping" to isTyping
        ))
        chatRepository.sendEvent(json)
    }
}
```

#### 3. Live Collaborative Editing
**Konsep:** Memungkinkan beberapa pengguna mengedit dokumen yang sama secara bersamaan, seperti Google Docs.

```kotlin
// Repository untuk kolaborasi
class CollaborationRepository @Inject constructor(
    private val webSocketManager: WebSocketManager
) {
    /**
     * Mengirim perubahan teks
     */
    fun sendTextChange(documentId: String, change: TextChange) {
        val json = gson.toJson(mapOf(
            "type" to "text_change",
            "documentId" to documentId,
            "position" to change.position,
            "text" to change.text,
            "operation" to change.operation, // insert, delete, retain
            "timestamp" to System.currentTimeMillis()
        ))
        webSocketManager.send(json)
    }
    
    /**
     * Mengamati perubahan teks
     */
    fun observeTextChanges(documentId: String): Flow<TextChange> {
        return webSocketManager.messages
            .filter { isValidTextChange(it, documentId) }
            .map { json ->
                val event = gson.fromJson(json, Map::class.java)
                TextChange(
                    position = event["position"] as Int,
                    text = event["text"] as String,
                    operation = event["operation"] as String
                )
            }
    }
    
    /**
     * Memvalidasi apakah perubahan teks valid
     */
    private fun isValidTextChange(json: String, documentId: String): Boolean {
        return try {
            val event = gson.fromJson(json, Map::class.java)
            event["type"] == "text_change" && event["documentId"] == documentId
        } catch (e: Exception) {
            false
        }
    }
}

/**
 * Model untuk perubahan teks
 */
data class TextChange(
    val position: Int,
    val text: String,
    val operation: String // insert, delete, retain
)
```

#### 4. Live Notifications
**Konsep:** Mengirimkan notifikasi real-time kepada pengguna, seperti notifikasi pesan baru atau update status.

```kotlin
// Repository untuk notifikasi
class NotificationRepository @Inject constructor(
    private val sseManager: SSEManager
) {
    /**
     * Menghubungkan ke aliran notifikasi
     */
    fun connectToNotifications(userId: String) {
        sseManager.connect("https://api.example.com/notifications/stream/$userId")
    }
    
    /**
     * Mengamati notifikasi yang masuk
     */
    fun observeNotifications(): Flow<Notification> {
        return sseManager.events
            .filter { it.type == "notification" }
            .map { event ->
                gson.fromJson(event.data, Notification::class.java)
            }
    }
}
```

### üéì Penjelasan Konsep:
**Real-Time Use Cases seperti Berbagai Aplikasi Teknologi:**
- **Live Location Tracking**: Aplikasi GPS yang memperbarui posisi secara real-time.
- **Live Typing Indicator**: Aplikasi chat yang menampilkan "Sedang mengetik...".
- **Live Collaborative Editing**: Aplikasi dokumen kolaboratif seperti Google Docs.
- **Live Notifications**: Sistem notifikasi real-time seperti push notification.

**Best Practices:**
- Pilih metode komunikasi yang sesuai dengan use case (WebSocket untuk dua arah, SSE untuk satu arah).
- Implementasikan mekanisme untuk menangani konflik (misalnya, dalam kolaborasi editing).
- Optimalkan penggunaan bandwidth dengan hanya mengirim data yang diperlukan.
- Berikan feedback visual kepada pengguna tentang status operasi.

---

## 7Ô∏è‚É£ Best Practices ‚úÖ

### Konsep Dasar
Best Practices seperti aturan main dalam olahraga ‚öΩ - memastikan semua pemain bermain dengan adil, efektif, dan aman!

### Daftar Best Practices untuk Real-Time Communication:

#### ‚úÖ Implement Heartbeat/Ping-Pong
- Kirim pesan ping secara berkala untuk menjaga koneksi tetap hidup.
- Tangani respons pong dari server.
- Gunakan interval yang wajar (30-60 detik).

```kotlin
// Contoh implementasi heartbeat
private fun startHeartbeat() {
    heartbeatJob = CoroutineScope(Dispatchers.Default).launch {
        while (true) {
            try {
                send("""{"type":"ping"}""")
                delay(30_000) // Ping setiap 30 detik
            } catch (e: Exception) {
                break
            }
        }
    }
}
```

#### ‚úÖ Handle Reconnection dengan Exponential Backoff
- Coba hubungkan kembali jika koneksi terputus.
- Gunakan exponential backoff untuk mencegah membebani server.
- Batasi jumlah percobaan reconnection.

```kotlin
// Contoh implementasi exponential backoff
suspend fun attemptReconnect(connectAction: suspend () -> Unit) {
    var reconnectAttempts = 0
    val maxReconnectAttempts = 5
    val baseDelay = 1000L // 1 detik
    
    while (reconnectAttempts < maxReconnectAttempts) {
        try {
            val delay = baseDelay * (2.0.pow(reconnectAttempts.toDouble())).toLong()
            delay(delay)
            
            connectAction()
            
            // Jika berhasil, reset counter
            reconnectAttempts = 0
            break
        } catch (e: Exception) {
            reconnectAttempts++
        }
    }
}
```

#### ‚úÖ Queue Messages Ketika Offline
- Simpan pesan yang akan dikirim ketika aplikasi offline.
- Kirim pesan tersebut ketika koneksi tersedia kembali.
- Berikan feedback visual kepada pengguna tentang status pengiriman.

```kotlin
// Contoh implementasi message queue
suspend fun queueMessage(
    type: String,
    content: String,
    recipientId: String
) {
    val message = PendingMessageEntity(
        type = type,
        content = content,
        recipientId = recipientId
    )
    pendingMessageDao.insert(message)
}
```

#### ‚úÖ Tampilkan Status Koneksi ke Pengguna
- Berikan indikator visual tentang status koneksi (terhubung, menghubungkan, error).
- Bersihkan koneksi saat tidak diperlukan lagi (misalnya, di `onCleared()` ViewModel) untuk mencegah memory leak.

```kotlin
// ViewModel
class ChatViewModel : ViewModel() {
    // ... properti lain

    override fun onCleared() {
        super.onCleared()
        // Sangat penting untuk memutuskan koneksi saat ViewModel dihancurkan
        chatRepository.disconnect()
    }
}
```

#### ‚úÖ Handle Binary Messages Jika Diperlukan
- WebSocket dapat mengirim data biner (`ByteString`).
- Gunakan ini untuk file, gambar, atau data terstruktur lainnya.
- Pastikan kedua sisi (klien dan server) memahami format biner yang digunakan.

```kotlin
// Di WebSocketListener
override fun onMessage(webSocket: WebSocket, bytes: ByteString) {
    // Tangani pesan biner
    CoroutineScope(Dispatchers.IO).launch {
        val file = saveBytesToFile(bytes.toByteArray())
        _binaryMessages.emit(file)
    }
}

// Fungsi untuk mengirim data biner
fun sendFile(file: File) {
    webSocket?.send(file.readBytes())
}
```

#### ‚úÖ Implementasikan Timeout Handling
- Tetapkan timeout untuk koneksi untuk mencegah aplikasi menunggu selamanya.
- Gunakan `OkHttpClient.Builder` dengan `callTimeout()`, `connectTimeout()`, dan `readTimeout()`.

```kotlin
val client = OkHttpClient.Builder()
    .callTimeout(30, TimeUnit.SECONDS) // Total timeout untuk satu panggilan
    .connectTimeout(10, TimeUnit.SECONDS) // Timeout untuk membuat koneksi
    .readTimeout(0, TimeUnit.SECONDS) // Tidak ada timeout untuk membaca (penting untuk SSE/WebSocket)
    .writeTimeout(10, TimeUnit.SECONDS) // Timeout untuk menulis
    .build()
```

#### ‚úÖ Uji dengan Kondisi Jaringan Buruk
- Uji aplikasi dalam berbagai skenario jaringan (sinyal lemah, koneksi hilang, perubahan WiFi ke seluler).
- Pastikan mekanisme reconnection dan antrian pesan berfungsi dengan baik.
- Gunakan emulator atau perangkat fisik untuk mensimulasikan kondisi jaringan yang buruk.

#### ‚úÖ Gunakan Koneksi Aman (wss://)
- Selalu gunakan `wss://` (WebSocket Secure) daripada `ws://` untuk komunikasi terenkripsi.
- Ini melindungi data dari penyadapan dan serangan man-in-the-middle.

```kotlin
// Gunakan URL yang aman
val secureUrl = "wss://api.example.com/chat/$roomId"
webSocketManager.connect(secureUrl)
```

#### ‚úÖ Tangani Urutan Pesan (Message Ordering)
- Untuk aplikasi seperti chat, urutan pesan sangat penting.
- Gunakan ID unik atau timestamp untuk setiap pesan.
- Di sisi klien, urutkan pesan berdasarkan timestamp atau ID jika diterima tidak berurutan.

```kotlin
// Di ViewModel
private fun insertMessageInOrder(newMessage: ChatMessage) {
    val currentMessages = _messages.value.toMutableList()
    currentMessages.add(newMessage)
    // Urutkan pesan berdasarkan timestamp untuk memastikan urutan yang benar
    _messages.value = currentMessages.sortedBy { it.timestamp }
}
```

### üéì Penjelasan Konsep:
**Best Practices seperti Aturan Main:**
- **Heartbeat**: Sistem "check-in" berkala untuk memastikan semua pemain masih aktif.
- **Reconnection**: Strategi untuk memasukkan kembali pemain yang keluar dari permainan.
- **Message Queue**: Bangku cadangan untuk pemain yang sedang menunggu giliran.
- **Connection Status**: Papan skor yang menunjukkan status permainan kepada penonton.
- **Cleanup**: Membersihkan lapangan setelah permainan selesai agar tidak berantakan.

**Mengapa Best Practices Penting:**
- **Stabilitas**: Mencegah aplikasi crash atau berperilaku tidak terduga.
- **Efisiensi**: Menghemat baterai dan sumber daya dengan tidak melakukan operasi yang tidak perlu.
- **Keamanan**: Melindungi data dan privasi pengguna.
- **Pengalaman Pengguna**: Memberikan pengalaman yang mulus dan dapat diandalkan, bahkan dalam kondisi jaringan yang buruk.

---

## 8Ô∏è‚É£ Hands-on Project üî®

### Konsep Dasar
Hands-on Project seperti membangun menara komunikasi üóº - menerapkan semua teori untuk menciptakan struktur yang kokoh dan memungkinkan komunikasi jarak jauh!

### Tujuan Proyek:
Membangun aplikasi chat real-time sederhana bernama **"Chit-Chat"** dengan fitur:
- Koneksi ke room chat
- Mengirim dan menerima pesan secara real-time
- Indikator status koneksi (terhubung, menghubungkan, error)
- Indikator "sedang mengetik"
- Antrian pesan untuk dukungan offline
- Mekanisme reconnection otomatis

### Langkah-Langkah Implementasi:

#### Langkah 1: Setup Proyek
1.  Buat proyek baru di Android Studio dengan template "Empty Activity".
2.  Tambahkan dependensi berikut di `build.gradle.kts` (Module: app):
    ```kotlin
    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
    
    // OkHttp for WebSocket
    implementation("com.squareup.okhttp3:okhttp:4.12.0")
    
    // ViewModel & LiveData
    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
    
    // Jetpack Compose
    implementation("androidx.activity:activity-compose:1.8.2")
    implementation(platform("androidx.compose:compose-bom:2023.08.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    
    // Hilt for DI
    implementation("com.google.dagger:hilt-android:2.48")
    kapt("com.google.dagger:hilt-compiler:2.48")
    
    // Room for offline queue
    implementation("androidx.room:room-runtime:2.6.1")
    implementation("androidx.room:room-ktx:2.6.1")
    kapt("androidx.room:room-compiler:2.6.1")
    ```
3.  Buat class Application dan anotasi dengan `@HiltAndroidApp`.

#### Langkah 2: Buat WebSocket Manager
Gunakan kode `WebSocketManager` yang telah dibahas di bagian sebelumnya. Ini adalah jantung dari komunikasi real-time aplikasi kita.

#### Langkah 3: Buat Database untuk Antrian Offline
1.  Buat `PendingMessageEntity` dan `PendingMessageDao`.
2.  Buat `AppDatabase` yang menyertakan `PendingMessageDao`.

#### Langkah 4: Buat Repository
**repository/ChatRepository.kt**
```kotlin
package com.example.chitchat.repository

import com.example.chitchat.data.local.dao.PendingMessageDao
import com.example.chitchat.data.local.entity.PendingMessageEntity
import com.example.chitchat.data.model.ChatMessage
import com.example.chitchat.network.WebSocketManager
import com.google.gson.Gson
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ChatRepository @Inject constructor(
    private val webSocketManager: WebSocketManager,
    private val pendingMessageDao: PendingMessageDao,
    private val gson: Gson
) {
    fun connect(roomId: String) {
        webSocketManager.connect("wss://your-server.com/chat/$roomId")
    }

    fun sendMessage(content: String) {
        val json = gson.toJson(mapOf("type" to "message", "content" to content))
        try {
            webSocketManager.send(json)
        } catch (e: Exception) {
            // Jika gagal, tambahkan ke antrian
            CoroutineScope(Dispatchers.IO).launch {
                pendingMessageDao.insert(PendingMessageEntity(content = json))
            }
        }
    }

    fun observeMessages(): Flow<ChatMessage> {
        return webSocketManager.messages
            .filter { it.contains("\"type\":\"message\"") }
            .map { gson.fromJson(it, ChatMessage::class.java) }
    }

    fun observeConnectionState() = webSocketManager.connectionState

    suspend fun sendPendingMessages() {
        withContext(Dispatchers.IO) {
            pendingMessageDao.getAllPending().forEach { message ->
                try {
                    webSocketManager.send(message.content)
                    pendingMessageDao.delete(message)
                } catch (e: Exception) {
                    // Gagal mengirim, biarkan di antrian untuk coba lagi nanti
                }
            }
        }
    }

    fun disconnect() {
        webSocketManager.disconnect()
    }
}
```

#### Langkah 5: Buat ViewModel
**presentation/viewmodel/ChatViewModel.kt**
```kotlin
package com.example.chitchat.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.chitchat.data.model.ChatMessage
import com.example.chitchat.network.ConnectionState
import com.example.chitchat.repository.ChatRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class ChatViewModel @Inject constructor(
    private val chatRepository: ChatRepository
) : ViewModel() {

    private val _messages = MutableStateFlow<List<ChatMessage>>(emptyList())
    val messages: StateFlow<List<ChatMessage>> = _messages.asStateFlow()

    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)
    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()

    init {
        viewModelScope.launch {
            // Amati pesan yang masuk
            chatRepository.observeMessages().collect { message ->
                _messages.value = _messages.value + message
            }
        }

        viewModelScope.launch {
            // Amati status koneksi
            combine(chatRepository.observeConnectionState()) { state ->
                state
            }.collect { state ->
                _connectionState.value = state
                if (state == ConnectionState.CONNECTED) {
                    // Jika terhubung, kirim pesan yang tertunda
                    chatRepository.sendPendingMessages()
                }
            }
        }
    }

    fun connect(roomId: String) {
        chatRepository.connect(roomId)
    }

    fun sendMessage(content: String) {
        if (content.isNotBlank()) {
            chatRepository.sendMessage(content)
        }
    }

    override fun onCleared() {
        super.onCleared()
        chatRepository.disconnect()
    }
}
```

#### Langkah 6: Buat UI dengan Jetpack Compose
**presentation/ui/ChatScreen.kt**
```kotlin
package com.example.chitchat.presentation.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Send
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.example.chitchat.data.model.ChatMessage
import com.example.chitchat.network.ConnectionState
import com.example.chitchat.presentation.ui.component.ConnectionStatusBar
import com.example.chitchat.presentation.viewmodel.ChatViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ChatScreen(
    viewModel: ChatViewModel = hiltViewModel()
) {
    val messages by viewModel.messages.collectAsStateWithLifecycle()
    val connectionState by viewModel.connectionState.collectAsStateWithLifecycle()
    var messageText by remember { mutableStateOf("") }
    val listState = rememberLazyListState()

    LaunchedEffect(messages.size) {
        if (messages.isNotEmpty()) {
            listState.animateScrollToItem(messages.size - 1)
        }
    }

    Column(modifier = Modifier.fillMaxSize()) {
        ConnectionStatusBar(connectionState = connectionState)

        LazyColumn(
            modifier = Modifier.weight(1f),
            state = listState,
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(messages) { message ->
                MessageBubble(message = message)
            }
        }

        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            OutlinedTextField(
                value = messageText,
                onValueChange = { messageText = it },
                modifier = Modifier.weight(1f),
                placeholder = { Text("Ketik pesan...") }
            )
            Spacer(modifier = Modifier.width(8.dp))
            IconButton(
                onClick = {
                    viewModel.sendMessage(messageText)
                    messageText = ""
                },
                enabled = messageText.isNotBlank() && connectionState == ConnectionState.CONNECTED
            ) {
                Icon(Icons.Default.Send, contentDescription = "Kirim")
            }
        }
    }
}

@Composable
fun MessageBubble(message: ChatMessage) {
    // Implementasi UI untuk bubble pesan
    // ...
}
```

### üéì Penjelasan Konsep:
**Hands-on Project seperti Membangun Menara Komunikasi:**
- **Teori**: Rencana dan desain menara (konsep WebSocket, reconnection).
- **Dependencies**: Bahan-bahan bangunan (OkHttp, Coroutines, Compose).
- **WebSocket Manager**: Pondasi dan struktur utama menara.
- **Repository**: Sistem kabel dan antena untuk transmisi.
- **ViewModel**: Ruang kontrol di puncak menara.
- **UI**: Lampu sinyal dan layar untuk menampilkan pesan.
- **Offline Queue**: Generator cadangan untuk saat listrik padam.

**Kunci Keberhasilan Proyek:**
- **Mulai dari Manager**: Bangun `WebSocketManager` terlebih dahulu sebagai fondasi.
- **Pisahkan Tanggung Jawab**: Repository menangani logika bisnis, ViewModel menangani state UI.
- **Reaktif**: Gunakan `StateFlow` dan `collectAsStateWithLifecycle` agar UI selalu up-to-date.
- **Uji Secara Iteratif**: Uji koneksi, pengiriman pesan, dan reconnection secara bertahap.

---

## üéØ Kesimpulan

Selamat! üéâ Anda telah menyelesaikan perjalanan singkat namun padat untuk memahami **Real-Time Communication**. Anda kini dibekali dengan keterampilan untuk:

- **Memahami Berbagai Metode**: Anda tahu kapan harus menggunakan Polling, Long Polling, WebSocket, atau SSE.
- **Menerapkan WebSocket**: Anda bisa membangun koneksi real-time dua arah yang andal dengan OkHttp.
- **Memanfaatkan SSE**: Anda bisa membuat fitur notifikasi real-time yang efisien.
- **Membangun Sistem yang Tangguh**: Aplikasi Anda dapat menangani koneksi terputus, mencoba menghubungkan kembali, dan mengantrikan pesan saat offline.
- **Memberikan Pengalaman Terbaik**: Dengan menampilkan status koneksi dan memberikan feedback yang tepat, aplikasi Anda terasa lebih profesional dan dapat diandalkan.

Dengan kekuatan komunikasi real-time, Anda siap untuk membangun aplikasi Android yang lebih interaktif, kolaboratif, dan responsif. Teruslah bereksperimen dengan berbagai use case, dan nikmati kemudahan dalam menciptakan pengalaman pengguna yang terhubung secara instan