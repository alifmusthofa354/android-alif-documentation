# üéØ Panduan Lengkap: Use Cases di Android (Domain Layer)

## üöÄ Pengantar: Pengelola Logika Bisnis dalam Clean Architecture

Bayangkan kamu adalah seorang direktur operasional üé¨:
- **Use Cases** seperti rencana kerja atau skenario operasional
- **Domain Layer** seperti kantor pusat perusahaan
- **Business Logic** seperti aturan main dan prosedur operasional

Dengan Use Cases yang baik, kamu bisa memisahkan logika bisnis dari tampilan dan pengelolaan data!

## üìö Daftar Isi Pembelajaran
1. [üåü Pengenalan Use Cases](#1Ô∏è‚É£-pengenalan-use-cases-üåü)
2. [üß© Struktur Use Case](#2Ô∏è‚É£-struktur-use-case-üß©)
3. [üèóÔ∏è Membuat Use Cases](#3Ô∏è‚É£-membuat-use-cases-üèóÔ∏è)
4. [üìã Kategori Use Cases](#4Ô∏è‚É£-kategori-use-cases-üìã)
5. [üîÑ Input dan Output Models](#5Ô∏è‚É£-input-dan-output-models-üîÑ)
6. [‚öôÔ∏è Implementasi Business Logic](#6Ô∏è‚É£-implementasi-business-logic-‚öôÔ∏è)
7. [‚ö° Use Cases dengan Coroutines](#7Ô∏è‚É£-use-cases-dengan-coroutines-‚ö°)
8. [üîó Menggabungkan Use Cases](#8Ô∏è‚É£-menggabungkan-use-cases-üîó)
9. [üõ°Ô∏è Error Handling](#9Ô∏è‚É£-error-handling-üõ°Ô∏è)
10. [üß™ Testing Use Cases](#1Ô∏è‚É£0Ô∏è‚É£-testing-use-cases-üß™)
11. [üìä Use Cases vs ViewModel](#1Ô∏è‚É£1Ô∏è‚É£-use-cases-vs-viewmodel-üìä)
12. [üíâ Dependency Injection](#1Ô∏è‚É£2Ô∏è‚É£-dependency-injection-üíâ)
13. [üî® Hands-on Project](#1Ô∏è‚É£3Ô∏è‚É£-hands-on-project-üî®)
14. [üéØ Kesimpulan](#üéØ-kesimpulan)

---

## 1Ô∏è‚É£ Pengenalan Use Cases üåü

### Konsep Dasar
Use Cases seperti rencana bisnis üìã yang menjelaskan alur kerja dan aturan-aturan yang harus diikuti dalam sebuah sistem!

### Apa itu Use Case dan mengapa penting?
**Use Case (Interactor)** adalah komponen dalam Domain Layer yang:
- **Mengandung logika bisnis murni**
- **Tidak terikat pada teknologi UI atau data**
- **Mengkoordinasikan antar repository**
- **Menerapkan aturan bisnis**

### Peran Use Cases dalam Clean Architecture:
```
UI (Compose/Activity/Fragment) ‚Üí ViewModel ‚Üí Use Case ‚Üí Repository
                                                        ‚Üì
                                                  Domain Model
```

### Use Case dalam Domain Layer:
- **Berada di lapisan inti** (Core Layer)
- **Tidak bergantung pada Android Framework**
- **Hanya bergantung pada Repository Interfaces**
- **Murni Kotlin/Java**

### Single Responsibility per Use Case:
- **Satu Use Case, satu tanggung jawab**
- **Fokus pada satu operasi bisnis**
- **Mudah diuji dan dipelihara**

### Kapan perlu Use Case vs logic di ViewModel?

**Gunakan Use Case ketika:**
- ‚úÖ Ada logika bisnis kompleks
- ‚úÖ Berinteraksi dengan beberapa repository
- ‚úÖ Berisi aturan bisnis penting
- ‚úÖ Bisa digunakan di banyak tempat
- ‚úÖ Perlu diuji secara terpisah

**Gunakan logic di ViewModel ketika:**
- ‚úÖ Operasi sederhana (misal: sorting UI)
- ‚úÖ Transformasi data untuk tampilan
- ‚úÖ Manajemen state UI
- ‚úÖ Pemrosesan data hanya untuk tampilan

### Business Logic vs Presentation Logic:

| Business Logic | Presentation Logic |
|----------------|--------------------|
| Aturan bisnis utama | Format data untuk UI |
| Validasi bisnis | Transformasi tampilan |
| Operasi kompleks | Sorting untuk UI |
| Berlaku di semua platform | Hanya untuk tampilan |

### Contoh Struktur Sederhana:

**domain/usecase/GetUserUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Use Case untuk mendapatkan informasi pengguna
 * Mengandung hanya logika bisnis
 */
class GetUserUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Operator invoke agar bisa dipanggil seperti function
     */
    suspend operator fun invoke(userId: String): User? {
        return userRepository.getUserById(userId)
    }
}
```

### üéì Penjelasan Konsep:
**Use Cases seperti Rencana Bisnis:**
- **Menjelaskan prosedur** operasional dalam sistem
- **Berisi aturan main** yang harus diikuti
- **Tidak tahu bagaimana eksekusi** (UI atau data)
- **Hanya tahu apa yang harus dilakukan**

**Keunggulan Use Cases:**
- **Modular**: Setiap operasi dikelola sendiri
- **Testable**: Bisa diuji tanpa UI atau data
- **Reusable**: Bisa digunakan di banyak tempat
- **Maintainable**: Perubahan logika tidak merambat

---

## 2Ô∏è‚É£ Struktur Use Case üß©

### Konsep Dasar
Struktur Use Case seperti template dokumen resmi üìÑ - format yang konsisten membuatnya mudah dipahami dan dipelihara!

### Class-based Use Cases:

**domain/usecase/GetUserByIdUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Template standar untuk Use Case
 */
class GetUserByIdUseCase(
    private val userRepository: UserRepository  // Dependencies di constructor
) {
    /**
     * Method utama dengan operator invoke
     * Memungkinkan pemanggilan seperti function
     */
    suspend operator fun invoke(userId: String): User? {
        // Business logic di sini
        return userRepository.getUserById(userId)
    }
}
```

### Operator invoke():

**domain/usecase/ComplexOperationUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Use Case dengan operator invoke
 * Memungkinkan pemanggilan yang lebih ringkas
 */
class ComplexOperationUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Gunakan operator invoke untuk pemanggilan yang lebih natural
     */
    suspend operator fun invoke(userId: String, operationType: OperationType): Result<User> {
        return try {
            when (operationType) {
                OperationType.PROCESS -> processUser(userId)
                OperationType.VALIDATE -> validateUser(userId)
                OperationType.ENHANCE -> enhanceUser(userId)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun processUser(userId: String): Result<User> {
        val user = userRepository.getUserById(userId) ?: return Result.failure(Exception("User not found"))
        
        // Business logic
        val updatedUser = user.copy(
            lastProcessed = System.currentTimeMillis()
        )
        
        userRepository.saveUser(updatedUser)
        return Result.success(updatedUser)
    }
    
    private suspend fun validateUser(userId: String): Result<User> {
        // Validation logic
        val user = userRepository.getUserById(userId) ?: return Result.failure(Exception("User not found"))
        
        if (!isValidForBusiness(user)) {
            return Result.failure(Exception("User validation failed"))
        }
        
        return Result.success(user)
    }
    
    private suspend fun enhanceUser(userId: String): Result<User> {
        // Enhancement logic
        val user = userRepository.getUserById(userId) ?: return Result.failure(Exception("User not found"))
        
        val enhancedUser = user.copy(
            enhanced = true,
            enhancementDate = System.currentTimeMillis()
        )
        
        userRepository.saveUser(enhancedUser)
        return Result.success(enhancedUser)
    }
    
    private fun isValidForBusiness(user: User): Boolean {
        return user.email.contains("@") && user.name.isNotBlank()
    }
}

enum class OperationType {
    PROCESS, VALIDATE, ENHANCE
}
```

### Input Parameters (Encapsulation):

**domain/usecase/GetUserWithFiltersUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Parameter input yang terstruktur
 */
data class UserFilter(
    val isActive: Boolean? = null,
    val minAge: Int? = null,
    val maxAge: Int? = null,
    val sortBy: SortOrder = SortOrder.NAME
)

enum class SortOrder {
    NAME, EMAIL, AGE
}

class GetUserWithFiltersUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Gunakan data class untuk parameter kompleks
     */
    suspend operator fun invoke(filter: UserFilter): List<User> {
        var users = userRepository.getUsers()
        
        // Apply filters
        if (filter.isActive != null) {
            users = users.filter { it.isActive == filter.isActive }
        }
        
        if (filter.minAge != null) {
            users = users.filter { it.age >= filter.minAge }
        }
        
        if (filter.maxAge != null) {
            users = users.filter { it.age <= filter.maxAge }
        }
        
        // Apply sorting
        users = when (filter.sortBy) {
            SortOrder.NAME -> users.sortedBy { it.name }
            SortOrder.EMAIL -> users.sortedBy { it.email }
            SortOrder.AGE -> users.sortedBy { it.age }
        }
        
        return users
    }
}
```

### Output Types (Result, Flow):

**domain/usecase/GetUsersWithResultUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import kotlinx.coroutines.flow.Flow

/**
 * Berbagai tipe output untuk Use Case
 */
class GetUsersWithResultUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Return dengan Result untuk error handling
     */
    suspend operator fun invoke(): Result<List<User>> {
        return try {
            val users = userRepository.getUsers()
            Result.success(users)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Return Flow untuk streaming data
     */
    fun invokeAsStream(): Flow<List<User>> {
        return userRepository.getUsersStream()
    }
    
    /**
     * Return nullable untuk kasus bisa null
     */
    suspend fun getUserById(userId: String): User? {
        return userRepository.getUserById(userId)
    }
    
    /**
     * Return Boolean untuk operasi yang hanya perlu status
     */
    suspend fun deleteUser(userId: String): Boolean {
        return try {
            userRepository.deleteUser(userId)
            true
        } catch (e: Exception) {
            false
        }
    }
}
```

### Naming Convention:

```
‚úÖ GetUsersUseCase        - Query operations
‚úÖ GetUserByIdUseCase     - Specific query
‚úÖ CreateUserUseCase      - Create operations
‚úÖ UpdateUserUseCase      - Update operations
‚úÖ DeleteUserUseCase      - Delete operations
‚úÖ ValidateUserUseCase    - Validation operations
‚úÖ ProcessPaymentUseCase  - Complex operations
```

### One Public Method Per Use Case:

**domain/usecase/GoodUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * ‚úÖ SATU METHOD UTAMA PER USE CASE
 */
class GetUserUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): User? {
        return userRepository.getUserById(userId)
    }
    
    // Private methods untuk support logic
    private fun validateInput(userId: String): Boolean {
        return userId.isNotBlank()
    }
}
```

**domain/usecase/BadUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * ‚ùå BANYAK METHOD PUBLIK (TIDAK DIREKOMENDASIKAN)
 */
class BadUseCase(
    private val userRepository: UserRepository
) {
    suspend fun getUser(userId: String): User? {
        return userRepository.getUserById(userId)
    }
    
    suspend fun saveUser(user: User) {
        userRepository.saveUser(user)
    }
    
    suspend fun deleteUser(userId: String) {
        userRepository.deleteUser(userId)
    }
    
    suspend fun updateUser(user: User) {
        userRepository.updateUser(user)
    }
}
```

### üéì Penjelasan Konsep:
**Struktur Use Case seperti Template Resmi:**
- **Format konsisten** memudahkan pemahaman
- **Standar pemanggilan** dengan operator invoke
- **Parameter terstruktur** untuk kompleksitas
- **Output jelas** untuk error handling

---

## 3Ô∏è‚É£ Membuat Use Cases üèóÔ∏è

### Konsep Dasar
Membuat Use Cases seperti menulis skenario lengkap üìù - setiap langkah harus jelas dan terstruktur!

### Contoh Struktur Dasar:

**domain/usecase/GetUserProfileUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import com.example.usecasesample.domain.repository.ProfileRepository

/**
 * Contoh struktur dasar Use Case
 */
class GetUserProfileUseCase(
    private val userRepository: UserRepository,
    private val profileRepository: ProfileRepository
) {
    /**
     * Struktur standar: input, logic, output
     */
    suspend operator fun invoke(userId: String): Result<User> {
        return try {
            // 1. Validasi input
            if (userId.isBlank()) {
                return Result.failure(IllegalArgumentException("User ID cannot be blank"))
            }
            
            // 2. Ambil data dari repository
            val user = userRepository.getUserById(userId)
            
            // 3. Cek hasil
            if (user == null) {
                return Result.failure(Exception("User not found"))
            }
            
            // 4. Proses lanjutan (jika perlu)
            val completeUser = enrichUserWithProfile(user)
            
            // 5. Return hasil
            Result.success(completeUser)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Support method untuk proses tambahan
     */
    private suspend fun enrichUserWithProfile(user: User): User {
        val profile = profileRepository.getProfileByUserId(user.id)
        return user.copy(
            profile = profile,
            isComplete = profile != null
        )
    }
}
```

### Use Case dengan Validasi Kompleks:

**domain/usecase/CreateUserWithValidationUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import com.example.usecasesample.domain.validation.UserValidator

/**
 * Use Case dengan validasi bisnis kompleks
 */
class CreateUserWithValidationUseCase(
    private val userRepository: UserRepository,
    private val validator: UserValidator = UserValidator
) {
    suspend operator fun invoke(user: User): Result<String> {
        return try {
            // Validasi bisnis
            val validationErrors = mutableListOf<String>()
            
            // Validasi format
            validator.validateEmail(user.email).let { result ->
                if (result is UserValidator.ValidationResult.Invalid) {
                    validationErrors.add("Email: ${result.message}")
                }
            }
            
            validator.validateName(user.name).let { result ->
                if (result is UserValidator.ValidationResult.Invalid) {
                    validationErrors.add("Name: ${result.message}")
                }
            }
            
            // Validasi bisnis
            if (isEmailAlreadyExists(user.email)) {
                validationErrors.add("Email already exists")
            }
            
            if (validationErrors.isNotEmpty()) {
                return Result.failure(Exception(validationErrors.joinToString("\n")))
            }
            
            // Buat user baru
            val userId = generateUserId()
            val userWithId = user.copy(id = userId)
            
            userRepository.saveUser(userWithId)
            
            Result.success(userId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun isEmailAlreadyExists(email: String): Boolean {
        return userRepository.getUserByEmail(email) != null
    }
    
    private fun generateUserId(): String {
        return "user_${System.currentTimeMillis()}"
    }
}
```

### Use Case untuk Operasi Update:

**domain/usecase/UpdateUserWithRulesUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import com.example.usecasesample.domain.validation.UserValidator

/**
 * Use Case untuk update dengan aturan bisnis
 */
class UpdateUserWithRulesUseCase(
    private val userRepository: UserRepository,
    private val validator: UserValidator = UserValidator
) {
    suspend operator fun invoke(userId: String, updates: UserUpdateRequest): Result<User> {
        return try {
            // Ambil user eksisting
            val existingUser = userRepository.getUserById(userId)
                ?: return Result.failure(Exception("User not found"))
            
            // Validasi permintaan update
            validateUpdateRequest(updates, existingUser)
            
            // Buat user baru dengan update
            val updatedUser = applyUpdates(existingUser, updates)
            
            // Simpan perubahan
            userRepository.updateUser(updatedUser)
            
            Result.success(updatedUser)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun validateUpdateRequest(request: UserUpdateRequest, existingUser: User) {
        val errors = mutableListOf<String>()
        
        // Validasi email jika diupdate
        if (request.email != null) {
            validator.validateEmail(request.email).let { result ->
                if (result is UserValidator.ValidationResult.Invalid) {
                    errors.add("Email: ${result.message}")
                }
            }
            
            // Cek apakah email sudah digunakan
            if (userRepository.getUserByEmail(request.email) != null) {
                errors.add("Email already exists")
            }
        }
        
        // Validasi name jika diupdate
        if (request.name != null) {
            validator.validateName(request.name).let { result ->
                if (result is UserValidator.ValidationResult.Invalid) {
                    errors.add("Name: ${result.message}")
                }
            }
        }
        
        if (errors.isNotEmpty()) {
            throw Exception(errors.joinToString("\n"))
        }
    }
    
    private fun applyUpdates(existingUser: User, request: UserUpdateRequest): User {
        return existingUser.copy(
            name = request.name ?: existingUser.name,
            email = request.email ?: existingUser.email,
            age = request.age ?: existingUser.age,
            updatedAt = System.currentTimeMillis()
        )
    }
}

/**
 * Data class untuk permintaan update
 */
data class UserUpdateRequest(
    val name: String? = null,
    val email: String? = null,
    val age: Int? = null
)
```

### Use Case untuk Operasi Delete:

**domain/usecase/DeleteUserWithRulesUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import com.example.usecasesample.domain.repository.UserActivityRepository

/**
 * Use Case untuk delete dengan aturan bisnis
 */
class DeleteUserWithRulesUseCase(
    private val userRepository: UserRepository,
    private val userActivityRepository: UserActivityRepository
) {
    suspend operator fun invoke(userId: String): Result<Boolean> {
        return try {
            // Ambil user
            val user = userRepository.getUserById(userId)
                ?: return Result.failure(Exception("User not found"))
            
            // Validasi aturan bisnis
            validateDeletionRules(user)
            
            // Lakukan operasi cleanup sebelum delete
            cleanupUserData(userId)
            
            // Hapus user
            userRepository.deleteUser(userId)
            
            Result.success(true)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun validateDeletionRules(user: User) {
        // Aturan: tidak bisa hapus admin
        if (user.role == "ADMIN") {
            throw Exception("Cannot delete admin user")
        }
        
        // Aturan: user dengan aktivitas aktif tidak boleh dihapus
        if (userActivityRepository.hasActiveSubscriptions(user.id)) {
            throw Exception("User has active subscriptions")
        }
        
        // Aturan: user dengan saldo tidak boleh dihapus
        if (user.balance > 0) {
            throw Exception("User has remaining balance")
        }
    }
    
    private suspend fun cleanupUserData(userId: String) {
        // Cleanup berbagai data terkait
        userActivityRepository.deleteUserActivities(userId)
        // Tambahkan cleanup lainnya sesuai kebutuhan
    }
}
```

### üéì Penjelasan Konsep:
**Membuat Use Cases seperti Menulis Skenario:**
- **Input jelas**: Parameter dan validasi
- **Logic terstruktur**: Aturan sesuai bisnis
- **Output konsisten**: Format hasil yang jelas
- **Error handling**: Penanganan masalah dengan baik

---

## 4Ô∏è‚É£ Kategori Use Cases üìã

### Konsep Dasar
Use Cases memiliki berbagai kategori seperti jenis pekerjaan kantor üè¢ - masing-masing memiliki tujuan dan cara kerja yang berbeda!

### 1. Query Use Cases (Mendapatkan Data):

**domain/usecase/QueryUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.model.Post
import com.example.usecasesample.domain.repository.UserRepository
import com.example.usecasesample.domain.repository.PostRepository
import kotlinx.coroutines.flow.Flow

/**
 * Query Use Cases - untuk mendapatkan data
 */
class GetUsersUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(): List<User> {
        return userRepository.getUsers()
    }
}

class GetUserByIdUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): User? {
        return userRepository.getUserById(userId)
    }
}

class GetUsersByRoleUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(role: String): List<User> {
        return userRepository.getUsersByRole(role)
    }
}

class GetUserPostsUseCase(
    private val postRepository: PostRepository
) {
    suspend operator fun invoke(userId: String): List<Post> {
        return postRepository.getPostsByUserId(userId)
    }
}

class SearchUsersUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(query: String): List<User> {
        return userRepository.searchUsers(query)
    }
}

class GetUserStatsUseCase(
    private val userRepository: UserRepository,
    private val postRepository: PostRepository
) {
    suspend operator fun invoke(userId: String): UserStats {
        val user = userRepository.getUserById(userId) ?: return UserStats.empty()
        val postCount = postRepository.getPostCountByUserId(userId)
        val userEngagement = calculateEngagementScore(user.id)
        
        return UserStats(
            userId = user.id,
            postCount = postCount,
            engagementScore = userEngagement,
            joinDate = user.createdAt
        )
    }
    
    private suspend fun calculateEngagementScore(userId: String): Double {
        // Complex calculation logic
        return 0.0
    }
}

data class UserStats(
    val userId: String,
    val postCount: Int,
    val engagementScore: Double,
    val joinDate: Long
)

/**
 * Companion object untuk query yang kompleks
 */
class ComplexQueryUseCase(
    private val userRepository: UserRepository,
    private val postRepository: PostRepository
) {
    suspend operator fun invoke(query: ComplexQuery): List<User> {
        var users = userRepository.getUsers()
        
        // Apply filters
        users = applyFilters(users, query.filters)
        
        // Apply sorting
        users = applySorting(users, query.sorting)
        
        // Apply pagination
        users = applyPagination(users, query.pagination)
        
        return users
    }
    
    private fun applyFilters(users: List<User>, filters: List<Filter>): List<User> {
        var filteredUsers = users
        filters.forEach { filter ->
            filteredUsers = when (filter.type) {
                FilterType.ACTIVE -> filteredUsers.filter { it.isActive }
                FilterType.ROLE -> filteredUsers.filter { it.role == filter.value }
                FilterType.AGE_RANGE -> filteredUsers.filter { it.age >= filter.min && it.age <= filter.max }
            }
        }
        return filteredUsers
    }
    
    private fun applySorting(users: List<User>, sorting: Sorting): List<User> {
        return when (sorting.field) {
            SortField.NAME -> users.sortedBy { it.name }
            SortField.EMAIL -> users.sortedBy { it.email }
            SortField.CREATED_AT -> users.sortedBy { it.createdAt }
        }
    }
    
    private fun applyPagination(users: List<User>, pagination: Pagination): List<User> {
        val startIndex = pagination.page * pagination.size
        val endIndex = minOf(startIndex + pagination.size, users.size)
        return users.subList(startIndex, endIndex)
    }
}

data class ComplexQuery(
    val filters: List<Filter>,
    val sorting: Sorting,
    val pagination: Pagination
)

data class Filter(
    val type: FilterType,
    val value: String? = null,
    val min: Int? = null,
    val max: Int? = null
)

enum class FilterType { ACTIVE, ROLE, AGE_RANGE }
enum class SortField { NAME, EMAIL, CREATED_AT }
data class Sorting(val field: SortField, val ascending: Boolean = true)
data class Pagination(val page: Int, val size: Int)
```

### 2. Command Use Cases (Mengubah Data):

**domain/usecase/CommandUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Command Use Cases - untuk mengubah data
 */
class CreateUserUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userData: UserData): Result<String> {
        return try {
            // Validasi
            if (userData.email.isBlank()) {
                return Result.failure(Exception("Email cannot be blank"))
            }
            
            // Cek apakah email sudah ada
            if (userRepository.getUserByEmail(userData.email) != null) {
                return Result.failure(Exception("Email already exists"))
            }
            
            // Buat user baru
            val userId = "user_${System.currentTimeMillis()}"
            val user = User(
                id = userId,
                name = userData.name,
                email = userData.email,
                createdAt = System.currentTimeMillis()
            )
            
            userRepository.saveUser(user)
            
            Result.success(userId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

class UpdateUserUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String, updates: UserUpdates): Result<User> {
        return try {
            val existingUser = userRepository.getUserById(userId)
                ?: return Result.failure(Exception("User not found"))
            
            val updatedUser = existingUser.copy(
                name = updates.name ?: existingUser.name,
                email = updates.email ?: existingUser.email,
                updatedAt = System.currentTimeMillis()
            )
            
            userRepository.updateUser(updatedUser)
            Result.success(updatedUser)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

class DeleteUserUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): Result<Boolean> {
        return try {
            userRepository.deleteUser(userId)
            Result.success(true)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

class ActivateUserUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): Result<User> {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return Result.failure(Exception("User not found"))
            
            if (user.isActive) {
                return Result.failure(Exception("User is already active"))
            }
            
            val activatedUser = user.copy(
                isActive = true,
                lastActive = System.currentTimeMillis()
            )
            
            userRepository.updateUser(activatedUser)
            Result.success(activatedUser)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

class DeactivateUserUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): Result<User> {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return Result.failure(Exception("User not found"))
            
            if (!user.isActive) {
                return Result.failure(Exception("User is already inactive"))
            }
            
            val deactivatedUser = user.copy(
                isActive = false,
                lastActive = System.currentTimeMillis()
            )
            
            userRepository.updateUser(deactivatedUser)
            Result.success(deactivatedUser)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

data class UserData(
    val name: String,
    val email: String
)

data class UserUpdates(
    val name: String? = null,
    val email: String? = null
)
```

### 3. Validation Use Cases:

**domain/usecase/ValidationUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import com.example.usecasesample.domain.validation.UserValidator

/**
 * Validation Use Cases - untuk validasi aturan bisnis
 */
class ValidateUserRegistrationUseCase(
    private val userRepository: UserRepository,
    private val validator: UserValidator = UserValidator
) {
    suspend operator fun invoke(userData: UserData): ValidationResult {
        val errors = mutableListOf<String>()
        
        // Validasi format
        validator.validateEmail(userData.email).let { result ->
            if (result is UserValidator.ValidationResult.Invalid) {
                errors.add("Email: ${result.message}")
            }
        }
        
        validator.validateName(userData.name).let { result ->
            if (result is UserValidator.ValidationResult.Invalid) {
                errors.add("Name: ${result.message}")
            }
        }
        
        // Validasi bisnis
        if (userRepository.getUserByEmail(userData.email) != null) {
            errors.add("Email already exists")
        }
        
        return if (errors.isEmpty()) {
            ValidationResult.Valid
        } else {
            ValidationResult.Invalid(errors)
        }
    }
}

class ValidateUserUpdateUseCase(
    private val userRepository: UserRepository,
    private val validator: UserValidator = UserValidator
) {
    suspend operator fun invoke(userId: String, updates: UserUpdates): ValidationResult {
        val errors = mutableListOf<String>()
        
        // Ambil user eksisting
        val existingUser = userRepository.getUserById(userId)
            ?: return ValidationResult.Invalid(listOf("User not found"))
        
        // Validasi email jika diupdate
        if (updates.email != null) {
            validator.validateEmail(updates.email).let { result ->
                if (result is UserValidator.ValidationResult.Invalid) {
                    errors.add("Email: ${result.message}")
                }
            }
            
            // Cek kesamaan email
            if (updates.email != existingUser.email) {
                // Cek apakah email baru sudah digunakan
                if (userRepository.getUserByEmail(updates.email) != null) {
                    errors.add("Email already exists")
                }
            }
        }
        
        // Validasi name jika diupdate
        if (updates.name != null) {
            validator.validateName(updates.name).let { result ->
                if (result is UserValidator.ValidationResult.Invalid) {
                    errors.add("Name: ${result.message}")
                }
            }
        }
        
        return if (errors.isEmpty()) {
            ValidationResult.Valid
        } else {
            ValidationResult.Invalid(errors)
        }
    }
}

class ValidateBusinessRulesUseCase {
    suspend operator fun invoke(transaction: Transaction): ValidationResult {
        val errors = mutableListOf<String>()
        
        // Validasi saldo cukup
        if (transaction.amount > transaction.userBalance) {
            errors.add("Insufficient balance")
        }
        
        // Validasi limit harian
        if (transaction.amount > transaction.dailyLimit) {
            errors.add("Exceeds daily limit")
        }
        
        // Validasi waktu transaksi
        if (!isTransactionTimeValid(transaction.timestamp)) {
            errors.add("Invalid transaction time")
        }
        
        return if (errors.isEmpty()) {
            ValidationResult.Valid
        } else {
            ValidationResult.Invalid(errors)
        }
    }
    
    private fun isTransactionTimeValid(timestamp: Long): Boolean {
        // Logic untuk validasi waktu transaksi
        return true
    }
}

data class Transaction(
    val userId: String,
    val amount: Double,
    val userBalance: Double,
    val dailyLimit: Double,
    val timestamp: Long
)

sealed class ValidationResult {
    object Valid : ValidationResult()
    data class Invalid(val errors: List<String>) : ValidationResult()
}
```

### 4. Calculation Use Cases:

**domain/usecase/CalculationUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import com.example.usecasesample.domain.repository.OrderRepository

/**
 * Calculation Use Cases - untuk perhitungan kompleks
 */
class CalculateUserScoreUseCase(
    private val userRepository: UserRepository,
    private val orderRepository: OrderRepository
) {
    suspend operator fun invoke(userId: String): UserScore {
        val user = userRepository.getUserById(userId)
            ?: return UserScore.empty()
        
        val orderHistory = orderRepository.getOrdersByUserId(userId)
        val totalSpent = orderHistory.sumOf { it.totalAmount }
        val orderCount = orderHistory.size
        val avgOrderValue = if (orderCount > 0) totalSpent / orderCount else 0.0
        
        val engagementScore = calculateEngagementScore(user)
        val loyaltyScore = calculateLoyaltyScore(user)
        val activityScore = calculateActivityScore(orderHistory)
        
        val finalScore = (engagementScore * 0.4 + loyaltyScore * 0.3 + activityScore * 0.3)
        
        return UserScore(
            userId = userId,
            totalSpent = totalSpent,
            orderCount = orderCount,
            avgOrderValue = avgOrderValue,
            engagementScore = engagementScore,
            loyaltyScore = loyaltyScore,
            activityScore = activityScore,
            finalScore = finalScore
        )
    }
    
    private fun calculateEngagementScore(user: User): Double {
        // Logic kompleks untuk penghitungan engagement
        val daysSinceJoin = (System.currentTimeMillis() - user.createdAt) / (24 * 60 * 60 * 1000L)
        val baseScore = minOf(daysSinceJoin / 30.0, 10.0) // Max 10 bulan member
        return baseScore
    }
    
    private fun calculateLoyaltyScore(user: User): Double {
        // Logic kompleks untuk penghitungan loyalty
        return if (user.isPremium) 10.0 else 5.0
    }
    
    private fun calculateActivityScore(orders: List<Order>): Double {
        // Logic kompleks untuk penghitungan activity
        return orders.size.toDouble()
    }
}

class CalculateOrderTotalUseCase {
    operator fun invoke(orderItems: List<OrderItem>, discount: Discount?): OrderTotal {
        val subtotal = orderItems.sumOf { it.price * it.quantity }
        val discountAmount = calculateDiscount(subtotal, discount)
        val taxAmount = calculateTax(subtotal - discountAmount)
        val total = subtotal - discountAmount + taxAmount
        
        return OrderTotal(
            subtotal = subtotal,
            discount = discountAmount,
            tax = taxAmount,
            total = total
        )
    }
    
    private fun calculateDiscount(subtotal: Double, discount: Discount?): Double {
        return when (discount) {
            is Discount.Percentage -> subtotal * (discount.percentage / 100.0)
            is Discount.FixedAmount -> discount.amount
            null -> 0.0
        }
    }
    
    private fun calculateTax(subtotal: Double): Double {
        val taxRate = 0.1 // 10%
        return subtotal * taxRate
    }
}

class CalculateShippingCostUseCase {
    suspend operator fun invoke(
        origin: Location,
        destination: Location,
        weight: Double,
        deliveryType: DeliveryType
    ): ShippingCost {
        val distance = calculateDistance(origin, destination)
        val baseCost = calculateBaseCost(distance, weight, deliveryType)
        val additionalCost = calculateAdditionalCost(origin, destination)
        
        return ShippingCost(
            baseCost = baseCost,
            additionalCost = additionalCost,
            totalCost = baseCost + additionalCost,
            estimatedDeliveryTime = calculateDeliveryTime(distance, deliveryType)
        )
    }
    
    private fun calculateDistance(origin: Location, destination: Location): Double {
        // Implementasi perhitungan jarak (misalnya haversine formula)
        return 0.0
    }
    
    private fun calculateBaseCost(distance: Double, weight: Double, deliveryType: DeliveryType): Double {
        return when (deliveryType) {
            DeliveryType.STANDARD -> distance * 0.1 + weight * 0.5
            DeliveryType.EXPRESS -> distance * 0.2 + weight * 0.8
        }
    }
    
    private fun calculateAdditionalCost(origin: Location, destination: Location): Double {
        // Biaya tambahan berdasarkan lokasi
        return 0.0
    }
    
    private fun calculateDeliveryTime(distance: Double, deliveryType: DeliveryType): String {
        return when (deliveryType) {
            DeliveryType.STANDARD -> "${(distance / 50).toInt()}-7 days"
            DeliveryType.EXPRESS -> "${(distance / 100).toInt()} day"
        }
    }
}

data class UserScore(
    val userId: String,
    val totalSpent: Double,
    val orderCount: Int,
    val avgOrderValue: Double,
    val engagementScore: Double,
    val loyaltyScore: Double,
    val activityScore: Double,
    val finalScore: Double
) {
    companion object {
        fun empty() = UserScore(
            userId = "",
            totalSpent = 0.0,
            orderCount = 0,
            avgOrderValue = 0.0,
            engagementScore = 0.0,
            loyaltyScore = 0.0,
            activityScore = 0.0,
            finalScore = 0.0
        )
    }
}

data class OrderTotal(
    val subtotal: Double,
    val discount: Double,
    val tax: Double,
    val total: Double
)

data class ShippingCost(
    val baseCost: Double,
    val additionalCost: Double,
    val totalCost: Double,
    val estimatedDeliveryTime: String
)

data class Location(val latitude: Double, val longitude: Double)
data class OrderItem(val productId: String, val price: Double, val quantity: Int)
data class Order(val id: String, val userId: String, val totalAmount: Double, val createdAt: Long)
data class Discount(val type: String, val value: Double)

sealed class Discount {
    data class Percentage(val percentage: Double) : Discount()
    data class FixedAmount(val amount: Double) : Discount()
}

enum class DeliveryType { STANDARD, EXPRESS }
```

### 5. Transformation Use Cases:

**domain/usecase/TransformationUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.model.UserReport

/**
 * Transformation Use Cases - untuk transformasi data
 */
class GenerateUserReportUseCase {
    suspend operator fun invoke(users: List<User>): UserReport {
        val activeUsers = users.filter { it.isActive }
        val inactiveUsers = users.filterNot { it.isActive }
        val premiumUsers = users.filter { it.isPremium }
        
        val report = UserReport(
            totalUsers = users.size,
            activeUsersCount = activeUsers.size,
            inactiveUsersCount = inactiveUsers.size,
            premiumUsersCount = premiumUsers.size,
            averageUserAge = users.map { it.age }.average(),
            countryDistribution = calculateCountryDistribution(users),
            registrationTrend = calculateRegistrationTrend(users)
        )
        
        return report
    }
    
    private fun calculateCountryDistribution(users: List<User>): Map<String, Int> {
        return users.groupingBy { it.country }.eachCount()
    }
    
    private fun calculateRegistrationTrend(users: List<User>): Map<String, Int> {
        // Group by month of registration
        return users.groupingBy { 
            // Convert timestamp to month-year string
            convertToMonthYear(it.createdAt)
        }.eachCount()
    }
    
    private fun convertToMonthYear(timestamp: Long): String {
        // Simple conversion to month-year string
        return "2023-01" // Placeholder
    }
}

class TransformUserDataUseCase {
    operator fun invoke(userData: RawUserData): TransformedUserData {
        return TransformedUserData(
            id = processId(userData.id),
            name = normalizeName(userData.name),
            email = normalizeEmail(userData.email),
            phone = formatPhone(userData.phone),
            address = formatAddress(userData.address),
            preferences = parsePreferences(userData.preferences),
            tags = extractTags(userData.profile)
        )
    }
    
    private fun processId(rawId: String): String {
        // Process and standardize ID
        return rawId.trim().uppercase()
    }
    
    private fun normalizeName(rawName: String): String {
        // Normalize name format
        return rawName.trim().split(" ").joinToString(" ") { it.capitalize() }
    }
    
    private fun normalizeEmail(rawEmail: String): String {
        // Normalize email format
        return rawEmail.trim().lowercase()
    }
    
    private fun formatPhone(rawPhone: String): String {
        // Format phone number
        val cleaned = rawPhone.replace(Regex("[^0-9]"), "")
        return if (cleaned.length == 10) "($cleaned.substring(0, 3)) $cleaned.substring(3, 6)-$cleaned.substring(6)" else cleaned
    }
    
    private fun formatAddress(rawAddress: String): String {
        // Format address
        return rawAddress.trim().replace("\n", ", ")
    }
    
    private fun parsePreferences(rawPreferences: String): Map<String, String> {
        // Parse preferences from string
        return rawPreferences.split(",").associate { 
            val parts = it.split("=")
            if (parts.size == 2) parts[0].trim() to parts[1].trim() else it.trim() to "true"
        }
    }
    
    private fun extractTags(profile: String): List<String> {
        // Extract tags from profile text
        val tagRegex = Regex("#(\\w+)")
        return tagRegex.findAll(profile).map { it.groupValues[1] }.toList()
    }
}

class DataMigrationUseCase {
    suspend operator fun invoke(oldData: OldUserData): NewUserData {
        return NewUserData(
            id = mapId(oldData.legacyId),
            profile = mapProfile(oldData.userInfo),
            preferences = mapPreferences(oldData.settings),
            history = mapHistory(oldData.activityLog),
            status = mapStatus(oldData.accountStatus)
        )
    }
    
    private fun mapId(legacyId: String): String {
        // Migrate ID format
        return "new_$legacyId"
    }
    
    private fun mapProfile(userInfo: UserInfo): UserProfile {
        return UserProfile(
            firstName = userInfo.firstName,
            lastName = userInfo.lastName,
            email = userInfo.email,
            phone = userInfo.phone,
            birthDate = userInfo.dob
        )
    }
    
    private fun mapPreferences(settings: Settings): UserPreferences {
        return UserPreferences(
            theme = mapTheme(settings.theme),
            notifications = settings.notificationEnabled,
            language = settings.language
        )
    }
    
    private fun mapTheme(oldTheme: String): String {
        return when (oldTheme.toLowerCase()) {
            "light" -> "system"
            "dark" -> "dark"
            else -> "light"
        }
    }
    
    private fun mapHistory(activityLog: List<ActivityLog>): List<UserActivity> {
        return activityLog.map { log ->
            UserActivity(
                type = log.action,
                timestamp = log.timestamp,
                details = log.details
            )
        }
    }
    
    private fun mapStatus(accountStatus: String): UserStatus {
        return when (accountStatus.toLowerCase()) {
            "active" -> UserStatus.ACTIVE
            "inactive" -> UserStatus.INACTIVE
            "suspended" -> UserStatus.SUSPENDED
            else -> UserStatus.PENDING
        }
    }
}

// Data classes untuk contoh
data class RawUserData(
    val id: String,
    val name: String,
    val email: String,
    val phone: String,
    val address: String,
    val preferences: String,
    val profile: String
)

data class TransformedUserData(
    val id: String,
    val name: String,
    val email: String,
    val phone: String,
    val address: String,
    val preferences: Map<String, String>,
    val tags: List<String>
)

data class OldUserData(
    val legacyId: String,
    val userInfo: UserInfo,
    val settings: Settings,
    val activityLog: List<ActivityLog>,
    val accountStatus: String
)

data class NewUserData(
    val id: String,
    val profile: UserProfile,
    val preferences: UserPreferences,
    val history: List<UserActivity>,
    val status: UserStatus
)

data class UserInfo(
    val firstName: String,
    val lastName: String,
    val email: String,
    val phone: String,
    val dob: String
)

data class Settings(
    val theme: String,
    val notificationEnabled: Boolean,
    val language: String
)

data class ActivityLog(
    val action: String,
    val timestamp: Long,
    val details: String
)

data class UserProfile(
    val firstName: String,
    val lastName: String,
    val email: String,
    val phone: String,
    val birthDate: String
)

data class UserPreferences(
    val theme: String,
    val notifications: Boolean,
    val language: String
)

data class UserActivity(
    val type: String,
    val timestamp: Long,
    val details: String
)

enum class UserStatus { ACTIVE, INACTIVE, SUSPENDED, PENDING }
```

### üéì Penjelasan Konsep:
**Kategori Use Cases seperti Jenis Pekerjaan:**
- **Query**: Pekerjaan mengambil informasi
- **Command**: Pekerjaan mengubah data
- **Validation**: Pekerjaan memeriksa aturan
- **Calculation**: Pekerjaan perhitungan kompleks
- **Transformation**: Pekerjaan mengubah format data

---

## 5Ô∏è‚É£ Input dan Output Models üîÑ

### Konsep Dasar
Input dan Output Models seperti formulir dan dokumen resmi üìã - harus dalam format yang benar dan sesuai kebutuhan!

### Use Case Parameters:

**domain/usecase/ParameterizedUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import kotlinx.coroutines.flow.Flow

/**
 * Parameter yang terstruktur untuk Use Cases
 */
class GetUsersWithParametersUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Use Case dengan parameter kompleks
     */
    suspend operator fun invoke(
        page: Int = 0,
        size: Int = 20,
        sort: Sort = Sort.NAME,
        filter: Filter = Filter.ALL,
        search: String? = null
    ): PagedResult<User> {
        val total = userRepository.getUserCount()
        val users = userRepository.getUsersWithFilters(
            page = page,
            size = size,
            sort = sort,
            filter = filter,
            search = search
        )
        
        return PagedResult(
            data = users,
            page = page,
            size = size,
            total = total,
            totalPages = (total + size - 1) / size
        )
    }
}

/**
 * Data class untuk parameter
 */
data class PagedResult<T>(
    val data: List<T>,
    val page: Int,
    val size: Int,
    val total: Int,
    val totalPages: Int
)

enum class Sort { NAME, EMAIL, CREATED_AT }
enum class Filter { ALL, ACTIVE, INACTIVE, PREMIUM }

/**
 * Use Case dengan parameter objek
 */
class ProcessUserUpdatesUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(request: UserUpdateRequest): Result<User> {
        return try {
            // Validasi request
            val validation = validateRequest(request)
            if (validation !is ValidationResult.Valid) {
                return Result.failure(Exception("Validation failed"))
            }
            
            // Proses update
            val user = userRepository.getUserById(request.userId)
                ?: return Result.failure(Exception("User not found"))
            
            val updatedUser = updateWithRequest(user, request)
            userRepository.updateUser(updatedUser)
            
            Result.success(updatedUser)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private fun validateRequest(request: UserUpdateRequest): ValidationResult {
        val errors = mutableListOf<String>()
        
        if (request.userId.isBlank()) {
            errors.add("User ID is required")
        }
        
        if (request.updates.isEmpty()) {
            errors.add("At least one update is required")
        }
        
        return if (errors.isEmpty()) ValidationResult.Valid else ValidationResult.Invalid(errors)
    }
    
    private fun updateWithRequest(user: User, request: UserUpdateRequest): User {
        var updatedUser = user
        for (update in request.updates) {
            updatedUser = when (update.key) {
                "name" -> updatedUser.copy(name = update.value as String)
                "email" -> updatedUser.copy(email = update.value as String)
                "age" -> updatedUser.copy(age = update.value as Int)
                else -> updatedUser
            }
        }
        return updatedUser.copy(updatedAt = System.currentTimeMillis())
    }
}

data class UserUpdateRequest(
    val userId: String,
    val updates: Map<String, Any>,
    val timestamp: Long = System.currentTimeMillis(),
    val requesterId: String? = null
)

/**
 * Use Case dengan multiple parameters
 */
class ComplexOperationUseCase(
    private val userRepository: UserRepository,
    private val notificationRepository: NotificationRepository
) {
    suspend operator fun invoke(
        operation: OperationType,
        target: TargetType,
        user: String,
        data: Map<String, Any>,
        options: OperationOptions = OperationOptions.default()
    ): Result<OperationResult> {
        return try {
            val result = when (operation) {
                OperationType.CREATE -> handleCreate(target, user, data, options)
                OperationType.UPDATE -> handleUpdate(target, user, data, options)
                OperationType.DELETE -> handleDelete(target, user, data, options)
                OperationType.VALIDATE -> handleValidate(target, user, data, options)
            }
            
            Result.success(result)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun handleCreate(
        target: TargetType,
        user: String,
        data: Map<String, Any>,
        options: OperationOptions
    ): OperationResult {
        // Logic for create operation
        return OperationResult.Success("Created successfully")
    }
    
    private suspend fun handleUpdate(
        target: TargetType,
        user: String,
        data: Map<String, Any>,
        options: OperationOptions
    ): OperationResult {
        // Logic for update operation
        return OperationResult.Success("Updated successfully")
    }
    
    private suspend fun handleDelete(
        target: TargetType,
        user: String,
        data: Map<String, Any>,
        options: OperationOptions
    ): OperationResult {
        // Logic for delete operation
        return OperationResult.Success("Deleted successfully")
    }
    
    private suspend fun handleValidate(
        target: TargetType,
        user: String,
        data: Map<String, Any>,
        options: OperationOptions
    ): OperationResult {
        // Logic for validate operation
        return OperationResult.Success("Validated successfully")
    }
}

enum class OperationType { CREATE, UPDATE, DELETE, VALIDATE }
enum class TargetType { USER, POST, COMMENT, MESSAGE }
data class OperationOptions(
    val dryRun: Boolean = false,
    val auditTrail: Boolean = true,
    val sendNotification: Boolean = true,
    val requireConfirmation: Boolean = false
) {
    companion object {
        fun default() = OperationOptions()
    }
}

sealed class OperationResult {
    data class Success(val message: String) : OperationResult()
    data class Error(val error: String, val code: Int) : OperationResult()
}
```

### Domain Models vs UI Models:

**domain/model/DomainModels.kt**
```kotlin
package com.example.usecasesample.domain.model

/**
 * Domain Models - murni untuk bisnis logic
 */
data class User(
    val id: String,
    val name: String,
    val email: String,
    val age: Int,
    val isActive: Boolean = true,
    val isPremium: Boolean = false,
    val role: String = "USER",
    val country: String = "ID",
    val createdAt: Long = System.currentTimeMillis(),
    val updatedAt: Long = System.currentTimeMillis(),
    val balance: Double = 0.0,
    val profile: UserProfile? = null
)

data class UserProfile(
    val firstName: String,
    val lastName: String,
    val phone: String,
    val address: String,
    val preferences: Map<String, String> = emptyMap()
)

/**
 * Domain model untuk transaksi
 */
data class Transaction(
    val id: String,
    val userId: String,
    val amount: Double,
    val type: TransactionType,
    val status: TransactionStatus,
    val description: String,
    val timestamp: Long = System.currentTimeMillis(),
    val fee: Double = 0.0
)

enum class TransactionType { DEPOSIT, WITHDRAWAL, TRANSFER, PURCHASE }
enum class TransactionStatus { PENDING, COMPLETED, FAILED, CANCELLED }
```

### Result Wrappers:

**domain/usecase/ResultWrappers.kt**
```kotlin
package com.example.usecasesample.domain.usecase

/**
 * Custom Result wrapper untuk kasus kompleks
 */
sealed class UseCaseResult<out T> {
    data class Success<T>(val data: T) : UseCaseResult<T>()
    data class Error(val message: String, val code: String? = null, val exception: Exception? = null) : UseCaseResult<Nothing>()
    object Loading : UseCaseResult<Nothing>()
}

/**
 * Use Case dengan custom Result wrapper
 */
class GetUserWithCustomResultUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): UseCaseResult<User> {
        return try {
            val user = userRepository.getUserById(userId)
            if (user != null) {
                UseCaseResult.Success(user)
            } else {
                UseCaseResult.Error("User not found", "USER_NOT_FOUND")
            }
        } catch (e: Exception) {
            UseCaseResult.Error("Failed to get user", "REPOSITORY_ERROR", e)
        }
    }
}

/**
 * Use Case untuk operasi yang bisa loading
 */
class ProcessUserOperationUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(
        userId: String,
        operation: OperationType
    ): Flow<UseCaseResult<User>> = flow {
        emit(UseCaseResult.Loading)
        
        try {
            when (operation) {
                OperationType.ACTIVATE -> {
                    val user = activateUser(userId)
                    emit(UseCaseResult.Success(user))
                }
                OperationType.DEACTIVATE -> {
                    val user = deactivateUser(userId)
                    emit(UseCaseResult.Success(user))
                }
                OperationType.PREMIUM -> {
                    val user = upgradeToPremium(userId)
                    emit(UseCaseResult.Success(user))
                }
            }
        } catch (e: Exception) {
            emit(UseCaseResult.Error(e.message ?: "Operation failed", null, e))
        }
    }
    
    private suspend fun activateUser(userId: String): User {
        val user = userRepository.getUserById(userId) ?: throw Exception("User not found")
        val updatedUser = user.copy(isActive = true, lastActive = System.currentTimeMillis())
        userRepository.updateUser(updatedUser)
        return updatedUser
    }
    
    private suspend fun deactivateUser(userId: String): User {
        val user = userRepository.getUserById(userId) ?: throw Exception("User not found")
        val updatedUser = user.copy(isActive = false, lastActive = System.currentTimeMillis())
        userRepository.updateUser(updatedUser)
        return updatedUser
    }
    
    private suspend fun upgradeToPremium(userId: String): User {
        val user = userRepository.getUserById(userId) ?: throw Exception("User not found")
        val updatedUser = user.copy(isPremium = true, premiumSince = System.currentTimeMillis())
        userRepository.updateUser(updatedUser)
        return updatedUser
    }
}
```

### Success dan Error Cases:

**domain/usecase/SuccessErrorCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User

/**
 * Use Case dengan penanganan success dan error cases yang lengkap
 */
class CreateUserWithErrorHandlingUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userData: UserData): UseCaseResult<String> {
        return try {
            // Validasi input
            val validation = validateInput(userData)
            if (validation is UseCaseResult.Error) {
                return validation
            }
            
            // Cek apakah user sudah ada
            if (userRepository.getUserByEmail(userData.email) != null) {
                return UseCaseResult.Error("Email already exists", "EMAIL_EXISTS")
            }
            
            // Buat user baru
            val userId = generateUserId()
            val user = User(
                id = userId,
                name = userData.name,
                email = userData.email
            )
            
            userRepository.saveUser(user)
            
            UseCaseResult.Success(userId)
        } catch (e: ValidationException) {
            UseCaseResult.Error(e.message ?: "Validation failed", "VALIDATION_ERROR", e)
        } catch (e: RepositoryException) {
            UseCaseResult.Error(e.message ?: "Repository error", "REPOSITORY_ERROR", e)
        } catch (e: Exception) {
            UseCaseResult.Error(e.message ?: "Unknown error", "UNKNOWN_ERROR", e)
        }
    }
    
    private fun validateInput(userData: UserData): UseCaseResult<Unit> {
        val errors = mutableListOf<String>()
        
        if (userData.name.isBlank()) {
            errors.add("Name is required")
        }
        
        if (userData.email.isBlank()) {
            errors.add("Email is required")
        } else if (!isValidEmail(userData.email)) {
            errors.add("Email format is invalid")
        }
        
        if (errors.isNotEmpty()) {
            return UseCaseResult.Error(errors.joinToString(", "))
        }
        
        return UseCaseResult.Success(Unit)
    }
    
    private fun isValidEmail(email: String): Boolean {
        return email.contains("@") && email.contains(".")
    }
    
    private fun generateUserId(): String {
        return "user_${System.currentTimeMillis()}"
    }
}

/**
 * Custom exceptions
 */
class ValidationException(message: String) : Exception(message)
class RepositoryException(message: String) : Exception(message)
class BusinessRuleException(message: String) : Exception(message)
```

### Nullable vs NonNull Returns:

**domain/usecase/NullableUsesCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Use Case dengan return nullable
 */
class GetUserNullableUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Return nullable ketika item bisa tidak ditemukan
     */
    suspend operator fun invoke(userId: String): User? {
        return userRepository.getUserById(userId)
    }
}

/**
 * Use Case dengan return Result<T?>
 */
class GetUserResultNullableUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Return Result dengan nullable data
     */
    suspend operator fun invoke(userId: String): Result<User?> {
        return try {
            val user = userRepository.getUserById(userId)
            Result.success(user)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

/**
 * Use Case dengan return Result<T> tapi bisa representasikan "not found"
 */
class GetUserWithNotFoundUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Gunakan custom result untuk handle not found secara eksplisit
     */
    suspend operator fun invoke(userId: String): GetUserResult {
        return try {
            val user = userRepository.getUserById(userId)
            if (user != null) {
                GetUserResult.Success(user)
            } else {
                GetUserResult.NotFound
            }
        } catch (e: Exception) {
            GetUserResult.Error(e)
        }
    }
}

sealed class GetUserResult {
    data class Success(val user: User) : GetUserResult()
    object NotFound : GetUserResult()
    data class Error(val exception: Exception) : GetUserResult()
}

/**
 * Use Case dengan return non-null (harus selalu berhasil)
 */
class GenerateReportUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Return non-null karena selalu bisa generate report kosong
     */
    suspend operator fun invoke(filter: ReportFilter): UserReport {
        val users = if (filter.userId != null) {
            val user = userRepository.getUserById(filter.userId)
            if (user != null) listOf(user) else emptyList()
        } else {
            userRepository.getUsers()
        }
        
        return UserReport(
            users = users,
            filter = filter,
            generatedAt = System.currentTimeMillis()
        )
    }
}

data class ReportFilter(
    val userId: String? = null,
    val role: String? = null,
    val isActive: Boolean? = null
)

data class UserReport(
    val users: List<User>,
    val filter: ReportFilter,
    val generatedAt: Long
)
```

### Flow untuk Streaming Data:

**domain/usecase/FlowUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.filter

/**
 * Use Case dengan Flow untuk streaming data
 */
class GetUserStreamUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Return Flow untuk streaming data secara real-time
     */
    operator fun invoke(): Flow<List<User>> {
        return userRepository.getUsersStream()
    }
    
    /**
     * Return Flow dengan filter
     */
    fun getActiveUsersStream(): Flow<List<User>> {
        return userRepository.getUsersStream()
            .map { users -> users.filter { it.isActive } }
    }
    
    /**
     * Return Flow dengan transformasi
     */
    fun getUserNamesStream(): Flow<List<String>> {
        return userRepository.getUsersStream()
            .map { users -> users.map { it.name } }
    }
}

/**
 * Use Case dengan Flow kompleks
 */
class ComplexUserStreamUseCase(
    private val userRepository: UserRepository
) {
    operator fun invoke(filter: UserFilter): Flow<UserStreamResult> {
        return userRepository.getUsersStream()
            .map { users ->
                val filtered = applyFilter(users, filter)
                UserStreamResult.Success(filtered)
            }
    }
    
    private fun applyFilter(users: List<User>, filter: UserFilter): List<User> {
        return users.filter { user ->
            var match = true
            if (filter.role != null) match = match && user.role == filter.role
            if (filter.isActive != null) match = match && user.isActive == filter.isActive
            if (filter.isPremium != null) match = match && user.isPremium == filter.isPremium
            if (filter.minAge != null) match = match && user.age >= filter.minAge
            if (filter.maxAge != null) match = match && user.age <= filter.maxAge
            match
        }
    }
}

data class UserFilter(
    val role: String? = null,
    val isActive: Boolean? = null,
    val isPremium: Boolean? = null,
    val minAge: Int? = null,
    val maxAge: Int? = null
)

sealed class UserStreamResult {
    data class Success(val users: List<User>) : UserStreamResult()
    data class Error(val exception: Exception) : UserStreamResult()
}
```

### üéì Penjelasan Konsep:
**Input dan Output Models seperti Formulir:**
- **Input**: Harus dalam format yang benar dan terstruktur
- **Output**: Harus jelas jenis dan kemungkinannya
- **Domain Models**: Format murni untuk logika bisnis
- **Result Wrappers**: Untuk penanganan error yang baik

---

## 6Ô∏è‚É£ Implementasi Business Logic ‚öôÔ∏è

### Konsep Dasar
Implementasi Business Logic seperti aturan main perusahaan üè¢ - harus diikuti secara ketat dan konsisten!

### Complex Validations:

**domain/usecase/ComplexValidationUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import com.example.usecasesample.domain.repository.TransactionRepository

/**
 * Use Case dengan validasi kompleks
 */
class ProcessTransactionWithValidationUseCase(
    private val userRepository: UserRepository,
    private val transactionRepository: TransactionRepository
) {
    suspend operator fun invoke(request: TransactionRequest): UseCaseResult<Transaction> {
        return try {
            // Validasi request
            val validationErrors = validateTransactionRequest(request)
            if (validationErrors.isNotEmpty()) {
                return UseCaseResult.Error(
                    "Transaction validation failed: ${validationErrors.joinToString(", ")}",
                    "VALIDATION_ERROR"
                )
            }
            
            // Ambil user
            val user = userRepository.getUserById(request.userId)
                ?: return UseCaseResult.Error("User not found", "USER_NOT_FOUND")
            
            // Validasi bisnis
            val businessValidation = validateBusinessRules(user, request)
            if (businessValidation !is ValidationResult.Valid) {
                return UseCaseResult.Error(
                    "Business rule validation failed: ${(businessValidation as ValidationResult.Invalid).errors.joinToString(", ")}",
                    "BUSINESS_RULE_ERROR"
                )
            }
            
            // Buat transaksi
            val transaction = createTransaction(request, user)
            transactionRepository.saveTransaction(transaction)
            
            // Update user balance jika perlu
            updateUserBalance(user, request.amount, request.type)
            
            UseCaseResult.Success(transaction)
        } catch (e: Exception) {
            UseCaseResult.Error(e.message ?: "Process transaction failed", "PROCESS_ERROR", e)
        }
    }
    
    private fun validateTransactionRequest(request: TransactionRequest): List<String> {
        val errors = mutableListOf<String>()
        
        if (request.userId.isBlank()) {
            errors.add("User ID is required")
        }
        
        if (request.amount <= 0) {
            errors.add("Amount must be greater than 0")
        }
        
        if (request.type !in TransactionType.values()) {
            errors.add("Invalid transaction type")
        }
        
        if (request.description.isBlank()) {
            errors.add("Description is required")
        }
        
        return errors
    }
    
    private suspend fun validateBusinessRules(user: User, request: TransactionRequest): ValidationResult {
        val errors = mutableListOf<String>()
        
        // Validasi saldo untuk withdrawal
        if (request.type == TransactionType.WITHDRAWAL && user.balance < request.amount) {
            errors.add("Insufficient balance")
        }
        
        // Validasi limit harian
        val dailyTransactions = transactionRepository.getDailyTransactions(user.id)
        val dailyTotal = dailyTransactions.sumOf { it.amount }
        if (dailyTotal + request.amount > user.dailyLimit) {
            errors.add("Exceeds daily limit of ${user.dailyLimit}")
        }
        
        // Validasi jam operasional
        if (!isBusinessHours()) {
            errors.add("Transactions not allowed outside business hours")
        }
        
        // Validasi status user
        if (!user.isActive) {
            errors.add("User account is inactive")
        }
        
        // Validasi apakah user terverifikasi
        if (!user.isVerified && request.amount > 1000000) {
            errors.add("Unverified users cannot make transactions above 1,000,000")
        }
        
        return if (errors.isEmpty()) {
            ValidationResult.Valid
        } else {
            ValidationResult.Invalid(errors)
        }
    }
    
    private fun createTransaction(request: TransactionRequest, user: User): Transaction {
        return Transaction(
            id = "txn_${System.currentTimeMillis()}",
            userId = request.userId,
            amount = request.amount,
            type = request.type,
            status = TransactionStatus.PENDING,
            description = request.description,
            timestamp = System.currentTimeMillis(),
            fee = calculateTransactionFee(request)
        )
    }
    
    private suspend fun updateUserBalance(user: User, amount: Double, type: TransactionType) {
        val updatedBalance = when (type) {
            TransactionType.DEPOSIT -> user.balance + amount
            TransactionType.WITHDRAWAL -> user.balance - amount
            TransactionType.TRANSFER -> user.balance - amount  // Assuming transfer out
            TransactionType.PURCHASE -> user.balance - amount
        }
        
        val updatedUser = user.copy(balance = updatedBalance)
        userRepository.updateUser(updatedUser)
    }
    
    private fun calculateTransactionFee(request: TransactionRequest): Double {
        // Fee calculation based on amount and type
        val baseFee = when (request.type) {
            TransactionType.WITHDRAWAL -> 5000.0
            TransactionType.TRANSFER -> 2500.0
            TransactionType.PURCHASE -> 0.0
            TransactionType.DEPOSIT -> 0.0
        }
        
        val percentageFee = request.amount * 0.001  // 0.1%
        return maxOf(baseFee, percentageFee)
    }
    
    private fun isBusinessHours(): Boolean {
        // Simplified business hours check
        val currentHour = getCurrentHour()
        return currentHour >= 8 && currentHour <= 17  // 8 AM to 5 PM
    }
    
    private fun getCurrentHour(): Int {
        // Placeholder for current hour
        return 10
    }
}

data class TransactionRequest(
    val userId: String,
    val amount: Double,
    val type: TransactionType,
    val description: String
)

sealed class ValidationResult {
    object Valid : ValidationResult()
    data class Invalid(val errors: List<String>) : ValidationResult()
}
```

### Multi-step Operations:

**domain/usecase/MultiStepOperationUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.*

/**
 * Use Case dengan operasi multi-langkah
 */
class CompleteUserRegistrationUseCase(
    private val userRepository: UserRepository,
    private val profileRepository: ProfileRepository,
    private val notificationRepository: NotificationRepository,
    private val analyticsRepository: AnalyticsRepository
) {
    suspend operator fun invoke(request: RegistrationRequest): RegistrationResult {
        var currentStep = "start"
        
        try {
            // Langkah 1: Validasi input
            currentStep = "validation"
            validateInput(request)
            
            // Langkah 2: Cek apakah user sudah ada
            currentStep = "check_existing"
            if (userRepository.getUserByEmail(request.email) != null) {
                return RegistrationResult.Error("Email already exists", "EMAIL_EXISTS")
            }
            
            // Langkah 3: Buat user dasar
            currentStep = "create_user"
            val userId = generateUserId()
            val user = createUser(request, userId)
            userRepository.saveUser(user)
            
            // Langkah 4: Buat profile
            currentStep = "create_profile"
            val profile = createProfile(request, userId)
            profileRepository.saveProfile(profile)
            
            // Langkah 5: Kirim notifikasi verifikasi
            currentStep = "send_verification"
            sendVerificationNotification(user)
            
            // Langkah 6: Log analitik
            currentStep = "log_analytics"
            logRegistrationAnalytics(user)
            
            // Langkah 7: Kirim welcome notification
            currentStep = "send_welcome"
            sendWelcomeNotification(user)
            
            return RegistrationResult.Success(
                user = user,
                verificationSent = true
            )
        } catch (e: Exception) {
            // Rollback jika gagal di tengah jalan
            rollbackOnFailure(currentStep, userId)
            return RegistrationResult.Error(e.message ?: "Registration failed", "REGISTRATION_ERROR", e)
        }
    }
    
    private fun validateInput(request: RegistrationRequest) {
        val errors = mutableListOf<String>()
        
        if (request.email.isBlank() || !request.email.contains("@")) {
            errors.add("Invalid email format")
        }
        
        if (request.name.isBlank() || request.name.length < 2) {
            errors.add("Name must be at least 2 characters")
        }
        
        if (request.password.length < 8) {
            errors.add("Password must be at least 8 characters")
        }
        
        if (request.phoneNumber.isBlank()) {
            errors.add("Phone number is required")
        }
        
        if (errors.isNotEmpty()) {
            throw ValidationException(errors.joinToString(", "))
        }
    }
    
    private fun createUser(request: RegistrationRequest, userId: String): User {
        return User(
            id = userId,
            name = request.name,
            email = request.email,
            phone = request.phoneNumber,
            isActive = false, // User belum aktif sampai verifikasi
            isVerified = false,
            isPremium = false,
            balance = 0.0,
            createdAt = System.currentTimeMillis()
        )
    }
    
    private fun createProfile(request: RegistrationRequest, userId: String): UserProfile {
        return UserProfile(
            id = "profile_$userId",
            userId = userId,
            firstName = request.firstName,
            lastName = request.lastName,
            dateOfBirth = request.dateOfBirth,
            address = request.address,
            preferences = mapOf("theme" to "light", "notifications" to "true")
        )
    }
    
    private fun sendVerificationNotification(user: User) {
        val notification = Notification(
            to = user.email,
            subject = "Account Verification",
            body = "Please verify your account using this link: ${generateVerificationLink(user)}"
        )
        notificationRepository.sendNotification(notification)
    }
    
    private fun logRegistrationAnalytics(user: User) {
        val event = AnalyticsEvent(
            eventName = "user_registration",
            userId = user.id,
            properties = mapOf(
                "timestamp" to user.createdAt.toString(),
                "source" to "android_app"
            )
        )
        analyticsRepository.logEvent(event)
    }
    
    private fun sendWelcomeNotification(user: User) {
        val notification = Notification(
            to = user.email,
            subject = "Welcome to Our App!",
            body = "Thank you for registering. Your account is now active!"
        )
        notificationRepository.sendNotification(notification)
    }
    
    private fun generateVerificationLink(user: User): String {
        return "https://api.example.com/verify/${user.id}"
    }
    
    private fun generateUserId(): String {
        return "user_${System.currentTimeMillis()}"
    }
    
    private suspend fun rollbackOnFailure(currentStep: String, userId: String) {
        when (currentStep) {
            "create_profile" -> {
                // Hapus user yang sudah dibuat
                userRepository.deleteUser(userId)
            }
            "send_verification", "log_analytics", "send_welcome" -> {
                // Hapus user dan profile
                profileRepository.deleteProfile(userId)
                userRepository.deleteUser(userId)
            }
        }
    }
}

/**
 * Data classes untuk multi-step operation
 */
data class RegistrationRequest(
    val name: String,
    val email: String,
    val password: String,
    val firstName: String,
    val lastName: String,
    val phoneNumber: String,
    val dateOfBirth: String,
    val address: String
)

sealed class RegistrationResult {
    data class Success(
        val user: User,
        val verificationSent: Boolean
    ) : RegistrationResult()
    
    data class Error(
        val message: String,
        val code: String,
        val exception: Exception? = null
    ) : RegistrationResult()
}

data class Notification(
    val to: String,
    val subject: String,
    val body: String
)

data class AnalyticsEvent(
    val eventName: String,
    val userId: String,
    val properties: Map<String, String>
)

data class UserProfile(
    val id: String,
    val userId: String,
    val firstName: String,
    val lastName: String,
    val dateOfBirth: String,
    val address: String,
    val preferences: Map<String, String>
)
```

### Orchestrating Multiple Repositories:

**domain/usecase/RepositoryOrchestrationUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.*
import com.example.usecasesample.domain.repository.*

/**
 * Use Case yang mengkoordinasikan beberapa repository
 */
class ProcessOrderUseCase(
    private val userRepository: UserRepository,
    private val orderRepository: OrderRepository,
    private val inventoryRepository: InventoryRepository,
    private val paymentRepository: PaymentRepository,
    private val notificationRepository: NotificationRepository
) {
    suspend operator fun invoke(orderRequest: OrderRequest): ProcessOrderResult {
        return try {
            // Validasi permintaan
            validateOrderRequest(orderRequest)
            
            // Ambil user
            val user = userRepository.getUserById(orderRequest.userId)
                ?: return ProcessOrderResult.Error("User not found")
            
            // Cek ketersediaan produk
            val inventoryCheck = checkInventory(orderRequest.items)
            if (!inventoryCheck.isAvailable) {
                return ProcessOrderResult.Error("Insufficient inventory: ${inventoryCheck.unavailableItems.joinToString(", ")}")
            }
            
            // Hitung total harga
            val totalAmount = calculateTotalAmount(orderRequest.items)
            
            // Validasi saldo user
            if (user.balance < totalAmount) {
                return ProcessOrderResult.Error("Insufficient balance")
            }
            
            // Buat order sementara
            val order = createOrder(orderRequest, user, totalAmount)
            orderRepository.saveOrder(order)
            
            // Proses pembayaran
            val paymentResult = processPayment(user, totalAmount)
            if (!paymentResult.isSuccess) {
                orderRepository.updateOrderStatus(order.id, OrderStatus.PAYMENT_FAILED)
                return ProcessOrderResult.Error("Payment failed: ${paymentResult.message}")
            }
            
            // Kurangi stok
            reduceInventory(orderRequest.items)
            
            // Update status order
            val completedOrder = order.copy(status = OrderStatus.COMPLETED)
            orderRepository.updateOrder(completedOrder)
            
            // Kirim notifikasi
            sendOrderConfirmationNotification(user, completedOrder)
            
            ProcessOrderResult.Success(completedOrder)
        } catch (e: Exception) {
            // Rollback jika terjadi kesalahan
            return ProcessOrderResult.Error(e.message ?: "Order processing failed")
        }
    }
    
    private fun validateOrderRequest(request: OrderRequest) {
        if (request.userId.isBlank()) {
            throw ValidationException("User ID is required")
        }
        
        if (request.items.isEmpty()) {
            throw ValidationException("Order items cannot be empty")
        }
        
        request.items.forEach { item ->
            if (item.productId.isBlank()) {
                throw ValidationException("Product ID is required")
            }
            if (item.quantity <= 0) {
                throw ValidationException("Quantity must be greater than 0")
            }
        }
    }
    
    private suspend fun checkInventory(items: List<OrderItem>): InventoryCheckResult {
        val unavailableItems = mutableListOf<String>()
        
        for (item in items) {
            val availableStock = inventoryRepository.getStock(item.productId)
            if (availableStock < item.quantity) {
                unavailableItems.add(item.productId)
            }
        }
        
        return if (unavailableItems.isEmpty()) {
            InventoryCheckResult(isAvailable = true, unavailableItems = emptyList())
        } else {
            InventoryCheckResult(isAvailable = false, unavailableItems = unavailableItems)
        }
    }
    
    private fun calculateTotalAmount(items: List<OrderItem>): Double {
        return items.sumOf { item ->
            val product = inventoryRepository.getProduct(item.productId)
            (product?.price ?: 0.0) * item.quantity
        }
    }
    
    private fun createOrder(request: OrderRequest, user: User, totalAmount: Double): Order {
        return Order(
            id = "order_${System.currentTimeMillis()}",
            userId = request.userId,
            items = request.items,
            totalAmount = totalAmount,
            status = OrderStatus.PENDING,
            createdAt = System.currentTimeMillis(),
            address = request.shippingAddress
        )
    }
    
    private suspend fun processPayment(user: User, amount: Double): PaymentResult {
        val paymentRequest = PaymentRequest(
            userId = user.id,
            amount = amount,
            description = "Order payment"
        )
        
        return paymentRepository.processPayment(paymentRequest)
    }
    
    private suspend fun reduceInventory(items: List<OrderItem>) {
        for (item in items) {
            inventoryRepository.reduceStock(item.productId, item.quantity)
        }
    }
    
    private suspend fun sendOrderConfirmationNotification(user: User, order: Order) {
        val notification = Notification(
            to = user.email,
            subject = "Order Confirmation",
            body = "Your order #${order.id} has been confirmed. Total: ${order.totalAmount}"
        )
        notificationRepository.sendNotification(notification)
    }
}

/**
 * Data classes untuk order processing
 */
data class OrderRequest(
    val userId: String,
    val items: List<OrderItem>,
    val shippingAddress: String
)

data class OrderItem(
    val productId: String,
    val quantity: Int
)

data class Order(
    val id: String,
    val userId: String,
    val items: List<OrderItem>,
    val totalAmount: Double,
    val status: OrderStatus,
    val createdAt: Long,
    val address: String
)

enum class OrderStatus { PENDING, COMPLETED, CANCELLED, PAYMENT_FAILED }

data class PaymentRequest(
    val userId: String,
    val amount: Double,
    val description: String
)

data class PaymentResult(
    val isSuccess: Boolean,
    val message: String,
    val transactionId: String? = null
)

data class InventoryCheckResult(
    val isAvailable: Boolean,
    val unavailableItems: List<String>
)

sealed class ProcessOrderResult {
    data class Success(val order: Order) : ProcessOrderResult()
    data class Error(val message: String) : ProcessOrderResult()
}
```

### Business Rules Enforcement:

**domain/usecase/BusinessRulesUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import kotlinx.datetime.LocalDateTime

/**
 * Use Case yang menerapkan aturan bisnis kompleks
 */
class ApplyBusinessRulesUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String, action: BusinessAction): BusinessRuleResult {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return BusinessRuleResult.Error("User not found")
            
            // Terapkan aturan bisnis berdasarkan aksi
            when (action) {
                is BusinessAction.PremiumUpgrade -> handlePremiumUpgrade(user, action)
                is BusinessAction.PromotionAccess -> handlePromotionAccess(user, action)
                is BusinessAction.LimitAdjustment -> handleLimitAdjustment(user, action)
                is BusinessAction.VipAssignment -> handleVipAssignment(user, action)
            }
        } catch (e: Exception) {
            BusinessRuleResult.Error(e.message ?: "Business rule application failed")
        }
    }
    
    private suspend fun handlePremiumUpgrade(user: User, action: BusinessAction.PremiumUpgrade): BusinessRuleResult {
        // Aturan: hanya user aktif bisa upgrade
        if (!user.isActive) {
            return BusinessRuleResult.Error("User must be active to upgrade to premium")
        }
        
        // Aturan: hanya user tertentu yang bisa upgrade
        val eligibility = checkPremiumEligibility(user)
        if (!eligibility.isEligible) {
            return BusinessRuleResult.Error("User not eligible for premium: ${eligibility.reason}")
        }
        
        // Aturan: cek pembayaran
        if (!action.hasPayment) {
            return BusinessRuleResult.Error("Payment required for premium upgrade")
        }
        
        // Lakukan upgrade
        val updatedUser = user.copy(
            isPremium = true,
            premiumSince = System.currentTimeMillis(),
            premiumUntil = System.currentTimeMillis() + action.durationInMillis
        )
        
        userRepository.updateUser(updatedUser)
        return BusinessRuleResult.Success("User upgraded to premium")
    }
    
    private suspend fun handlePromotionAccess(user: User, action: BusinessAction.PromotionAccess): BusinessRuleResult {
        // Aturan: hanya premium user bisa akses promosi tertentu
        if (!user.isPremium && action.requiresPremium) {
            return BusinessRuleResult.Error("Premium membership required for this promotion")
        }
        
        // Aturan: cek apakah promosi masih aktif
        if (!isPromotionActive(action.promotionId)) {
            return BusinessRuleResult.Error("Promotion is not active")
        }
        
        // Aturan: cek kuota promosi
        if (isPromotionQuotaExhausted(action.promotionId)) {
            return BusinessRuleResult.Error("Promotion quota exhausted")
        }
        
        // Tandai bahwa user telah mengakses promosi
        userRepository.addPromotionAccess(user.id, action.promotionId)
        
        return BusinessRuleResult.Success("Promotion access granted")
    }
    
    private suspend fun handleLimitAdjustment(user: User, action: BusinessAction.LimitAdjustment): BusinessRuleResult {
        // Aturan: hanya admin atau user dengan peran tertentu bisa adjust limit
        if (!hasLimitAdjustmentPermission(user)) {
            return BusinessRuleResult.Error("Insufficient permissions to adjust limit")
        }
        
        // Aturan: cek batas maksimum dan minimum
        if (action.newLimit < MIN_LIMIT || action.newLimit > MAX_LIMIT) {
            return BusinessRuleResult.Error("Limit must be between $MIN_LIMIT and $MAX_LIMIT")
        }
        
        // Aturan: log perubahan limit
        logLimitAdjustment(user.id, user.dailyLimit, action.newLimit, action.reason)
        
        // Update limit
        val updatedUser = user.copy(dailyLimit = action.newLimit)
        userRepository.updateUser(updatedUser)
        
        return BusinessRuleResult.Success("Limit adjusted successfully")
    }
    
    private suspend fun handleVipAssignment(user: User, action: BusinessAction.VipAssignment): BusinessRuleResult {
        // Aturan: hanya user dengan aktivitas tinggi bisa jadi VIP
        val activityScore = calculateActivityScore(user.id)
        if (activityScore < VIP_THRESHOLD) {
            return BusinessRuleResult.Error("User does not meet VIP activity requirements")
        }
        
        // Aturan: hanya bisa assign VIP untuk user tertentu
        if (!isVipEligibleUser(user)) {
            return BusinessRuleResult.Error("User is not eligible for VIP status")
        }
        
        // Aturan: cek apakah user sudah VIP
        if (user.isVip) {
            return BusinessRuleResult.Error("User is already a VIP")
        }
        
        // Assign VIP status
        val updatedUser = user.copy(
            isVip = true,
            vipSince = System.currentTimeMillis(),
            vipBenefits = action.benefits
        )
        
        userRepository.updateUser(updatedUser)
        return BusinessRuleResult.Success("VIP status assigned successfully")
    }
    
    private fun checkPremiumEligibility(user: User): EligibilityResult {
        // Aturan kompleks untuk eligibility
        if (user.isVerified) {
            return EligibilityResult(isEligible = true)
        }
        
        if (user.registrationDate < getEligibleDate()) {
            return EligibilityResult(isEligible = true, reason = "Long-term member")
        }
        
        return EligibilityResult(isEligible = false, reason = "User must be verified")
    }
    
    private fun isPromotionActive(promotionId: String): Boolean {
        // Logic untuk cek status promosi
        return true
    }
    
    private fun isPromotionQuotaExhausted(promotionId: String): Boolean {
        // Logic untuk cek kuota promosi
        return false
    }
    
    private fun hasLimitAdjustmentPermission(user: User): Boolean {
        return user.role == "ADMIN" || user.role == "SUPERVISOR"
    }
    
    private fun isVipEligibleUser(user: User): Boolean {
        return user.isActive && user.isPremium
    }
    
    private suspend fun calculateActivityScore(userId: String): Double {
        // Logic kompleks untuk menghitung skor aktivitas
        return 10.0
    }
    
    private suspend fun logLimitAdjustment(
        userId: String,
        oldLimit: Double,
        newLimit: Double,
        reason: String
    ) {
        // Log perubahan limit
    }
    
    private fun getEligibleDate(): Long {
        // Misalnya, user harus terdaftar lebih dari 30 hari yang lalu
        return System.currentTimeMillis() - (30 * 24 * 60 * 60 * 1000L)
    }
    
    companion object {
        const val MIN_LIMIT = 10000.0
        const val MAX_LIMIT = 10000000.0
        const val VIP_THRESHOLD = 8.0
    }
}

/**
 * Data classes untuk business rules
 */
sealed class BusinessAction {
    data class PremiumUpgrade(
        val hasPayment: Boolean,
        val durationInMillis: Long
    ) : BusinessAction()
    
    data class PromotionAccess(
        val promotionId: String,
        val requiresPremium: Boolean
    ) : BusinessAction()
    
    data class LimitAdjustment(
        val newLimit: Double,
        val reason: String
    ) : BusinessAction()
    
    data class VipAssignment(
        val benefits: List<String>
    ) : BusinessAction()
}

data class EligibilityResult(
    val isEligible: Boolean,
    val reason: String? = null
)

sealed class BusinessRuleResult {
    data class Success(val message: String) : BusinessRuleResult()
    data class Error(val message: String) : BusinessRuleResult()
}
```

### Data Processing:

**domain/usecase/DataProcessingUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Use Case untuk pemrosesan data kompleks
 */
class ProcessUserDataUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String, processData: ProcessDataRequest): ProcessDataResult {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return ProcessDataResult.Error("User not found")
            
            // Proses data berdasarkan jenis permintaan
            val processedData = when (processData.type) {
                ProcessType.ENRICHMENT -> enrichUserData(user, processData)
                ProcessType.AGGREGATION -> aggregateUserData(user, processData)
                ProcessType.ANALYSIS -> analyzeUserData(user, processData)
                ProcessType.CLEANUP -> cleanupUserData(user, processData)
            }
            
            // Simpan hasil pemrosesan jika diperlukan
            if (processData.saveResult) {
                saveProcessedData(user.id, processedData)
            }
            
            ProcessDataResult.Success(processedData)
        } catch (e: Exception) {
            ProcessDataResult.Error(e.message ?: "Data processing failed")
        }
    }
    
    private suspend fun enrichUserData(user: User, request: ProcessDataRequest): ProcessDataResult.Data {
        // Tambahkan informasi tambahan ke user data
        val additionalInfo = fetchAdditionalInfo(user)
        val enrichedData = user.copy(
            additionalInfo = additionalInfo
        )
        
        return ProcessDataResult.Data(
            type = ProcessType.ENRICHMENT,
            content = mapOf("user" to enrichedData)
        )
    }
    
    private suspend fun aggregateUserData(user: User, request: ProcessDataRequest): ProcessDataResult.Data {
        // Gabungkan data dari berbagai sumber
        val userActivity = getUserActivity(user.id)
        val userTransactions = getUserTransactions(user.id)
        val userPreferences = getUserPreferences(user.id)
        
        val aggregatedData = mapOf(
            "activity" to userActivity,
            "transactions" to userTransactions,
            "preferences" to userPreferences
        )
        
        return ProcessDataResult.Data(
            type = ProcessType.AGGREGATION,
            content = aggregatedData
        )
    }
    
    private suspend fun analyzeUserData(user: User, request: ProcessDataRequest): ProcessDataResult.Data {
        // Analisis pola dan kebiasaan user
        val activityPattern = analyzeActivityPattern(user.id)
        val spendingPattern = analyzeSpendingPattern(user.id)
        val preferenceTrend = analyzePreferenceTrend(user.id)
        
        val analysisResult = AnalysisResult(
            userId = user.id,
            activityPattern = activityPattern,
            spendingPattern = spendingPattern,
            preferenceTrend = preferenceTrend,
            overallScore = calculateOverallScore(activityPattern, spendingPattern, preferenceTrend)
        )
        
        return ProcessDataResult.Data(
            type = ProcessType.ANALYSIS,
            content = mapOf("analysis" to analysisResult)
        )
    }
    
    private suspend fun cleanupUserData(user: User, request: ProcessDataRequest): ProcessDataResult.Data {
        // Bersihkan dan validasi data user
        val cleanedUser = user.copy(
            email = user.email.trim().lowercase(),
            name = user.name.trim().replace(Regex("\\s+"), " "),
            phone = user.phone.replace(Regex("[^0-9]"), ""),
            preferences = user.preferences.filter { it.value.isNotEmpty() }
        )
        
        return ProcessDataResult.Data(
            type = ProcessType.CLEANUP,
            content = mapOf("cleanedUser" to cleanedUser)
        )
    }
    
    private suspend fun fetchAdditionalInfo(user: User): Map<String, Any> {
        // Ambil informasi tambahan dari sumber eksternal
        return mapOf(
            "socialMedia" to getSocialMediaInfo(user.email),
            "location" to getUserLocation(user.id),
            "interests" to getUserInterests(user.id)
        )
    }
    
    private suspend fun getUserActivity(userId: String): List<Activity> {
        // Ambil data aktivitas user
        return emptyList()
    }
    
    private suspend fun getUserTransactions(userId: String): List<Transaction> {
        // Ambil data transaksi user
        return emptyList()
    }
    
    private suspend fun getUserPreferences(userId: String): Map<String, String> {
        // Ambil preferensi user
        return userRepository.getUserPreferences(userId)
    }
    
    private suspend fun analyzeActivityPattern(userId: String): ActivityPattern {
        // Analisis pola aktivitas
        return ActivityPattern(
            mostActiveTime = "09:00-17:00",
            preferredDays = listOf("Monday", "Wednesday", "Friday"),
            activityFrequency = "daily"
        )
    }
    
    private suspend fun analyzeSpendingPattern(userId: String): SpendingPattern {
        // Analisis pola pengeluaran
        return SpendingPattern(
            averageSpending = 500000.0,
            spendingCategory = "food_and_beverage",
            peakSpendingDays = listOf("Friday", "Saturday")
        )
    }
    
    private suspend fun analyzePreferenceTrend(userId: String): PreferenceTrend {
        // Analisis tren preferensi
        return PreferenceTrend(
            preferredCategory = "electronics",
            trendDirection = "increasing",
            confidenceLevel = 0.85
        )
    }
    
    private fun calculateOverallScore(
        activityPattern: ActivityPattern,
        spendingPattern: SpendingPattern,
        preferenceTrend: PreferenceTrend
    ): Double {
        // Hitung skor keseluruhan berdasarkan berbagai faktor
        return 7.5
    }
    
    private suspend fun saveProcessedData(userId: String, data: ProcessDataResult.Data) {
        // Simpan hasil pemrosesan
        userRepository.saveProcessedData(userId, data)
    }
    
    private suspend fun getSocialMediaInfo(email: String): Map<String, String> {
        // Ambil info media sosial
        return emptyMap()
    }
    
    private suspend fun getUserLocation(userId: String): String {
        // Ambil lokasi user
        return "Jakarta"
    }
    
    private suspend fun getUserInterests(userId: String): List<String> {
        // Ambil minat user
        return listOf("technology", "gaming", "music")
    }
}

/**
 * Data classes untuk data processing
 */
data class ProcessDataRequest(
    val type: ProcessType,
    val parameters: Map<String, Any> = emptyMap(),
    val saveResult: Boolean = false
)

enum class ProcessType { ENRICHMENT, AGGREGATION, ANALYSIS, CLEANUP }

data class ActivityPattern(
    val mostActiveTime: String,
    val preferredDays: List<String>,
    val activityFrequency: String
)

data class SpendingPattern(
    val averageSpending: Double,
    val spendingCategory: String,
    val peakSpendingDays: List<String>
)

data class PreferenceTrend(
    val preferredCategory: String,
    val trendDirection: String,
    val confidenceLevel: Double
)

data class AnalysisResult(
    val userId: String,
    val activityPattern: ActivityPattern,
    val spendingPattern: SpendingPattern,
    val preferenceTrend: PreferenceTrend,
    val overallScore: Double
)

data class Activity(
    val type: String,
    val timestamp: Long,
    val details: String
)

data class AdditionalInfo(
    val socialMedia: Map<String, String>,
    val location: String,
    val interests: List<String>
)

data class ProcessedUserData(
    val user: User,
    val additionalInfo: AdditionalInfo,
    val processedAt: Long = System.currentTimeMillis()
)

sealed class ProcessDataResult {
    data class Success(val data: Data) : ProcessDataResult()
    data class Error(val message: String) : ProcessDataResult()
    
    data class Data(
        val type: ProcessType,
        val content: Map<String, Any>
    ) : ProcessDataResult()
}
```

### Calculations and Algorithms:

**domain/usecase/CalculationUseCase.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Use Case untuk perhitungan dan algoritma kompleks
 */
class ComplexCalculationUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String, calculationType: CalculationType): CalculationResult {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return CalculationResult.Error("User not found")
            
            val result = when (calculationType) {
                is CalculationType.RiskScore -> calculateRiskScore(user, calculationType)
                is CalculationType.CreditScore -> calculateCreditScore(user, calculationType)
                is CalculationType.InvestmentRecommendation -> calculateInvestmentRecommendation(user, calculationType)
                is CalculationType.LoyaltyPoints -> calculateLoyaltyPoints(user, calculationType)
                is CalculationType.PredictiveAnalysis -> performPredictiveAnalysis(user, calculationType)
            }
            
            CalculationResult.Success(result)
        } catch (e: Exception) {
            CalculationResult.Error(e.message ?: "Calculation failed")
        }
    }
    
    private suspend fun calculateRiskScore(user: User, config: CalculationType.RiskScore): CalculationResult.Data {
        var score = BASE_RISK_SCORE
        
        // Faktor-faktor yang mempengaruhi risiko
        score += calculateAccountAgeFactor(user.createdAt)  // Semakin lama semakin rendah risiko
        score += calculateActivityFactor(user.id)           // Aktivitas semakin tinggi semakin rendah risiko
        score += calculateBalanceFactor(user.balance)       // Saldo tinggi semakin rendah risiko
        score += calculateTransactionHistoryFactor(user.id) // Riwayat transaksi bagus semakin rendah risiko
        score += calculateVerificationFactor(user.isVerified) // User terverifikasi semakin rendah risiko
        
        // Pastikan skor dalam range yang valid
        val finalScore = score.coerceIn(0.0, 100.0)
        
        return CalculationResult.Data(
            type = "risk_score",
            value = finalScore,
            details = mapOf(
                "base_score" to BASE_RISK_SCORE,
                "account_age_factor" to calculateAccountAgeFactor(user.createdAt),
                "activity_factor" to calculateActivityFactor(user.id),
                "balance_factor" to calculateBalanceFactor(user.balance),
                "verification_factor" to calculateVerificationFactor(user.isVerified)
            )
        )
    }
    
    private suspend fun calculateCreditScore(user: User, config: CalculationType.CreditScore): CalculationResult.Data {
        // Algoritma FICO-like score
        val paymentHistory = calculatePaymentHistoryScore(user.id)
        val creditUtilization = calculateCreditUtilizationScore(user.balance, user.creditLimit)
        val creditAge = calculateCreditAgeScore(user.createdAt)
        val creditMix = calculateCreditMixScore(user.id)
        val newCredit = calculateNewCreditScore(user.id)
        
        // Bobot-bobot untuk masing-masing faktor
        val totalScore = (
            paymentHistory * 0.35 +
            creditUtilization * 0.30 +
            creditAge * 0.15 +
            creditMix * 0.10 +
            newCredit * 0.10
        ).coerceIn(300.0, 850.0)
        
        return CalculationResult.Data(
            type = "credit_score",
            value = totalScore,
            details = mapOf(
                "payment_history" to paymentHistory,
                "credit_utilization" to creditUtilization,
                "credit_age" to creditAge,
                "credit_mix" to creditMix,
                "new_credit" to newCredit
            )
        )
    }
    
    private suspend fun calculateInvestmentRecommendation(
        user: User,
        config: CalculationType.InvestmentRecommendation
    ): CalculationResult.Data {
        // Analisis berdasarkan usia, pendapatan, toleransi risiko
        val riskProfile = calculateRiskProfile(user.age, config.income, config.investmentGoal)
        val portfolioRecommendation = recommendPortfolio(riskProfile)
        val expectedReturn = calculateExpectedReturn(portfolioRecommendation)
        
        return CalculationResult.Data(
            type = "investment_recommendation",
            value = expectedReturn,
            details = mapOf(
                "risk_profile" to riskProfile,
                "recommended_portfolio" to portfolioRecommendation,
                "expected_return" to expectedReturn
            )
        )
    }
    
    private suspend fun calculateLoyaltyPoints(user: User, config: CalculationType.LoyaltyPoints): CalculationResult.Data {
        // Perhitungan poin loyalitas berdasarkan aktivitas
        val basePoints = user.transactionHistory.sumOf { it.amount * LOYALTY_MULTIPLIER }
        val bonusPoints = calculateBonusPoints(user.id, user.isPremium)
        val totalPoints = basePoints + bonusPoints
        
        return CalculationResult.Data(
            type = "loyalty_points",
            value = totalPoints,
            details = mapOf(
                "base_points" to basePoints,
                "bonus_points" to bonusPoints,
                "multiplier" to LOYALTY_MULTIPLIER
            )
        )
    }
    
    private suspend fun performPredictiveAnalysis(
        user: User,
        config: CalculationType.PredictiveAnalysis
    ): CalculationResult.Data {
        // Analisis prediktif berdasarkan data historis
        val churnProbability = predictChurnProbability(user.id)
        val lifetimeValue = predictLifetimeValue(user.id)
        val nextPurchaseProbability = predictNextPurchaseProbability(user.id)
        
        return CalculationResult.Data(
            type = "predictive_analysis",
            value = churnProbability, // Using churn probability as main value
            details = mapOf(
                "churn_probability" to churnProbability,
                "lifetime_value" to lifetimeValue,
                "next_purchase_probability" to nextPurchaseProbability
            )
        )
    }
    
    // Fungsi-fungsi perhitungan internal
    private fun calculateAccountAgeFactor(createdAt: Long): Double {
        val accountAgeInDays = (System.currentTimeMillis() - createdAt) / (24 * 60 * 60 * 1000L)
        return minOf(accountAgeInDays / 365.0, 10.0) // Max 10 poin untuk account age
    }
    
    private suspend fun calculateActivityFactor(userId: String): Double {
        val activityCount = userRepository.getActivityCount(userId)
        return minOf(activityCount / 100.0, 15.0) // Max 15 poin untuk aktivitas
    }
    
    private fun calculateBalanceFactor(balance: Double): Double {
        return minOf(balance / 1000000.0, 20.0) // Max 20 poin untuk saldo
    }
    
    private suspend fun calculateTransactionHistoryFactor(userId: String): Double {
        val transactionCount = userRepository.getTransactionCount(userId)
        val avgTransactionAmount = userRepository.getAverageTransactionAmount(userId)
        
        return minOf(
            (transactionCount * avgTransactionAmount / 100000.0),
            25.0 // Max 25 poin untuk riwayat transaksi
        )
    }
    
    private fun calculateVerificationFactor(isVerified: Boolean): Double {
        return if (isVerified) 15.0 else 0.0
    }
    
    private suspend fun calculatePaymentHistoryScore(userId: String): Double {
        // Placeholder untuk perhitungan berdasarkan riwayat pembayaran
        return 85.0
    }
    
    private fun calculateCreditUtilizationScore(balance: Double, limit: Double): Double {
        if (limit == 0.0) return 100.0
        val utilization = balance / limit
        return when {
            utilization <= 0.1 -> 100.0
            utilization <= 0.3 -> 85.0
            utilization <= 0.5 -> 70.0
            utilization <= 0.7 -> 50.0
            else -> 30.0
        }
    }
    
    private fun calculateCreditAgeScore(createdAt: Long): Double {
        val creditAgeInYears = (System.currentTimeMillis() - createdAt) / (365 * 24 * 60 * 60 * 1000L).toDouble()
        return minOf(creditAgeInYears * 5, 15.0)
    }
    
    private suspend fun calculateCreditMixScore(userId: String): Double {
        // Placeholder untuk perhitungan berdasarkan jenis kredit
        return 10.0
    }
    
    private suspend fun calculateNewCreditScore(userId: String): Double {
        // Placeholder untuk perhitungan berdasarkan kredit baru
        return 10.0
    }
    
    private fun calculateRiskProfile(age: Int, income: Double, goal: String): String {
        return when {
            age < 30 && income > 10000000 -> "aggressive"
            age < 30 && income <= 10000000 -> "moderate"
            age in 30..50 && income > 15000000 -> "moderate"
            age in 30..50 && income <= 15000000 -> "conservative"
            age > 50 -> "conservative"
            else -> "moderate"
        }
    }
    
    private fun recommendPortfolio(riskProfile: String): String {
        return when (riskProfile) {
            "aggressive" -> "70% stocks, 20% bonds, 10% alternatives"
            "moderate" -> "50% stocks, 40% bonds, 10% alternatives"
            "conservative" -> "30% stocks, 60% bonds, 10% alternatives"
            else -> "50% stocks, 40% bonds, 10% alternatives"
        }
    }
    
    private fun calculateExpectedReturn(portfolio: String): Double {
        // Simplified calculation
        return when {
            portfolio.contains("70% stocks") -> 8.5
            portfolio.contains("50% stocks") -> 6.0
            else -> 4.0
        }
    }
    
    private suspend fun calculateBonusPoints(userId: String, isPremium: Boolean): Double {
        var bonus = 0.0
        
        // Bonus untuk user premium
        if (isPremium) bonus += 100.0
        
        // Bonus untuk aktivitas tertentu
        bonus += userRepository.getActivityBonus(userId)
        
        return bonus
    }
    
    private suspend fun predictChurnProbability(userId: String): Double {
        // Placeholder untuk algoritma prediksi churn
        return 0.15
    }
    
    private suspend fun predictLifetimeValue(userId: String): Double {
        // Placeholder untuk algoritma prediksi LTV
        return 5000000.0
    }
    
    private suspend fun predictNextPurchaseProbability(userId: String): Double {
        // Placeholder untuk algoritma prediksi pembelian
        return 0.65
    }
    
    companion object {
        const val BASE_RISK_SCORE = 50.0
        const val LOYALTY_MULTIPLIER = 0.01  // 1 poin per 100 unit mata uang
    }
}

/**
 * Data classes untuk perhitungan
 */
sealed class CalculationType {
    object RiskScore : CalculationType()
    object CreditScore : CalculationType()
    data class InvestmentRecommendation(
        val income: Double,
        val investmentGoal: String
    ) : CalculationType()
    object LoyaltyPoints : CalculationType()
    object PredictiveAnalysis : CalculationType()
}

sealed class CalculationResult {
    data class Success(val data: Data) : CalculationResult()
    data class Error(val message: String) : CalculationResult()
    
    data class Data(
        val type: String,
        val value: Double,
        val details: Map<String, Any>
    ) : CalculationResult()
}
```

### üéì Penjelasan Konsep:
**Business Logic seperti Aturan Main:**
- **Kompleks**: Bisa melibatkan banyak validasi
- **Multi-langkah**: Proses bisa berjalan dalam beberapa tahap
- **Koordinasi**: Bekerja dengan beberapa repository
- **Aturan Ketat**: Harus diikuti tanpa pengecualian
- **Perhitungan**: Bisa melibatkan algoritma kompleks

---

## 7Ô∏è‚É£ Use Cases dengan Coroutines ‚ö°

### Konsep Dasar
Use Cases dengan Coroutines seperti tim kerja yang bisa mengerjakan banyak tugas sekaligus ‚ö° - efisien dan tidak memblokir alur kerja!

### Suspend Functions:

**domain/usecase/SuspendUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Use Case dengan suspend functions
 */
class GetUserWithSuspendUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Basic suspend function
     */
    suspend operator fun invoke(userId: String): User? {
        return userRepository.getUserById(userId)
    }
    
    /**
     * Suspend function dengan error handling
     */
    suspend fun getUserWithErrorHandling(userId: String): Result<User> {
        return try {
            val user = userRepository.getUserById(userId)
            if (user != null) {
                Result.success(user)
            } else {
                Result.failure(Exception("User not found"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Suspend function dengan logging
     */
    suspend fun getUserWithLogging(userId: String): User? {
        println("Fetching user with ID: $userId")  // Log start
        val user = userRepository.getUserById(userId)
        println("Fetched user: ${user?.name ?: "null"}")  // Log result
        return user
    }
    
    /**
     * Suspend function dengan delay untuk simulasi network call
     */
    suspend fun getUserWithDelay(userId: String, delayMs: Long = 1000): User? {
        kotlinx.coroutines.delay(delayMs)  // Simulasi network delay
        return userRepository.getUserById(userId)
    }
}

/**
 * Use Case dengan multiple repository calls
 */
class GetUserWithMultipleCallsUseCase(
    private val userRepository: UserRepository,
    private val profileRepository: ProfileRepository,
    private val activityRepository: ActivityRepository
) {
    /**
     * Multiple suspend calls sequentially
     */
    suspend operator fun invoke(userId: String): UserWithDetails? {
        val user = userRepository.getUserById(userId) ?: return null
        val profile = profileRepository.getProfileByUserId(userId)
        val recentActivity = activityRepository.getRecentActivity(userId)
        
        return UserWithDetails(
            user = user,
            profile = profile,
            recentActivity = recentActivity
        )
    }
    
    /**
     * Multiple suspend calls with error handling
     */
    suspend fun getUserWithDetailsErrorHandling(userId: String): Result<UserWithDetails> {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return Result.failure(Exception("User not found"))
            
            // Secara berurutan, jika salah satu gagal, operasi selesai
            val profile = profileRepository.getProfileByUserId(userId)
            val recentActivity = activityRepository.getRecentActivity(userId)
            
            Result.success(
                UserWithDetails(
                    user = user,
                    profile = profile,
                    recentActivity = recentActivity
                )
            )
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Multiple suspend calls with partial success
     */
    suspend fun getUserWithPartialSuccess(userId: String): PartialUserDetails {
        val user = userRepository.getUserById(userId)
        val profile = try {
            profileRepository.getProfileByUserId(userId)
        } catch (e: Exception) {
            null // Jika profile gagal, lanjutkan saja
        }
        val recentActivity = try {
            activityRepository.getRecentActivity(userId)
        } catch (e: Exception) {
            emptyList() // Jika activity gagal, kembalikan empty list
        }
        
        return PartialUserDetails(
            user = user,
            profile = profile,
            recentActivity = recentActivity,
            profileError = if (profile == null) "Failed to load profile" else null,
            activityError = if (recentActivity.isEmpty()) "Failed to load activity" else null
        )
    }
}

data class UserWithDetails(
    val user: User,
    val profile: Profile? = null,
    val recentActivity: List<Activity> = emptyList()
)

data class PartialUserDetails(
    val user: User?,
    val profile: Profile? = null,
    val recentActivity: List<Activity> = emptyList(),
    val profileError: String? = null,
    val activityError: String? = null
)

data class Profile(
    val userId: String,
    val bio: String,
    val avatar: String,
    val preferences: Map<String, String> = emptyMap()
)

data class Activity(
    val id: String,
    val userId: String,
    val type: String,
    val timestamp: Long,
    val details: String
)
```

### Flow Emissions:

**domain/usecase/FlowUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import kotlinx.coroutines.flow.*

/**
 * Use Case dengan Flow untuk streaming data
 */
class GetUserFlowUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Basic flow emission
     */
    operator fun invoke(): Flow<List<User>> {
        return userRepository.getUsersStream()
    }
    
    /**
     * Flow with transformation
     */
    fun getActiveUsersFlow(): Flow<List<User>> {
        return userRepository.getUsersStream()
            .map { users -> users.filter { it.isActive } }
    }
    
    /**
     * Flow with filtering and sorting
     */
    fun getSortedActiveUsersFlow(): Flow<List<User>> {
        return userRepository.getUsersStream()
            .map { users -> users.filter { it.isActive } }
            .map { users -> users.sortedBy { it.name } }
    }
    
    /**
     * Flow with state emission
     */
    fun getUserStateFlow(): Flow<UserState> {
        return userRepository.getUsersStream()
            .map { users ->
                UserState(
                    users = users,
                    total = users.size,
                    activeCount = users.count { it.isActive },
                    loading = false
                )
            }
            .startWith(UserState(loading = true))  // Emit loading state first
    }
}

/**
 * Use Case dengan Flow kompleks
 */
class ComplexUserFlowUseCase(
    private val userRepository: UserRepository,
    private val activityRepository: ActivityRepository
) {
    /**
     * Combine multiple flows
     */
    fun getUserAndActivityFlow(userId: String): Flow<UserActivityState> {
        val userFlow = userRepository.getUserStream(userId)
        val activityFlow = activityRepository.getActivityStream(userId)
        
        return combine(userFlow, activityFlow) { user, activities ->
            UserActivityState(
                user = user,
                activities = activities,
                lastActivity = activities.maxByOrNull { it.timestamp }
            )
        }
    }
    
    /**
     * Flow with debounce and distinct
     */
    fun getDebouncedUserSearchFlow(query: String): Flow<List<User>> {
        return flowOf(query)
            .debounce(300)  // Wait 300ms after last emission
            .distinctUntilChanged()  // Only emit when value changes
            .flatMapLatest { searchQuery ->
                // Cancel previous search when new query comes
                userRepository.searchUsersStream(searchQuery)
            }
    }
    
    /**
     * Flow with error handling
     */
    fun getUserWithErrorHandlingFlow(): Flow<LoadableState<List<User>>> {
        return userRepository.getUsersStream()
            .map { users -> LoadableState.Success(users) }
            .catch { exception -> 
                emit(LoadableState.Error(exception.message ?: "Unknown error"))
            }
            .onStart { 
                emit(LoadableState.Loading) 
            }
    }
    
    /**
     * Flow with retry mechanism
     */
    fun getUserWithRetryFlow(): Flow<List<User>> {
        return userRepository.getUsersStream()
            .retryWhen { cause, attempt ->
                if (attempt < 3 && cause is NetworkException) {
                    kotlinx.coroutines.delay(1000 * attempt)  // Exponential backoff
                    true
                } else {
                    false
                }
            }
    }
}

data class UserState(
    val users: List<User> = emptyList(),
    val total: Int = 0,
    val activeCount: Int = 0,
    val loading: Boolean = false
)

data class UserActivityState(
    val user: User?,
    val activities: List<Activity> = emptyList(),
    val lastActivity: Activity? = null
)

sealed class LoadableState<out T> {
    object Loading : LoadableState<Nothing>()
    data class Success<T>(val data: T) : LoadableState<T>()
    data class Error(val message: String) : LoadableState<Nothing>()
}

class NetworkException(message: String) : Exception(message)
```

### Sequential vs Parallel Operations:

**domain/usecase/ParallelSequentialUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.*
import kotlinx.coroutines.*

/**
 * Use Case dengan operasi sekuensial
 */
class SequentialOperationUseCase(
    private val userRepository: UserRepository,
    private val profileRepository: ProfileRepository,
    private val activityRepository: ActivityRepository,
    private val notificationRepository: NotificationRepository
) {
    /**
     * Operasi dilakukan satu per satu (sekuensial)
     * Setiap langkah harus menunggu selesai sebelum ke langkah berikutnya
     */
    suspend operator fun invoke(userId: String): SequentialResult {
        val startTime = System.currentTimeMillis()
        
        // Langkah 1: Ambil user
        val user = userRepository.getUserById(userId)
            ?: return SequentialResult.Error("User not found")
        
        // Langkah 2: Ambil profile
        val profile = profileRepository.getProfileByUserId(userId)
        
        // Langkah 3: Ambil aktivitas terbaru
        val recentActivity = activityRepository.getRecentActivity(userId)
        
        // Langkah 4: Kirim notifikasi
        notificationRepository.sendNotification(
            Notification(
                to = user.email,
                subject = "Update Info",
                body = "Your info has been updated"
            )
        )
        
        val endTime = System.currentTimeMillis()
        
        return SequentialResult.Success(
            user = user,
            profile = profile,
            recentActivity = recentActivity,
            processingTime = endTime - startTime
        )
    }
}

/**
 * Use Case dengan operasi paralel
 */
class ParallelOperationUseCase(
    private val userRepository: UserRepository,
    private val profileRepository: ProfileRepository,
    private val activityRepository: ActivityRepository,
    private val notificationRepository: NotificationRepository
) {
    /**
     * Operasi dilakukan secara paralel (async)
     * Semua langkah bisa berjalan bersamaan
     */
    suspend operator fun invoke(userId: String): ParallelResult {
        val startTime = System.currentTimeMillis()
        
        // Jalankan semua operasi secara paralel
        val userDeferred = coroutineScope {
            async { userRepository.getUserById(userId) }
        }
        
        val profileDeferred = coroutineScope {
            async { profileRepository.getProfileByUserId(userId) }
        }
        
        val activityDeferred = coroutineScope {
            async { activityRepository.getRecentActivity(userId) }
        }
        
        // Tunggu semua operasi selesai
        val user = userDeferred.await()
        val profile = profileDeferred.await()
        val recentActivity = activityDeferred.await()
        
        if (user == null) {
            return ParallelResult.Error("User not found")
        }
        
        // Kirim notifikasi (tidak perlu ditunggu jika tidak kritis)
        val notificationDeferred = async {
            notificationRepository.sendNotification(
                Notification(
                    to = user.email,
                    subject = "Update Info",
                    body = "Your info has been updated"
                )
            )
        }
        
        // Tunggu notifikasi selesai
        notificationDeferred.await()
        
        val endTime = System.currentTimeMillis()
        
        return ParallelResult.Success(
            user = user,
            profile = profile,
            recentActivity = recentActivity,
            processingTime = endTime - startTime
        )
    }
    
    /**
     * Operasi paralel dengan struktur lebih kompleks
     */
    suspend fun getFullUserDetails(userId: String): FullUserDetails {
        coroutineScope {
            // Group 1: Data dasar user
            val userAsync = async { userRepository.getUserById(userId) }
            val profileAsync = async { profileRepository.getProfileByUserId(userId) }
            
            // Group 2: Data aktivitas dan statistik
            val activityAsync = async { activityRepository.getUserActivities(userId) }
            val statsAsync = async { activityRepository.getUserStats(userId) }
            
            // Group 3: Data tambahan
            val preferencesAsync = async { userRepository.getUserPreferences(userId) }
            val permissionsAsync = async { userRepository.getUserPermissions(userId) }
            
            // Tunggu semua grup selesai
            val user = userAsync.await()
            val profile = profileAsync.await()
            val activities = activityAsync.await()
            val stats = statsAsync.await()
            val preferences = preferencesAsync.await()
            val permissions = permissionsAsync.await()
            
            return FullUserDetails(
                user = user,
                profile = profile,
                activities = activities,
                stats = stats,
                preferences = preferences,
                permissions = permissions
            )
        }
    }
    
    /**
     * Operasi paralel dengan error handling
     */
    suspend fun getPartialUserDetails(userId: String): PartialDetailsResult {
        return coroutineScope {
            val userAsync = async {
                try {
                    Result.success(userRepository.getUserById(userId))
                } catch (e: Exception) {
                    Result.failure<User?>(e)
                }
            }
            
            val profileAsync = async {
                try {
                    Result.success(profileRepository.getProfileByUserId(userId))
                } catch (e: Exception) {
                    Result.failure<Profile?>(e)
                }
            }
            
            val activityAsync = async {
                try {
                    Result.success(activityRepository.getRecentActivity(userId))
                } catch (e: Exception) {
                    Result.failure<List<Activity>>(e)
                }
            }
            
            // Kumpulkan hasil
            val userResult = userAsync.await()
            val profileResult = profileAsync.await()
            val activityResult = activityAsync.await()
            
            // Bangun result dengan error handling
            PartialDetailsResult(
                user = userResult.getOrNull(),
                profile = profileResult.getOrNull(),
                activities = activityResult.getOrNull() ?: emptyList(),
                userError = if (userResult.isFailure) userResult.exceptionOrNull()?.message else null,
                profileError = if (profileResult.isFailure) profileResult.exceptionOrNull()?.message else null,
                activityError = if (activityResult.isFailure) activityResult.exceptionOrNull()?.message else null
            )
        }
    }
}

/**
 * Use Case dengan kombinasi sequential dan parallel
 */
class CombinedOperationsUseCase(
    private val userRepository: UserRepository,
    private val profileRepository: ProfileRepository,
    private val activityRepository: ActivityRepository,
    private val analyticsRepository: AnalyticsRepository
) {
    /**
     * Sekuensial untuk validasi awal, paralel untuk pengambilan data, sekuensial untuk proses akhir
     */
    suspend operator fun invoke(userId: String, options: RequestOptions): CombinedResult {
        // Phase 1: Validasi (sekuensial)
        val user = userRepository.getUserById(userId)
            ?: return CombinedResult.Error("User not found")
        
        validatePermissions(user, options)
        
        // Phase 2: Ambil data (paralel)
        val (profile, activities, preferences) = coroutineScope {
            val profileAsync = async { profileRepository.getProfileByUserId(userId) }
            val activityAsync = async { activityRepository.getUserActivities(userId) }
            val prefAsync = async { userRepository.getUserPreferences(userId) }
            
            Triple(
                profileAsync.await(),
                activityAsync.await(),
                prefAsync.await()
            )
        }
        
        // Phase 3: Proses dan simpan (sekuensial)
        val processedData = processUserData(user, profile, activities, preferences)
        analyticsRepository.logUserDetailView(userId)
        notificationRepository.sendNotification(
            Notification(
                to = user.email,
                subject = "Data Viewed",
                body = "Your details have been viewed"
            )
        )
        
        return CombinedResult.Success(processedData)
    }
    
    private suspend fun validatePermissions(user: User, options: RequestOptions) {
        if (!options.allowPremiumData && user.isPremium) {
            throw PermissionException("Premium data access not allowed")
        }
    }
    
    private fun processUserData(
        user: User,
        profile: Profile?,
        activities: List<Activity>,
        preferences: Map<String, String>
    ): ProcessedUser {
        return ProcessedUser(
            basicInfo = user.copy(isActive = true),  // Misalnya update status
            profile = profile,
            recentActivityCount = activities.size,
            lastActive = activities.maxOfOrNull { it.timestamp } ?: user.lastActive,
            preferences = preferences,
            processedAt = System.currentTimeMillis()
        )
    }
}

// Data classes untuk operasi kompleks
data class SequentialResult(
    val user: User? = null,
    val profile: Profile? = null,
    val recentActivity: List<Activity> = emptyList(),
    val processingTime: Long = 0
) {
    companion object {
        fun Error(message: String) = SequentialResult().copy()
    }
}

data class ParallelResult(
    val user: User? = null,
    val profile: Profile? = null,
    val recentActivity: List<Activity> = emptyList(),
    val processingTime: Long = 0
) {
    companion object {
        fun Error(message: String) = ParallelResult().copy()
    }
}

data class FullUserDetails(
    val user: User?,
    val profile: Profile?,
    val activities: List<Activity>,
    val stats: UserStats,
    val preferences: Map<String, String>,
    val permissions: List<String>
)

data class PartialDetailsResult(
    val user: User?,
    val profile: Profile?,
    val activities: List<Activity>,
    val userError: String?,
    val profileError: String?,
    val activityError: String?
)

data class RequestOptions(
    val allowPremiumData: Boolean = false,
    val includeActivity: Boolean = true,
    val includePreferences: Boolean = true
)

data class ProcessedUser(
    val basicInfo: User,
    val profile: Profile?,
    val recentActivityCount: Int,
    val lastActive: Long?,
    val preferences: Map<String, String>,
    val processedAt: Long
)

sealed class CombinedResult {
    data class Success(val processedUser: ProcessedUser) : CombinedResult()
    data class Error(val message: String) : CombinedResult()
}

class PermissionException(message: String) : Exception(message)
```

### Error Handling with Coroutines:

**domain/usecase/CoroutinesErrorHandlingUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import kotlinx.coroutines.*

/**
 * Use Case dengan error handling dalam coroutine
 */
class ErrorHandlingUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Error handling dengan try-catch dalam suspend function
     */
    suspend operator fun invoke(userId: String): Result<User> {
        return try {
            val user = userRepository.getUserById(userId)
            if (user != null) {
                Result.success(user)
            } else {
                Result.failure(Exception("User not found"))
            }
        } catch (networkError: NetworkException) {
            Result.failure(Exception("Network error occurred", networkError))
        } catch (dataError: DataException) {
            Result.failure(Exception("Data error occurred", dataError))
        } catch (e: Exception) {
            Result.failure(Exception("Unknown error occurred", e))
        }
    }
    
    /**
     * Error handling dengan supervisorScope untuk mencegah cancellation
     */
    suspend fun getUserWithSupervisorScope(userId: String): Result<User> {
        return supervisorScope {
            try {
                val user = async {
                    userRepository.getUserById(userId)
                }
                
                val result = user.await()
                if (result != null) {
                    Result.success(result)
                } else {
                    Result.failure(Exception("User not found"))
                }
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
    
    /**
     * Error handling dengan custom exception handling
     */
    suspend fun getUserWithCustomErrorHandling(userId: String): GetUserResult {
        return try {
            val user = userRepository.getUserById(userId)
            when {
                user == null -> GetUserResult.NotFound("User with ID $userId not found")
                !user.isActive -> GetUserResult.Inactive("User is inactive")
                else -> GetUserResult.Success(user)
            }
        } catch (e: NetworkException) {
            GetUserResult.NetworkError("Network issue: ${e.message}")
        } catch (e: DataException) {
            GetUserResult.DataError("Data issue: ${e.message}")
        } catch (e: Exception) {
            GetUserResult.UnknownError("Unexpected error: ${e.message}")
        }
    }
    
    /**
     * Error handling dengan retry mechanism
     */
    suspend fun getUserWithRetry(userId: String, maxRetries: Int = 3): Result<User> {
        var lastException: Exception? = null
        
        for (attempt in 1..maxRetries) {
            try {
                val user = userRepository.getUserById(userId)
                if (user != null) {
                    return Result.success(user)
                } else {
                    return Result.failure(Exception("User not found after $attempt attempts"))
                }
            } catch (e: NetworkException) {
                lastException = e
                if (attempt < maxRetries) {
                    // Tunggu sebelum retry (exponential backoff)
                    delay((1000 * attempt).toLong())
                }
            } catch (e: Exception) {
                // Jangan retry untuk error non-network
                return Result.failure(e)
            }
        }
        
        return Result.failure(lastException ?: Exception("Unknown error after $maxRetries attempts"))
    }
    
    /**
     * Error handling untuk operasi paralel
     */
    suspend fun getUserParallelWithErrorHandling(userId: String): ParallelUserResult {
        return coroutineScope {
            val userAsync = async {
                try {
                    userRepository.getUserById(userId)
                } catch (e: Exception) {
                    null
                }
            }
            
            val profileAsync = async {
                try {
                    userRepository.getUserProfile(userId)
                } catch (e: Exception) {
                    null
                }
            }
            
            val preferencesAsync = async {
                try {
                    userRepository.getUserPreferences(userId)
                } catch (e: Exception) {
                    emptyMap()
                }
            }
            
            // Tangani error secara individual
            val user = userAsync.await()
            val profile = profileAsync.await()
            val preferences = preferencesAsync.await()
            
            if (user == null) {
                ParallelUserResult.Error("User not found")
            } else {
                ParallelUserResult.Success(
                    user = user,
                    profile = profile,
                    preferences = preferences
                )
            }
        }
    }
}

/**
 * Use Case dengan timeout handling
 */
class TimeoutHandlingUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Operasi dengan timeout
     */
    suspend operator fun invoke(userId: String, timeoutMs: Long = 5000): TimeoutResult {
        return withTimeoutOrNull(timeoutMs) {
            try {
                val user = userRepository.getUserById(userId)
                if (user != null) {
                    TimeoutResult.Success(user)
                } else {
                    TimeoutResult.NotFound("User not found")
                }
            } catch (e: Exception) {
                TimeoutResult.Error("Operation failed: ${e.message}")
            }
        } ?: TimeoutResult.Timeout("Operation timed out after ${timeoutMs}ms")
    }
    
    /**
     * Operasi paralel dengan timeout individual
     */
    suspend fun getUserWithTimeoutPerOperation(userId: String): TimeoutResult {
        return coroutineScope {
            val userJob = async {
                withTimeoutOrNull(3000) {  // 3 detik timeout untuk user
                    userRepository.getUserById(userId)
                } ?: throw TimeoutException("User fetch timed out")
            }
            
            val profileJob = async {
                withTimeoutOrNull(2000) {  // 2 detik timeout untuk profile
                    userRepository.getUserProfile(userId)
                }
            }
            
            try {
                val user = userJob.await()
                val profile = profileJob.await()
                
                TimeoutResult.SuccessWithPartialData(
                    user = user,
                    profile = profile
                )
            } catch (e: TimeoutException) {
                TimeoutResult.Timeout("Operation timed out: ${e.message}")
            } catch (e: Exception) {
                TimeoutResult.Error("Operation failed: ${e.message}")
            }
        }
    }
}

/**
 * Use Case dengan cancellation handling
 */
class CancellationHandlingUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Operasi cancellable
     */
    suspend operator fun invoke(userId: String, cancellationToken: Job? = null): Result<User> {
        return try {
            // Cek apakah job sudah dibatalkan sebelum eksekusi
            cancellationToken?.let { job ->
                if (job.isCancelled) {
                    return Result.failure(Exception("Operation cancelled"))
                }
            }
            
            val user = userRepository.getUserById(userId)
            if (user != null) {
                Result.success(user)
            } else {
                Result.failure(Exception("User not found"))
            }
        } catch (e: CancellationException) {
            Result.failure(Exception("Operation was cancelled"))
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Operasi dengan handling cancellation di tengah jalan
     */
    suspend fun getCancellableUserDetails(userId: String): Flow<UserDetails> = flow {
        emit(UserDetails.Loading)
        
        try {
            // Cek cancellation di tengah operasi
            ensureActive()
            
            val user = userRepository.getUserById(userId)
                ?: throw Exception("User not found")
            
            emit(UserDetails.UserLoaded(user))
            
            ensureActive()  // Cek lagi sebelum operasi berikutnya
            
            val profile = userRepository.getUserProfile(userId)
            emit(UserDetails.ProfileLoaded(user, profile))
            
            ensureActive()  // Cek lagi sebelum selesai
            
            val preferences = userRepository.getUserPreferences(userId)
            emit(UserDetails.Complete(user, profile, preferences))
            
        } catch (e: CancellationException) {
            emit(UserDetails.Cancelled)
        } catch (e: Exception) {
            emit(UserDetails.Error(e.message ?: "Unknown error"))
        }
    }
}

// Data classes untuk error handling
sealed class GetUserResult {
    data class Success(val user: User) : GetUserResult()
    data class NotFound(val message: String) : GetUserResult()
    data class Inactive(val message: String) : GetUserResult()
    data class NetworkError(val message: String) : GetUserResult()
    data class DataError(val message: String) : GetUserResult()
    data class UnknownError(val message: String) : GetUserResult()
}

data class ParallelUserResult(
    val user: User? = null,
    val profile: Profile? = null,
    val preferences: Map<String, String> = emptyMap(),
    val userError: String? = null,
    val profileError: String? = null,
    val preferencesError: String? = null
) {
    companion object {
        fun Error(message: String) = ParallelUserResult().copy()
        fun Success(user: User, profile: Profile?, preferences: Map<String, String>) = ParallelUserResult(
            user = user,
            profile = profile,
            preferences = preferences
        )
    }
}

sealed class TimeoutResult {
    data class Success(val user: User) : TimeoutResult()
    data class NotFound(val message: String) : TimeoutResult()
    data class Error(val message: String) : TimeoutResult()
    data class Timeout(val message: String) : TimeoutResult()
    data class SuccessWithPartialData(
        val user: User,
        val profile: Profile?
    ) : TimeoutResult()
}

sealed class UserDetails {
    object Loading : UserDetails()
    data class UserLoaded(val user: User) : UserDetails()
    data class ProfileLoaded(val user: User, val profile: Profile?) : UserDetails()
    data class Complete(
        val user: User,
        val profile: Profile?,
        val preferences: Map<String, String>
    ) : UserDetails()
    object Cancelled : UserDetails()
    data class Error(val message: String) : UserDetails()
}

class TimeoutException(message: String) : Exception(message)
```

### Cancellation Support:

**domain/usecase/CancellationUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import kotlinx.coroutines.*

/**
 * Use Case dengan cancellation support
 */
class CancellableUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Use Case cancellable dengan Job
     */
    suspend operator fun invoke(userId: String, job: Job? = null): CancellableResult<User> {
        return try {
            job?.let { ensureJobActive(it) }
            
            val user = userRepository.getUserById(userId)
            if (user != null) {
                CancellableResult.Success(user)
            } else {
                CancellableResult.NotFound("User not found")
            }
        } catch (e: CancellationException) {
            CancellableResult.Cancelled("Operation was cancelled")
        } catch (e: Exception) {
            CancellableResult.Error("Operation failed: ${e.message}")
        }
    }
    
    /**
     * Use Case dengan progress tracking dan cancellation
     */
    fun getUserWithProgress(userId: String): Flow<CancellableProgressResult<User>> = flow {
        emit(CancellableProgressResult.Loading(0))
        
        // Simulasi operasi dengan beberapa tahap
        val user = userRepository.getUserById(userId)
        
        // Cek apakah dibatalkan sebelum mengirim hasil
        ensureActive()
        emit(CancellableProgressResult.Loading(50))
        
        // Operasi tambahan
        val enrichedUser = enrichUserData(user)
        
        ensureActive()
        emit(CancellableProgressResult.Loading(100))
        
        emit(CancellableProgressResult.Success(enrichedUser))
    }.catch { exception ->
        if (exception is CancellationException) {
            emit(CancellableProgressResult.Cancelled)
        } else {
            emit(CancellableProgressResult.Error("Operation failed: ${exception.message}"))
        }
    }
    
    /**
     * Use Case dengan nested cancellation
     */
    suspend fun getComplexUserDetails(userId: String, cancellationToken: Job? = null): ComplexUserResult {
        return coroutineScope {
            // Buat child scope untuk operasi ini
            supervisorScope {
                val userJob = async {
                    withContext(Dispatchers.IO) {
                        cancellationToken?.let { ensureJobActive(it) }
                        userRepository.getUserById(userId)
                    }
                }
                
                val profileJob = async {
                    withContext(Dispatchers.IO) {
                        cancellationToken?.let { ensureJobActive(it) }
                        userRepository.getUserProfile(userId)
                    }
                }
                
                try {
                    val user = userJob.await()
                    val profile = profileJob.await()
                    
                    if (user == null) {
                        ComplexUserResult.NotFound("User not found")
                    } else {
                        cancellationToken?.let { ensureJobActive(it) }
                        ComplexUserResult.Success(user, profile)
                    }
                } catch (e: CancellationException) {
                    ComplexUserResult.Cancelled("Operation was cancelled")
                } catch (e: Exception) {
                    ComplexUserResult.Error("Operation failed: ${e.message}")
                }
            }
        }
    }
    
    private suspend fun enrichUserData(user: User?): User? {
        // Simulasi operasi yang memakan waktu
        delay(100)
        return user
    }
    
    private fun ensureJobActive(job: Job) {
        if (job.isCancelled) {
            throw CancellationException("Job was cancelled")
        }
    }
}

/**
 * Use Case untuk batch operations dengan cancellation
 */
class BatchOperationUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Operasi batch yang bisa dibatalkan
     */
    suspend fun processBatchUserIds(
        userIds: List<String>,
        onProgress: (Int, Int) -> Unit = { _, _ -> }
    ): BatchResult {
        val results = mutableListOf<BatchItemResult>()
        var processed = 0
        val total = userIds.size
        
        for (userId in userIds) {
            // Cek cancellation di awal setiap iterasi
            ensureActive()
            
            try {
                val user = userRepository.getUserById(userId)
                results.add(
                    BatchItemResult.Success(
                        userId = userId,
                        user = user
                    )
                )
            } catch (e: Exception) {
                results.add(
                    BatchItemResult.Error(
                        userId = userId,
                        error = e.message ?: "Unknown error"
                    )
                )
            }
            
            processed++
            onProgress(processed, total)
            
            // Cancellation bisa terjadi kapan saja
            ensureActive()
        }
        
        return BatchResult(
            results = results,
            processed = processed,
            total = total
        )
    }
    
    /**
     * Operasi batch paralel dengan cancellation
     */
    suspend fun processBatchParallel(
        userIds: List<String>,
        maxConcurrency: Int = 5
    ): BatchResult {
        return coroutineScope {
            val semaphore = Semaphore(maxConcurrency)
            
            val deferredResults = userIds.map { userId ->
                async {
                    semaphore.withPermit {
                        // Cancellation bisa terjadi dalam operasi ini
                        ensureActive()
                        
                        try {
                            val user = userRepository.getUserById(userId)
                            BatchItemResult.Success(userId, user)
                        } catch (e: Exception) {
                            BatchItemResult.Error(userId, e.message ?: "Unknown error")
                        }
                    }
                }
            }
            
            // Tunggu hasil dengan cancellation handling
            val results = mutableListOf<BatchItemResult>()
            for (deferred in deferredResults) {
                try {
                    results.add(deferred.await())
                } catch (cancelled: CancellationException) {
                    // Cancellation terjadi, kembalikan hasil sejauh ini
                    return@coroutineScope BatchResult(
                        results = results,
                        processed = results.size,
                        total = userIds.size
                    )
                }
            }
            
            BatchResult(
                results = results,
                processed = results.size,
                total = userIds.size
            )
        }
    }
}

// Data classes untuk cancellation
sealed class CancellableResult<out T> {
    data class Success<T>(val data: T) : CancellableResult<T>()
    data class NotFound<T>(val message: String) : CancellableResult<T>()
    data class Error<T>(val message: String) : CancellableResult<T>()
    data class Cancelled<T>(val message: String) : CancellableResult<T>()
}

sealed class CancellableProgressResult<out T> {
    data class Loading<T>(val progress: Int) : CancellableProgressResult<T>()
    data class Success<T>(val data: T) : CancellableProgressResult<T>()
    object Cancelled : CancellableProgressResult<Nothing>()
    data class Error<T>(val message: String) : CancellableProgressResult<T>()
}

sealed class ComplexUserResult {
    data class Success(val user: User, val profile: Profile?) : ComplexUserResult()
    data class NotFound(val message: String) : ComplexUserResult()
    data class Error(val message: String) : ComplexUserResult()
    data class Cancelled(val message: String) : ComplexUserResult()
}

data class BatchResult(
    val results: List<BatchItemResult>,
    val processed: Int,
    val total: Int
)

sealed class BatchItemResult {
    data class Success(
        val userId: String,
        val user: User?
    ) : BatchItemResult()
    
    data class Error(
        val userId: String,
        val error: String
    ) : BatchItemResult()
}
```

### Timeout Handling:

**domain/usecase/TimeoutUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import kotlinx.coroutines.*

/**
 * Use Case dengan timeout handling
 */
class TimeoutUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Operasi tunggal dengan timeout
     */
    suspend operator fun invoke(userId: String, timeoutMs: Long = 5000): TimeoutOperationResult {
        return withTimeoutOrNull(timeoutMs) {
            try {
                val user = userRepository.getUserById(userId)
                if (user != null) {
                    TimeoutOperationResult.Success(user)
                } else {
                    TimeoutOperationResult.NotFound("User not found")
                }
            } catch (e: Exception) {
                TimeoutOperationResult.Error("Operation failed: ${e.message}")
            }
        } ?: TimeoutOperationResult.Timeout("Operation timed out after ${timeoutMs}ms")
    }
    
    /**
     * Operasi dengan timeout yang bisa di-custom per langkah
     */
    suspend fun getUserWithCustomTimeouts(
        userId: String,
        userTimeout: Long = 3000,
        profileTimeout: Long = 2000,
        activityTimeout: Long = 5000
    ): MultiStepTimeoutResult {
        var user: User? = null
        var profile: Profile? = null
        var activities: List<Activity>? = null
        var userTimeoutReached = false
        var profileTimeoutReached = false
        var activityTimeoutReached = false
        
        // Ambil user dengan timeout
        withTimeoutOrNull(userTimeout) {
            user = userRepository.getUserById(userId)
        } ?: run { userTimeoutReached = true }
        
        if (user == null && userTimeoutReached) {
            return MultiStepTimeoutResult.TimeoutStep("user", "User fetch timed out")
        }
        
        // Ambil profile dengan timeout
        withTimeoutOrNull(profileTimeout) {
            profile = userRepository.getUserProfile(userId)
        } ?: run { profileTimeoutReached = true }
        
        // Ambil activities dengan timeout
        withTimeoutOrNull(activityTimeout) {
            activities = userRepository.getUserActivities(userId)
        } ?: run { activityTimeoutReached = true }
        
        return if (userTimeoutReached || profileTimeoutReached || activityTimeoutReached) {
            MultiStepTimeoutResult.PartialSuccess(
                user = user,
                profile = profile,
                activities = activities ?: emptyList(),
                timeoutSteps = buildList {
                    if (userTimeoutReached) add("user")
                    if (profileTimeoutReached) add("profile")
                    if (activityTimeoutReached) add("activities")
                }
            )
        } else {
            MultiStepTimeoutResult.Success(
                user = user!!,
                profile = profile,
                activities = activities ?: emptyList()
            )
        }
    }
    
    /**
     * Operasi paralel dengan timeout individual
     */
    suspend fun getUserParallelWithTimeouts(userId: String): ParallelTimeoutResult {
        return coroutineScope {
            val userJob = async {
                withTimeoutOrNull(3000) {
                    userRepository.getUserById(userId)
                }
            }
            
            val profileJob = async {
                withTimeoutOrNull(2000) {
                    userRepository.getUserProfile(userId)
                }
            }
            
            val activityJob = async {
                withTimeoutOrNull(4000) {
                    userRepository.getUserActivities(userId)
                }
            }
            
            // Kumpulkan hasil dengan info timeout
            val userResult = userJob.await()
            val profileResult = profileJob.await()
            val activityResult = activityJob.await()
            
            ParallelTimeoutResult(
                user = userResult,
                profile = profileResult,
                activities = activityResult ?: emptyList(),
                timeoutInfo = ParallelTimeoutInfo(
                    userTimeout = userResult == null,
                    profileTimeout = profileResult == null,
                    activityTimeout = activityResult == null
                )
            )
        }
    }
    
    /**
     * Operasi dengan timeout fallback
     */
    suspend fun getUserWithTimeoutFallback(userId: String): TimeoutFallbackResult {
        // Coba operasi utama dulu
        val mainResult = withTimeoutOrNull(5000) {
            userRepository.getUserById(userId)
        }
        
        if (mainResult != null) {
            return TimeoutFallbackResult.Success(mainResult)
        }
        
        // Jika timeout, coba dari cache
        return try {
            val cachedUser = userRepository.getUserFromCache(userId)
            if (cachedUser != null) {
                TimeoutFallbackResult.SuccessWithCacheInfo(cachedUser, "Used cached data due to timeout")
            } else {
                TimeoutFallbackResult.Timeout("Main operation timed out and no cached data available")
            }
        } catch (e: Exception) {
            TimeoutFallbackResult.Timeout("Main operation timed out and cache lookup failed: ${e.message}")
        }
    }
    
    /**
     * Operasi dengan exponential backoff timeout
     */
    suspend fun getUserWithExponentialTimeout(userId: String, maxRetries: Int = 3): ExponentialTimeoutResult {
        var timeout = 1000L  // 1 detik awal
        
        for (attempt in 1..maxRetries) {
            val result = withTimeoutOrNull(timeout) {
                try {
                    val user = userRepository.getUserById(userId)
                    if (user != null) {
                        ExponentialTimeoutResult.Success(user)
                    } else {
                        ExponentialTimeoutResult.NotFound("User not found")
                    }
                } catch (e: Exception) {
                    ExponentialTimeoutResult.Error("Attempt $attempt failed: ${e.message}")
                }
            }
            
            if (result is ExponentialTimeoutResult.Success) {
                return result
            }
            
            if (attempt < maxRetries) {
                timeout *= 2  // Exponential backoff
                delay(500) // Jeda sebentar sebelum retry
            }
        }
        
        return ExponentialTimeoutResult.Timeout("All $maxRetries attempts timed out with increasing timeouts")
    }
}

/**
 * Use Case untuk timeout yang kompleks
 */
class ComplexTimeoutUseCase(
    private val userRepository: UserRepository,
    private val backupRepository: BackupUserRepository
) {
    /**
     * Operasi dengan timeout dan fallback ke backup
     */
    suspend operator fun invoke(userId: String, config: TimeoutConfig): ComplexTimeoutResult {
        return coroutineScope {
            // Coba primary repository dengan timeout
            val primaryResult = async {
                withTimeoutOrNull(config.primaryTimeout) {
                    try {
                        userRepository.getUserById(userId)
                    } catch (e: Exception) {
                        null
                    }
                }
            }
            
            // Coba backup repository dengan timeout yang berbeda
            val backupResult = async {
                withTimeoutOrNull(config.backupTimeout) {
                    try {
                        backupRepository.getUserById(userId)
                    } catch (e: Exception) {
                        null
                    }
                }
            }
            
            // Gunakan hasil yang pertama selesai
            val primaryUser = primaryResult.await()
            val backupUser = backupResult.await()
            
            when {
                primaryUser != null -> {
                    // Simpan ke cache jika diambil dari backup
                    if (backupUser != null && primaryUser == null) {
                        userRepository.saveUserToCache(backupUser)
                    }
                    ComplexTimeoutResult.Success(primaryUser, "primary")
                }
                backupUser != null -> {
                    userRepository.saveUserToCache(backupUser)
                    ComplexTimeoutResult.Success(backupUser, "backup")
                }
                else -> ComplexTimeoutResult.Timeout("Both primary and backup timed out")
            }
        }
    }
    
    /**
     * Operasi dengan timeout per jenis data
     */
    suspend fun getFullUserDetailsWithTimeouts(userId: String): FullUserDetailsWithTimeout {
        return coroutineScope {
            val userJob = async {
                withTimeoutOrNull(3000) { userRepository.getUserById(userId) }
            }
            
            val profileJob = async {
                withTimeoutOrNull(2000) { userRepository.getUserProfile(userId) }
            }
            
            val activityJob = async {
                withTimeoutOrNull(5000) { userRepository.getUserActivities(userId) }
            }
            
            val preferencesJob = async {
                withTimeoutOrNull(1500) { userRepository.getUserPreferences(userId) }
            }
            
            val resultUser = userJob.await()
            val resultProfile = profileJob.await()
            val resultActivity = activityJob.await()
            val resultPreferences = preferencesJob.await()
            
            FullUserDetailsWithTimeout(
                user = resultUser,
                profile = resultProfile,
                activities = resultActivity ?: emptyList(),
                preferences = resultPreferences ?: emptyMap(),
                timeouts = TimeoutsInfo(
                    user = resultUser == null,
                    profile = resultProfile == null,
                    activities = resultActivity == null,
                    preferences = resultPreferences == null
                )
            )
        }
    }
}

// Data classes untuk timeout
sealed class TimeoutOperationResult {
    data class Success(val user: User) : TimeoutOperationResult()
    data class NotFound(val message: String) : TimeoutOperationResult()
    data class Error(val message: String) : TimeoutOperationResult()
    data class Timeout(val message: String) : TimeoutOperationResult()
}

data class MultiStepTimeoutResult(
    val user: User? = null,
    val profile: Profile? = null,
    val activities: List<Activity>? = null,
    val timeoutSteps: List<String> = emptyList()
) {
    companion object {
        fun TimeoutStep(step: String, message: String) = MultiStepTimeoutResult().copy()
        fun Success(user: User, profile: Profile?, activities: List<Activity>) = MultiStepTimeoutResult(
            user = user,
            profile = profile,
            activities = activities
        )
        fun PartialSuccess(
            user: User?,
            profile: Profile?,
            activities: List<Activity>,
            timeoutSteps: List<String>
        ) = MultiStepTimeoutResult(
            user = user,
            profile = profile,
            activities = activities,
            timeoutSteps = timeoutSteps
        )
    }
}

data class ParallelTimeoutResult(
    val user: User?,
    val profile: Profile?,
    val activities: List<Activity>,
    val timeoutInfo: ParallelTimeoutInfo
)

data class ParallelTimeoutInfo(
    val userTimeout: Boolean,
    val profileTimeout: Boolean,
    val activityTimeout: Boolean
)

sealed class TimeoutFallbackResult {
    data class Success(val user: User) : TimeoutFallbackResult()
    data class SuccessWithCacheInfo(val user: User, val info: String) : TimeoutFallbackResult()
    data class Timeout(val message: String) : TimeoutFallbackResult()
}

sealed class ExponentialTimeoutResult {
    data class Success(val user: User) : ExponentialTimeoutResult()
    data class NotFound(val message: String) : ExponentialTimeoutResult()
    data class Error(val message: String) : ExponentialTimeoutResult()
    data class Timeout(val message: String) : ExponentialTimeoutResult()
}

// Konfigurasi timeout
data class TimeoutConfig(
    val primaryTimeout: Long = 5000,
    val backupTimeout: Long = 10000,
    val useCache: Boolean = true
)

sealed class ComplexTimeoutResult {
    data class Success(val user: User, val source: String) : ComplexTimeoutResult()
    data class Timeout(val message: String) : ComplexTimeoutResult()
}

data class FullUserDetailsWithTimeout(
    val user: User?,
    val profile: Profile?,
    val activities: List<Activity>,
    val preferences: Map<String, String>,
    val timeouts: TimeoutsInfo
)

data class TimeoutsInfo(
    val user: Boolean,
    val profile: Boolean,
    val activities: Boolean,
    val preferences: Boolean
)

interface BackupUserRepository {
    suspend fun getUserById(userId: String): User?
    suspend fun saveUserToCache(user: User)
}
```

### üéì Penjelasan Konsep:
**Coroutines dalam Use Cases seperti Tim Multi-tasking:**
- **Suspend Functions**: Fungsi yang bisa "tidur" tanpa memblokir thread
- **Flow**: Streaming data secara asinkron
- **Sequential vs Parallel**: Urutan vs operasi bersamaan
- **Error Handling**: Penanganan kesalahan dalam coroutine
- **Cancellation**: Pembatalan operasi ketika tidak lagi diperlukan
- **Timeout**: Batas waktu untuk operasi

---

## 8Ô∏è‚É£ Menggabungkan Use Cases üîó

### Konsep Dasar
Menggabungkan Use Cases seperti kolaborasi tim kerja üë• - beberapa spesialis bekerja bersama untuk menyelesaikan tugas kompleks!

### Use Case Composition:

**domain/usecase/CompositionUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Use Case yang menggabungkan beberapa Use Cases lain
 */
class CompleteUserRegistrationWithCompositionUseCase(
    private val validateUserUseCase: ValidateUserRegistrationUseCase,
    private val createUserUseCase: CreateUserUseCase,
    private val sendVerificationUseCase: SendVerificationEmailUseCase,
    private val logUserRegistrationUseCase: LogUserRegistrationUseCase
) {
    suspend operator fun invoke(request: RegistrationRequest): CompositionResult {
        return try {
            // Langkah 1: Validasi
            val validation = validateUserUseCase(request.toValidationRequest())
            if (validation is ValidationResult.Invalid) {
                return CompositionResult.ValidationError(validation.errors)
            }
            
            // Langkah 2: Buat user
            val createResult = createUserUseCase(request.toUserData())
            if (createResult.isFailure) {
                return CompositionResult.Error("Failed to create user: ${createResult.exceptionOrNull()?.message}")
            }
            
            val userId = createResult.getOrThrow()
            
            // Langkah 3: Kirim verifikasi
            sendVerificationUseCase(userId)
            
            // Langkah 4: Log registrasi
            logUserRegistrationUseCase(userId)
            
            CompositionResult.Success(userId)
        } catch (e: Exception) {
            CompositionResult.Error("Registration failed: ${e.message}")
        }
    }
    
    private fun RegistrationRequest.toValidationRequest(): UserData {
        return UserData(name = this.name, email = this.email)
    }
    
    private fun RegistrationRequest.toUserData(): UserData {
        return UserData(name = this.name, email = this.email)
    }
}

/**
 * Use Case komposit untuk proses checkout
 */
class ProcessCheckoutWithCompositionUseCase(
    private val validateCartUseCase: ValidateCartUseCase,
    private val calculateTotalUseCase: CalculateOrderTotalUseCase,
    private val processPaymentUseCase: ProcessPaymentUseCase,
    private val updateInventoryUseCase: UpdateInventoryUseCase,
    private val sendOrderConfirmationUseCase: SendOrderConfirmationUseCase
) {
    suspend operator fun invoke(request: CheckoutRequest): CheckoutCompositionResult {
        return try {
            // Validasi keranjang
            val cartValidation = validateCartUseCase(request.cartId)
            if (cartValidation !is ValidationResult.Valid) {
                return CheckoutCompositionResult.ValidationError("Cart validation failed")
            }
            
            // Hitung total
            val orderTotal = calculateTotalUseCase(request.items, request.discount)
            
            // Proses pembayaran
            val paymentResult = processPaymentUseCase(
                PaymentRequest(
                    userId = request.userId,
                    amount = orderTotal.total,
                    orderId = generateOrderId()
                )
            )
            
            if (!paymentResult.isSuccess) {
                return CheckoutCompositionResult.PaymentError(paymentResult.message)
            }
            
            // Update inventory
            updateInventoryUseCase(request.items)
            
            // Kirim konfirmasi
            sendOrderConfirmationUseCase(request.orderId, request.userId)
            
            CheckoutCompositionResult.Success(request.orderId, paymentResult.transactionId!!)
        } catch (e: Exception) {
            CheckoutCompositionResult.Error("Checkout failed: ${e.message}")
        }
    }
    
    private fun generateOrderId(): String {
        return "order_${System.currentTimeMillis()}"
    }
}

/**
 * Use Case komposit untuk update profile lengkap
 */
class UpdateCompleteUserProfileUseCase(
    private val updateUserBasicInfoUseCase: UpdateUserBasicInfoUseCase,
    private val updateUserProfileUseCase: UpdateUserProfileUseCase,
    private val updateUserSettingsUseCase: UpdateUserSettingsUseCase,
    private val validateProfileUseCase: ValidateProfileUseCase
) {
    suspend operator fun invoke(userId: String, updates: CompleteProfileUpdates): CompleteUpdateResult {
        return try {
            var currentResult = CompleteUpdateResult()

            // Validasi sebelum update
            val validation = validateProfileUseCase(
                userId,
                updates.toProfileValidationData()
            )
            
            if (validation is ValidationResult.Invalid) {
                return CompleteUpdateResult.ValidationError(validation.errors)
            }

            // Update basic info
            val basicUpdateResult = updateUserBasicInfoUseCase(userId, updates.basicInfo)
            if (basicUpdateResult.isSuccess) {
                currentResult = currentResult.copy(basicInfoUpdated = true)
            } else {
                currentResult = currentResult.copy(basicInfoError = basicUpdateResult.exceptionOrNull()?.message)
            }

            // Update profile
            val profileUpdateResult = updateUserProfileUseCase(userId, updates.profile)
            if (profileUpdateResult.isSuccess) {
                currentResult = currentResult.copy(profileUpdated = true)
            } else {
                currentResult = currentResult.copy(profileError = profileUpdateResult.exceptionOrNull()?.message)
            }

            // Update settings
            val settingsUpdateResult = updateUserSettingsUseCase(userId, updates.settings)
            if (settingsUpdateResult.isSuccess) {
                currentResult = currentResult.copy(settingsUpdated = true)
            } else {
                currentResult = currentResult.copy(settingsError = settingsUpdateResult.exceptionOrNull()?.message)
            }

            // Jika semua berhasil
            if (currentResult.allSuccessful()) {
                CompleteUpdateResult.Success(currentResult)
            } else {
                currentResult
            }
        } catch (e: Exception) {
            CompleteUpdateResult.Error("Complete profile update failed: ${e.message}")
        }
    }
    
    private fun CompleteProfileUpdates.toProfileValidationData(): ProfileValidationData {
        return ProfileValidationData(
            name = this.basicInfo?.name,
            email = this.basicInfo?.email,
            phone = this.profile?.phone
        )
    }
}

// Data classes untuk composition
data class RegistrationRequest(
    val name: String,
    val email: String,
    val password: String,
    val phone: String
)

data class CheckoutRequest(
    val userId: String,
    val cartId: String,
    val items: List<OrderItem>,
    val discount: Discount? = null,
    val orderId: String = "order_${System.currentTimeMillis()}"
)

data class CompleteProfileUpdates(
    val basicInfo: BasicInfoUpdate? = null,
    val profile: ProfileUpdate? = null,
    val settings: SettingsUpdate? = null
)

data class BasicInfoUpdate(
    val name: String? = null,
    val email: String? = null,
    val phone: String? = null
)

data class ProfileUpdate(
    val bio: String? = null,
    val avatar: String? = null,
    val location: String? = null
)

data class SettingsUpdate(
    val theme: String? = null,
    val notifications: Boolean? = null,
    val privacy: String? = null
)

data class CompleteUpdateResult(
    val basicInfoUpdated: Boolean = false,
    val profileUpdated: Boolean = false,
    val settingsUpdated: Boolean = false,
    val basicInfoError: String? = null,
    val profileError: String? = null,
    val settingsError: String? = null
) {
    fun allSuccessful(): Boolean {
        return basicInfoUpdated && profileUpdated && settingsUpdated &&
               basicInfoError == null && profileError == null && settingsError == null
    }
    
    companion object {
        fun ValidationError(errors: List<String>) = CompleteUpdateResult().copy()
        fun Success(result: CompleteUpdateResult) = result
        fun Error(message: String) = CompleteUpdateResult().copy()
    }
}

sealed class CompositionResult {
    data class Success(val userId: String) : CompositionResult()
    data class ValidationError(val errors: List<String>) : CompositionResult()
    data class Error(val message: String) : CompositionResult()
}

sealed class CheckoutCompositionResult {
    data class Success(val orderId: String, val transactionId: String) : CheckoutCompositionResult()
    data class ValidationError(val message: String) : CheckoutCompositionResult()
    data class PaymentError(val message: String) : CheckoutCompositionResult()
    data class Error(val message: String) : CheckoutCompositionResult()
}
```

### One Use Case Calling Another:

**domain/usecase/ChainedUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository

/**
 * Use Case yang memanggil Use Case lain dalam langkah-langkahnya
 */
class EnrichUserWithAdditionalDataUseCase(
    private val getUserUseCase: GetUserUseCase,
    private val getSocialMediaUseCase: GetSocialMediaInfoUseCase,
    private val getUserPreferencesUseCase: GetUserPreferencesUseCase,
    private val getUserActivityUseCase: GetUserActivityUseCase
) {
    suspend operator fun invoke(userId: String): EnrichedUserResult {
        return try {
            // Ambil user dasar
            val user = getUserUseCase(userId)
                ?: return EnrichedUserResult.NotFound("User not found")
            
            // Ambil data tambahan dengan use cases lain
            val socialMediaInfo = getSocialMediaUseCase(userId)
            val preferences = getUserPreferencesUseCase(userId)
            val recentActivity = getUserActivityUseCase(userId, limit = 10)
            
            val enrichedUser = EnrichedUser(
                user = user,
                socialMedia = socialMediaInfo,
                preferences = preferences,
                recentActivity = recentActivity,
                enrichmentTimestamp = System.currentTimeMillis()
            )
            
            EnrichedUserResult.Success(enrichedUser)
        } catch (e: Exception) {
            EnrichedUserResult.Error("Failed to enrich user: ${e.message}")
        }
    }
}

/**
 * Use Case rantai untuk upgrade user ke premium
 */
class UpgradeUserToPremiumUseCase(
    private val getUserUseCase: GetUserUseCase,
    private val validatePremiumEligibilityUseCase: ValidatePremiumEligibilityUseCase,
    private val processPaymentUseCase: ProcessPaymentUseCase,
    private val updateUserStatusUseCase: UpdateUserStatusUseCase,
    private val grantPremiumBenefitsUseCase: GrantPremiumBenefitsUseCase
) {
    suspend operator fun invoke(request: PremiumUpgradeRequest): PremiumUpgradeResult {
        return try {
            // Ambil user
            val user = getUserUseCase(request.userId)
                ?: return PremiumUpgradeResult.UserNotFound("User not found")
            
            // Validasi eligibility
            val eligibility = validatePremiumEligibilityUseCase(user)
            if (!eligibility.isEligible) {
                return PremiumUpgradeResult.NotEligible("User not eligible: ${eligibility.reason}")
            }
            
            // Proses pembayaran
            val paymentResult = processPaymentUseCase(
                PaymentRequest(
                    userId = request.userId,
                    amount = request.amount,
                    description = "Premium subscription"
                )
            )
            
            if (!paymentResult.isSuccess) {
                return PremiumUpgradeResult.PaymentFailed(paymentResult.message)
            }
            
            // Update status user
            val statusUpdateResult = updateUserStatusUseCase(
                request.userId,
                UserStatusUpdateRequest(
                    status = "PREMIUM",
                    premiumSince = System.currentTimeMillis(),
                    premiumUntil = System.currentTimeMillis() + request.duration
                )
            )
            
            if (!statusUpdateResult.isSuccess) {
                // Rollback pembayaran jika update status gagal
                rollbackPayment(paymentResult.transactionId!!)
                return PremiumUpgradeResult.StatusUpdateFailed(statusUpdateResult.message)
            }
            
            // Grant benefit premium
            grantPremiumBenefitsUseCase(request.userId)
            
            PremiumUpgradeResult.Success(
                userId = request.userId,
                transactionId = paymentResult.transactionId!!
            )
        } catch (e: Exception) {
            PremiumUpgradeResult.Error("Premium upgrade failed: ${e.message}")
        }
    }
    
    private suspend fun rollbackPayment(transactionId: String) {
        // Logika untuk rollback pembayaran
    }
}

/**
 * Use Case rantai untuk onboarding user baru
 */
class CompleteUserOnboardingUseCase(
    private val getUserUseCase: GetUserUseCase,
    private val updateUserOnboardingStatusUseCase: UpdateUserOnboardingStatusUseCase,
    private val sendWelcomeEmailUseCase: SendWelcomeEmailUseCase,
    private val setUserPreferencesUseCase: SetUserPreferencesUseCase,
    private val recommendInitialContentUseCase: RecommendInitialContentUseCase
) {
    suspend operator fun invoke(userId: String, onboardingData: OnboardingData): OnboardingResult {
        return try {
            // Validasi user
            val user = getUserUseCase(userId)
                ?: return OnboardingResult.UserNotFound("User not found")
            
            // Update status onboarding
            updateUserOnboardingStatusUseCase(userId, "IN_PROGRESS")
            
            // Set preferensi awal
            setUserPreferencesUseCase(userId, onboardingData.initialPreferences)
            
            // Kirim email selamat datang
            sendWelcomeEmailUseCase(userId)
            
            // Rekomendasikan konten awal
            val recommendations = recommendInitialContentUseCase(
                userId,
                onboardingData.interests
            )
            
            // Tandai onboarding selesai
            updateUserOnboardingStatusUseCase(userId, "COMPLETED")
            
            OnboardingResult.Success(
                userId = userId,
                recommendations = recommendations,
                completedAt = System.currentTimeMillis()
            )
        } catch (e: Exception) {
            // Update status ke failed
            updateUserOnboardingStatusUseCase(userId, "FAILED")
            OnboardingResult.Error("Onboarding failed: ${e.message}")
        }
    }
}

// Data classes untuk chained operations
data class PremiumUpgradeRequest(
    val userId: String,
    val amount: Double,
    val duration: Long, // dalam milliseconds
    val paymentMethod: String
)

data class UserStatusUpdateRequest(
    val status: String,
    val premiumSince: Long? = null,
    val premiumUntil: Long? = null
)

data class OnboardingData(
    val interests: List<String>,
    val initialPreferences: Map<String, String> = emptyMap(),
    val referralCode: String? = null
)

data class EnrichedUser(
    val user: User,
    val socialMedia: SocialMediaInfo,
    val preferences: Map<String, String>,
    val recentActivity: List<Activity>,
    val enrichmentTimestamp: Long
)

data class SocialMediaInfo(
    val facebook: String? = null,
    val twitter: String? = null,
    val linkedin: String? = null,
    val instagram: String? = null
)

sealed class EnrichedUserResult {
    data class Success(val enrichedUser: EnrichedUser) : EnrichedUserResult()
    data class NotFound(val message: String) : EnrichedUserResult()
    data class Error(val message: String) : EnrichedUserResult()
}

sealed class PremiumUpgradeResult {
    data class Success(val userId: String, val transactionId: String) : PremiumUpgradeResult()
    data class UserNotFound(val message: String) : PremiumUpgradeResult()
    data class NotEligible(val message: String) : PremiumUpgradeResult()
    data class PaymentFailed(val message: String) : PremiumUpgradeResult()
    data class StatusUpdateFailed(val message: String) : PremiumUpgradeResult()
    data class Error(val message: String) : PremiumUpgradeResult()
}

sealed class OnboardingResult {
    data class Success(
        val userId: String,
        val recommendations: List<ContentRecommendation>,
        val completedAt: Long
    ) : OnboardingResult()
    
    data class UserNotFound(val message: String) : OnboardingResult()
    data class Error(val message: String) : OnboardingResult()
}
```

### Parallel Execution with Async:

**domain/usecase/ParallelCompositionUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import kotlinx.coroutines.*

/**
 * Use Case dengan eksekusi paralel dari beberapa Use Cases
 */
class GetUserCompleteProfileParallelUseCase(
    private val getUserBasicInfoUseCase: GetUserUseCase,
    private val getUserProfileUseCase: GetUserProfileUseCase,
    private val getUserActivityUseCase: GetUserActivityUseCase,
    private val getUserPreferencesUseCase: GetUserPreferencesUseCase,
    private val getUserStatsUseCase: GetUserStatsUseCase
) {
    suspend operator fun invoke(userId: String): CompleteProfileResult {
        return coroutineScope {
            // Eksekusi semua use case secara paralel
            val basicInfoDeferred = async { getUserBasicInfoUseCase(userId) }
            val profileDeferred = async { getUserProfileUseCase(userId) }
            val activityDeferred = async { getUserActivityUseCase(userId, limit = 50) }
            val preferencesDeferred = async { getUserPreferencesUseCase(userId) }
            val statsDeferred = async { getUserStatsUseCase(userId) }
            
            try {
                // Tunggu semua selesai
                val basicInfo = basicInfoDeferred.await()
                val profile = profileDeferred.await()
                val activity = activityDeferred.await()
                val preferences = preferencesDeferred.await()
                val stats = statsDeferred.await()
                
                CompleteProfileResult.Success(
                    CompleteUserProfile(
                        user = basicInfo,
                        profile = profile,
                        recentActivity = activity,
                        preferences = preferences,
                        stats = stats,
                        fetchedAt = System.currentTimeMillis()
                    )
                )
            } catch (e: Exception) {
                CompleteProfileResult.Error("Failed to fetch complete profile: ${e.message}")
            }
        }
    }
    
    /**
     * Eksekusi paralel dengan error handling individual
     */
    suspend fun getUserPartialProfile(userId: String): PartialProfileResult {
        return coroutineScope {
            // Eksekusi dengan error handling individual
            val basicInfoResult = async {
                try {
                    Result.success(getUserBasicInfoUseCase(userId))
                } catch (e: Exception) {
                    Result.failure<User?>(e)
                }
            }
            
            val profileResult = async {
                try {
                    Result.success(getUserProfileUseCase(userId))
                } catch (e: Exception) {
                    Result.failure<Profile?>(e)
                }
            }
            
            val activityResult = async {
                try {
                    Result.success(getUserActivityUseCase(userId, limit = 20))
                } catch (e: Exception) {
                    Result.failure<List<Activity>>(e)
                }
            }
            
            // Kumpulkan hasil
            val basicInfo = basicInfoResult.await().getOrNull()
            val profile = profileResult.await().getOrNull()
            val activity = activityResult.await().getOrNull() ?: emptyList()
            
            PartialProfileResult(
                user = basicInfo,
                profile = profile,
                activity = activity,
                basicInfoError = if (basicInfoResult.await().isFailure) basicInfoResult.await().exceptionOrNull()?.message else null,
                profileError = if (profileResult.await().isFailure) profileResult.await().exceptionOrNull()?.message else null,
                activityError = if (activityResult.await().isFailure) activityResult.await().exceptionOrNull()?.message else null
            )
        }
    }
}

/**
 * Use Case untuk analisis user secara paralel
 */
class UserAnalysisParallelUseCase(
    private val getUserRiskScoreUseCase: GetUserRiskScoreUseCase,
    private val getUserCreditScoreUseCase: GetUserCreditScoreUseCase,
    private val getUserEngagementScoreUseCase: GetUserEngagementScoreUseCase,
    private val getUserLoyaltyScoreUseCase: GetUserLoyaltyScoreUseCase,
    private val getUserPredictiveScoreUseCase: GetUserPredictiveScoreUseCase
) {
    suspend operator fun invoke(userId: String): UserAnalysisResult {
        return coroutineScope {
            // Analisis secara paralel
            val riskScore = async { getUserRiskScoreUseCase(userId) }
            val creditScore = async { getUserCreditScoreUseCase(userId) }
            val engagementScore = async { getUserEngagementScoreUseCase(userId) }
            val loyaltyScore = async { getUserLoyaltyScoreUseCase(userId) }
            val predictiveScore = async { getUserPredictiveScoreUseCase(userId) }
            
            try {
                val analysis = UserAnalysis(
                    userId = userId,
                    riskScore = riskScore.await(),
                    creditScore = creditScore.await(),
                    engagementScore = engagementScore.await(),
                    loyaltyScore = loyaltyScore.await(),
                    predictiveScore = predictiveScore.await(),
                    analyzedAt = System.currentTimeMillis()
                )
                
                // Hitung skor keseluruhan
                val overallScore = calculateOverallScore(analysis)
                
                UserAnalysisResult.Success(
                    analysis = analysis,
                    overallScore = overallScore
                )
            } catch (e: Exception) {
                UserAnalysisResult.Error("Analysis failed: ${e.message}")
            }
        }
    }
    
    private fun calculateOverallScore(analysis: UserAnalysis): Double {
        // Perhitungan bobot berdasarkan kebutuhan bisnis
        return (
            analysis.riskScore.score * 0.2 +
            analysis.creditScore.score * 0.25 +
            analysis.engagementScore.score * 0.2 +
            analysis.loyaltyScore.score * 0.2 +
            analysis.predictiveScore.score * 0.15
        ).coerceIn(0.0, 100.0)
    }
}

/**
 * Use Case untuk notifikasi bulk secara paralel
 */
class SendBulkNotificationsParallelUseCase(
    private val getUserUseCase: GetUserUseCase,
    private val sendNotificationUseCase: SendNotificationUseCase
) {
    suspend operator fun invoke(notificationRequests: List<BulkNotificationRequest>): BulkNotificationResult {
        return coroutineScope {
            // Proses setiap notifikasi secara paralel
            val results = notificationRequests.map { request ->
                async {
                    try {
                        // Ambil user
                        val user = getUserUseCase(request.userId)
                        if (user == null) {
                            BulkNotificationItemResult.Error(request.userId, "User not found")
                        } else {
                            // Kirim notifikasi
                            val result = sendNotificationUseCase(
                                NotificationRequest(
                                    userId = request.userId,
                                    message = request.message,
                                    type = request.type
                                )
                            )
                            
                            if (result.isSuccess) {
                                BulkNotificationItemResult.Success(request.userId)
                            } else {
                                BulkNotificationItemResult.Error(request.userId, result.message)
                            }
                        }
                    } catch (e: Exception) {
                        BulkNotificationItemResult.Error(request.userId, e.message ?: "Unknown error")
                    }
                }
            }
            
            // Tunggu semua selesai
            val itemResults = results.map { it.await() }
            
            // Hitung statistik
            val successful = itemResults.count { it is BulkNotificationItemResult.Success }
            val failed = itemResults.count { it is BulkNotificationItemResult.Error }
            
            BulkNotificationResult(
                results = itemResults,
                total = notificationRequests.size,
                successful = successful,
                failed = failed
            )
        }
    }
}

// Data classes untuk parallel composition
data class CompleteUserProfile(
    val user: User?,
    val profile: Profile?,
    val recentActivity: List<Activity>,
    val preferences: Map<String, String>,
    val stats: UserStats?,
    val fetchedAt: Long
)

data class PartialProfileResult(
    val user: User?,
    val profile: Profile?,
    val activity: List<Activity>,
    val basicInfoError: String?,
    val profileError: String?,
    val activityError: String?
)

data class UserAnalysis(
    val userId: String,
    val riskScore: RiskScoreResult,
    val creditScore: CreditScoreResult,
    val engagementScore: EngagementScoreResult,
    val loyaltyScore: LoyaltyScoreResult,
    val predictiveScore: PredictiveScoreResult,
    val analyzedAt: Long
)

data class BulkNotificationRequest(
    val userId: String,
    val message: String,
    val type: String
)

data class NotificationRequest(
    val userId: String,
    val message: String,
    val type: String
)

data class BulkNotificationResult(
    val results: List<BulkNotificationItemResult>,
    val total: Int,
    val successful: Int,
    val failed: Int
)

sealed class BulkNotificationItemResult {
    data class Success(val userId: String) : BulkNotificationItemResult()
    data class Error(val userId: String, val message: String) : BulkNotificationItemResult()
}

sealed class CompleteProfileResult {
    data class Success(val profile: CompleteUserProfile) : CompleteProfileResult()
    data class Error(val message: String) : CompleteProfileResult()
}

sealed class UserAnalysisResult {
    data class Success(
        val analysis: UserAnalysis,
        val overallScore: Double
    ) : UserAnalysisResult()
    
    data class Error(val message: String) : UserAnalysisResult()
}

// Placeholder untuk use case dependencies
class GetUserUseCase(private val userRepository: UserRepository) {
    suspend operator fun invoke(userId: String): User? {
        return userRepository.getUserById(userId)
    }
}

class GetUserProfileUseCase(private val profileRepository: ProfileRepository) {
    suspend operator fun invoke(userId: String): Profile? {
        return profileRepository.getProfileByUserId(userId)
    }
}

class GetUserActivityUseCase(private val activityRepository: ActivityRepository) {
    suspend operator fun invoke(userId: String, limit: Int): List<Activity> {
        return activityRepository.getRecentActivity(userId, limit)
    }
}

class GetUserPreferencesUseCase(private val userRepository: UserRepository) {
    suspend operator fun invoke(userId: String): Map<String, String> {
        return userRepository.getUserPreferences(userId)
    }
}

class GetUserStatsUseCase(private val statsRepository: StatsRepository) {
    suspend operator fun invoke(userId: String): UserStats {
        return statsRepository.getUserStats(userId)
    }
}

class GetUserRiskScoreUseCase {
    suspend operator fun invoke(userId: String): RiskScoreResult {
        return RiskScoreResult(score = 75.0, details = emptyMap())
    }
}

class GetUserCreditScoreUseCase {
    suspend operator fun invoke(userId: String): CreditScoreResult {
        return CreditScoreResult(score = 82.0, details = emptyMap())
    }
}

class GetUserEngagementScoreUseCase {
    suspend operator fun invoke(userId: String): EngagementScoreResult {
        return EngagementScoreResult(score = 90.0, details = emptyMap())
    }
}

class GetUserLoyaltyScoreUseCase {
    suspend operator fun invoke(userId: String): LoyaltyScoreResult {
        return LoyaltyScoreResult(score = 88.0, details = emptyMap())
    }
}

class GetUserPredictiveScoreUseCase {
    suspend operator fun invoke(userId: String): PredictiveScoreResult {
        return PredictiveScoreResult(score = 85.0, details = emptyMap())
    }
}

class SendNotificationUseCase(private val notificationRepository: NotificationRepository) {
    suspend operator fun invoke(request: NotificationRequest): NotificationResult {
        return try {
            notificationRepository.sendNotification(
                Notification(
                    to = request.userId,
                    subject = request.type,
                    body = request.message
                )
            )
            NotificationResult.Success("Notification sent", "txn_${System.currentTimeMillis()}")
        } catch (e: Exception) {
            NotificationResult.Error("Failed to send: ${e.message}")
        }
    }
}

// Placeholder data classes
data class RiskScoreResult(val score: Double, val details: Map<String, Any>)
data class CreditScoreResult(val score: Double, val details: Map<String, Any>)
data class EngagementScoreResult(val score: Double, val details: Map<String, Any>)
data class LoyaltyScoreResult(val score: Double, val details: Map<String, Any>)
data class PredictiveScoreResult(val score: Double, val details: Map<String, Any>)
data class NotificationResult(val isSuccess: Boolean = false, val message: String, val transactionId: String? = null)

interface StatsRepository {
    suspend fun getUserStats(userId: String): UserStats
}

data class ContentRecommendation(
    val id: String,
    val title: String,
    val type: String,
    val relevanceScore: Double
)
```

### Sequential Operations:

**domain/usecase/SequentialUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import kotlinx.coroutines.*

/**
 * Use Case dengan operasi sekuensial kompleks
 */
class ProcessUserAccountClosureUseCase(
    private val validateAccountClosureUseCase: ValidateAccountClosureUseCase,
    private val retrieveUserAssetsUseCase: RetrieveUserAssetsUseCase,
    private val processAssetTransferUseCase: ProcessAssetTransferUseCase,
    private val cancelSubscriptionsUseCase: CancelSubscriptionsUseCase,
    private val anonymizeUserDataUseCase: AnonymizeUserDataUseCase,
    private val deactivateAccountUseCase: DeactivateAccountUseCase,
    private val sendClosureNotificationUseCase: SendClosureNotificationUseCase
) {
    suspend operator fun invoke(userId: String, closureReason: ClosureReason): AccountClosureResult {
        var currentStep = "start"
        
        return try {
            // Langkah 1: Validasi penutupan akun
            currentStep = "validation"
            val validation = validateAccountClosureUseCase(userId, closureReason)
            if (!validation.isValid) {
                return AccountClosureResult.ValidationError(validation.message)
            }
            
            // Langkah 2: Ambil aset user
            currentStep = "retrieve_assets"
            val userAssets = retrieveUserAssetsUseCase(userId)
            
            // Langkah 3: Proses transfer aset jika ada
            currentStep = "process_assets"
            if (userAssets.isNotEmpty()) {
                val transferResult = processAssetTransferUseCase(
                    userId,
                    userAssets,
                    closureReason.transferDestination
                )
                
                if (!transferResult.isSuccess) {
                    return AccountClosureResult.AssetTransferError(transferResult.message)
                }
            }
            
            // Langkah 4: Batalkan semua subscription
            currentStep = "cancel_subscriptions"
            cancelSubscriptionsUseCase(userId)
            
            // Langkah 5: Anonimkan data user
            currentStep = "anonymize_data"
            anonymizeUserDataUseCase(userId)
            
            // Langkah 6: Nonaktifkan akun
            currentStep = "deactivate_account"
            deactivateAccountUseCase(userId)
            
            // Langkah 7: Kirim notifikasi
            currentStep = "send_notification"
            sendClosureNotificationUseCase(userId, closureReason)
            
            AccountClosureResult.Success(userId)
            
        } catch (e: Exception) {
            // Log error dan coba rollback jika memungkinkan
            logClosureError(userId, currentStep, e)
            rollbackClosure(userId, currentStep)
            AccountClosureResult.Error("Account closure failed at step '$currentStep': ${e.message}")
        }
    }
    
    private suspend fun logClosureError(userId: String, step: String, exception: Exception) {
        // Log error untuk keperluan audit
    }
    
    private suspend fun rollbackClosure(userId: String, failedAtStep: String) {
        // Implementasi rollback berdasarkan step yang gagal
        when (failedAtStep) {
            "process_assets" -> {
                // Rollback transfer aset
            }
            "cancel_subscriptions" -> {
                // Kembalikan subscription
            }
            "anonymize_data" -> {
                // Kembalikan data anonim
            }
            "deactivate_account" -> {
                // Aktifkan kembali akun
            }
        }
    }
}

/**
 * Use Case untuk migrasi data user secara sekuensial
 */
class MigrateUserDataUseCase(
    private val validateMigrationUseCase: ValidateMigrationUseCase,
    private val exportUserDataUseCase: ExportUserDataUseCase,
    private val importUserDataUseCase: ImportUserDataUseCase,
    private val verifyMigrationUseCase: VerifyMigrationUseCase,
    private val updateMigrationStatusUseCase: UpdateMigrationStatusUseCase
) {
    suspend operator fun invoke(migrationRequest: DataMigrationRequest): DataMigrationResult {
        var currentStep = "start"
        
        return try {
            // Validasi migrasi
            currentStep = "validation"
            val validation = validateMigrationUseCase(migrationRequest)
            if (!validation.isValid) {
                return DataMigrationResult.ValidationError(validation.message)
            }
            
            // Ekspor data lama
            currentStep = "export"
            val exportedData = exportUserDataUseCase(migrationRequest.userId)
            
            // Impor data ke sistem baru
            currentStep = "import"
            val importResult = importUserDataUseCase(
                migrationRequest.targetSystem,
                exportedData
            )
            
            if (!importResult.isSuccess) {
                return DataMigrationResult.ImportError(importResult.message)
            }
            
            // Verifikasi migrasi
            currentStep = "verification"
            val verification = verifyMigrationUseCase(
                migrationRequest.userId,
                importResult.migratedUserId
            )
            
            if (!verification.isSuccess) {
                return DataMigrationResult.VerificationError(verification.message)
            }
            
            // Update status migrasi
            currentStep = "update_status"
            updateMigrationStatusUseCase(
                migrationRequest.userId,
                MigrationStatus.COMPLETED
            )
            
            DataMigrationResult.Success(importResult.migratedUserId)
            
        } catch (e: Exception) {
            updateMigrationStatusUseCase(
                migrationRequest.userId,
                MigrationStatus.FAILED
            )
            DataMigrationResult.Error("Migration failed: ${e.message}")
        }
    }
}

/**
 * Use Case untuk proses onboarding bertahap
 */
class ProgressiveOnboardingUseCase(
    private val updateUserOnboardingStepUseCase: UpdateUserOnboardingStepUseCase,
    private val validateOnboardingStepUseCase: ValidateOnboardingStepUseCase,
    private val processOnboardingStepUseCase: ProcessOnboardingStepUseCase,
    private val sendOnboardingNotificationUseCase: SendOnboardingNotificationUseCase
) {
    suspend operator fun invoke(userId: String, step: OnboardingStep): OnboardingStepResult {
        return try {
            // Validasi step saat ini
            val validation = validateOnboardingStepUseCase(userId, step)
            if (!validation.isValid) {
                return OnboardingStepResult.ValidationError(validation.message)
            }
            
            // Proses step
            val processResult = processOnboardingStepUseCase(userId, step)
            if (!processResult.isSuccess) {
                return OnboardingStepResult.ProcessError(processResult.message)
            }
            
            // Update step berikutnya
            updateUserOnboardingStepUseCase(userId, step.next())
            
            // Kirim notifikasi
            sendOnboardingNotificationUseCase(userId, step)
            
            OnboardingStepResult.Success(step)
        } catch (e: Exception) {
            OnboardingStepResult.Error("Onboarding step failed: ${e.message}")
        }
    }
    
    suspend fun completeOnboarding(userId: String): CompleteOnboardingResult {
        return try {
            // Lengkapi semua step yang tersisa
            val remainingSteps = getRemainingOnboardingSteps(userId)
            
            for (step in remainingSteps) {
                val stepResult = invoke(userId, step)
                if (stepResult is OnboardingStepResult.Error) {
                    return CompleteOnboardingResult.PartialSuccess(
                        completedSteps = getCompletedSteps(userId),
                        failedStep = step,
                        error = stepResult.message
                    )
                }
            }
            
            // Tandai onboarding selesai
            updateUserOnboardingStepUseCase(userId, OnboardingStep.COMPLETED)
            
            CompleteOnboardingResult.Success(userId)
        } catch (e: Exception) {
            CompleteOnboardingResult.Error("Complete onboarding failed: ${e.message}")
        }
    }
    
    private suspend fun getRemainingOnboardingSteps(userId: String): List<OnboardingStep> {
        val currentStep = getCurrentOnboardingStep(userId)
        return OnboardingStep.values()
            .dropWhile { it != currentStep }
            .drop(1) // Exclude current step
            .filter { it != OnboardingStep.COMPLETED }
    }
    
    private suspend fun getCurrentOnboardingStep(userId: String): OnboardingStep {
        // Implementasi untuk mendapatkan current step
        return OnboardingStep.PROFILE_SETUP
    }
    
    private suspend fun getCompletedSteps(userId: String): List<OnboardingStep> {
        // Implementasi untuk mendapatkan completed steps
        return emptyList()
    }
}

// Data classes untuk sequential operations
data class ClosureReason(
    val reason: String,
    val details: String,
    val transferDestination: String? = null
)

data class AccountClosureResult(
    val isSuccess: Boolean = false,
    val message: String = "",
    val userId: String? = null
) {
    companion object {
        fun Success(userId: String) = AccountClosureResult(
            isSuccess = true,
            message = "Account closed successfully",
            userId = userId
        )
        
        fun ValidationError(message: String) = AccountClosureResult(
            isSuccess = false,
            message = "Validation error: $message"
        )
        
        fun AssetTransferError(message: String) = AccountClosureResult(
            isSuccess = false,
            message = "Asset transfer error: $message"
        )
        
        fun Error(message: String) = AccountClosureResult(
            isSuccess = false,
            message = message
        )
    }
}

data class DataMigrationRequest(
    val userId: String,
    val targetSystem: String,
    val migrationType: MigrationType
)

enum class MigrationType { USER_DATA, CONFIGURATION, PREFERENCES }

data class DataMigrationResult(
    val isSuccess: Boolean = false,
    val migratedUserId: String? = null,
    val message: String = ""
) {
    companion object {
        fun Success(migratedUserId: String) = DataMigrationResult(
            isSuccess = true,
            migratedUserId = migratedUserId,
            message = "Migration completed successfully"
        )
        
        fun ValidationError(message: String) = DataMigrationResult(
            isSuccess = false,
            message = "Validation error: $message"
        )
        
        fun ImportError(message: String) = DataMigrationResult(
            isSuccess = false,
            message = "Import error: $message"
        )
        
        fun VerificationError(message: String) = DataMigrationResult(
            isSuccess = false,
            message = "Verification error: $message"
        )
        
        fun Error(message: String) = DataMigrationResult(
            isSuccess = false,
            message = message
        )
    }
}

enum class OnboardingStep {
    WELCOME,
    PROFILE_SETUP,
    PREFERENCES,
    TUTORIAL,
    COMPLETED;
    
    fun next(): OnboardingStep {
        val values = values()
        val currentIndex = values.indexOf(this)
        return if (currentIndex < values.lastIndex) values[currentIndex + 1] else COMPLETED
    }
}

data class OnboardingStepResult(
    val isSuccess: Boolean = false,
    val completedStep: OnboardingStep? = null,
    val message: String = ""
) {
    companion object {
        fun Success(step: OnboardingStep) = OnboardingStepResult(
            isSuccess = true,
            completedStep = step,
            message = "Step completed successfully"
        )
        
        fun ValidationError(message: String) = OnboardingStepResult(
            isSuccess = false,
            message = "Validation error: $message"
        )
        
        fun ProcessError(message: String) = OnboardingStepResult(
            isSuccess = false,
            message = "Process error: $message"
        )
        
        fun Error(message: String) = OnboardingStepResult(
            isSuccess = false,
            message = message
        )
    }
}

sealed class CompleteOnboardingResult {
    data class Success(val userId: String) : CompleteOnboardingResult()
    data class PartialSuccess(
        val completedSteps: List<OnboardingStep>,
        val failedStep: OnboardingStep,
        val error: String
    ) : CompleteOnboardingResult()
    data class Error(val message: String) : CompleteOnboardingResult()
}

// Placeholder interfaces untuk dependencies
interface ValidateAccountClosureUseCase {
    suspend operator fun invoke(userId: String, reason: ClosureReason): ValidationResponse
}

interface RetrieveUserAssetsUseCase {
    suspend operator fun invoke(userId: String): List<UserAsset>
}

interface ProcessAssetTransferUseCase {
    suspend operator fun invoke(userId: String, assets: List<UserAsset>, destination: String?): TransferResult
}

interface CancelSubscriptionsUseCase {
    suspend operator fun invoke(userId: String)
}

interface AnonymizeUserDataUseCase {
    suspend operator fun invoke(userId: String)
}

interface DeactivateAccountUseCase {
    suspend operator fun invoke(userId: String)
}

interface SendClosureNotificationUseCase {
    suspend operator fun invoke(userId: String, reason: ClosureReason)
}

interface ValidateMigrationUseCase {
    suspend operator fun invoke(request: DataMigrationRequest): ValidationResponse
}

interface ExportUserDataUseCase {
    suspend operator fun invoke(userId: String): UserDataExport
}

interface ImportUserDataUseCase {
    suspend operator fun invoke(targetSystem: String, export: UserDataExport): ImportResult
}

interface VerifyMigrationUseCase {
    suspend operator fun invoke(oldUserId: String, newUserId: String): VerificationResult
}

interface UpdateMigrationStatusUseCase {
    suspend operator fun invoke(userId: String, status: MigrationStatus)
}

interface UpdateUserOnboardingStepUseCase {
    suspend operator fun invoke(userId: String, step: OnboardingStep)
}

interface ValidateOnboardingStepUseCase {
    suspend operator fun invoke(userId: String, step: OnboardingStep): ValidationResponse
}

interface ProcessOnboardingStepUseCase {
    suspend operator fun invoke(userId: String, step: OnboardingStep): ProcessResult
}

interface SendOnboardingNotificationUseCase {
    suspend operator fun invoke(userId: String, step: OnboardingStep)
}

// Placeholder data classes
data class UserAsset(val id: String, val type: String, val value: Double)
data class TransferResult(val isSuccess: Boolean, val message: String)
data class ValidationResponse(val isValid: Boolean, val message: String)
data class UserDataExport(val data: Map<String, Any>)
data class ImportResult(val isSuccess: Boolean, val message: String, val migratedUserId: String)
data class VerificationResult(val isSuccess: Boolean, val message: String)
data class ProcessResult(val isSuccess: Boolean, val message: String)
enum class MigrationStatus { PENDING, IN_PROGRESS, COMPLETED, FAILED }
</code></pre>

### Transaction Management:

**domain/usecase/TransactionManagementUseCases.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import kotlinx.coroutines.*

/**
 * Use Case untuk manajemen transaksi kompleks
 */
class ComplexTransactionUseCase(
    private val userRepository: UserRepository,
    private val transactionRepository: TransactionRepository,
    private val inventoryRepository: InventoryRepository
) {
    suspend operator fun invoke(request: ComplexTransactionRequest): TransactionResult {
        // Gunakan coroutine scope untuk manajemen transaksi
        return coroutineScope {
            val transactionId = "txn_${System.currentTimeMillis()}"
            
            // Simpan reference transaksi
            val transactionRef = TransactionReference(
                id = transactionId,
                userId = request.userId,
                status = TransactionStatus.PENDING
            )
            
            try {
                transactionRepository.saveTransaction(transactionRef)
                
                // Lakukan semua operasi dalam satu atomic unit secara konseptual
                val operations = mutableListOf<suspend () -> Boolean>()
                
                // Operasi untuk user balance
                operations.add {
                    updateUserBalance(request.userId, request.amount, request.type)
                }
                
                // Operasi untuk inventory jika diperlukan
                if (request.itemIds.isNotEmpty()) {
                    operations.add {
                        updateInventory(request.itemIds, request.type)
                    }
                }
                
                // Operasi untuk log transaksi
                operations.add {
                    logTransaction(request, transactionId)
                }
                
                // Eksekusi semua operasi
                var allSuccessful = true
                for (operation in operations) {
                    if (!operation()) {
                        allSuccessful = false
                        break
                    }
                }
                
                if (allSuccessful) {
                    // Commit transaksi
                    transactionRepository.updateTransactionStatus(transactionId, TransactionStatus.COMPLETED)
                    TransactionResult.Success(transactionId)
                } else {
                    // Rollback semua perubahan
                    rollbackTransaction(transactionId, request)
                    TransactionResult.Error("Transaction failed and rolled back")
                }
            } catch (e: Exception) {
                // Rollback jika ada exception
                rollbackTransaction(transactionId, request)
                TransactionResult.Error("Transaction failed: ${e.message}")
            }
        }
    }
    
    private suspend fun updateUserBalance(userId: String, amount: Double, type: TransactionType): Boolean {
        try {
            val user = userRepository.getUserById(userId)
                ?: return false
            
            val newBalance = when (type) {
                TransactionType.CREDIT -> user.balance + amount
                TransactionType.DEBIT -> user.balance - amount
            }
            
            if (newBalance < 0) {
                return false // Tidak cukup saldo
            }
            
            val updatedUser = user.copy(balance = newBalance)
            userRepository.updateUser(updatedUser)
            return true
        } catch (e: Exception) {
            return false
        }
    }
    
    private suspend fun updateInventory(itemIds: List<String>, type: TransactionType): Boolean {
        try {
            for (itemId in itemIds) {
                when (type) {
                    TransactionType.CREDIT -> {
                        // Tambah stok
                        inventoryRepository.increaseStock(itemId, 1)
                    }
                    TransactionType.DEBIT -> {
                        // Kurangi stok
                        if (!inventoryRepository.hasStock(itemId, 1)) {
                            return false
                        }
                        inventoryRepository.decreaseStock(itemId, 1)
                    }
                }
            }
            return true
        } catch (e: Exception) {
            return false
        }
    }
    
    private suspend fun logTransaction(request: ComplexTransactionRequest, transactionId: String): Boolean {
        try {
            val log = TransactionLog(
                transactionId = transactionId,
                userId = request.userId,
                type = request.type,
                amount = request.amount,
                items = request.itemIds,
                timestamp = System.currentTimeMillis()
            )
            transactionRepository.saveTransactionLog(log)
            return true
        } catch (e: Exception) {
            return false
        }
    }
    
    private suspend fun rollbackTransaction(transactionId: String, request: ComplexTransactionRequest) {
        try {
            // Update status transaksi
            transactionRepository.updateTransactionStatus(transactionId, TransactionStatus.FAILED)
            
            // Rollback perubahan user balance
            rollbackUserBalance(request.userId, request.amount, request.type)
            
            // Rollback perubahan inventory
            if (request.itemIds.isNotEmpty()) {
                rollbackInventory(request.itemIds, request.type)
            }
            
            // Log rollback
            transactionRepository.logRollback(transactionId, "Transaction rolled back")
        } catch (e: Exception) {
            // Log error rollback
        }
    }
    
    private suspend fun rollbackUserBalance(userId: String, amount: Double, type: TransactionType) {
        try {
            val user = userRepository.getUserById(userId) ?: return
            val reversedBalance = when (type) {
                TransactionType.CREDIT -> user.balance - amount
                TransactionType.DEBIT -> user.balance + amount
            }
            
            val updatedUser = user.copy(balance = reversedBalance)
            userRepository.updateUser(updatedUser)
        } catch (e: Exception) {
            // Log error
        }
    }
    
    private suspend fun rollbackInventory(itemIds: List<String>, type: TransactionType) {
        try {
            for (itemId in itemIds) {
                when (type) {
                    TransactionType.CREDIT -> {
                        // Kurangi stok yang ditambahkan
                        inventoryRepository.decreaseStock(itemId, 1)
                    }
                    TransactionType.DEBIT -> {
                        // Tambah stok yang dikurangi
                        inventoryRepository.increaseStock(itemId, 1)
                    }
                }
            }
        } catch (e: Exception) {
            // Log error
        }
    }
}

/**
 * Use Case untuk transaksi distribusi
 */
class DistributedTransactionUseCase(
    private val primaryRepository: PrimaryTransactionRepository,
    private val secondaryRepository: SecondaryTransactionRepository,
    private val auditRepository: AuditRepository
) {
    suspend operator fun invoke(request: DistributedTransactionRequest): DistributedTransactionResult {
        return supervisorScope {
            val transactionId = "dist_txn_${System.currentTimeMillis()}"
            
            try {
                // Inisialisasi transaksi
                auditRepository.logTransactionStart(transactionId, request)
                
                // Eksekusi di primary system
                val primaryResult = executeInPrimary(request.copy(transactionId = transactionId))
                
                if (!primaryResult.isSuccess) {
                    auditRepository.logTransactionFailure(transactionId, "Primary failed: ${primaryResult.message}")
                    return@supervisorScope DistributedTransactionResult.Error("Primary system failed: ${primaryResult.message}")
                }
                
                // Eksekusi di secondary system
                val secondaryResult = executeInSecondary(request.copy(transactionId = transactionId))
                
                if (!secondaryResult.isSuccess) {
                    // Batalkan di primary karena secondary gagal
                    rollbackInPrimary(request.transactionId ?: transactionId)
                    auditRepository.logTransactionFailure(transactionId, "Secondary failed: ${secondaryResult.message}")
                    return@supervisorScope DistributedTransactionResult.Error("Secondary system failed: ${secondaryResult.message}")
                }
                
                // Simpan audit bahwa transaksi selesai
                auditRepository.logTransactionSuccess(transactionId)
                
                DistributedTransactionResult.Success(transactionId)
                
            } catch (e: Exception) {
                // Rollback jika ada exception
                rollbackTransaction(request.transactionId ?: transactionId)
                DistributedTransactionResult.Error("Distributed transaction failed: ${e.message}")
            }
        }
    }
    
    private suspend fun executeInPrimary(request: DistributedTransactionRequest): ExecutionResult {
        return try {
            primaryRepository.executeTransaction(request)
            ExecutionResult.Success
        } catch (e: Exception) {
            ExecutionResult.Error("Primary execution failed: ${e.message}")
        }
    }
    
    private suspend fun executeInSecondary(request: DistributedTransactionRequest): ExecutionResult {
        return try {
            secondaryRepository.executeTransaction(request)
            ExecutionResult.Success
        } catch (e: Exception) {
            ExecutionResult.Error("Secondary execution failed: ${e.message}")
        }
    }
    
    private suspend fun rollbackInPrimary(transactionId: String) {
        try {
            primaryRepository.rollbackTransaction(transactionId)
        } catch (e: Exception) {
            // Log rollback error
        }
    }
    
    private suspend fun rollbackInSecondary(transactionId: String) {
        try {
            secondaryRepository.rollbackTransaction(transactionId)
        } catch (e: Exception) {
            // Log rollback error
        }
    }
    
    private suspend fun rollbackTransaction(transactionId: String) {
        rollbackInPrimary(transactionId)
        rollbackInSecondary(transactionId)
        auditRepository.logTransactionRollback(transactionId)
    }
}

/**
 * Use Case untuk transaksi batch
 */
class BatchTransactionUseCase(
    private val transactionUseCase: ComplexTransactionUseCase,
    private val notificationRepository: NotificationRepository
) {
    suspend operator fun invoke(request: BatchTransactionRequest): BatchTransactionResult {
        return coroutineScope {
            val results = mutableListOf<TransactionResult>()
            var successfulCount = 0
            var failedCount = 0
            
            for ((index, singleRequest) in request.transactions.withIndex()) {
                try {
                    val result = transactionUseCase(singleRequest.copy(parentBatchId = request.batchId))
                    results.add(result)
                    
                    if (result is TransactionResult.Success) {
                        successfulCount++
                    } else {
                        failedCount++
                    }
                } catch (e: Exception) {
                    results.add(TransactionResult.Error("Transaction ${index + 1} failed: ${e.message}"))
                    failedCount++
                }
            }
            
            val overallSuccess = failedCount == 0
            val result = BatchTransactionResult(
                batchId = request.batchId,
                total = request.transactions.size,
                successful = successfulCount,
                failed = failedCount,
                results = results,
                overallSuccess = overallSuccess
            )
            
            // Kirim notifikasi jika semua berhasil
            if (overallSuccess) {
                notificationRepository.sendBatchSuccessNotification(
                    Notification(
                        to = request.userId,
                        subject = "Batch Transaction Success",
                        body = "All ${successfulCount} transactions completed successfully"
                    )
                )
            }
            
            result
        }
    }
}

// Data classes untuk transaction management
data class ComplexTransactionRequest(
    val userId: String,
    val amount: Double,
    val type: TransactionType,
    val itemIds: List<String> = emptyList(),
    val description: String = "",
    val parentBatchId: String? = null
)

data class TransactionReference(
    val id: String,
    val userId: String,
    val status: TransactionStatus,
    val createdAt: Long = System.currentTimeMillis()
)

data class TransactionLog(
    val transactionId: String,
    val userId: String,
    val type: TransactionType,
    val amount: Double,
    val items: List<String>,
    val timestamp: Long
)

enum class TransactionType { CREDIT, DEBIT }
enum class TransactionStatus { PENDING, COMPLETED, FAILED }

data class DistributedTransactionRequest(
    val userId: String,
    val transactionId: String? = null,
    val amount: Double,
    val primaryData: Map<String, Any>,
    val secondaryData: Map<String, Any>
)

sealed class TransactionResult {
    data class Success(val transactionId: String) : TransactionResult()
    data class Error(val message: String) : TransactionResult()
}

data class DistributedTransactionResult(
    val transactionId: String? = null,
    val isSuccess: Boolean = false,
    val message: String = ""
) {
    companion object {
        fun Success(transactionId: String) = DistributedTransactionResult(
            transactionId = transactionId,
            isSuccess = true,
            message = "Transaction completed successfully"
        )
        
        fun Error(message: String) = DistributedTransactionResult(
            isSuccess = false,
            message = message
        )
    }
}

data class BatchTransactionRequest(
    val batchId: String,
    val userId: String,
    val transactions: List<ComplexTransactionRequest>
)

data class BatchTransactionResult(
    val batchId: String,
    val total: Int,
    val successful: Int,
    val failed: Int,
    val results: List<TransactionResult>,
    val overallSuccess: Boolean
)

sealed class ExecutionResult {
    object Success : ExecutionResult()
    data class Error(val message: String) : ExecutionResult()
}

// Placeholder interfaces
interface TransactionRepository {
    suspend fun saveTransaction(transaction: TransactionReference)
    suspend fun updateTransactionStatus(id: String, status: TransactionStatus)
    suspend fun saveTransactionLog(log: TransactionLog)
    suspend fun logRollback(transactionId: String, reason: String)
}

interface PrimaryTransactionRepository {
    suspend fun executeTransaction(request: DistributedTransactionRequest)
    suspend fun rollbackTransaction(transactionId: String)
}

interface SecondaryTransactionRepository {
    suspend fun executeTransaction(request: DistributedTransactionRequest)
    suspend fun rollbackTransaction(transactionId: String)
}

interface AuditRepository {
    suspend fun logTransactionStart(transactionId: String, request: DistributedTransactionRequest)
    suspend fun logTransactionSuccess(transactionId: String)
    suspend fun logTransactionFailure(transactionId: String, reason: String)
    suspend fun logTransactionRollback(transactionId: String)
}

interface InventoryRepository {
    suspend fun hasStock(itemId: String, quantity: Int): Boolean
    suspend fun increaseStock(itemId: String, quantity: Int)
    suspend fun decreaseStock(itemId: String, quantity: Int)
}
</code></pre>

### üéì Penjelasan Konsep:
**Menggabungkan Use Cases seperti Tim Proyek:**
- **Composition**: Beberapa spesialis bekerja sama untuk satu tujuan
- **Chaining**: Satu Use Case memanggil Use Case lain secara berurutan
- **Parallel Execution**: Beberapa Use Case dijalankan bersamaan untuk efisiensi
- **Sequential Operations**: Langkah-langkah yang harus diikuti secara berurutan
- **Transaction Management**: Menjaga konsistensi data di seluruh operasi

---

## 9Ô∏è‚É£ Error Handling üõ°Ô∏è

### Konsep Dasar
Error Handling dalam Use Cases seperti sistem keamanan dan pertahanan üõ°Ô∏è - harus siap untuk menghadapi dan menangani berbagai jenis kesalahan!

### Domain-specific Exceptions:

**domain/usecase/DomainSpecificExceptions.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User

/**
 * Exception spesifik domain untuk pengguna
 */
sealed class DomainException(message: String, cause: Throwable? = null) : Exception(message, cause) {
    data class UserNotFoundException(val userId: String) : DomainException("User with ID $userId not found")
    data class UserAlreadyExistsException(val email: String) : DomainException("User with email $email already exists")
    data class InvalidEmailException(val email: String) : DomainException("Invalid email format: $email")
    data class InsufficientFundsException(val amount: Double, val balance: Double) : DomainException("Insufficient funds. Required: $amount, Available: $balance")
    data class UnauthorizedAccessException(val userId: String, val action: String) : DomainException("User $userId is not authorized to perform $action")
    data class AccountDeactivatedException(val userId: String) : DomainException("Account $userId is deactivated")
    data class ValidationError(val field: String, val reason: String) : DomainException("Validation failed for field $field: $reason")
    data class BusinessRuleViolationException(val rule: String, val details: String) : DomainException("Business rule '$rule' violated: $details")
}

/**
 * Use Case dengan exception spesifik domain
 */
class GetUserWithDomainExceptionUseCase(
    private val userRepository: UserRepository
) {
    @Throws(DomainException::class)
    suspend operator fun invoke(userId: String): User {
        val user = userRepository.getUserById(userId)
            ?: throw DomainException.UserNotFoundException(userId)
        
        if (!user.isActive) {
            throw DomainException.AccountDeactivatedException(userId)
        }
        
        return user
    }
}

/**
 * Use Case untuk registrasi dengan validasi domain
 */
class RegisterUserWithDomainValidationUseCase(
    private val userRepository: UserRepository,
    private val validator: UserValidator
) {
    @Throws(DomainException::class)
    suspend operator fun invoke(userData: UserData): String {
        // Validasi domain
        validateUserData(userData)
        
        // Cek apakah user sudah ada
        if (userRepository.getUserByEmail(userData.email) != null) {
            throw DomainException.UserAlreadyExistsException(userData.email)
        }
        
        // Buat user
        val userId = generateUserId()
        val user = User(
            id = userId,
            name = userData.name,
            email = userData.email,
            isActive = true,
            createdAt = System.currentTimeMillis()
        )
        
        userRepository.saveUser(user)
        return userId
    }
    
    private fun validateUserData(userData: UserData) {
        if (!validator.isValidEmail(userData.email)) {
            throw DomainException.InvalidEmailException(userData.email)
        }
        
        if (userData.name.isBlank()) {
            throw DomainException.ValidationError("name", "Name cannot be blank")
        }
        
        if (userData.name.length < 2) {
            throw DomainException.ValidationError("name", "Name must be at least 2 characters")
        }
    }
    
    private fun generateUserId(): String {
        return "user_${System.currentTimeMillis()}"
    }
}

/**
 * Use Case dengan multiple domain exception
 */
class ProcessTransactionWithDomainExceptionsUseCase(
    private val userRepository: UserRepository,
    private val transactionRepository: TransactionRepository
) {
    @Throws(DomainException::class)
    suspend operator fun invoke(request: TransactionRequest): String {
        // Cek apakah user aktif
        val user = userRepository.getUserById(request.userId)
            ?: throw DomainException.UserNotFoundException(request.userId)
        
        if (!user.isActive) {
            throw DomainException.AccountDeactivatedException(request.userId)
        }
        
        // Validasi saldo
        if (request.amount > user.balance) {
            throw DomainException.InsufficientFundsException(request.amount, user.balance)
        }
        
        // Validasi aturan bisnis
        validateBusinessRules(user, request)
        
        // Proses transaksi
        val transactionId = generateTransactionId()
        val transaction = Transaction(
            id = transactionId,
            userId = request.userId,
            amount = request.amount,
            type = request.type,
            status = TransactionStatus.PENDING,
            description = request.description
        )
        
        transactionRepository.saveTransaction(transaction)
        
        // Update balance
        val updatedUser = user.copy(balance = user.balance - request.amount)
        userRepository.updateUser(updatedUser)
        
        return transactionId
    }
    
    private fun validateBusinessRules(user: User, request: TransactionRequest) {
        // Validasi jumlah maksimum per hari
        val dailyCount = transactionRepository.getDailyTransactionCount(user.id)
        if (dailyCount >= MAX_DAILY_TRANSACTIONS) {
            throw DomainException.BusinessRuleViolationException(
                "Daily transaction limit",
                "Maximum ${MAX_DAILY_TRANSACTIONS} transactions per day"
            )
        }
        
        // Validasi jumlah maksimum per transaksi
        if (request.amount > user.dailyLimit) {
            throw DomainException.BusinessRuleViolationException(
                "Daily limit",
                "Transaction amount exceeds daily limit of ${user.dailyLimit}"
            )
        }
    }
    
    private fun generateTransactionId(): String {
        return "txn_${System.currentTimeMillis()}"
    }
    
    companion object {
        const val MAX_DAILY_TRANSACTIONS = 10
    }
}
```

### Result Sealed Classes:

**domain/usecase/ResultSealedClasses.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User

/**
 * Sealed class untuk representasi hasil dengan error handling
 */
sealed class UseCaseResult<out T> {
    data class Success<T>(val data: T) : UseCaseResult<T>()
    data class Error(val exception: DomainException) : UseCaseResult<Nothing>()
    object Loading : UseCaseResult<Nothing>()
}

/**
 * Use Case dengan Result sealed class
 */
class GetUserResultUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): UseCaseResult<User> {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return UseCaseResult.Error(
                    DomainException.UserNotFoundException(userId)
                )
            
            if (!user.isActive) {
                return UseCaseResult.Error(
                    DomainException.AccountDeactivatedException(userId)
                )
            }
            
            UseCaseResult.Success(user)
        } catch (e: Exception) {
            UseCaseResult.Error(
                DomainException.BusinessRuleViolationException(
                    "GetUser",
                    e.message ?: "Unknown error"
                )
            )
        }
    }
}

/**
 * Use Case untuk operasi yang bisa loading
 */
class ProcessUserOperationResultUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(
        userId: String,
        operation: UserOperation
    ): Flow<UseCaseResult<User>> = flow {
        emit(UseCaseResult.Loading)
        
        try {
            val user = userRepository.getUserById(userId)
                ?: throw DomainException.UserNotFoundException(userId)
            
            val updatedUser = when (operation) {
                UserOperation.ACTIVATE -> user.copy(isActive = true)
                UserOperation.DEACTIVATE -> user.copy(isActive = false)
                UserOperation.SET_PREMIUM -> user.copy(isPremium = true)
            }.copy(updatedAt = System.currentTimeMillis())
            
            userRepository.updateUser(updatedUser)
            emit(UseCaseResult.Success(updatedUser))
            
        } catch (e: DomainException) {
            emit(UseCaseResult.Error(e))
        } catch (e: Exception) {
            emit(UseCaseResult.Error(
                DomainException.BusinessRuleViolationException(
                    "ProcessOperation",
                    e.message ?: "Unknown error"
                )
            ))
        }
    }
}

/**
 * Use Case dengan multiple type Result
 */
class ComplexOperationResultUseCase(
    private val userRepository: UserRepository,
    private val profileRepository: ProfileRepository
) {
    suspend operator fun invoke(request: ComplexRequest): ComplexOperationResult {
        return try {
            val user = userRepository.getUserById(request.userId)
                ?: return ComplexOperationResult.UserError(
                    DomainException.UserNotFoundException(request.userId)
                )
            
            val profile = profileRepository.getProfileByUserId(request.userId)
            
            when {
                !user.isActive -> {
                    ComplexOperationResult.UserError(
                        DomainException.AccountDeactivatedException(request.userId)
                    )
                }
                !request.allowInactiveProfile && profile == null -> {
                    ComplexOperationResult.ProfileError("Profile not found for active user")
                }
                else -> {
                    val processedData = processComplexData(user, profile, request.data)
                    ComplexOperationResult.Success(processedData)
                }
            }
        } catch (e: DomainException) {
            ComplexOperationResult.DomainError(e)
        } catch (e: Exception) {
            ComplexOperationResult.UnknownError(e.message ?: "Unknown error")
        }
    }
    
    private fun processComplexData(
        user: User,
        profile: Profile?,
        data: Map<String, Any>
    ): ProcessedComplexData {
        // Proses data kompleks
        return ProcessedComplexData(
            userId = user.id,
            processedAt = System.currentTimeMillis(),
            originalData = data,
            enrichedData = enrichData(data, user, profile)
        )
    }
    
    private fun enrichData(
        originalData: Map<String, Any>,
        user: User,
        profile: Profile?
    ): Map<String, Any> {
        return originalData + mapOf(
            "userEnriched" to true,
            "userName" to user.name,
            "userEmail" to user.email,
            "profileExists" to (profile != null)
        )
    }
}

/**
 * Use Case dengan Result hierarki
 */
class HierarchicalResultUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): HierarchicalResult {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return HierarchicalResult.Failure.UserNotFound(userId)
            
            if (!user.isActive) {
                return HierarchicalResult.Failure.AccountDeactivated(userId)
            }
            
            if (!user.isVerified) {
                return HierarchicalResult.Failure.AccountNotVerified(userId)
            }
            
            val enrichedUser = enrichUserDetails(user)
            HierarchicalResult.Success.UserDetails(enrichedUser)
            
        } catch (e: DomainException) {
            HierarchicalResult.Failure.DomainError(e)
        } catch (e: Exception) {
            HierarchicalResult.Failure.UnknownError(e.message ?: "Unknown error")
        }
    }
    
    private suspend fun enrichUserDetails(user: User): EnrichedUserDetails {
        val activityCount = userRepository.getActivityCount(user.id)
        val lastLogin = userRepository.getLastLogin(user.id)
        
        return EnrichedUserDetails(
            user = user,
            activityCount = activityCount,
            lastLogin = lastLogin,
            riskLevel = calculateRiskLevel(user),
            engagementScore = calculateEngagementScore(user)
        )
    }
    
    private fun calculateRiskLevel(user: User): RiskLevel {
        // Logika perhitungan risk level
        return RiskLevel.LOW
    }
    
    private fun calculateEngagementScore(user: User): Double {
        // Logika perhitungan engagement score
        return 8.5
    }
}

// Data classes untuk Result kompleks
data class ComplexRequest(
    val userId: String,
    val data: Map<String, Any>,
    val allowInactiveProfile: Boolean = false
)

data class ProcessedComplexData(
    val userId: String,
    val processedAt: Long,
    val originalData: Map<String, Any>,
    val enrichedData: Map<String, Any>
)

sealed class ComplexOperationResult {
    data class Success(val data: ProcessedComplexData) : ComplexOperationResult()
    data class UserError(val exception: DomainException) : ComplexOperationResult()
    data class ProfileError(val message: String) : ComplexOperationResult()
    data class DomainError(val exception: DomainException) : ComplexOperationResult()
    data class UnknownError(val message: String) : ComplexOperationResult()
}

sealed class HierarchicalResult {
    sealed class Success : HierarchicalResult() {
        data class UserDetails(val details: EnrichedUserDetails) : Success()
    }
    
    sealed class Failure : HierarchicalResult() {
        data class UserNotFound(val userId: String) : Failure()
        data class AccountDeactivated(val userId: String) : Failure()
        data class AccountNotVerified(val userId: String) : Failure()
        data class DomainError(val exception: DomainException) : Failure()
        data class UnknownError(val message: String) : Failure()
    }
}

data class EnrichedUserDetails(
    val user: User,
    val activityCount: Int,
    val lastLogin: Long?,
    val riskLevel: RiskLevel,
    val engagementScore: Double
)

enum class RiskLevel { LOW, MEDIUM, HIGH }

enum class UserOperation { ACTIVATE, DEACTIVATE, SET_PREMIUM }
```

### Mapping Repository Errors:

**domain/usecase/RepositoryErrorMapping.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User

/**
 * Use Case yang memetakan error dari repository ke domain error
 */
class GetUserWithRepositoryErrorMappingUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): UseCaseResult<User> {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return UseCaseResult.Error(DomainException.UserNotFoundException(userId))
            
            UseCaseResult.Success(user)
        } catch (e: RepositoryException.NetworkException) {
            UseCaseResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Network",
                    "Unable to connect to data source"
                )
            )
        } catch (e: RepositoryException.DataException) {
            UseCaseResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Data",
                    "Data corruption or inconsistency: ${e.message}"
                )
            )
        } catch (e: RepositoryException.TimeoutException) {
            UseCaseResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Timeout",
                    "Operation timed out"
                )
            )
        } catch (e: RepositoryException.PermissionException) {
            UseCaseResult.Error(
                DomainException.UnauthorizedAccessException(userId, "read")
            )
        } catch (e: Exception) {
            UseCaseResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Unknown",
                    e.message ?: "Unknown error occurred"
                )
            )
        }
    }
}

/**
 * Use Case kompleks dengan error mapping
 */
class ComplexOperationWithRepositoryErrorMappingUseCase(
    private val userRepository: UserRepository,
    private val profileRepository: ProfileRepository,
    private val activityRepository: ActivityRepository
) {
    suspend operator fun invoke(request: ComplexRequest): ComplexOperationResult {
        return try {
            // Ambil user dengan error mapping
            val user = getUserWithMapping(request.userId)
                ?: return ComplexOperationResult.UserError(
                    DomainException.UserNotFoundException(request.userId)
                )
            
            if (!user.isActive) {
                return ComplexOperationResult.UserError(
                    DomainException.AccountDeactivatedException(request.userId)
                )
            }
            
            // Ambil profile dengan error mapping
            val profile = getProfileWithMapping(request.userId)
            
            // Ambil activity dengan error mapping
            val recentActivity = getActivityWithMapping(request.userId, 10)
            
            // Proses data
            val processedData = processComplexData(user, profile, recentActivity, request.data)
            
            ComplexOperationResult.Success(processedData)
            
        } catch (e: DomainException) {
            ComplexOperationResult.DomainError(e)
        } catch (e: Exception) {
            ComplexOperationResult.UnknownError(e.message ?: "Unknown error")
        }
    }
    
    private suspend fun getUserWithMapping(userId: String): User? {
        return try {
            userRepository.getUserById(userId)
        } catch (e: RepositoryException.NetworkException) {
            throw DomainException.BusinessRuleViolationException(
                "Network",
                "Cannot fetch user due to network issues"
            )
        } catch (e: RepositoryException.TimeoutException) {
            throw DomainException.BusinessRuleViolationException(
                "Timeout",
                "User fetch timed out"
            )
        } catch (e: RepositoryException.DataException) {
            throw DomainException.BusinessRuleViolationException(
                "Data",
                "User data is corrupted: ${e.message}"
            )
        }
    }
    
    private suspend fun getProfileWithMapping(userId: String): Profile? {
        return try {
            profileRepository.getProfileByUserId(userId)
        } catch (e: RepositoryException.DataException) {
            // Jangan throw exception jika profile tidak wajib
            null
        } catch (e: RepositoryException.TimeoutException) {
            // Jangan throw exception jika hanya timeout
            null
        } catch (e: RepositoryException.NetworkException) {
            // Jangan throw exception jika network bermasalah
            null
        }
    }
    
    private suspend fun getActivityWithMapping(userId: String, limit: Int): List<Activity> {
        return try {
            activityRepository.getRecentActivity(userId, limit)
        } catch (e: RepositoryException.DataException) {
            // Return empty list jika data bermasalah
            emptyList()
        } catch (e: RepositoryException.TimeoutException) {
            // Return empty list jika timeout
            emptyList()
        } catch (e: RepositoryException.NetworkException) {
            // Return empty list jika network bermasalah
            emptyList()
        }
    }
    
    private fun processComplexData(
        user: User,
        profile: Profile?,
        activity: List<Activity>,
        data: Map<String, Any>
    ): ProcessedComplexData {
        return ProcessedComplexData(
            userId = user.id,
            processedAt = System.currentTimeMillis(),
            originalData = data,
            enrichedData = buildMap {
                putAll(data)
                put("userEnriched", true)
                put("profileAvailable", profile != null)
                put("activityCount", activity.size)
            }
        )
    }
}

/**
 * Use Case dengan error mapping kondisional
 */
class ConditionalErrorMappingUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(request: ConditionalRequest): ConditionalResult {
        return try {
            val user = userRepository.getUserById(request.userId)
            
            when {
                user == null -> {
                    when (request.failureStrategy) {
                        FailureStrategy.FAIL -> {
                            ConditionalResult.Error(
                                DomainException.UserNotFoundException(request.userId)
                            )
                        }
                        FailureStrategy.RETURN_NULL -> {
                            ConditionalResult.Success(null)
                        }
                        FailureStrategy.USE_DEFAULT -> {
                            val defaultUser = createDefaultUser(request.userId)
                            ConditionalResult.Success(defaultUser)
                        }
                    }
                }
                else -> {
                    if (!user.isActive && request.requireActiveUser) {
                        ConditionalResult.Error(
                            DomainException.AccountDeactivatedException(request.userId)
                        )
                    } else {
                        ConditionalResult.Success(user)
                    }
                }
            }
        } catch (e: RepositoryException.NetworkException) {
            when (request.networkFailureStrategy) {
                NetworkFailureStrategy.FAIL -> {
                    ConditionalResult.Error(
                        DomainException.BusinessRuleViolationException(
                            "Network",
                            "Network error occurred"
                        )
                    )
                }
                NetworkFailureStrategy.USE_CACHE -> {
                    val cachedUser = userRepository.getUserFromCache(request.userId)
                    ConditionalResult.Success(cachedUser)
                }
                NetworkFailureStrategy.DEFAULT -> {
                    val defaultUser = createDefaultUser(request.userId)
                    ConditionalResult.Success(defaultUser)
                }
            }
        } catch (e: Exception) {
            ConditionalResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Unknown",
                    e.message ?: "Unknown error"
                )
            )
        }
    }
    
    private fun createDefaultUser(userId: String): User {
        return User(
            id = userId,
            name = "Unknown User",
            email = "unknown@example.com",
            isActive = false,
            isVerified = false
        )
    }
}

// Data classes untuk error mapping
enum class FailureStrategy { FAIL, RETURN_NULL, USE_DEFAULT }
enum class NetworkFailureStrategy { FAIL, USE_CACHE, DEFAULT }

data class ConditionalRequest(
    val userId: String,
    val requireActiveUser: Boolean = true,
    val failureStrategy: FailureStrategy = FailureStrategy.FAIL,
    val networkFailureStrategy: NetworkFailureStrategy = NetworkFailureStrategy.FAIL
)

sealed class ConditionalResult {
    data class Success(val user: User?) : ConditionalResult()
    data class Error(val exception: DomainException) : ConditionalResult()
}

// Repository exception classes
sealed class RepositoryException(message: String, cause: Throwable? = null) : Exception(message, cause) {
    class NetworkException(cause: Throwable? = null) : RepositoryException("Network error", cause)
    class DataException(message: String, cause: Throwable? = null) : RepositoryException(message, cause)
    class TimeoutException(cause: Throwable? = null) : RepositoryException("Timeout error", cause)
    class PermissionException(cause: Throwable? = null) : RepositoryException("Permission error", cause)
}
```

### Business Rule Violations:

**domain/usecase/BusinessRuleViolations.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User

/**
 * Use Case dengan validasi aturan bisnis kompleks
 */
class ValidateBusinessRulesUseCase(
    private val userRepository: UserRepository,
    private val transactionRepository: TransactionRepository,
    private val ruleEngine: BusinessRuleEngine
) {
    suspend operator fun invoke(userId: String, action: BusinessAction): ValidationResult {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return ValidationResult.Error(DomainException.UserNotFoundException(userId))
            
            // Validasi aturan bisnis utama
            val businessRules = listOf(
                { validateUserStatus(user) },
                { validateDailyLimits(user) },
                { validateTransactionAmount(action) },
                { validateGeographicRestrictions(user, action) },
                { validateTimeBasedRules(action) }
            )
            
            for (rule in businessRules) {
                val ruleResult = rule()
                if (ruleResult is ValidationResult.Error) {
                    return ruleResult
                }
            }
            
            ValidationResult.Success
            
        } catch (e: DomainException) {
            ValidationResult.Error(e)
        } catch (e: Exception) {
            ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Validation",
                    e.message ?: "Unknown validation error"
                )
            )
        }
    }
    
    private fun validateUserStatus(user: User): ValidationResult {
        return when {
            !user.isActive -> {
                ValidationResult.Error(
                    DomainException.AccountDeactivatedException(user.id)
                )
            }
            !user.isVerified -> {
                ValidationResult.Error(
                    DomainException.BusinessRuleViolationException(
                        "Verification Required",
                        "User must be verified to perform this action"
                    )
                )
            }
            user.isSuspended -> {
                ValidationResult.Error(
                    DomainException.BusinessRuleViolationException(
                        "Account Suspended",
                        "Account is suspended until ${user.suspensionUntil}"
                    )
                )
            }
            else -> ValidationResult.Success
        }
    }
    
    private suspend fun validateDailyLimits(user: User): ValidationResult {
        val today = getCurrentDay()
        val dailyTransactions = transactionRepository.getDailyTransactions(user.id, today)
        val dailyAmount = dailyTransactions.sumOf { it.amount }
        
        if (dailyAmount > user.dailyLimit) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Daily Limit Exceeded",
                    "Daily limit of ${user.dailyLimit} exceeded. Current: $dailyAmount"
                )
            )
        }
        
        if (dailyTransactions.size > user.maxDailyTransactions) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Daily Transaction Limit",
                    "Maximum ${user.maxDailyTransactions} transactions per day reached"
                )
            )
        }
        
        return ValidationResult.Success
    }
    
    private fun validateTransactionAmount(action: BusinessAction): ValidationResult {
        if (action is BusinessAction.Transaction && action.amount <= 0) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Invalid Amount",
                    "Transaction amount must be greater than 0"
                )
            )
        }
        
        if (action is BusinessAction.Transaction && action.amount > MAX_TRANSACTION_AMOUNT) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Transaction Limit",
                    "Transaction amount exceeds maximum of $MAX_TRANSACTION_AMOUNT"
                )
            )
        }
        
        return ValidationResult.Success
    }
    
    private fun validateGeographicRestrictions(user: User, action: BusinessAction): ValidationResult {
        if (user.country == "RESTRICTED_COUNTRY" && action.requiresInternationalAccess()) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Geographic Restriction",
                    "Action not allowed from restricted country: ${user.country}"
                )
            )
        }
        
        return ValidationResult.Success
    }
    
    private fun validateTimeBasedRules(action: BusinessAction): ValidationResult {
        if (action is BusinessAction.Transaction) {
            val currentHour = getCurrentHour()
            if (currentHour !in BUSINESS_HOURS) {
                return ValidationResult.Error(
                    DomainException.BusinessRuleViolationException(
                        "Business Hours",
                        "Transactions only allowed between ${BUSINESS_HOURS.first} and ${BUSINESS_HOURS.last} hours"
                    )
                )
            }
        }
        
        return ValidationResult.Success
    }
    
    private fun getCurrentDay(): String {
        // Implementasi untuk mendapatkan tanggal hari ini
        return "2023-10-01"
    }
    
    private fun getCurrentHour(): Int {
        // Implementasi untuk mendapatkan jam sekarang
        return 10
    }
    
    companion object {
        const val MAX_TRANSACTION_AMOUNT = 10000000.0 // 10 juta
        val BUSINESS_HOURS = 8..17 // 8 AM to 5 PM
    }
}

/**
 * Use Case untuk upgrade premium dengan aturan bisnis
 */
class PremiumUpgradeWithBusinessRulesUseCase(
    private val userRepository: UserRepository,
    private val billingRepository: BillingRepository,
    private val notificationRepository: NotificationRepository
) {
    suspend operator fun invoke(request: PremiumUpgradeRequest): PremiumUpgradeResult {
        return try {
            val user = userRepository.getUserById(request.userId)
                ?: return PremiumUpgradeResult.Error(
                    DomainException.UserNotFoundException(request.userId)
                )
            
            // Validasi aturan bisnis untuk premium upgrade
            val validation = validatePremiumUpgradeRules(user, request)
            if (validation !is ValidationResult.Success) {
                return PremiumUpgradeResult.ValidationError(
                    (validation as? ValidationResult.Error)?.exception?.message ?: "Validation failed"
                )
            }
            
            // Proses pembayaran
            val paymentResult = processPayment(
                request.userId,
                request.plan,
                request.paymentMethod
            )
            
            if (!paymentResult.isSuccess) {
                return PremiumUpgradeResult.PaymentError(paymentResult.message)
            }
            
            // Update status premium
            val upgradedUser = user.copy(
                isPremium = true,
                premiumSince = System.currentTimeMillis(),
                premiumUntil = System.currentTimeMillis() + request.duration,
                premiumTier = request.plan.tier
            )
            
            userRepository.updateUser(upgradedUser)
            
            // Kirim notifikasi
            sendPremiumConfirmation(upgradedUser, request.plan)
            
            PremiumUpgradeResult.Success(upgradedUser.id, paymentResult.transactionId!!)
            
        } catch (e: DomainException) {
            PremiumUpgradeResult.Error(e)
        } catch (e: Exception) {
            PremiumUpgradeResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Premium Upgrade",
                    e.message ?: "Unknown error during premium upgrade"
                )
            )
        }
    }
    
    private fun validatePremiumUpgradeRules(user: User, request: PremiumUpgradeRequest): ValidationResult {
        // Aturan: hanya user aktif bisa upgrade
        if (!user.isActive) {
            return ValidationResult.Error(
                DomainException.AccountDeactivatedException(user.id)
            )
        }
        
        // Aturan: user harus verified
        if (!user.isVerified) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Verification Required",
                    "User must be verified to upgrade to premium"
                )
            )
        }
        
        // Aturan: user tidak sedang dalam trial
        if (user.isInTrial && user.trialEndsAt > System.currentTimeMillis()) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Active Trial",
                    "User has active trial until ${user.trialEndsAt}"
                )
            )
        }
        
        // Aturan: cek apakah user sudah premium
        if (user.isPremium && user.premiumUntil > System.currentTimeMillis()) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Already Premium",
                    "User already has active premium subscription"
                )
            )
        }
        
        // Aturan: validasi payment method
        if (!isValidPaymentMethod(request.paymentMethod)) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Invalid Payment Method",
                    "Payment method is not valid or verified"
                )
            )
        }
        
        // Aturan: cek billing history
        if (hasBillingIssues(user.id)) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Billing Issues",
                    "User has outstanding billing issues"
                )
            )
        }
        
        return ValidationResult.Success
    }
    
    private fun isValidPaymentMethod(paymentMethod: PaymentMethod): Boolean {
        return paymentMethod.isVerified && paymentMethod.isActive
    }
    
    private suspend fun hasBillingIssues(userId: String): Boolean {
        // Cek apakah user punya billing issues
        return billingRepository.hasBillingIssues(userId)
    }
    
    private suspend fun processPayment(
        userId: String,
        plan: PremiumPlan,
        paymentMethod: PaymentMethod
    ): PaymentResult {
        // Proses pembayaran
        return billingRepository.processPayment(
            PaymentRequest(
                userId = userId,
                amount = plan.price,
                paymentMethodId = paymentMethod.id,
                description = "Premium subscription - ${plan.name}"
            )
        )
    }
    
    private suspend fun sendPremiumConfirmation(user: User, plan: PremiumPlan) {
        val notification = Notification(
            to = user.email,
            subject = "Premium Upgrade Successful",
            body = "Congratulations! You've successfully upgraded to ${plan.name} premium plan."
        )
        notificationRepository.sendNotification(notification)
    }
}

/**
 * Use Case untuk referral dengan aturan bisnis
 */
class ReferralBusinessRulesUseCase(
    private val userRepository: UserRepository,
    private val referralRepository: ReferralRepository,
    private val rewardRepository: RewardRepository
) {
    suspend operator fun invoke(request: ReferralRequest): ReferralResult {
        return try {
            // Validasi referral code
            val referralCode = referralRepository.getReferralCode(request.referralCode)
                ?: return ReferralResult.Error(
                    DomainException.BusinessRuleViolationException(
                        "Invalid Referral",
                        "Referral code not found"
                    )
                )
            
            // Validasi apakah code masih aktif
            if (!referralCode.isActive) {
                return ReferralResult.Error(
                    DomainException.BusinessRuleViolationException(
                        "Referral Expired",
                        "Referral code has expired"
                    )
                )
            }
            
            // Validasi apakah sudah mencapai limit
            if (referralCode.usageCount >= referralCode.maxUses) {
                return ReferralResult.Error(
                    DomainException.BusinessRuleViolationException(
                        "Referral Limit Reached",
                        "Referral code usage limit reached"
                    )
                )
            }
            
            // Validasi penerima referral (user yang merefer)
            val referrerUser = userRepository.getUserById(referralCode.userId)
                ?: return ReferralResult.Error(
                    DomainException.BusinessRuleViolationException(
                        "Invalid Referrer",
                        "Referrer user not found"
                    )
                )
            
            // Validasi pengguna baru (user yang direfer)
            val refereeUser = userRepository.getUserById(request.userId)
                ?: return ReferralResult.Error(
                    DomainException.UserNotFoundException(request.userId)
                )
            
            // Validasi aturan bisnis
            val businessValidation = validateReferralBusinessRules(referrerUser, refereeUser, referralCode)
            if (businessValidation !is ValidationResult.Success) {
                return ReferralResult.ValidationError(
                    (businessValidation as? ValidationResult.Error)?.exception?.message ?: "Validation failed"
                )
            }
            
            // Proses referral
            val referral = Referral(
                id = "ref_${System.currentTimeMillis()}",
                referrerId = referralCode.userId,
                refereeId = request.userId,
                code = request.referralCode,
                rewardAmount = referralCode.rewardAmount,
                status = ReferralStatus.PENDING
            )
            
            referralRepository.saveReferral(referral)
            
            // Berikan reward jika memenuhi syarat
            if (isReferralCompleted(refereeUser)) {
                completeReferral(referral)
            }
            
            ReferralResult.Success(referral.id)
            
        } catch (e: DomainException) {
            ReferralResult.Error(e)
        } catch (e: Exception) {
            ReferralResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Referral",
                    e.message ?: "Unknown error during referral processing"
                )
            )
        }
    }
    
    private fun validateReferralBusinessRules(
        referrer: User,
        referee: User,
        referralCode: ReferralCode
    ): ValidationResult {
        // Aturan: penerima referral tidak bisa merefer diri sendiri
        if (referrer.id == referee.id) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Self Referral",
                    "User cannot refer themselves"
                )
            )
        }
        
        // Aturan: penerima referral harus user aktif
        if (!referrer.isActive) {
            return ValidationResult.Error(
                DomainException.AccountDeactivatedException(referrer.id)
            )
        }
        
        // Aturan: pengguna baru tidak bisa menggunakan referral dari akun yang sama
        if (referee.referrerId == referrer.id) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Duplicate Referral",
                    "User already referred by this user"
                )
            )
        }
        
        // Aturan: jumlah referral per hari
        val dailyReferrals = referralRepository.getDailyReferrals(referrer.id)
        if (dailyReferrals >= MAX_DAILY_REFERRALS) {
            return ValidationResult.Error(
                DomainException.BusinessRuleViolationException(
                    "Daily Referral Limit",
                    "Daily referral limit of $MAX_DAILY_REFERRALS reached"
                )
            )
        }
        
        return ValidationResult.Success
    }
    
    private suspend fun isReferralCompleted(referee: User): Boolean {
        // Misalnya, referral dianggap complete jika user melakukan tindakan tertentu
        return referee.onboardingComplete && referee.hasMadeFirstTransaction
    }
    
    private suspend fun completeReferral(referral: Referral) {
        // Update status referral
        val completedReferral = referral.copy(status = ReferralStatus.COMPLETED)
        referralRepository.updateReferral(completedReferral)
        
        // Berikan reward ke penerima
        rewardRepository.grantReward(
            Reward(
                userId = referral.referrerId,
                type = RewardType.REFERRAL,
                amount = referral.rewardAmount,
                referenceId = referral.id
            )
        )
    }
    
    companion object {
        const val MAX_DAILY_REFERRALS = 5
    }
}

// Data classes untuk business rules
sealed class BusinessAction {
    data class Transaction(
        val amount: Double,
        val type: String
    ) : BusinessAction()
    
    object InternationalTransfer : BusinessAction()
    object PremiumUpgrade : BusinessAction()
}

fun BusinessAction.requiresInternationalAccess(): Boolean {
    return this is BusinessAction.InternationalTransfer
}

sealed class ValidationResult {
    object Success : ValidationResult()
    data class Error(val exception: DomainException) : ValidationResult()
}

data class PremiumUpgradeRequest(
    val userId: String,
    val plan: PremiumPlan,
    val paymentMethod: PaymentMethod,
    val duration: Long
)

data class PremiumPlan(
    val id: String,
    val name: String,
    val price: Double,
    val tier: String,
    val features: List<String>
)

data class PaymentMethod(
    val id: String,
    val type: String,
    val isVerified: Boolean,
    val isActive: Boolean
)

data class PaymentRequest(
    val userId: String,
    val amount: Double,
    val paymentMethodId: String,
    val description: String
)

data class PaymentResult(
    val isSuccess: Boolean,
    val message: String,
    val transactionId: String? = null
)

sealed class PremiumUpgradeResult {
    data class Success(val userId: String, val transactionId: String) : PremiumUpgradeResult()
    data class ValidationError(val message: String) : PremiumUpgradeResult()
    data class PaymentError(val message: String) : PremiumUpgradeResult()
    data class Error(val exception: DomainException) : PremiumUpgradeResult()
}

data class ReferralRequest(
    val userId: String,
    val referralCode: String
)

data class ReferralCode(
    val id: String,
    val userId: String,
    val code: String,
    val rewardAmount: Double,
    val maxUses: Int,
    val usageCount: Int,
    val isActive: Boolean,
    val expiresAt: Long?
)

data class Referral(
    val id: String,
    val referrerId: String,
    val refereeId: String,
    val code: String,
    val rewardAmount: Double,
    val status: ReferralStatus
)

enum class ReferralStatus { PENDING, COMPLETED, FAILED }

enum class RewardType { REFERRAL, PROMOTION, LOYALTY }

data class Reward(
    val id: String = "reward_${System.currentTimeMillis()}",
    val userId: String,
    val type: RewardType,
    val amount: Double,
    val referenceId: String,
    val grantedAt: Long = System.currentTimeMillis()
)

sealed class ReferralResult {
    data class Success(val referralId: String) : ReferralResult()
    data class ValidationError(val message: String) : ReferralResult()
    data class Error(val exception: DomainException) : ReferralResult()
}

// Placeholder interfaces
interface BusinessRuleEngine {
    fun validate(rule: String, context: Map<String, Any>): Boolean
}

interface BillingRepository {
    suspend fun hasBillingIssues(userId: String): Boolean
    suspend fun processPayment(request: PaymentRequest): PaymentResult
}

interface ReferralRepository {
    suspend fun getReferralCode(code: String): ReferralCode?
    suspend fun saveReferral(referral: Referral)
    suspend fun updateReferral(referral: Referral)
    suspend fun getDailyReferrals(userId: String): Int
}

interface RewardRepository {
    suspend fun grantReward(reward: Reward)
}
```

### User-facing Error Messages:

**domain/usecase/UserFacingErrorMessages.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User

/**
 * Use Case dengan pesan error yang user-friendly
 */
class GetUserWithUserFriendlyErrorsUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): GetUserResult {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return GetUserResult.Error(
                    "User not found",
                    "We couldn't find an account with the ID: $userId. Please check the ID and try again."
                )
            
            if (!user.isActive) {
                return GetUserResult.Error(
                    "Account deactivated",
                    "This account has been deactivated. Please contact support if you believe this is an error."
                )
            }
            
            GetUserResult.Success(user)
            
        } catch (e: RepositoryException.NetworkException) {
            GetUserResult.Error(
                "Network error",
                "We're having trouble connecting to our servers. Please check your internet connection and try again."
            )
        } catch (e: RepositoryException.TimeoutException) {
            GetUserResult.Error(
                "Request timeout", 
                "The request took too long to complete. Please try again in a moment."
            )
        } catch (e: RepositoryException.DataException) {
            GetUserResult.Error(
                "Data error",
                "There was an issue with retrieving your data. Our team has been notified."
            )
        } catch (e: Exception) {
            GetUserResult.Error(
                "Unknown error",
                "An unexpected error occurred. Please try again or contact support."
            )
        }
    }
}

/**
 * Use Case untuk registrasi dengan pesan error khusus user
 */
class RegisterUserWithUserMessagesUseCase(
    private val userRepository: UserRepository,
    private val validator: UserValidator
) {
    suspend operator fun invoke(userData: UserData): RegisterResult {
        return try {
            // Validasi dengan pesan yang clear
            val validation = validateUserDataForUser(userData)
            if (validation !is ValidationForUser.Success) {
                return RegisterResult.ValidationError(
                    validation.message,
                    validation.userMessage
                )
            }
            
            // Cek apakah user sudah ada
            if (userRepository.getUserByEmail(userData.email) != null) {
                return RegisterResult.Error(
                    "Email exists",
                    "An account with this email address already exists. Please use a different email or try logging in."
                )
            }
            
            // Proses registrasi
            val userId = generateUserId()
            val user = User(
                id = userId,
                name = userData.name,
                email = userData.email,
                isActive = true,
                isVerified = false,
                createdAt = System.currentTimeMillis()
            )
            
            userRepository.saveUser(user)
            
            // Kirim verifikasi email
            sendVerificationEmail(user.email, userId)
            
            RegisterResult.Success(user.id, "Account created successfully! Please check your email to verify your account.")
            
        } catch (e: RepositoryException.NetworkException) {
            RegisterResult.Error(
                "Network error",
                "We couldn't create your account due to a network issue. Please check your connection and try again."
            )
        } catch (e: RepositoryException.DataException) {
            RegisterResult.Error(
                "Data error",
                "There was an issue creating your account. Please try again later."
            )
        } catch (e: Exception) {
            RegisterResult.Error(
                "Registration failed",
                "We couldn't create your account. Please try again or contact support."
            )
        }
    }
    
    private fun validateUserDataForUser(userData: UserData): ValidationForUser {
        if (userData.name.isBlank()) {
            return ValidationForUser.Error(
                "Name is required",
                "Please enter your full name."
            )
        }
        
        if (userData.name.length < 2) {
            return ValidationForUser.Error(
                "Name too short",
                "Your name must be at least 2 characters long."
            )
        }
        
        if (userData.name.length > 50) {
            return ValidationForUser.Error(
                "Name too long",
                "Your name must be less than 50 characters."
            )
        }
        
        if (!validator.isValidEmail(userData.email)) {
            return ValidationForUser.Error(
                "Invalid email",
                "Please enter a valid email address (e.g., name@example.com)."
            )
        }
        
        if (userData.email.length > 100) {
            return ValidationForUser.Error(
                "Email too long",
                "Email address must be less than 100 characters."
            )
        }
        
        return ValidationForUser.Success
    }
    
    private fun generateUserId(): String {
        return "user_${System.currentTimeMillis()}"
    }
    
    private suspend fun sendVerificationEmail(email: String, userId: String) {
        // Simulasi pengiriman email verifikasi
    }
}

/**
 * Use Case untuk transaksi dengan pesan error langsung ke user
 */
class TransactionWithUserMessagesUseCase(
    private val userRepository: UserRepository,
    private val transactionRepository: TransactionRepository
) {
    suspend operator fun invoke(request: TransactionRequest): TransactionResult {
        return try {
            // Validasi permintaan
            val requestValidation = validateTransactionRequest(request)
            if (requestValidation !is ValidationForUser.Success) {
                return TransactionResult.ValidationError(
                    requestValidation.message,
                    requestValidation.userMessage
                )
            }
            
            // Ambil user
            val user = userRepository.getUserById(request.userId)
                ?: return TransactionResult.Error(
                    "User not found",
                    "We couldn't find your account. Please log in again."
                )
            
            // Validasi aturan bisnis dengan pesan user-friendly
            val businessValidation = validateBusinessRulesForUser(user, request)
            if (businessValidation !is ValidationForUser.Success) {
                return TransactionResult.Error(
                    businessValidation.message,
                    businessValidation.userMessage
                )
            }
            
            // Proses transaksi
            val transaction = createTransaction(request, user)
            transactionRepository.saveTransaction(transaction)
            
            // Update user balance
            val updatedUser = user.copy(balance = user.balance - request.amount)
            userRepository.updateUser(updatedUser)
            
            TransactionResult.Success(
                transaction.id,
                "Transaction completed successfully! Your balance has been updated."
            )
            
        } catch (e: RepositoryException.NetworkException) {
            TransactionResult.Error(
                "Network error",
                "We're having trouble processing your transaction. Please check your connection and try again."
            )
        } catch (e: RepositoryException.TimeoutException) {
            TransactionResult.Error(
                "Transaction timeout",
                "Your transaction is taking longer than expected. Please try again in a moment."
            )
        } catch (e: RepositoryException.PermissionException) {
            TransactionResult.Error(
                "Permission denied",
                "You don't have permission to perform this transaction. Please check your account status."
            )
        } catch (e: Exception) {
            TransactionResult.Error(
                "Transaction failed",
                "We couldn't process your transaction. Please try again or contact support."
            )
        }
    }
    
    private fun validateTransactionRequest(request: TransactionRequest): ValidationForUser {
        if (request.amount <= 0) {
            return ValidationForUser.Error(
                "Invalid amount",
                "Transaction amount must be greater than zero."
            )
        }
        
        if (request.amount > MAX_TRANSACTION_AMOUNT) {
            return ValidationForUser.Error(
                "Amount exceeds limit",
                "Transaction amount exceeds the maximum allowed amount of ${formatCurrency(MAX_TRANSACTION_AMOUNT)}."
            )
        }
        
        return ValidationForUser.Success
    }
    
    private fun validateBusinessRulesForUser(user: User, request: TransactionRequest): ValidationForUser {
        if (!user.isActive) {
            return ValidationForUser.Error(
                "Account deactivated",
                "Your account is deactivated. Please contact support to reactivate."
            )
        }
        
        if (!user.isVerified) {
            return ValidationForUser.Error(
                "Account not verified",
                "Please verify your account before making transactions."
            )
        }
        
        if (request.amount > user.balance) {
            return ValidationForUser.Error(
                "Insufficient funds",
                "You don't have enough balance for this transaction. Your current balance is ${formatCurrency(user.balance)}."
            )
        }
        
        // Validasi limit harian
        val dailyAmount = transactionRepository.getDailySpending(user.id)
        if (dailyAmount + request.amount > user.dailyLimit) {
            val remaining = user.dailyLimit - dailyAmount
            return ValidationForUser.Error(
                "Daily limit exceeded",
                "This transaction would exceed your daily limit. You can spend ${formatCurrency(remaining)} more today."
            )
        }
        
        return ValidationForUser.Success
    }
    
    private fun createTransaction(request: TransactionRequest, user: User): Transaction {
        return Transaction(
            id = "txn_${System.currentTimeMillis()}",
            userId = request.userId,
            amount = request.amount,
            type = request.type,
            status = TransactionStatus.PENDING,
            description = request.description,
            timestamp = System.currentTimeMillis()
        )
    }
    
    private fun formatCurrency(amount: Double): String {
        return "Rp ${String.format("%, .0f", amount)}"
    }
    
    companion object {
        const val MAX_TRANSACTION_AMOUNT = 10000000.0
    }
}

/**
 * Use Case untuk operasi kompleks dengan pesan error berjenjang
 */
class ComplexOperationWithUserMessagesUseCase(
    private val userRepository: UserRepository,
    private val profileRepository: ProfileRepository,
    private val activityRepository: ActivityRepository
) {
    suspend operator fun invoke(request: ComplexOperationRequest): ComplexOperationWithUserResult {
        return try {
            // Tahap 1: Validasi permintaan
            val requestValidation = validateRequestForUser(request)
            if (requestValidation !is ValidationForUser.Success) {
                return ComplexOperationWithUserResult.ValidationError(
                    requestValidation.message,
                    requestValidation.userMessage
                )
            }
            
            // Tahap 2: Ambil dan validasi user
            val userResult = getUserForOperation(request.userId)
            if (userResult !is GetUserResult.Success) {
                return ComplexOperationWithUserResult.Error(
                    userResult.message ?: "User validation failed",
                    userResult.userMessage ?: "Failed to validate your account"
                )
            }
            
            // Tahap 3: Validasi profile (opsional, bisa lanjut jika gagal)
            val profile = try {
                profileRepository.getProfileByUserId(request.userId)
            } catch (e: RepositoryException.DataException) {
                null // Lanjutkan tanpa profile
            }
            
            // Tahap 4: Proses operasi kompleks
            val processedData = processComplexDataForUser(
                userResult.user,
                profile,
                request.operationData
            )
            
            // Tahap 5: Simpan hasil
            saveProcessedData(userResult.user.id, processedData)
            
            // Tahap 6: Kembalikan hasil dengan pesan sukses
            ComplexOperationWithUserResult.Success(
                processedData,
                "Operation completed successfully!"
            )
            
        } catch (e: RepositoryException.NetworkException) {
            ComplexOperationWithUserResult.Error(
                "Network connection error",
                "We're having trouble connecting to our servers. Please check your internet connection and try again."
            )
        } catch (e: RepositoryException.TimeoutException) {
            ComplexOperationWithUserResult.Error(
                "Operation timeout",
                "The operation is taking longer than expected. Please try again in a moment."
            )
        } catch (e: DomainException) {
            // Petakan domain exception ke pesan user-friendly
            mapDomainExceptionToUserMessage(e)
        } catch (e: Exception) {
            ComplexOperationWithUserResult.Error(
                "Operation failed",
                "We couldn't complete your request. Please try again or contact support."
            )
        }
    }
    
    private fun validateRequestForUser(request: ComplexOperationRequest): ValidationForUser {
        if (request.userId.isBlank()) {
            return ValidationForUser.Error(
                "User ID required",
                "Please provide a valid user ID."
            )
        }
        
        if (request.operationData.isEmpty()) {
            return ValidationForUser.Error(
                "Operation data required",
                "Please provide data for the operation."
            )
        }
        
        return ValidationForUser.Success
    }
    
    private suspend fun getUserForOperation(userId: String): GetUserResult {
        return try {
            val user = userRepository.getUserById(userId)
                ?: return GetUserResult.Error(
                    "User not found",
                    "We couldn't find your account. Please log in again."
                )
            
            if (!user.isActive) {
                return GetUserResult.Error(
                    "Account deactivated", 
                    "Your account is deactivated. Please contact support."
                )
            }
            
            GetUserResult.Success(user)
        } catch (e: RepositoryException) {
            GetUserResult.Error(
                "User validation failed",
                "We couldn't validate your account. Please try again."
            )
        }
    }
    
    private fun processComplexDataForUser(
        user: User,
        profile: Profile?,
        operationData: Map<String, Any>
    ): ProcessedComplexDataForUser {
        return ProcessedComplexDataForUser(
            userId = user.id,
            processedAt = System.currentTimeMillis(),
            originalData = operationData,
            enrichedData = buildMap {
                putAll(operationData)
                put("processed", true)
                put("userEnriched", true)
                put("profileAvailable", profile != null)
                put("processingCenter", "Jakarta")
            },
            metadata = mapOf(
                "userCountry" to user.country,
                "userTier" to if (user.isPremium) "premium" else "standard",
                "profileExists" to (profile != null)
            )
        )
    }
    
    private suspend fun saveProcessedData(userId: String, data: ProcessedComplexDataForUser) {
        // Simpan data yang diproses
    }
    
    private fun mapDomainExceptionToUserMessage(exception: DomainException): ComplexOperationWithUserResult {
        return when (exception) {
            is DomainException.UserNotFoundException -> {
                ComplexOperationWithUserResult.Error(
                    "User not found",
                    "We couldn't find your account. Please log in again."
                )
            }
            is DomainException.AccountDeactivatedException -> {
                ComplexOperationWithUserResult.Error(
                    "Account deactivated",
                    "Your account is deactivated. Please contact support."
                )
            }
            is DomainException.UnauthorizedAccessException -> {
                ComplexOperationWithUserResult.Error(
                    "Access denied",
                    "You don't have permission to perform this operation."
                )
            }
            else -> {
                ComplexOperationWithUserResult.Error(
                    "Operation validation failed",
                    "We couldn't validate your request. Please check your input and try again."
                )
            }
        }
    }
}

// Data classes untuk user-facing error messages
data class UserData(
    val name: String,
    val email: String
)

sealed class GetUserResult {
    data class Success(val user: User) : GetUserResult()
    data class Error(
        val message: String?,
        val userMessage: String
    ) : GetUserResult()
}

sealed class ValidationForUser {
    object Success : ValidationForUser()
    data class Error(
        val message: String,
        val userMessage: String
    ) : ValidationForUser()
}

data class TransactionRequest(
    val userId: String,
    val amount: Double,
    val type: TransactionType,
    val description: String
)

sealed class TransactionResult {
    data class Success(
        val transactionId: String,
        val userMessage: String
    ) : TransactionResult()
    
    data class ValidationError(
        val message: String,
        val userMessage: String
    ) : TransactionResult()
    
    data class Error(
        val message: String,
        val userMessage: String
    ) : TransactionResult()
}

data class ComplexOperationRequest(
    val userId: String,
    val operationData: Map<String, Any>
)

data class ProcessedComplexDataForUser(
    val userId: String,
    val processedAt: Long,
    val originalData: Map<String, Any>,
    val enrichedData: Map<String, Any>,
    val metadata: Map<String, Any>
)

sealed class ComplexOperationWithUserResult {
    data class Success(
        val data: ProcessedComplexDataForUser,
        val userMessage: String
    ) : ComplexOperationWithUserResult()
    
    data class ValidationError(
        val message: String,
        val userMessage: String
    ) : ComplexOperationWithUserResult()
    
    data class Error(
        val message: String,
        val userMessage: String
    ) : ComplexOperationWithUserResult()
}

sealed class RegisterResult {
    data class Success(
        val userId: String,
        val userMessage: String
    ) : RegisterResult()
    
    data class ValidationError(
        val message: String,
        val userMessage: String
    ) : RegisterResult()
    
    data class Error(
        val message: String,
        val userMessage: String
    ) : RegisterResult()
}
```

### Retry Logic:

**domain/usecase/RetryLogic.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import kotlinx.coroutines.delay

/**
 * Use Case dengan retry logic dasar
 */
class GetUserWithRetryUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(
        userId: String,
        maxRetries: Int = 3,
        retryDelay: Long = 1000 // 1 detik
    ): GetUserResult {
        var lastException: Exception? = null
        
        for (attempt in 1..maxRetries) {
            try {
                val user = userRepository.getUserById(userId)
                
                if (user != null) {
                    return GetUserResult.Success(user)
                } else {
                    return GetUserResult.Error(
                        "User not found after $attempt attempts",
                        "We're having trouble finding your account after $attempt attempts."
                    )
                }
            } catch (e: RepositoryException.NetworkException) {
                lastException = e
                if (attempt < maxRetries) {
                    delay(retryDelay * attempt) // Exponential backoff
                }
            } catch (e: RepositoryException.TimeoutException) {
                lastException = e
                if (attempt < maxRetries) {
                    delay(retryDelay * attempt)
                }
            } catch (e: Exception) {
                // Jangan retry untuk error selain network/timeout
                return GetUserResult.Error(
                    "Unknown error: ${e.message}",
                    "We're having trouble accessing your account. Please try again later."
                )
            }
        }
        
        return GetUserResult.Error(
            "All $maxRetries attempts failed: ${lastException?.message}",
            "We couldn't access your account after multiple attempts. Please try again later."
        )
    }
}

/**
 * Use Case dengan retry conditional
 */
class ConditionalRetryUseCase(
    private val userRepository: UserRepository,
    private val apiService: ExternalApiService
) {
    suspend operator fun invoke(
        request: ConditionalRetryRequest
    ): ConditionalRetryResult {
        var currentAttempt = 1
        var lastResult: ConditionalRetryResult? = null
        var lastError: Exception? = null
        
        while (currentAttempt <= request.maxAttempts) {
            try {
                when (request.operationType) {
                    OperationType.FETCH_USER -> {
                        val user = userRepository.getUserById(request.userId)
                        if (user != null) {
                            return ConditionalRetryResult.Success(mapOf("user" to user))
                        }
                    }
                    OperationType.EXTERNAL_API -> {
                        val response = apiService.callExternalApi(request.apiParams)
                        if (response.isSuccess) {
                            return ConditionalRetryResult.Success(response.data)
                        }
                    }
                }
            } catch (e: RepositoryException.NetworkException) {
                lastError = e
                if (shouldRetry(currentAttempt, request.maxAttempts, e)) {
                    delay(calculateRetryDelay(currentAttempt, request.baseDelay))
                    currentAttempt++
                    continue
                }
            } catch (e: RepositoryException.TimeoutException) {
                lastError = e
                if (shouldRetry(currentAttempt, request.maxAttempts, e)) {
                    delay(calculateRetryDelay(currentAttempt, request.baseDelay))
                    currentAttempt++
                    continue
                }
            } catch (e: Exception) {
                // Jangan retry untuk error tidak didukung
                return ConditionalRetryResult.Error(
                    "Non-retryable error: ${e.message}",
                    "Operation failed with a non-retryable error."
                )
            }
            
            // Jika sukses dalam loop, keluar dari loop
            break
        }
        
        return lastResult ?: ConditionalRetryResult.Error(
            "All attempts failed: ${lastError?.message}",
            "Operation failed after ${request.maxAttempts} attempts."
        )
    }
    
    private fun shouldRetry(attempt: Int, maxAttempts: Int, error: Exception): Boolean {
        // Hanya retry untuk network dan timeout errors
        return error is RepositoryException.NetworkException ||
               error is RepositoryException.TimeoutException
    }
    
    private fun calculateRetryDelay(attempt: Int, baseDelay: Long): Long {
        // Exponential backoff: baseDelay * (2 ^ (attempt - 1))
        return baseDelay * (1L shl (attempt - 1))
    }
}

/**
 * Use Case dengan retry dengan penanganan error yang berbeda
 */
class SmartRetryUseCase(
    private val userRepository: UserRepository,
    private val backupRepository: BackupUserRepository
) {
    suspend operator fun invoke(
        userId: String,
        retryStrategy: RetryStrategy = RetryStrategy.EXPONENTIAL_BACKOFF
    ): SmartRetryResult {
        return when (retryStrategy) {
            RetryStrategy.EXPONENTIAL_BACKOFF -> {
                retryWithExponentialBackoff(userId)
            }
            RetryStrategy.FAILOVER -> {
                retryWithFailover(userId)
            }
            RetryStrategy.CIRCUIT_BREAKER -> {
                retryWithCircuitBreaker(userId)
            }
        }
    }
    
    private suspend fun retryWithExponentialBackoff(userId: String): SmartRetryResult {
        var attempt = 1
        var delayMs = 1000L // 1 detik
        
        while (attempt <= MAX_RETRY_ATTEMPTS) {
            try {
                val user = userRepository.getUserById(userId)
                if (user != null) {
                    return SmartRetryResult.Success(user)
                }
            } catch (e: RepositoryException.NetworkException) {
                if (attempt < MAX_RETRY_ATTEMPTS) {
                    delay(delayMs)
                    delayMs *= 2 // Exponential backoff
                    attempt++
                    continue
                }
            } catch (e: RepositoryException.TimeoutException) {
                if (attempt < MAX_RETRY_ATTEMPTS) {
                    delay(delayMs)
                    delayMs *= 2
                    attempt++
                    continue
                }
            }
            
            break
        }
        
        return SmartRetryResult.Error(
            "Failed after $MAX_RETRY_ATTEMPTS attempts",
            "We couldn't access your account after multiple attempts. Please try again later."
        )
    }
    
    private suspend fun retryWithFailover(userId: String): SmartRetryResult {
        var lastError: String? = null
        
        try {
            val user = userRepository.getUserById(userId)
            if (user != null) {
                return SmartRetryResult.Success(user)
            }
        } catch (e: RepositoryException.NetworkException) {
            lastError = "Primary repository network error: ${e.message}"
        } catch (e: RepositoryException.TimeoutException) {
            lastError = "Primary repository timeout: ${e.message}"
        }
        
        // Jika primary gagal, coba backup
        try {
            val backupUser = backupRepository.getUserById(userId)
            if (backupUser != null) {
                return SmartRetryResult.Success(backupUser)
            }
        } catch (e: Exception) {
            // Jika backup juga gagal, return error dari primary
            return SmartRetryResult.Error(
                "Both primary and backup failed: $lastError",
                "We're having trouble accessing your account. Our backup systems are also unavailable."
            )
        }
        
        return SmartRetryResult.Error(
            "User not found in both repositories",
            "We couldn't find your account in our systems."
        )
    }
    
    private suspend fun retryWithCircuitBreaker(userId: String): SmartRetryResult {
        val circuitState = circuitBreaker.getState()
        
        return when (circuitState) {
            CircuitState.CLOSED -> {
                try {
                    val user = userRepository.getUserById(userId)
                    if (user != null) {
                        circuitBreaker.onSuccess()
                        SmartRetryResult.Success(user)
                    } else {
                        circuitBreaker.onFailure()
                        SmartRetryResult.Error(
                            "User not found",
                            "We couldn't find your account."
                        )
                    }
                } catch (e: RepositoryException.NetworkException) {
                    circuitBreaker.onFailure()
                    SmartRetryResult.Error(
                        "Network error",
                        "We're having trouble connecting to our servers."
                    )
                }
            }
            CircuitState.OPEN -> {
                SmartRetryResult.Error(
                    "Circuit breaker open",
                    "Service is temporarily unavailable due to high error rate. Please try again later."
                )
            }
            CircuitState.HALF_OPEN -> {
                // Coba sekali saja
                try {
                    val user = userRepository.getUserById(userId)
                    if (user != null) {
                        circuitBreaker.onSuccess()
                        SmartRetryResult.Success(user)
                    } else {
                        circuitBreaker.onFailure()
                        SmartRetryResult.Error(
                            "User not found",
                            "We couldn't find your account."
                        )
                    }
                } catch (e: RepositoryException.NetworkException) {
                    circuitBreaker.onFailure()
                    SmartRetryResult.Error(
                        "Network error",
                        "We're having trouble connecting to our servers."
                    )
                }
            }
        }
    }
    
    companion object {
        const val MAX_RETRY_ATTEMPTS = 3
        
        val circuitBreaker = CircuitBreaker(
            failureThreshold = 5,
            timeout = 60000,
            resetTimeout = 30000
        )
    }
}

/**
 * Use Case dengan retry untuk operasi yang bisa partial success
 */
class PartialSuccessRetryUseCase(
    private val userRepository: UserRepository,
    private val profileRepository: ProfileRepository,
    private val activityRepository: ActivityRepository
) {
    suspend operator fun invoke(
        userId: String,
        retryConfig: RetryConfig = RetryConfig()
    ): PartialSuccessRetryResult {
        val results = mutableMapOf<String, Any?>()
        val errors = mutableMapOf<String, String>()
        
        // Retry untuk user
        var userResult: User? = null
        var userError: String? = null
        
        for (attempt in 1..retryConfig.maxRetries) {
            try {
                userResult = userRepository.getUserById(userId)
                break
            } catch (e: RepositoryException.NetworkException) {
                userError = e.message
                if (attempt < retryConfig.maxRetries) {
                    delay(retryConfig.delayMs)
                }
            }
        }
        
        if (userResult != null) {
            results["user"] = userResult
        } else {
            errors["user"] = "Failed after ${retryConfig.maxRetries} attempts: $userError"
        }
        
        // Retry untuk profile
        var profileResult: Profile? = null
        var profileError: String? = null
        
        for (attempt in 1..retryConfig.maxRetries) {
            try {
                profileResult = profileRepository.getProfileByUserId(userId)
                break
            } catch (e: RepositoryException.NetworkException) {
                profileError = e.message
                if (attempt < retryConfig.maxRetries) {
                    delay(retryConfig.delayMs)
                }
            }
        }
        
        if (profileResult != null) {
            results["profile"] = profileResult
        } else {
            errors["profile"] = "Failed after ${retryConfig.maxRetries} attempts: $profileError"
        }
        
        // Tidak retry untuk activity (gunakan data terbaru yang tersedia)
        try {
            val activityResult = activityRepository.getRecentActivity(userId)
            results["activity"] = activityResult
        } catch (e: RepositoryException) {
            errors["activity"] = "Could not fetch activity: ${it.message}"
            results["activity"] = emptyList<Activity>() // Gunakan data kosong jika gagal
        }
        
        val hasAnySuccess = results.isNotEmpty()
        val hasErrors = errors.isNotEmpty()
        
        return if (hasAnySuccess) {
            PartialSuccessRetryResult.PartialSuccess(
                data = results,
                errors = errors,
                message = buildPartialSuccessMessage(results, errors)
            )
        } else {
            PartialSuccessRetryResult.Error(
                "All operations failed",
                "We couldn't retrieve any of your data after ${retryConfig.maxRetries} attempts."
            )
        }
    }
    
    private fun buildPartialSuccessMessage(
        results: Map<String, Any?>,
        errors: Map<String, String>
    ): String {
        val successItems = results.keys.joinToString(", ")
        val errorItems = errors.keys.joinToString(", ")
        
        return when {
            results.isNotEmpty() && errors.isEmpty() -> "All data retrieved successfully."
            results.isNotEmpty() && errors.isNotEmpty() -> 
                "Some data retrieved successfully (${successItems}), but some failed (${errorItems})."
            else -> "No data could be retrieved."
        }
    }
}

// Enum dan data classes untuk retry
enum class OperationType { FETCH_USER, EXTERNAL_API, UPDATE_PROFILE }
enum class RetryStrategy { EXPONENTIAL_BACKOFF, FAILOVER, CIRCUIT_BREAKER }
enum class CircuitState { CLOSED, OPEN, HALF_OPEN }

data class ConditionalRetryRequest(
    val userId: String,
    val operationType: OperationType,
    val maxAttempts: Int = 3,
    val baseDelay: Long = 1000,
    val apiParams: Map<String, String> = emptyMap()
)

data class RetryConfig(
    val maxRetries: Int = 3,
    val delayMs: Long = 1000
)

sealed class ConditionalRetryResult {
    data class Success(val data: Map<String, Any>) : ConditionalRetryResult()
    data class Error(
        val message: String,
        val userMessage: String
    ) : ConditionalRetryResult()
}

sealed class SmartRetryResult {
    data class Success(val user: User) : SmartRetryResult()
    data class Error(
        val message: String,
        val userMessage: String
    ) : SmartRetryResult()
}

sealed class PartialSuccessRetryResult {
    data class PartialSuccess(
        val data: Map<String, Any?>,
        val errors: Map<String, String>,
        val message: String
    ) : PartialSuccessRetryResult()
    
    data class Error(
        val message: String,
        val userMessage: String
    ) : PartialSuccessRetryResult()
}

// Circuit Breaker implementation
class CircuitBreaker(
    private val failureThreshold: Int,
    private val timeout: Long,
    private val resetTimeout: Long
) {
    private var failureCount = 0
    private var lastFailureTime = 0L
    private var state = CircuitState.CLOSED
    
    fun getState(): CircuitState {
        if (state == CircuitState.OPEN && System.currentTimeMillis() - lastFailureTime > resetTimeout) {
            state = CircuitState.HALF_OPEN
        }
        return state
    }
    
    fun onSuccess() {
        failureCount = 0
        state = CircuitState.CLOSED
    }
    
    fun onFailure() {
        failureCount++
        lastFailureTime = System.currentTimeMillis()
        
        if (failureCount >= failureThreshold) {
            state = CircuitState.OPEN
        }
    }
}

// Placeholder interfaces
interface ExternalApiService {
    suspend fun callExternalApi(params: Map<String, String>): ApiResponse
}

data class ApiResponse(
    val isSuccess: Boolean,
    val data: Map<String, Any>,
    val message: String? = null
)
</code></pre>

### üéì Penjelasan Konsep:
**Error Handling dalam Use Cases seperti Sistem Pertahanan:**
- **Domain-specific Exceptions**: Exception yang spesifik untuk aturan bisnis
- **Result Sealed Classes**: Representasi hasil operasi dengan error handling
- **Mapping Repository Errors**: Memetakan error dari lapisan bawah ke domain
- **Business Rule Violations**: Validasi dan penanganan pelanggaran aturan bisnis
- **User-facing Error Messages**: Pesan error yang mudah dimengerti user
- **Retry Logic**: Mekanisme untuk mengulang operasi yang gagal

---

## 1Ô∏è‚É£0Ô∏è‚É£ Testing Use Cases üß™

### Konsep Dasar
Testing Use Cases seperti Quality Assurance untuk logika bisnis üß™ - memastikan setiap alur kerja dan aturan bisnis berfungsi sesuai harapan!

### Unit Testing dengan Mocked Repositories:

**domain/usecase/GetUserUseCaseTest.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.mockk
import kotlinx.coroutines.test.runTest
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertNull

class GetUserUseCaseTest {
    
    private val mockUserRepository = mockk<UserRepository>()
    private val useCase = GetUserUseCase(mockUserRepository)
    
    @Test
    fun `should return user when repository returns user`() = runTest {
        // Given
        val userId = "user123"
        val expectedUser = User(
            id = userId,
            name = "John Doe",
            email = "john@example.com",
            isActive = true,
            isVerified = true
        )
        
        coEvery { mockUserRepository.getUserById(userId) } returns expectedUser
        
        // When
        val result = useCase(userId)
        
        // Then
        assertNotNull(result)
        assertEquals(expectedUser, result)
        coVerify { mockUserRepository.getUserById(userId) }
    }
    
    @Test
    fun `should return null when repository returns null`() = runTest {
        // Given
        val userId = "nonexistent"
        coEvery { mockUserRepository.getUserById(userId) } returns null
        
        // When
        val result = useCase(userId)
        
        // Then
        assertNull(result)
        coVerify { mockUserRepository.getUserById(userId) }
    }
    
    @Test
    fun `should handle repository exception properly`() = runTest {
        // Given
        val userId = "error_user"
        coEvery { mockUserRepository.getUserById(userId) } throws Exception("Database error")
        
        // When & Then
        try {
            useCase(userId)
        } catch (e: Exception) {
            assertEquals("Database error", e.message)
        }
        
        coVerify { mockUserRepository.getUserById(userId) }
    }
}

/**
 * Test untuk Use Case registrasi user
 */
class RegisterUserUseCaseTest {
    
    private val mockUserRepository = mockk<UserRepository>()
    private val validator = UserValidator() // Validator real, bukan mock
    private val useCase = RegisterUserWithDomainValidationUseCase(mockUserRepository, validator)
    
    @Test
    fun `should register user successfully with valid data`() = runTest {
        // Given
        val userData = UserData(
            name = "Jane Doe",
            email = "jane@example.com"
        )
        
        coEvery { mockUserRepository.getUserByEmail(userData.email) } returns null
        coEvery { mockUserRepository.saveUser(any()) } returns Unit
        
        // When
        val result = useCase(userData)
        
        // Then
        assertNotNull(result)
        coVerify { mockUserRepository.getUserByEmail(userData.email) }
        coVerify { mockUserRepository.saveUser(any()) }
    }
    
    @Test
    fun `should throw exception when email already exists`() = runTest {
        // Given
        val userData = UserData(
            name = "Jane Doe",
            email = "jane@example.com"
        )
        
        val existingUser = User(
            id = "existing123",
            name = "Jane Doe",
            email = "jane@example.com",
            isActive = true
        )
        
        coEvery { mockUserRepository.getUserByEmail(userData.email) } returns existingUser
        
        // When & Then
        try {
            useCase(userData)
            // Should not reach here
            assert(false)
        } catch (e: DomainException.UserAlreadyExistsException) {
            assertEquals(userData.email, e.email)
        }
        
        coVerify { mockUserRepository.getUserByEmail(userData.email) }
    }
    
    @Test
    fun `should throw exception when email is invalid`() = runTest {
        // Given
        val userData = UserData(
            name = "John Doe",
            email = "invalid-email" // Invalid email format
        )
        
        // When & Then
        try {
            useCase(userData)
            // Should not reach here
            assert(false)
        } catch (e: DomainException) {
            // Should be ValidationError
            assert(e is DomainException.ValidationError)
        }
    }
}

/**
 * Test untuk Use Case kompleks dengan banyak dependency
 */
class ComplexOperationUseCaseTest {
    
    private val mockUserRepository = mockk<UserRepository>()
    private val mockProfileRepository = mockk<ProfileRepository>()
    private val mockActivityRepository = mockk<ActivityRepository>()
    
    private val useCase = ComplexOperationWithRepositoryErrorMappingUseCase(
        mockUserRepository,
        mockProfileRepository,
        mockActivityRepository
    )
    
    @Test
    fun `should return success when all dependencies succeed`() = runTest {
        // Given
        val userId = "user123"
        val requestData = mapOf("key" to "value")
        val request = ComplexRequest(userId, requestData)
        
        val user = User(
            id = userId,
            name = "John Doe",
            email = "john@example.com",
            isActive = true
        )
        
        val profile = Profile(
            userId = userId,
            bio = "Test bio",
            avatar = "avatar_url"
        )
        
        val activities = listOf(
            Activity("act1", userId, "login", System.currentTimeMillis(), "details")
        )
        
        coEvery { mockUserRepository.getUserById(userId) } returns user
        coEvery { mockProfileRepository.getProfileByUserId(userId) } returns profile
        coEvery { mockActivityRepository.getRecentActivity(userId, 10) } returns activities
        
        // When
        val result = useCase(request)
        
        // Then
        assert(result is ComplexOperationResult.Success)
        val successResult = result as ComplexOperationResult.Success
        assertEquals(userId, successResult.data.userId)
    }
    
    @Test
    fun `should handle repository network exception`() = runTest {
        // Given
        val userId = "user123"
        val requestData = mapOf("key" to "value")
        val request = ComplexRequest(userId, requestData)
        
        coEvery { mockUserRepository.getUserById(userId) } throws RepositoryException.NetworkException()
        
        // When
        val result = useCase(request)
        
        // Then
        assert(result is ComplexOperationResult.DomainError)
        val errorResult = result as ComplexOperationResult.DomainError
        assert(errorResult.exception is DomainException.BusinessRuleViolationException)
    }
    
    @Test
    fun `should handle partial success when some dependencies fail`() = runTest {
        // Given
        val userId = "user123"
        val requestData = mapOf("key" to "value")
        val request = ComplexRequest(userId, requestData)
        
        val user = User(
            id = userId,
            name = "John Doe",
            email = "john@example.com",
            isActive = true
        )
        
        // User succeeds, profile fails, activity succeeds
        coEvery { mockUserRepository.getUserById(userId) } returns user
        coEvery { mockProfileRepository.getProfileByUserId(userId) } throws RepositoryException.NetworkException()
        coEvery { mockActivityRepository.getRecentActivity(userId, 10) } returns emptyList()
        
        // When
        val result = useCase(request)
        
        // Then
        assert(result is ComplexOperationResult.Success) // Should still succeed with partial data
    }
}
```

### Testing Business Logic Isolated:

**domain/usecase/BusinessLogicTest.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import kotlinx.coroutines.test.runTest
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertTrue

class ValidateBusinessRulesUseCaseTest {
    
    private val mockUserRepository = mockk<UserRepository>()
    private val mockTransactionRepository = mockk<TransactionRepository>()
    private val mockRuleEngine = mockk<BusinessRuleEngine>()
    
    private val useCase = ValidateBusinessRulesUseCase(
        mockUserRepository,
        mockTransactionRepository,
        mockRuleEngine
    )
    
    @Test
    fun `should return success when user active and verified`() = runTest {
        // Given
        val userId = "user123"
        val user = User(
            id = userId,
            name = "John Doe",
            email = "john@example.com",
            isActive = true,
            isVerified = true,
            dailyLimit = 10000000.0,
            maxDailyTransactions = 10
        )
        
        coEvery { mockUserRepository.getUserById(userId) } returns user
        coEvery { mockTransactionRepository.getDailyTransactions(userId, any()) } returns emptyList()
        
        val action = BusinessAction.Transaction(5000.0, "debit")
        
        // When
        val result = useCase(userId, action)
        
        // Then
        assertTrue(result is ValidationResult.Success)
    }
    
    @Test
    fun `should return error when user is not active`() = runTest {
        // Given
        val userId = "user123"
        val user = User(
            id = userId,
            name = "John Doe",
            email = "john@example.com",
            isActive = false, // Not active
            isVerified = true
        )
        
        coEvery { mockUserRepository.getUserById(userId) } returns user
        
        val action = BusinessAction.Transaction(5000.0, "debit")
        
        // When
        val result = useCase(userId, action)
        
        // Then
        assertTrue(result is ValidationResult.Error)
        assertTrue((result as ValidationResult.Error).exception is DomainException.AccountDeactivatedException)
    }
    
    @Test
    fun `should return error when user not verified`() = runTest {
        // Given
        val userId = "user123"
        val user = User(
            id = userId,
            name = "John Doe",
            email = "john@example.com",
            isActive = true,
            isVerified = false // Not verified
        )
        
        coEvery { mockUserRepository.getUserById(userId) } returns user
        
        val action = BusinessAction.Transaction(5000.0, "debit")
        
        // When
        val result = useCase(userId, action)
        
        // Then
        assertTrue(result is ValidationResult.Error)
        assertTrue((result as ValidationResult.Error).exception is DomainException.BusinessRuleViolationException)
    }
    
    @Test
    fun `should return error when daily transaction limit exceeded`() = runTest {
        // Given
        val userId = "user123"
        val user = User(
            id = userId,
            name = "John Doe",
            email = "john@example.com",
            isActive = true,
            isVerified = true,
            dailyLimit = 10000000.0,
            maxDailyTransactions = 1 // Only 1 allowed per day
        )
        
        val dailyTransactions = (1..2).map { i ->
            Transaction(
                id = "txn$i",
                userId = userId,
                amount = 1000.0,
                type = TransactionType.DEBIT,
                status = TransactionStatus.COMPLETED,
                description = "Test transaction $i"
            )
        }
        
        coEvery { mockUserRepository.getUserById(userId) } returns user
        coEvery { mockTransactionRepository.getDailyTransactions(userId, any()) } returns dailyTransactions
        
        val action = BusinessAction.Transaction(5000.0, "debit")
        
        // When
        val result = useCase(userId, action)
        
        // Then
        assertTrue(result is ValidationResult.Error)
        assertTrue((result as ValidationResult.Error).exception is DomainException.BusinessRuleViolationException)
    }
}

/**
 * Testing perhitungan logika bisnis
 */
class CalculateUserScoreUseCaseTest {
    
    @Test
    fun `should calculate risk score based on user properties`() = runTest {
        val userId = "user123"
        val user = User(
            id = userId,
            name = "John Doe",
            email = "john@example.com",
            isActive = true,
            isVerified = true,
            createdAt = System.currentTimeMillis() - 365 * 24 * 60 * 60 * 1000L, // 1 year ago
            balance = 5000000.0
        )
        
        // Create a use case that focuses on calculation
        val score = calculateRiskScoreForTesting(user)
        
        // Risk score should be lower for older accounts with good balance
        assertTrue(score < 50.0) // Should be relatively low risk
    }
    
    @Test
    fun `should calculate high risk for new account with low balance`() = runTest {
        val userId = "user123"
        val user = User(
            id = userId,
            name = "New User",
            email = "new@example.com",
            isActive = true,
            isVerified = true,
            createdAt = System.currentTimeMillis() - 1 * 24 * 60 * 60 * 1000L, // 1 day ago
            balance = 1000.0 // Very low balance
        )
        
        val score = calculateRiskScoreForTesting(user)
        
        // Should be higher risk for new account with low balance
        assertTrue(score > 70.0)
    }
    
    private fun calculateRiskScoreForTesting(user: User): Double {
        var score = 50.0 // Base risk score
        
        // Account age factor (newer accounts are riskier)
        val accountAgeInDays = (System.currentTimeMillis() - user.createdAt) / (24 * 60 * 60 * 1000L)
        score -= minOf(accountAgeInDays / 30.0, 20.0) // Max 20 points reduction for old account
        
        // Balance factor (higher balance is less risky)
        score -= minOf(user.balance / 1000000.0, 15.0) // Max 15 points reduction for high balance
        
        // Verification factor
        if (user.isVerified) {
            score -= 10.0
        }
        
        // Activity factor (simplified)
        score -= if (user.isActive) 5.0 else 0.0
        
        return score.coerceIn(0.0, 100.0)
    }
}

/**
 * Testing validasi input
 */
class ValidateUserDataUseCaseTest {
    
    private val validator = UserValidator()
    
    @Test
    fun `should validate valid email correctly`() {
        assertTrue(validator.isValidEmail("user@example.com"))
        assertTrue(validator.isValidEmail("test.user+tag@example.co.uk"))
    }
    
    @Test
    fun `should reject invalid email`() {
        assertFalse(validator.isValidEmail("invalid-email"))
        assertFalse(validator.isValidEmail("@example.com"))
        assertFalse(validator.isValidEmail("user@"))
        assertFalse(validator.isValidEmail(""))
    }
    
    @Test
    fun `should validate name length`() {
        assertTrue(validator.isValidName("John"))
        assertFalse(validator.isValidName("A")) // Too short
        assertTrue(validator.isValidName("A".repeat(50))) // At boundary
        assertFalse(validator.isValidName("A".repeat(51))) // Too long
    }
}
```

### Happy Path Testing:

**domain/usecase/HappyPathTest.kt**
```kotlin
package com.example.usecasesample.domain.usecase

import com.example.usecasesample.domain.model.User
import com.example.usecasesample.domain.repository.UserRepository
import io.mockk.coEvery
import io.mockk.coVerify
import kotlinx.coroutines.test.runTest
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull

class HappyPathUseCaseTest {
    
    @Test
    fun `get user happy path`() = runTest {
        // Given - Setup for success scenario
        val mockUserRepository = mockk<UserRepository>()
        val useCase = GetUserUseCase(mockUserRepository)
        
        val userId = "happy_path_user"
        val expectedUser = User(
            id = userId,
            name = "Happy Path User",
            email = "happy@example.com",
            isActive = true,
            isVerified = true,
            createdAt = System.currentTimeMillis()
        )
        
        coEvery { mockUserRepository.getUserById(userId) } returns expectedUser
        
        // When - Execute the use case
        val result = useCase(userId)
        
        // Then - Verify success conditions
        assertNotNull(result)
        assertEquals(expectedUser.id, result.id)
        assertEquals(expectedUser.name, result.name)
        assertEquals(expectedUser.email, result.email)
        assertEquals(expectedUser.isActive, result.isActive)
        coVerify { mockUserRepository.getUserById(userId) }
    }
    
    @Test
    fun `register user happy path`() = runTest {
        // Given
        val mockUserRepository = mockk<UserRepository>()
        val validator = UserValidator()
        val useCase = RegisterUserWithDomainValidationUseCase(mockUserRepository, validator)
        
        val validUserData = UserData(
            name = "Happy Path User",
            email = "happy.path@example.com"
        )
        
        coEvery { mockUserRepository.getUserByEmail(validUserData.email) } returns null
        coEvery { mockUserRepository.saveUser(any()) } returns Unit
        
        // When
        val userId = useCase(validUserData)
        
        // Then
        assertNotNull(userId