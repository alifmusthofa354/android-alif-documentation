

# ğŸš€ Panduan Lengkap: Advanced Networking di Android

## ğŸš€ Pengantar: Sistem Logistik Digital Canggih

Bayangkan kamu adalah seorang manajer logistik modern ğŸš›:
- **Advanced Networking** seperti sistem logistik canggih yang mengatur pengiriman paket di seluruh dunia
- **Exponential Backoff** seperti strategi pengiriman ulang dengan jeda waktu yang semakin lama jika penerima tidak ada
- **API Throttling** seperti pengaturan jumlah truk yang boleh masuk ke gudang per menit
- **Cache-Control** seperti gudang penyimpanan barang yang sering diminta di dekat pelanggan

Dengan menguasai Advanced Networking, kamu bisa membuat aplikasi yang tangguh, efisien, andal, dan memberikan pengalaman pengguna yang luar biasa!

## ğŸ“š Daftar Isi Pembelajaran
1. [ğŸ”„ Strategi Retry Lanjutan](#1ï¸âƒ£-strategi-retry-lanjutan-ğŸ”„)
2. [ğŸš¦ API Rate Limiting & Throttling](#2ï¸âƒ£-api-rate-limiting--throttling-ğŸš¦)
3. [ğŸ’¾ Cache-Control Headers](#3ï¸âƒ£-cache-control-headers-ğŸ’¾)
4. [ğŸ“¦ Request/Response Compression](#4ï¸âƒ£-requestresponse-compression-ğŸ“¦)
5. [â±ï¸ Request Timeout Configuration](#5ï¸âƒ£-request-timeout-configuration-â±ï¸)
6. [ğŸ”— Connection Pooling](#6ï¸âƒ£-connection-pooling-ğŸ”—)
7. [ğŸ” Certificate Pinning](#7ï¸âƒ£-certificate-pinning-ğŸ”)
8. [ğŸ¯ Request Prioritization](#8ï¸âƒ£-request-prioritization-ğŸ¯)
9. [ğŸ“¦ Batching Requests](#9ï¸âƒ£-batching-requests-ğŸ“¦)
10. [ğŸ“¡ WebSocket untuk Real-Time Updates](#1ï¸âƒ£0ï¸âƒ£-websocket-untuk-real-time-updates-ğŸ“¡)
11. [ğŸ“Š Network Monitoring](#1ï¸âƒ£1ï¸âƒ£-network-monitoring-ğŸ“Š)
12. [ğŸ”¢ API Versioning Strategies](#1ï¸âƒ£2ï¸âƒ£-api-versioning-strategies-ğŸ”¢)
13. [ğŸ“ˆ Performance Monitoring](#1ï¸âƒ£3ï¸âƒ£-performance-monitoring-ğŸ“ˆ)
14. [âš¡ Circuit Breaker Pattern](#1ï¸âƒ£4ï¸âƒ£-circuit-breaker-pattern-âš¡)
15. [âœ¨ Best Practices](#1ï¸âƒ£5ï¸âƒ£-best-practices-âœ¨)
16. [ğŸ”¨ Hands-on Project](#1ï¸âƒ£6ï¸âƒ£-hands-on-project-ğŸ”¨)
17. [ğŸ¯ Kesimpulan](#ğŸ¯-kesimpulan)

---

## 1ï¸âƒ£ Strategi Retry Lanjutan ğŸ”„

### Konsep Dasar
Strategi Retry Lanjutan seperti strategi pengiriman ulang paket ğŸ”„ - jika penerima tidak ada, coba lagi dengan jeda waktu yang semakin lama untuk menghindari kemacetan!

### Exponential Backoff:
```kotlin
suspend fun <T> retryWithExponentialBackoff(
    maxRetries: Int = 3,
    initialDelayMillis: Long = 1000,
    maxDelayMillis: Long = 32000,
    factor: Double = 2.0,
    shouldRetry: (Exception) -> Boolean = { true },
    block: suspend () -> T
): T {
    var currentDelay = initialDelayMillis
    var lastException: Exception? = null
    
    repeat(maxRetries) { attempt ->
        try {
            return block()
        } catch (e: Exception) {
            lastException = e
            
            // Check if we should retry this error
            if (!shouldRetry(e) || attempt == maxRetries - 1) {
                throw e
            }
            
            Log.d("Retry", "Attempt ${attempt + 1} failed. Retrying in ${currentDelay}ms")
            delay(currentDelay)
            
            // Exponential backoff with jitter
            currentDelay = (currentDelay * factor).toLong()
                .coerceAtMost(maxDelayMillis)
                .let { it + Random.nextLong(0, it / 10) } // Add jitter
        }
    }
    
    throw lastException ?: Exception("Max retries exceeded")
}

// Usage
val data = retryWithExponentialBackoff(
    maxRetries = 5,
    shouldRetry = { it is IOException || (it is HttpException && it.code() >= 500) }
) {
    apiService.getData()
}
```

### Retry Interceptor:
```kotlin
class RetryInterceptor(
    private val maxRetries: Int = 3
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        var response: Response? = null
        var exception: IOException? = null
        
        repeat(maxRetries) { attempt ->
            try {
                response?.close()
                response = chain.proceed(request)
                
                // Retry on server errors (5xx)
                if (response!!.isSuccessful || response!!.code() < 500) {
                    return response!!
                }
            } catch (e: IOException) {
                exception = e
                Log.w("RetryInterceptor", "Request failed, attempt ${attempt + 1}: ${e.message}")
            }
            
            if (attempt < maxRetries - 1) {
                Thread.sleep(1000L * (attempt + 1)) // Linear backoff
            }
        }
        
        // All retries failed
        throw exception ?: IOException("Max retries exceeded")
    }
}

// Add to OkHttp
val client = OkHttpClient.Builder()
    .addInterceptor(RetryInterceptor(maxRetries = 3))
    .build()
```

### ğŸ“ Penjelasan Konsep:
**Strategi Retry Lanjutan seperti Strategi Pengiriman Ulang Paket:**
- **Exponential Backoff**: Menunggu lebih lama setiap kali mencoba lagi
- **Jitter**: Menambahkan variasi waktu untuk menghindari thundering herd
- **Conditional Retry**: Mencoba lagi hanya untuk error tertentu
- **Interceptor**: Menangani retry di level network

**Keunggulan Exponential Backoff:**
- **Server Load**: Mengurangi beban server yang sedang bermasalah
- **Success Rate**: Meningkatkan kemungkinan keberhasilan
- **Efficiency**: Menghindari percobaan yang sia-sia
- **Adaptability**: Menyesuaikan dengan kondisi jaringan

**Best Practices:**
- Gunakan exponential backoff untuk retry
- Tambahkan jitter untuk menghindari thundering herd
- Retry hanya untuk error yang mungkin berhasil
- Batasi jumlah percobaan
- Log setiap percobaan untuk debugging

---

## 2ï¸âƒ£ API Rate Limiting & Throttling ğŸš¦

### Konsep Dasar
API Rate Limiting & Throttling seperti pengaturan lalu lintas di jalan tol ğŸš¦ - membatasi jumlah kendaraan yang masuk untuk menghindari kemacetan!

### Client-Side Rate Limiting:
```kotlin
class RateLimiter(
    private val maxRequests: Int,
    private val timeWindowMillis: Long
) {
    private val timestamps = mutableListOf<Long>()
    
    @Synchronized
    suspend fun acquire() {
        val now = System.currentTimeMillis()
        
        // Remove old timestamps
        timestamps.removeAll { now - it > timeWindowMillis }
        
        if (timestamps.size >= maxRequests) {
            val oldestTimestamp = timestamps.first()
            val waitTime = timeWindowMillis - (now - oldestTimestamp)
            delay(waitTime)
            acquire() // Try again
        } else {
            timestamps.add(now)
        }
    }
}

// Usage
class ApiClient {
    private val rateLimiter = RateLimiter(
        maxRequests = 10,
        timeWindowMillis = 60_000 // 10 requests per minute
    )
    
    suspend fun makeRequest() {
        rateLimiter.acquire()
        // Make API call
    }
}
```

### Throttling Interceptor:
```kotlin
class ThrottlingInterceptor(
    private val minIntervalMillis: Long = 1000
) : Interceptor {
    private var lastRequestTime: Long = 0
    
    @Synchronized
    override fun intercept(chain: Interceptor.Chain): Response {
        val now = System.currentTimeMillis()
        val timeSinceLastRequest = now - lastRequestTime
        
        if (timeSinceLastRequest < minIntervalMillis) {
            val sleepTime = minIntervalMillis - timeSinceLastRequest
            Thread.sleep(sleepTime)
        }
        
        lastRequestTime = System.currentTimeMillis()
        return chain.proceed(chain.request())
    }
}
```

### Handling 429 (Too Many Requests):
```kotlin
class RateLimitInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        var response = chain.proceed(chain.request())
        
        var retryCount = 0
        while (response.code() == 429 && retryCount < 3) {
            response.close()
            
            // Check for Retry-After header
            val retryAfter = response.header("Retry-After")?.toLongOrNull() ?: 60
            
            Log.d("RateLimit", "Rate limited. Retrying after $retryAfter seconds")
            Thread.sleep(retryAfter * 1000)
            
            response = chain.proceed(chain.request())
            retryCount++
        }
        
        return response
    }
}
```

### ğŸ“ Penjelasan Konsep:
**API Rate Limiting & Throttling seperti Pengaturan Lalu Lintas di Jalan Tol:**
- **Rate Limiting**: Membatasi jumlah kendaraan per periode waktu
- **Throttling**: Menjaga jarak minimum antar kendaraan
- **429 Handling**: Mengikuti petunjuk rambu lalu lintas saat macet
- **Client-Side**: Mengatur laju pengiriman dari sisi pengirim

**Strategi Rate Limiting:**
1. Tentukan batas permintaan per periode waktu
2. Lacak timestamp setiap permintaan
3. Tunggu jika batas terlampaui
4. Ikuti petunjuk Retry-After dari server
5. Implementasikan backoff saat rate limited

**Best Practices:**
- Gunakan rate limiting untuk menghindari blocking dari server
- Ikuti petunjuk Retry-After dari server
- Implementasikan throttling untuk permintaan berurutan
- Lacak rate limit status untuk debugging
- Pertimbangkan untuk menggunakan exponential backoff

---

## 3ï¸âƒ£ Cache-Control Headers ğŸ’¾

### Konsep Dasar
Cache-Control Headers seperti gudang penyimpanan barang ğŸ’¾ - menyimpan barang yang sering diminta di dekat pelanggan untuk pengiriman yang lebih cepat!

### HTTP Caching Basics:
```
Cache-Control: no-cache, no-store, must-revalidate
Cache-Control: public, max-age=3600
Cache-Control: private, max-age=0
Cache-Control: max-age=86400, stale-while-revalidate=86400
```

### Implementing Cache Strategy:
```kotlin
class CacheInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        
        // Force cache when offline
        val newRequest = if (!isNetworkAvailable()) {
            request.newBuilder()
                .header("Cache-Control", "public, only-if-cached, max-stale=86400")
                .build()
        } else {
            request
        }
        
        val response = chain.proceed(newRequest)
        
        // Cache response for 1 hour when online
        return if (isNetworkAvailable()) {
            response.newBuilder()
                .header("Cache-Control", "public, max-age=3600")
                .removeHeader("Pragma")
                .build()
        } else {
            response
        }
    }
}

// Setup cache
val cacheSize = 10 * 1024 * 1024 // 10 MB
val cache = Cache(context.cacheDir, cacheSize.toLong())

val okHttpClient = OkHttpClient.Builder()
    .cache(cache)
    .addInterceptor(CacheInterceptor())
    .build()
```

### Conditional Requests (ETag):
```kotlin
class ConditionalCacheInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        
        // Check if we have a cached response with ETag
        val cachedResponse = chain.proceed(request.newBuilder().build())
        val etag = cachedResponse.header("ETag")
        
        return if (etag != null) {
            // Make conditional request
            val conditionalRequest = request.newBuilder()
                .header("If-None-Match", etag)
                .build()
            
            val newResponse = chain.proceed(conditionalRequest)
            
            if (newResponse.code() == 304) {
                // Not modified, use cached response
                cachedResponse.newBuilder()
                    .request(conditionalRequest)
                    .build()
            } else {
                newResponse
            }
        } else {
            cachedResponse
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Cache-Control Headers seperti Gudang Penyimpanan Barang:**
- **Cache**: Gudang penyimpanan barang
- **Cache-Control**: Aturan penyimpanan dan pengambilan barang
- **ETag**: Label unik untuk setiap barang
- **Conditional Request**: Memeriksa apakah barang masih segar sebelum mengambil

**Strategi Caching:**
1. Tentukan kebijakan cache (public/private, max-age)
2. Gunakan cache saat offline
3. Implementasikan conditional request dengan ETag
4. Konfigurasikan ukuran cache yang sesuai
5. Bersihkan cache secara berkala

**Best Practices:**
- Gunakan cache untuk data yang tidak sering berubah
- Konfigurasikan cache-control headers dengan benar
- Implementasikan conditional request untuk menghemat bandwidth
- Gunakan cache yang lebih besar untuk aplikasi offline-first
- Pertimbangkan untuk menggunakan stale-while-revalidate

---

## 4ï¸âƒ£ Request/Response Compression ğŸ“¦

### Konsep Dasar
Request/Response Compression seperti mengemas barang dengan vakum ğŸ“¦ - mengurangi ukuran paket untuk pengiriman yang lebih cepat dan hemat biaya!

### GZIP Compression:
```kotlin
class GzipRequestInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val originalRequest = chain.request()
        
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest)
        }
        
        val compressedRequest = originalRequest.newBuilder()
            .header("Content-Encoding", "gzip")
            .method(originalRequest.method(), gzip(originalRequest.body()!!))
            .build()
        
        return chain.proceed(compressedRequest)
    }
    
    private fun gzip(body: RequestBody): RequestBody {
        return object : RequestBody() {
            override fun contentType() = body.contentType()
            
            override fun contentLength() = -1L // Unknown
            
            override fun writeTo(sink: BufferedSink) {
                val gzipSink = GzipSink(sink).buffer()
                body.writeTo(gzipSink)
                gzipSink.close()
            }
        }
    }
}

// OkHttp automatically handles GZIP response decompression
```

### ğŸ“ Penjelasan Konsep:
**Request/Response Compression seperti Mengemas Barang dengan Vakum:**
- **Compression**: Mengemas barang untuk mengurangi ukuran
- **GZIP**: Metode pengemasan yang umum digunakan
- **Request Body**: Barang yang dikirim
- **Response Body**: Barang yang diterima

**Keunggulan Compression:**
- **Bandwidth**: Menghemat penggunaan bandwidth
- **Speed**: Mempercepat transfer data
- **Cost**: Mengurangi biaya penggunaan data
- **Performance**: Meningkatkan performa aplikasi

**Best Practices:**
- Gunakan GZIP untuk request dan response
- Kompresi hanya untuk data yang besar
- Hindari kompresi untuk data yang sudah terkompresi
- Pertimbangkan untuk menggunakan kompresi di level aplikasi
- Monitor pengaruh kompresi terhadap performa

---

## 5ï¸âƒ£ Request Timeout Configuration â±ï¸

### Konsep Dasar
Request Timeout Configuration seperti batas waktu pengiriman paket â±ï¸ - menentukan berapa lama menunggu sebelum menganggap pengiriman gagal!

### Timeout Configuration:
```kotlin
val okHttpClient = OkHttpClient.Builder()
    .connectTimeout(30, TimeUnit.SECONDS)    // Connection timeout
    .readTimeout(30, TimeUnit.SECONDS)       // Read timeout
    .writeTimeout(30, TimeUnit.SECONDS)      // Write timeout
    .callTimeout(60, TimeUnit.SECONDS)       // Overall timeout
    .build()
```

### Per-Request Timeout:
```kotlin
interface ApiService {
    @GET("users")
    suspend fun getUsers(): List<User>
    
    @GET("large-data")
    suspend fun getLargeData(): Data
}

// In repository
suspend fun getLargeData(): Data {
    return withTimeout(120_000) { // 2 minutes
        apiService.getLargeData()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Request Timeout Configuration seperti Batas Waktu Pengiriman Paket:**
- **Connect Timeout**: Batas waktu untuk membuat koneksi
- **Read Timeout**: Batas waktu untuk membaca data
- **Write Timeout**: Batas waktu untuk menulis data
- **Call Timeout**: Batas waktu total untuk panggilan

**Strategi Timeout:**
1. Tentukan timeout yang sesuai untuk setiap jenis operasi
2. Gunakan timeout yang lebih lama untuk operasi yang besar
3. Implementasikan timeout per-request jika perlu
4. Tangani timeout exception dengan baik
5. Pertimbangkan untuk menggunakan retry dengan timeout

**Best Practices:**
- Konfigurasikan timeout yang sesuai dengan kebutuhan
- Gunakan timeout yang lebih lama untuk operasi yang besar
- Tangani timeout exception dengan baik
- Implementasikan retry dengan timeout
- Monitor timeout untuk optimasi

---

## 6ï¸âƒ£ Connection Pooling ğŸ”—

### Konsep Dasar
Connection Pooling seperti armada truk pengiriman ğŸ”— - menyediakan truk yang siap digunakan untuk menghindari waktu persiapan setiap pengiriman!

### Connection Pooling:
```kotlin
val connectionPool = ConnectionPool(
    maxIdleConnections = 5,
    keepAliveDuration = 5,
    timeUnit = TimeUnit.MINUTES
)

val okHttpClient = OkHttpClient.Builder()
    .connectionPool(connectionPool)
    .build()
```

### ğŸ“ Penjelasan Konsep:
**Connection Pooling seperti Armada Truk Pengiriman:**
- **Connection Pool**: Armada truk yang siap digunakan
- **Max Idle Connections**: Jumlah truk yang siap digunakan
- **Keep Alive Duration**: Lama truk tetap siap digunakan
- **Reuse**: Menggunakan truk yang sudah ada

**Keunggulan Connection Pooling:**
- **Performance**: Mengurangi waktu pembuatan koneksi
- **Resource**: Menghemat penggunaan sumber daya
- **Latency**: Mengurangi latensi koneksi
- **Efficiency**: Meningkatkan efisiensi penggunaan koneksi

**Best Practices:**
- Konfigurasikan jumlah koneksi yang sesuai
- Tentukan keep-alive duration yang optimal
- Monitor penggunaan connection pool
- Pertimbangkan untuk menggunakan connection pooling untuk aplikasi yang banyak permintaan
- Tutup koneksi yang tidak digunakan

---

## 7ï¸âƒ£ Certificate Pinning ğŸ”

### Konsep Dasar
Certificate Pinning seperti daftar identitas resmi pengemudi ğŸ” - memastikan hanya pengemudi terverifikasi yang boleh masuk!

### Certificate Pinning:
```kotlin
val certificatePinner = CertificatePinner.Builder()
    .add("api.example.com", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
    .add("api.example.com", "sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=")
    .build()

val okHttpClient = OkHttpClient.Builder()
    .certificatePinner(certificatePinner)
    .build()
```

### ğŸ“ Penjelasan Konsep:
**Certificate Pinning seperti Daftar Identitas Resmi Pengemudi:**
- **Certificate**: Identitas resmi server
- **Certificate Pinning**: Mencocokkan identitas dengan daftar yang disetujui
- **SHA-256**: Sidik jari sertifikat
- **Security**: Meningkatkan keamanan koneksi

**Keunggulan Certificate Pinning:**
- **Security**: Mencegah man-in-the-middle attacks
- **Trust**: Memastikan koneksi ke server yang benar
- **Integrity**: Memverifikasi integritas sertifikat
- **Control**: Memberikan kontrol atas koneksi yang diizinkan

**Best Practices:**
- Gunakan certificate pinning untuk aplikasi yang sensitif
- Pin sertifikat root atau intermediate
- Perbarui pin sertifikat secara berkala
- Tangani certificate pinning failure dengan baik
- Pertimbangkan untuk menggunakan certificate pinning dengan backup

---

## 8ï¸âƒ£ Request Prioritization ğŸ¯

### Konsep Dasar
Request Prioritization seperti jalur cepat di jalan tol ğŸ¯ - memberikan prioritas kepada kendaraan penting untuk lewat lebih dulu!

### Request Prioritization:
```kotlin
enum class Priority {
    LOW, NORMAL, HIGH, IMMEDIATE
}

class PriorityInterceptor : Interceptor {
    private val requestQueue = PriorityQueue<QueuedRequest>(
        compareByDescending { it.priority }
    )
    
    override fun intercept(chain: Interceptor.Chain): Response {
        val priority = chain.request().tag(Priority::class.java) ?: Priority.NORMAL
        
        // Add to queue and process based on priority
        // Implementation details...
        
        return chain.proceed(chain.request())
    }
}

// Usage
@GET("users")
@Tag(Priority.HIGH)
suspend fun getUsers(): List<User>
```

### ğŸ“ Penjelasan Konsep:
**Request Prioritization seperti Jalur Cepat di Jalan Tol:**
- **Priority**: Tingkat kepentingan permintaan
- **Queue**: Antrian permintaan berdasarkan prioritas
- **Processing**: Memproses permintaan berdasarkan prioritas
- **Tag**: Menandai permintaan dengan prioritas

**Strategi Prioritization:**
1. Tentukan tingkat prioritas untuk permintaan
2. Gunakan tag untuk menandai prioritas
3. Implementasikan antrian prioritas
4. Proses permintaan berdasarkan prioritas
5. Pertimbangkan untuk menggunakan thread pool dengan prioritas

**Best Practices:**
- Gunakan prioritas untuk permintaan yang kritis
- Jangan menyalahgunakan prioritas tinggi
- Implementasikan antrian prioritas dengan benar
- Monitor performa antrian prioritas
- Pertimbangkan untuk menggunakan thread pool dengan prioritas

---

## 9ï¸âƒ£ Batching Requests ğŸ“¦

### Konsep Dasar
Batching Requests seperti pengiriman paket grosir ğŸ“¦ - mengumpulkan beberapa permintaan ke dalam satu pengiriman untuk efisiensi!

### Batching Requests:
```kotlin
class RequestBatcher(
    private val batchSize: Int = 10,
    private val maxWaitMillis: Long = 1000
) {
    private val pendingRequests = mutableListOf<suspend () -> Unit>()
    private var lastBatchTime = System.currentTimeMillis()
    
    suspend fun addRequest(request: suspend () -> Unit) {
        pendingRequests.add(request)
        
        if (pendingRequests.size >= batchSize || 
            System.currentTimeMillis() - lastBatchTime >= maxWaitMillis) {
            executeBatch()
        }
    }
    
    private suspend fun executeBatch() {
        val batch = pendingRequests.toList()
        pendingRequests.clear()
        lastBatchTime = System.currentTimeMillis()
        
        // Execute all requests in parallel
        coroutineScope {
            batch.forEach { request ->
                launch { request() }
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Batching Requests seperti Pengiriman Paket Grosir:**
- **Batch**: Kumpulan permintaan
- **Batch Size**: Jumlah permintaan per batch
- **Max Wait Time**: Waktu maksimal menunggu batch
- **Parallel Execution**: Eksekusi paralel untuk batch

**Keunggulan Batching:**
- **Efficiency**: Mengurangi jumlah permintaan
- **Performance**: Meningkatkan performa aplikasi
- **Network**: Menghemat penggunaan jaringan
- **Latency**: Mengurangi latensi total

**Best Practices:**
- Tentukan ukuran batch yang optimal
- Gunakan batching untuk permintaan yang tidak urgent
- Implementasikan batas waktu maksimal untuk batch
- Eksekusi batch secara paralel
- Monitor performa batching

---

## 1ï¸âƒ£0ï¸âƒ£ WebSocket untuk Real-Time Updates ğŸ“¡

### Konsep Dasar
WebSocket seperti saluran komunikasi dua arah yang selalu terbuka ğŸ“¡ - memungkinkan komunikasi instan antara klien dan server!

### WebSocket:
```kotlin
val request = Request.Builder()
    .url("wss://api.example.com/ws")
    .build()

val webSocket = okHttpClient.newWebSocket(request, object : WebSocketListener() {
    override fun onOpen(webSocket: WebSocket, response: Response) {
        webSocket.send("Hello, Server!")
    }
    
    override fun onMessage(webSocket: WebSocket, text: String) {
        Log.d("WebSocket", "Received: $text")
    }
    
    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
        Log.e("WebSocket", "Error: ${t.message}")
    }
})
```

### ğŸ“ Penjelasan Konsep:
**WebSocket seperti Saluran Komunikasi Dua Arah:**
- **Connection**: Koneksi persisten antara klien dan server
- **Two-Way Communication**: Komunikasi dua arah
- **Real-Time**: Pembaruan real-time
- **Low Latency**: Latensi rendah

**Keunggulan WebSocket:**
- **Real-Time**: Pembaruan real-time tanpa polling
- **Efficiency**: Efisien dalam penggunaan sumber daya
- **Low Latency**: Latensi rendah untuk komunikasi
- **Bi-Directional**: Komunikasi dua arah

**Best Practices:**
- Gunakan WebSocket untuk pembaruan real-time
- Implementasikan mekanisme reconnection
- Tangani error dengan baik
- Tutup koneksi WebSocket saat tidak digunakan
- Pertimbangkan untuk menggunakan heartbeat untuk menjaga koneksi

---

## 1ï¸âƒ£1ï¸âƒ£ Network Monitoring ğŸ“Š

### Konsep Dasar
Network Monitoring seperti pusat kontrol lalu lintas ğŸ“Š - memantau kondisi jaringan untuk mengidentifikasi masalah dan mengoptimalkan performa!

### Network Monitoring:
```kotlin
class NetworkMonitor(context: Context) {
    private val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) 
        as ConnectivityManager
    
    private val _networkState = MutableStateFlow(NetworkState.UNKNOWN)
    val networkState: StateFlow<NetworkState> = _networkState.asStateFlow()
    
    init {
        val networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                _networkState.value = NetworkState.AVAILABLE
            }
            
            override fun onLost(network: Network) {
                _networkState.value = NetworkState.LOST
            }
        }
        
        connectivityManager.registerDefaultNetworkCallback(networkCallback)
    }
}

enum class NetworkState {
    UNKNOWN, AVAILABLE, LOST
}
```

### ğŸ“ Penjelasan Konsep:
**Network Monitoring seperti Pusat Kontrol Lalu Lintas:**
- **ConnectivityManager**: Manajer konektivitas
- **NetworkCallback**: Callback untuk perubahan jaringan
- **NetworkState**: Status jaringan
- **Monitoring**: Pemantauan kondisi jaringan

**Strategi Monitoring:**
1. Daftarkan network callback
2. Pantau perubahan status jaringan
3. Tangani perubahan status jaringan
4. Implementasikan fallback untuk offline
5. Monitor performa jaringan

**Best Practices:**
- Monitor status jaringan secara real-time
- Implementasikan fallback untuk offline
- Gunakan StateFlow untuk state yang observable
- Tangani perubahan status jaringan dengan baik
- Monitor performa jaringan untuk optimasi

---

## 1ï¸âƒ£2ï¸âƒ£ API Versioning Strategies ğŸ”¢

### Konsep Dasar
API Versioning seperti versi peta kota ğŸ”¢ - menyediakan versi peta yang berbeda saat tata letak kota berubah!

### URL Versioning:
```kotlin
/api/v1/users
/api/v2/users
```

### Header Versioning:
```kotlin
class VersionInterceptor(private val version: String) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request().newBuilder()
            .header("API-Version", version)
            .build()
        return chain.proceed(request)
    }
}
```

### ğŸ“ Penjelasan Konsep:
**API Versioning seperti Versi Peta Kota:**
- **Version**: Versi API
- **URL Versioning**: Versi di URL
- **Header Versioning**: Versi di header
- **Compatibility**: Kompatibilitas antar versi

**Strategi Versioning:**
1. Tentukan strategi versioning
2. Gunakan versioning di URL atau header
3. Pertahankan kompatibilitas dengan versi lama
4. Deprecasi versi lama secara bertahap
5. Dokumentasikan perubahan versi

**Best Practices:**
- Gunakan versioning untuk perubahan yang breaking
- Pertahankan kompatibilitas dengan versi lama
- Deprecasi versi lama secara bertahap
- Dokumentasikan perubahan versi
- Pertimbangkan untuk menggunakan versioning di URL

---

## 1ï¸âƒ£3ï¸âƒ£ Performance Monitoring ğŸ“ˆ

### Konsep Dasar
Performance Monitoring seperti GPS pelacak pengiriman ğŸ“ˆ - mencatat waktu tempuh untuk setiap rute untuk optimasi!

### Performance Monitoring:
```kotlin
class PerformanceInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val startTime = System.currentTimeMillis()
        
        val response = chain.proceed(request)
        
        val duration = System.currentTimeMillis() - startTime
        Log.d("Performance", "${request.url()} took ${duration}ms")
        
        // Send to analytics
        Analytics.logNetworkRequest(request.url().toString(), duration)
        
        return response
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Performance Monitoring seperti GPS Pelacak Pengiriman:**
- **Interceptor**: Interceptor untuk monitoring
- **Start Time**: Waktu mulai
- **Duration**: Durasi permintaan
- **Analytics**: Pengiriman data ke analytics

**Strategi Monitoring:**
1. Implementasikan interceptor untuk monitoring
2. Catat waktu mulai dan durasi
3. Kirim data ke analytics
4. Analisis data untuk optimasi
5. Monitor performa secara berkala

**Best Practices:**
- Monitor performa semua permintaan
- Kirim data ke analytics untuk analisis
- Gunakan data untuk optimasi
- Monitor performa secara berkala
- Pertimbangkan untuk menggunakan monitoring tools

---

## 1ï¸âƒ£4ï¸âƒ£ Circuit Breaker Pattern âš¡

### Konsep Dasar
Circuit Breaker Pattern seperti saklar otomatis listrik âš¡ - memutus aliran saat terjadi lonjakan untuk mencegah kerusakan!

### Circuit Breaker:
```kotlin
class CircuitBreaker(
    private val failureThreshold: Int = 5,
    private val timeoutMillis: Long = 60000
) {
    private var failureCount = 0
    private var lastFailureTime: Long = 0
    private var state = State.CLOSED
    
    enum class State { CLOSED, OPEN, HALF_OPEN }
    
    suspend fun <T> execute(block: suspend () -> T): T {
        when (state) {
            State.OPEN -> {
                if (System.currentTimeMillis() - lastFailureTime > timeoutMillis) {
                    state = State.HALF_OPEN
                } else {
                    throw CircuitBreakerOpenException()
                }
            }
            State.HALF_OPEN, State.CLOSED -> {}
        }
        
        return try {
            val result = block()
            onSuccess()
            result
        } catch (e: Exception) {
            onFailure()
            throw e
        }
    }

    private fun onSuccess() {
        failureCount = 0
        state = State.CLOSED
    }
    
    private fun onFailure() {
        failureCount++
        lastFailureTime = System.currentTimeMillis()
        if (failureCount >= failureThreshold) {
            state = State.OPEN
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Circuit Breaker Pattern seperti Saklar Otomatis Listrik:**
- **State**: Status circuit breaker (CLOSED, OPEN, HALF_OPEN)
- **Failure Threshold**: Batas kegagalan
- **Timeout**: Waktu tunggu sebelum mencoba lagi
- **Execution**: Eksekusi dengan perlindungan

**Strategi Circuit Breaker:**
1. Tentukan failure threshold
2. Implementasikan state management
3. Gunakan timeout untuk recovery
4. Eksekusi dengan perlindungan
5. Monitor status circuit breaker

**Best Practices:**
- Gunakan circuit breaker untuk layanan eksternal
- Tentukan failure threshold yang sesuai
- Implementasikan timeout untuk recovery
- Monitor status circuit breaker
- Gunakan circuit breaker dengan retry

---

## 1ï¸âƒ£5ï¸âƒ£ Best Practices âœ¨

### Konsep Dasar
Best Practices seperti buku panduan master âœ¨ - kumpulan aturan dan teknik yang telah terbukti efektif!

### Daftar Best Practices:
- âœ… Implement exponential backoff untuk retry
- âœ… Gunakan rate limiting untuk avoid API abuse
- âœ… Cache responses appropriately
- âœ… Monitor network performance
- âœ… Handle offline scenarios gracefully
- âœ… Compress large payloads
- âœ… Configure timeouts properly
- âœ… Use connection pooling
- âœ… Implement circuit breaker untuk resilience
- âœ… Log network metrics

### ğŸ“ Penjelasan Konsep:
**Best Practices seperti Buku Panduan Master:**
- **Retry**: Strategi percobaan kembali
- **Rate Limiting**: Pembatasan laju permintaan
- **Caching**: Penyimpanan sementara
- **Monitoring**: Pemantauan performa
- **Offline**: Penanganan skenario offline
- **Compression**: Kompresi data
- **Timeouts**: Konfigurasi timeout
- **Connection Pooling**: Pool koneksi
- **Circuit Breaker**: Perlindungan dari kegagalan
- **Logging**: Pencatatan metrik

**Prinsip Best Practices:**
1. Prioritaskan pengalaman pengguna
2. Optimalkan penggunaan sumber daya
3. Tangani error dengan baik
4. Monitor performa secara berkala
5. Implementasikan fallback mechanism

---

## 1ï¸âƒ£6ï¸âƒ£ Hands-on Project ğŸ”¨

### Konsep Dasar
Hands-on Project seperti proyek konstruksi nyata ğŸ”¨ - menerapkan semua teori dalam sebuah aplikasi yang fungsional!

### Daftar Proyek:
- Implement retry with exponential backoff
- Create rate limiting system
- Setup caching strategy
- Build network monitor
- Performance tracking
- Integration dengan real API

### ğŸ“ Penjelasan Konsep:
**Hands-on Project seperti Proyek Konstruksi Nyata:**
- **Retry**: Implementasi retry dengan exponential backoff
- **Rate Limiting**: Sistem pembatasan laju
- **Caching**: Strategi caching
- **Monitor**: Pemantauan jaringan
- **Performance**: Pelacakan performa
- **Integration**: Integrasi dengan API nyata

**Langkah Proyek:**
1. Pilih topik yang ingin diimplementasikan
2. Buat proyek baru atau tambahkan ke proyek existing
3. Implementasikan fitur yang dipilih
4. Test dengan berbagai skenario
5. Dokumentasikan hasil dan pembelajaran

---

## ğŸ¯ Kesimpulan

### ğŸŒŸ Apa yang Telah Kita Pelajari:
Kita telah menjelajahi dunia Advanced Networking, dari strategi retry hingga monitoring performa:

1. **Strategi Retry Lanjutan**: Menguasai exponential backoff dan retry interceptor
2. **API Rate Limiting & Throttling**: Memahami pembatasan laju permintaan
3. **Cache-Control Headers**: Mengimplementasikan strategi caching
4. **Request/Response Compression**: Mengompresi data untuk efisiensi
5. **Request Timeout Configuration**: Mengkonfigurasi timeout yang sesuai
6. **Connection Pooling**: Mengoptimalkan penggunaan koneksi
7. **Certificate Pinning**: Meningkatkan keamanan koneksi
8. **Request Prioritization**: Memberikan prioritas pada permintaan penting
9. **Batching Requests**: Mengumpulkan permintaan untuk efisiensi
10. **WebSocket untuk Real-Time Updates**: Mengimplementasikan komunikasi real-time
11. **Network Monitoring**: Memantau kondisi jaringan
12. **API Versioning Strategies**: Mengelola versi API
13. **Performance Monitoring**: Memantau performa jaringan
14. **Circuit Breaker Pattern**: Melindungi dari kegagalan layanan
15. **Best Practices**: Mengikuti praktik terbaik untuk jaringan yang andal
16. **Hands-on Project**: Menerapkan semua teori dalam proyek nyata

### ğŸš€ Langkah Selanjutnya:
Setelah memahami Advanced Networking, Anda siap untuk:

1. **Menerapkan di Proyek Nyata**: Menggunakan semua konsep dalam aplikasi yang sebenarnya
2. **Mengoptimalkan Performa**: Mengoptimalkan performa jaringan aplikasi
3. **Meningkatkan Keandalan**: Membuat aplikasi yang lebih andal
4. **Memonitor Produksi**: Memantau performa di lingkungan produksi
5. **Mengeksplorasi Teknologi Lanjutan**: Mempelajari teknologi jaringan yang lebih lanjut

### ğŸ¯ Tips untuk Menjadi Ahli Advanced Networking:
1. **Praktik Secara Rutin**: Terus menerapkan konsep dalam proyek
2. **Monitor Performa**: Selalu memantau performa jaringan
3. **Ikuti Best Practices**: Mengikuti praktik terbaik yang telah terbukti
4. **Tetap Update**: Mengikuti perkembangan teknologi jaringan
5. **Bagi Pengetahuan**: Membagikan pengetahuan dengan komunitas

Dengan pemahaman yang kuat tentang Advanced Networking, Anda sekarang memiliki fondasi yang kokoh untuk membangun aplikasi Android yang tangguh, efisien, andal, dan memberikan pengalaman pengguna yang luar biasa. Teruslah belajar dan berlatih, dan Anda akan menjadi ahli dalam Advanced Networking!