


## **7.10 WebView & Chrome Custom Tabs** (3 hari) ⭐⭐

### **Teknologi Modern:**
- WebView best practices
- Chrome Custom Tabs
- JavaScript Interface
- WebView security

### **Teknologi yang Ditinggalkan:**
- WebView tanpa security measures
- Unsecured JavaScript bridges

### **Sub-topik Detail:**

#### **1. WebView Basics**

**Setup WebView:**
```kotlin
class WebViewActivity : AppCompatActivity() {
    
    private lateinit var webView: WebView
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        webView = WebView(this).apply {
            settings.apply {
                javaScriptEnabled = true
                domStorageEnabled = true
                cacheMode = WebSettings.LOAD_DEFAULT
                mixedContentMode = WebSettings.MIXED_CONTENT_NEVER_ALLOW
            }
            
            webViewClient = MyWebViewClient()
            webChromeClient = MyWebChromeClient()
        }
        
        setContentView(webView)
        webView.loadUrl("https://example.com")
    }
    
    override fun onBackPressed() {
        if (webView.canGoBack()) {
            webView.goBack()
        } else {
            super.onBackPressed()
        }
    }
    
    override fun onDestroy() {
        webView.destroy()
        super.onDestroy()
    }
}
```

**WebViewClient:**
```kotlin
class MyWebViewClient : WebViewClient() {
    
    override fun shouldOverrideUrlLoading(
        view: WebView?,
        request: WebResourceRequest?
    ): Boolean {
        val url = request?.url?.toString() ?: return false
        
        return when {
            url.startsWith("http") -> {
                // Load in WebView
                false
            }
            url.startsWith("tel:") -> {
                // Handle phone call
                val intent = Intent(Intent.ACTION_DIAL, Uri.parse(url))
                view?.context?.startActivity(intent)
                true
            }
            else -> {
                // Handle other schemes
                true
            }
        }
    }
    
    override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
        super.onPageStarted(view, url, favicon)
        // Show loading
    }
    
    override fun onPageFinished(view: WebView?, url: String?) {
        super.onPageFinished(view, url)
        // Hide loading
    }
    
    override fun onReceivedError(
        view: WebView?,
        request: WebResourceRequest?,
        error: WebResourceError?
    ) {
        super.onReceivedError(view, request, error)
        // Handle error
    }
}
```

**WebChromeClient:**
```kotlin
class MyWebChromeClient : WebChromeClient() {
    
    override fun onProgressChanged(view: WebView?, newProgress: Int) {
        super.onProgressChanged(view, newProgress)
        // Update progress bar
    }
    
    override fun onReceivedTitle(view: WebView?, title: String?) {
        super.onReceivedTitle(view, title)
        // Update toolbar title
    }
    
    override fun onJsAlert(
        view: WebView?,
        url: String?,
        message: String?,
        result: JsResult?
    ): Boolean {
        // Handle JavaScript alert
        AlertDialog.Builder(view?.context!!)
            .setMessage(message)
            .setPositiveButton("OK") { _, _ ->
                result?.confirm()
            }
            .setCancelable(false)
            .create()
            .show()
        return true
    }
}
```

#### **2. JavaScript Interface**

**Secure JavaScript Bridge:**
```kotlin
class WebAppInterface(private val context: Context) {
    
    @JavascriptInterface
    fun showToast(message: String) {
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }
    
    @JavascriptInterface
    fun getUserData(): String {
        val user = getCurrentUser()
        return Gson().toJson(user)
    }
    
    @JavascriptInterface
    fun navigateToScreen(screenName: String) {
        (context as? Activity)?.runOnUiThread {
            // Navigate to native screen
        }
    }
}

// Setup
webView.addJavascriptInterface(WebAppInterface(this), "Android")

// JavaScript usage:
// Android.showToast("Hello from WebView");
// const userData = Android.getUserData();
```

**Calling JavaScript from Kotlin:**
```kotlin
// Execute JavaScript
webView.evaluateJavascript("javascript:myFunction()", null)

// Get result
webView.evaluateJavascript("javascript:getValue()") { result ->
    Log.d("WebView", "Result: $result")
}

// Complex interaction
webView.evaluateJavascript(
    """
    javascript:(function() {
        return document.getElementById('username').value;
    })()
    """.trimIndent()
) { value ->
    Log.d("WebView", "Username: $value")
}
```

#### **3. Chrome Custom Tabs**

**Basic Usage:**
```kotlin
class MainActivity : AppCompatActivity() {
    
    fun openUrl(url: String) {
        val builder = CustomTabsIntent.Builder()
            .setToolbarColor(ContextCompat.getColor(this, R.color.primary))
            .setShowTitle(true)
            .setStartAnimations(this, R.anim.slide_in_right, R.anim.slide_out_left)
            .setExitAnimations(this, R.anim.slide_in_left, R.anim.slide_out_right)
        
        val customTabsIntent = builder.build()
        customTabsIntent.launchUrl(this, Uri.parse(url))
    }
}
```

**With Custom Actions:**
```kotlin
fun openUrlWithActions(url: String) {
    // Share action
    val shareIntent = Intent(Intent.ACTION_SEND).apply {
        type = "text/plain"
        putExtra(Intent.EXTRA_TEXT, url)
    }
    val sharePendingIntent = PendingIntent.getActivity(
        this,
        0,
        Intent.createChooser(shareIntent, "Share via"),
        PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
    )
    
    val builder = CustomTabsIntent.Builder()
        .setToolbarColor(ContextCompat.getColor(this, R.color.primary))
        .setShowTitle(true)
        .setActionButton(
            BitmapFactory.decodeResource(resources, R.drawable.ic_share),
            "Share",
            sharePendingIntent,
            true
        )
        .addMenuItem("Copy Link") { _, uri ->
            val clipboard = getSystemService<ClipboardManager>()
            clipboard?.setPrimaryClip(ClipData.newPlainText("URL", uri.toString()))
            Toast.makeText(this, "Link copied", Toast.LENGTH_SHORT).show()
        }
    
    builder.build().launchUrl(this, Uri.parse(url))
}
```

**Pre-warming & Prefetching:**
```kotlin
class CustomTabsHelper(private val context: Context) {
    
    private var customTabsClient: CustomTabsClient? = null
    private var customTabsSession: CustomTabsSession? = null
    
    private val connection = object : CustomTabsServiceConnection() {
        override fun onCustomTabsServiceConnected(
            name: ComponentName,
            client: CustomTabsClient
        ) {
            customTabsClient = client
            client.warmup(0)
            customTabsSession = client.newSession(null)
        }
        
        override fun onServiceDisconnected(name: ComponentName?) {
            customTabsClient = null
            customTabsSession = null
        }
    }
    
    fun bindService() {
        val packageName = CustomTabsClient.getPackageName(context, null)
        if (packageName != null) {
            CustomTabsClient.bindCustomTabsService(context, packageName, connection)
        }
    }
    
    fun unbindService() {
        context.unbindService(connection)
    }
    
    fun mayLaunchUrl(url: String) {
        customTabsSession?.mayLaunchUrl(Uri.parse(url), null, null)
    }
    
    fun launchUrl(url: String) {
        val builder = CustomTabsIntent.Builder(customTabsSession)
            .setToolbarColor(ContextCompat.getColor(context, R.color.primary))
            .setShowTitle(true)
        
        builder.build().launchUrl(context, Uri.parse(url))
    }
}

// Usage
class MainActivity : AppCompatActivity() {
    private val customTabsHelper = CustomTabsHelper(this)
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        customTabsHelper.bindService()
        
        // Prefetch URL
        customTabsHelper.mayLaunchUrl("https://example.com")
    }
    
    override fun onDestroy() {
        customTabsHelper.unbindService()
        super.onDestroy()
    }
    
    fun openLink() {
        customTabsHelper.launchUrl("https://example.com")
    }
}
```

#### **4. WebView Security**

**Security Best Practices:**
```kotlin
class SecureWebViewActivity : AppCompatActivity() {
    
    private lateinit var webView: WebView
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        webView = WebView(this).apply {
            settings.apply {
                // JavaScript
                javaScriptEnabled = true  // Only if needed
                javaScriptCanOpenWindowsAutomatically = false
                
                // Storage
                domStorageEnabled = true
                databaseEnabled = false
                
                // Content
                allowContentAccess = false
                allowFileAccess = false
                allowFileAccessFromFileURLs = false
                allowUniversalAccessFromFileURLs = false
                
                // Security
                mixedContentMode = WebSettings.MIXED_CONTENT_NEVER_ALLOW
                
                // Privacy
                setSupportMultipleWindows(false)
                setGeolocationEnabled(false)
            }
            
            // Clear cache on exit
            clearCache(true)
            clearHistory()
        }
    }
    
    override fun onDestroy() {
        // Security cleanup
        webView.clearCache(true)
        webView.clearFormData()
        webView.clearHistory()
        webView.destroy()
        super.onDestroy()
    }
}
```

**SSL Error Handling:**
```kotlin
class SecureWebViewClient : WebViewClient() {
    
    override fun onReceivedSslError(
        view: WebView?,
        handler: SslErrorHandler?,
        error: SslError?
    ) {
        // DON'T call handler.proceed() in production!
        // Always reject SSL errors
        handler?.cancel()
        
        // Show error to user
        AlertDialog.Builder(view?.context!!)
            .setTitle("SSL Error")
            .setMessage("This site's security certificate is not trusted.")
            .setPositiveButton("Go Back") { _, _ ->
                view.goBack()
            }
            .show()
    }
    
    override fun onReceivedHttpAuthRequest(
        view: WebView?,
        handler: HttpAuthHandler?,
        host: String?,
        realm: String?
    ) {
        // Handle HTTP authentication
        // Show login dialog
    }
}
```

#### **5. Hands-on Exercises**
- Build simple browser dengan WebView
- Implement JavaScript bridge untuk native communication
- Create Chrome Custom Tabs integration
- Add WebView security measures
- Implement file download handling
- Build OAuth login dengan WebView
- Create web content caching strategy
- Implement deep linking dengan WebView

---
