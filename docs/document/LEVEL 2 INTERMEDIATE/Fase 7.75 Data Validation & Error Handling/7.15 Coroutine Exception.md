## **7.14 Coroutine Exception** (2 hari) ⭐⭐⭐

### **Teknologi Modern:**
- CoroutineExceptionHandler
- supervisorScope
- SupervisorJob
- try-catch in coroutines

### **Teknologi yang Ditinggalkan:**
- Swallowed exceptions
- Uncaught coroutine exceptions
- Silent failures

### **Sub-topik Detail:**

#### **1. Exception Propagation**

**Basic Exception Handling:**
```kotlin
viewModelScope.launch {
    try {
        val result = repository.fetchData()
        _uiState.value = UiState.Success(result)
    } catch (e: CancellationException) {
        // Don't catch cancellation
        throw e
    } catch (e: Exception) {
        _uiState.value = UiState.Error(e.message ?: "Unknown error")
    }
}
```

**Async Exception:**
```kotlin
viewModelScope.launch {
    try {
        val deferred = async { fetchData() }
        val result = deferred.await() // Exception thrown here
    } catch (e: Exception) {
        handleError(e)
    }
}
```

#### **2. CoroutineExceptionHandler**

**Global Handler:**
```kotlin
val exceptionHandler = CoroutineExceptionHandler { context, exception ->
    Timber.e(exception, "Coroutine exception in ${context[CoroutineName]}")
    FirebaseCrashlytics.getInstance().recordException(exception)
}

val scope = CoroutineScope(
    Dispatchers.Main + 
    SupervisorJob() + 
    exceptionHandler
)

scope.launch {
    throw Exception("This will be caught by handler")
}
```

**ViewModel Handler:**
```kotlin
class MyViewModel : ViewModel() {
    private val exceptionHandler = CoroutineExceptionHandler { _, exception ->
        _uiState.value = UiState.Error(exception.message ?: "Unknown error")
        Timber.e(exception)
    }
    
    fun loadData() {
        viewModelScope.launch(exceptionHandler) {
            val data = repository.getData()
            _uiState.value = UiState.Success(data)
        }
    }
}
```

#### **3. supervisorScope**

**Independent Children:**
```kotlin
suspend fun loadDashboard() {
    supervisorScope {
        val user = async {
            try {
                fetchUser()
            } catch (e: Exception) {
                Timber.e(e, "Failed to fetch user")
                null
            }
        }
        
        val posts = async {
            try {
                fetchPosts()
            } catch (e: Exception) {
                Timber.e(e, "Failed to fetch posts")
                emptyList()
            }
        }
        
        // Both can fail independently
        Dashboard(user.await(), posts.await())
    }
}
```

**Multiple API Calls:**
```kotlin
viewModelScope.launch {
    supervisorScope {
        launch {
            try {
                fetchUserData()
            } catch (e: Exception) {
                handleUserError(e)
            }
        }
        
        launch {
            try {
                fetchPosts()
            } catch (e: Exception) {
                handlePostsError(e)
            }
        }
    }
}
```

#### **4. SupervisorJob**

**Setup:**
```kotlin
class DataRepository {
    private val scope = CoroutineScope(
        SupervisorJob() + Dispatchers.IO
    )
    
    fun startPeriodicSync() {
        scope.launch {
            while (isActive) {
                try {
                    syncData()
                } catch (e: Exception) {
                    Timber.e(e, "Sync failed")
                }
                delay(60_000) // Continue despite errors
            }
        }
    }
}
```

#### **5. Exception Types**

**Network Exceptions:**
```kotlin
suspend fun fetchData(): Result<Data> {
    return try {
        val response = apiService.getData()
        Result.success(response)
    } catch (e: IOException) {
        Result.failure(NetworkException("No internet connection"))
    } catch (e: HttpException) {
        when (e.code()) {
            401 -> Result.failure(UnauthorizedException())
            404 -> Result.failure(NotFoundException())
            500 -> Result.failure(ServerException())
            else -> Result.failure(e)
        }
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

**Custom Exceptions:**
```kotlin
sealed class AppException(message: String) : Exception(message) {
    class NetworkException(message: String) : AppException(message)
    class AuthException(message: String) : AppException(message)
    class ValidationException(message: String) : AppException(message)
}

fun handleException(exception: Exception) {
    when (exception) {
        is AppException.NetworkException -> showNetworkError()
        is AppException.AuthException -> logout()
        is AppException.ValidationException -> showValidationError(exception.message)
        else -> showGenericError()
    }
}
```

#### **6. Cancellation Handling**

**Proper Cancellation:**
```kotlin
suspend fun doWork() {
    try {
        // Work
        processData()
    } catch (e: CancellationException) {
        // Cleanup
        cleanupResources()
        throw e // Must rethrow!
    } catch (e: Exception) {
        // Handle other exceptions
        handleError(e)
    }
}
```

**NonCancellable Context:**
```kotlin
val job = launch {
    try {
        workThatCanBeCancelled()
    } finally {
        withContext(NonCancellable) {
            cleanup() // Always runs
        }
    }
}
```

#### **7. Testing Exception Handling**

**Test Exceptions:**
```kotlin
@Test
fun `test exception handling`() = runTest {
    // Given
    val exception = IOException("Network error")
    coEvery { repository.getData() } throws exception
    
    // When
    viewModel.loadData()
    advanceUntilIdle()
    
    // Then
    val state = viewModel.uiState.value
    assertTrue(state is UiState.Error)
    assertEquals("Network error", (state as UiState.Error).message)
}
```

**Test Cancellation:**
```kotlin
@Test
fun `test cancellation`() = runTest {
    val job = launch {
        viewModel.loadData()
    }
    
    job.cancel()
    advanceUntilIdle()
    
    // Verify cleanup happened
    verify { repository.cancelRequests() }
}
```

#### **8. Best Practices**
✅ Always catch exceptions in coroutines
✅ Never catch CancellationException (or rethrow it)
✅ Use supervisorScope untuk independent tasks
✅ Set up CoroutineExceptionHandler
✅ Log all exceptions
✅ Provide user-friendly error messages
✅ Test exception scenarios
✅ Handle network timeouts

---
