## **7.1 Kotlin Coroutines** (1 minggu) ⭐⭐⭐

### **Teknologi Modern:**
- Coroutines
- suspend functions
- CoroutineScope
- Job
- Deferred

### **Teknologi yang Ditinggalkan:**
- AsyncTask
- Thread
- Handler
- RxJava (untuk simple async operations)

### **Sub-topik Detail:**

#### **1. Pengenalan Kotlin Coroutines**
- Apa itu Coroutines
- Lightweight threads
- Structured concurrency
- Keuntungan Coroutines vs Thread
- Coroutines vs Callbacks
- Sequential by default, async when needed

**Mengapa Coroutines:**
✅ Lightweight (dapat menjalankan ribuan coroutines)
✅ Mengurangi memory leaks
✅ Built-in cancellation support
✅ Exception handling yang lebih baik
✅ Sequential code untuk async operations
✅ Integrated dengan Jetpack libraries

#### **2. Setup Coroutines**

**Dependencies:**
```kotlin
dependencies {
    // Coroutines core
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
    
    // Lifecycle integration
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.6.2")
    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2")
    
    // Testing
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")
}
```

#### **3. Suspend Functions**

**Basic Suspend Function:**
```kotlin
suspend fun fetchUserData(userId: String): User {
    delay(1000) // Simulate network call
    return User(userId, "John Doe")
}

suspend fun loadData() {
    val user = fetchUserData("123") // Sequential execution
    println("User loaded: ${user.name}")
}
```

**Suspend Function dengan Error Handling:**
```kotlin
suspend fun fetchDataSafely(): Result<Data> {
    return try {
        val response = apiService.getData()
        Result.success(response)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

**Suspend Function Composition:**
```kotlin
suspend fun loadUserProfile(userId: String): UserProfile {
    val user = fetchUser(userId)
    val posts = fetchUserPosts(userId)
    val followers = fetchFollowers(userId)
    
    return UserProfile(user, posts, followers)
}
```

#### **4. Coroutine Builders**

**launch - Fire and Forget:**
```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Launch coroutine
        lifecycleScope.launch {
            val data = fetchData()
            updateUI(data)
        }
    }
}
```

**async/await - Return Result:**
```kotlin
suspend fun loadDashboard(): Dashboard {
    return coroutineScope {
        // Parallel execution
        val userData = async { fetchUserData() }
        val postsData = async { fetchPosts() }
        val statsData = async { fetchStats() }
        
        // Wait for all results
        Dashboard(
            user = userData.await(),
            posts = postsData.await(),
            stats = statsData.await()
        )
    }
}
```

**withContext - Switch Context:**
```kotlin
suspend fun processImage(bitmap: Bitmap): Bitmap {
    return withContext(Dispatchers.Default) {
        // Heavy computation on background thread
        applyFilters(bitmap)
    }
}

suspend fun saveToDatabase(data: Data) {
    withContext(Dispatchers.IO) {
        database.insert(data)
    }
}
```

**runBlocking - Blocking Execution:**
```kotlin
fun main() = runBlocking {
    launch {
        delay(1000)
        println("World!")
    }
    println("Hello")
}

// For testing
@Test
fun testCoroutine() = runBlocking {
    val result = fetchData()
    assertEquals(expected, result)
}
```

#### **5. CoroutineScope**

**Activity Scope:**
```kotlin
class MainActivity : AppCompatActivity() {
    
    private val scope = CoroutineScope(Dispatchers.Main + Job())
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        scope.launch {
            val data = fetchData()
            textView.text = data
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        scope.cancel() // Cancel all coroutines
    }
}
```

**LifecycleScope (Recommended):**
```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Automatically cancelled when lifecycle is destroyed
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                // Collect Flow only when STARTED
                viewModel.uiState.collect { state ->
                    updateUI(state)
                }
            }
        }
    }
}
```

**ViewModel Scope:**
```kotlin
class UserViewModel : ViewModel() {
    
    fun loadUser(userId: String) {
        viewModelScope.launch {
            try {
                _uiState.value = UiState.Loading
                val user = repository.getUser(userId)
                _uiState.value = UiState.Success(user)
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message)
            }
        }
    }
    
    // Automatically cancelled when ViewModel is cleared
}
```

**Custom Scope:**
```kotlin
class DataRepository {
    private val scope = CoroutineScope(
        SupervisorJob() + Dispatchers.IO
    )
    
    fun loadData() {
        scope.launch {
            // Background work
        }
    }
    
    fun cleanup() {
        scope.cancel()
    }
}
```

#### **6. Job Management**

**Basic Job:**
```kotlin
val job = scope.launch {
    repeat(1000) { i ->
        println("Job: I'm sleeping $i ...")
        delay(500)
    }
}

// Cancel job
job.cancel()

// Wait for completion
job.join()

// Check status
if (job.isActive) { /* ... */ }
if (job.isCancelled) { /* ... */ }
if (job.isCompleted) { /* ... */ }
```

**Job Hierarchy:**
```kotlin
val parentJob = scope.launch {
    val childJob1 = launch {
        delay(1000)
        println("Child 1 completed")
    }
    
    val childJob2 = launch {
        delay(2000)
        println("Child 2 completed")
    }
    
    println("Parent waiting...")
}

// Cancelling parent cancels all children
parentJob.cancel()
```

**SupervisorJob:**
```kotlin
val supervisor = SupervisorJob()
val scope = CoroutineScope(Dispatchers.Main + supervisor)

scope.launch {
    throw Exception("Child 1 failed")
}

scope.launch {
    delay(1000)
    println("Child 2 still running") // This will run
}
```

#### **7. Exception Handling**

**Try-Catch:**
```kotlin
viewModelScope.launch {
    try {
        val data = repository.fetchData()
        _uiState.value = UiState.Success(data)
    } catch (e: IOException) {
        _uiState.value = UiState.Error("Network error")
    } catch (e: HttpException) {
        _uiState.value = UiState.Error("Server error")
    } catch (e: Exception) {
        _uiState.value = UiState.Error("Unknown error")
    }
}
```

**CoroutineExceptionHandler:**
```kotlin
val exceptionHandler = CoroutineExceptionHandler { _, exception ->
    println("Caught $exception")
    // Log to analytics
}

val scope = CoroutineScope(Dispatchers.Main + exceptionHandler)

scope.launch {
    throw Exception("Something went wrong")
}
```

**Supervision:**
```kotlin
supervisorScope {
    val job1 = launch {
        delay(100)
        throw Exception("Job 1 failed")
    }
    
    val job2 = launch {
        delay(200)
        println("Job 2 completed") // This will still run
    }
}
```

#### **8. Cancellation**

**Cooperative Cancellation:**
```kotlin
val job = launch {
    repeat(1000) { i ->
        if (!isActive) return@launch // Check cancellation
        println("Job: I'm sleeping $i ...")
        delay(500)
    }
}

job.cancel()
```

**ensureActive:**
```kotlin
suspend fun doWork() {
    repeat(1000) { i ->
        ensureActive() // Throws CancellationException if cancelled
        // Heavy computation
        processItem(i)
    }
}
```

**yield:**
```kotlin
suspend fun doWork() {
    repeat(1000) { i ->
        yield() // Cooperative cancellation point
        processItem(i)
    }
}
```

**Cleanup on Cancellation:**
```kotlin
val job = launch {
    try {
        work()
    } finally {
        withContext(NonCancellable) {
            cleanup() // Always executes
        }
    }
}
```

**Timeout:**
```kotlin
try {
    withTimeout(5000) {
        val data = fetchData()
    }
} catch (e: TimeoutCancellationException) {
    println("Timeout!")
}

// Or non-throwing version
val result = withTimeoutOrNull(5000) {
    fetchData()
}

if (result == null) {
    println("Timeout!")
}
```

#### **9. Coroutine Context**

**Context Elements:**
```kotlin
// Dispatcher + Job
val context = Dispatchers.IO + Job()

// Multiple elements
val context = Dispatchers.Main + 
              Job() + 
              CoroutineName("MyCoroutine") +
              exceptionHandler

launch(context) {
    // Work with specific context
}
```

**CoroutineName:**
```kotlin
launch(CoroutineName("UpdateUser")) {
    println("Running in: ${coroutineContext[CoroutineName]}")
    updateUser()
}
```

#### **10. Testing Coroutines**

**Test Setup:**
```kotlin
@ExperimentalCoroutinesApi
class UserViewModelTest {
    
    private val testDispatcher = StandardTestDispatcher()
    
    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
    }
    
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
    
    @Test
    fun `test load user success`() = runTest {
        // Given
        val mockUser = User("1", "John")
        val repository = mockRepository(mockUser)
        val viewModel = UserViewModel(repository)
        
        // When
        viewModel.loadUser("1")
        advanceUntilIdle() // Progress time
        
        // Then
        val state = viewModel.uiState.value
        assertTrue(state is UiState.Success)
        assertEquals(mockUser, (state as UiState.Success).data)
    }
    
    @Test
    fun `test load user with delay`() = runTest {
        // When
        viewModel.loadUser("1")
        
        // Fast-forward time
        advanceTimeBy(1000)
        
        // Then
        // Assert state
    }
}
```

**Testing Flows:**
```kotlin
@Test
fun `test user flow`() = runTest {
    // Given
    val repository = FakeRepository()
    
    // When & Then
    repository.getUserFlow("1").test {
        assertEquals(UiState.Loading, awaitItem())
        assertEquals(UiState.Success(user), awaitItem())
        awaitComplete()
    }
}
```

#### **11. Best Practices**
✅ Use lifecycleScope atau viewModelScope
✅ Always handle exceptions
✅ Use structured concurrency
✅ Cancel coroutines when not needed
✅ Use withContext untuk switch dispatchers
✅ Avoid GlobalScope
✅ Use supervisorScope untuk independent tasks
✅ Test dengan TestDispatcher
✅ Use proper CoroutineScope
✅ Don't block main thread

#### **12. Common Patterns**

**Loading Pattern:**
```kotlin
sealed class UiState<out T> {
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(val message: String) : UiState<Nothing>()
}

class UserViewModel : ViewModel() {
    private val _uiState = MutableStateFlow<UiState<User>>(UiState.Loading)
    val uiState: StateFlow<UiState<User>> = _uiState.asStateFlow()
    
    fun loadUser(userId: String) {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            try {
                val user = repository.getUser(userId)
                _uiState.value = UiState.Success(user)
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message ?: "Unknown error")
            }
        }
    }
}
```

**Retry Pattern:**
```kotlin
suspend fun <T> retryWithExponentialBackoff(
    times: Int = 3,
    initialDelay: Long = 100,
    maxDelay: Long = 1000,
    factor: Double = 2.0,
    block: suspend () -> T
): T {
    var currentDelay = initialDelay
    repeat(times - 1) {
        try {
            return block()
        } catch (e: Exception) {
            delay(currentDelay)
            currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)
        }
    }
    return block() // Last attempt
}
```

#### **13. Hands-on Exercises**
- Buat aplikasi dengan network calls menggunakan coroutines
- Implement parallel API calls dengan async/await
- Buat loading states dengan StateFlow
- Implement proper error handling
- Buat cancellable operations
- Write unit tests untuk coroutines
- Implement retry mechanism
- Handle timeout scenarios

---
