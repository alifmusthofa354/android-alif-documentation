## **5.3 JSON Serialization** (3 hari) ⭐⭐⭐

### **Teknologi Modern:**
- Kotlinx Serialization
- Moshi

### **Teknologi yang Ditinggalkan:**
- Gson

### **Sub-topik Detail:**

#### 1. JSON Serialization Overview
- Apa itu serialization/deserialization
- JSON ↔ Kotlin objects
- Mengapa perlu serialization
- Comparison: Gson vs Moshi vs Kotlinx Serialization
- Performance considerations
- Type safety

#### 2. Kotlinx Serialization

**Setup:**
```kotlin
// build.gradle.kts (project level)
plugins {
    kotlin("plugin.serialization") version "1.9.0"
}

// build.gradle.kts (app level)
dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0")
}
```

**Basic Usage:**
```kotlin
import kotlinx.serialization.*
import kotlinx.serialization.json.*

@Serializable
data class User(
    val id: Int,
    val name: String,
    val email: String
)

// Serialization (Object → JSON)
val user = User(1, "John Doe", "john@example.com")
val jsonString = Json.encodeToString(user)
// {"id":1,"name":"John Doe","email":"john@example.com"}

// Deserialization (JSON → Object)
val jsonString = """{"id":1,"name":"John Doe","email":"john@example.com"}"""
val user = Json.decodeFromString<User>(jsonString)
```

**Custom Property Names:**
```kotlin
@Serializable
data class User(
    @SerialName("user_id")
    val id: Int,
    
    @SerialName("full_name")
    val name: String,
    
    val email: String
)
```

**Optional & Default Values:**
```kotlin
@Serializable
data class User(
    val id: Int,
    val name: String,
    val email: String? = null,  // Nullable
    val age: Int = 0,           // Default value
    val isActive: Boolean = true
)
```

**Custom Json Configuration:**
```kotlin
val json = Json {
    ignoreUnknownKeys = true  // Ignore extra JSON fields
    isLenient = true           // Relaxed parsing
    encodeDefaults = true      // Include default values
    prettyPrint = true         // Format JSON nicely
    coerceInputValues = true   // Handle invalid nulls
}

val user = json.decodeFromString<User>(jsonString)
```

**Collections:**
```kotlin
// List
val users = listOf(user1, user2, user3)
val jsonString = Json.encodeToString(users)
val userList = Json.decodeFromString<List<User>>(jsonString)

// Map
val userMap = mapOf("admin" to user1, "user" to user2)
val jsonString = Json.encodeToString(userMap)
```

**Nested Objects:**
```kotlin
@Serializable
data class Address(
    val street: String,
    val city: String,
    val country: String
)

@Serializable
data class User(
    val id: Int,
    val name: String,
    val address: Address  // Nested object
)
```

**Polymorphic Serialization:**
```kotlin
@Serializable
sealed class Response {
    @Serializable
    @SerialName("success")
    data class Success(val data: String) : Response()
    
    @Serializable
    @SerialName("error")
    data class Error(val message: String) : Response()
}

val json = Json {
    classDiscriminator = "type"
}
```

**Custom Serializers:**
```kotlin
@Serializable(with = DateSerializer::class)
data class Event(
    val name: String,
    val date: Date
)

object DateSerializer : KSerializer<Date> {
    override val descriptor = PrimitiveSerialDescriptor("Date", PrimitiveKind.LONG)
    
    override fun serialize(encoder: Encoder, value: Date) {
        encoder.encodeLong(value.time)
    }
    
    override fun deserialize(decoder: Decoder): Date {
        return Date(decoder.decodeLong())
    }
}
```

#### 3. Moshi

**Setup:**
```kotlin
dependencies {
    implementation("com.squareup.moshi:moshi:1.15.0")
    implementation("com.squareup.moshi:moshi-kotlin:1.15.0")
    kapt("com.squareup.moshi:moshi-kotlin-codegen:1.15.0")
}
```

**Basic Usage:**
```kotlin
import com.squareup.moshi.*

@JsonClass(generateAdapter = true)
data class User(
    val id: Int,
    val name: String,
    val email: String
)

// Serialization
val moshi = Moshi.Builder()
    .add(KotlinJsonAdapterFactory())
    .build()

val jsonAdapter = moshi.adapter(User::class.java)

val user = User(1, "John Doe", "john@example.com")
val jsonString = jsonAdapter.toJson(user)

// Deserialization
val user = jsonAdapter.fromJson(jsonString)
```

**Custom Property Names:**
```kotlin
@JsonClass(generateAdapter = true)
data class User(
    @Json(name = "user_id")
    val id: Int,
    
    @Json(name = "full_name")
    val name: String
)
```

**Nullable & Default Values:**
```kotlin
@JsonClass(generateAdapter = true)
data class User(
    val id: Int,
    val name: String,
    val email: String? = null,
    val age: Int = 0
)
```

**Custom Adapters:**
```kotlin
class DateAdapter {
    @ToJson
    fun toJson(date: Date): Long {
        return date.time
    }
    
    @FromJson
    fun fromJson(timestamp: Long): Date {
        return Date(timestamp)
    }
}

val moshi = Moshi.Builder()
    .add(DateAdapter())
    .add(KotlinJsonAdapterFactory())
    .build()
```

**Type Adapters:**
```kotlin
val moshi = Moshi.Builder()
    .add(Date::class.java, Rfc3339DateJsonAdapter())
    .add(KotlinJsonAdapterFactory())
    .build()
```

#### 4. Gson (Legacy, but still widely used)

**Setup:**
```kotlin
dependencies {
    implementation("com.google.code.gson:gson:2.10.1")
}
```

**Basic Usage:**
```kotlin
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName

data class User(
    @SerializedName("user_id")
    val id: Int,
    
    @SerializedName("full_name")
    val name: String,
    
    val email: String
)

// Serialization
val gson = Gson()
val user = User(1, "John Doe", "john@example.com")
val jsonString = gson.toJson(user)

// Deserialization
val user = gson.fromJson(jsonString, User::class.java)

// Collections
val users = listOf(user1, user2)
val jsonString = gson.toJson(users)
val userList = gson.fromJson(jsonString, Array<User>::class.java).toList()
```

**Custom Gson:**
```kotlin
val gson = GsonBuilder()
    .setPrettyPrinting()
    .setDateFormat("yyyy-MM-dd'T'HH:mm:ss")
    .serializeNulls()
    .create()
```

#### 5. Comparison: Kotlinx Serialization vs Moshi vs Gson

**Kotlinx Serialization:**
✅ Kotlin-first, multiplatform
✅ Compile-time safe
✅ No reflection in runtime
✅ Smaller APK size
❌ Requires compiler plugin

**Moshi:**
✅ Efficient, modern
✅ Kotlin support
✅ Good error messages
✅ Custom adapters
❌ Reflection-based (dapat dihindari dengan codegen)

**Gson:**
✅ Mature, widely used
✅ Simple API
✅ Large ecosystem
❌ Reflection-based (slower)
❌ Not Kotlin-first
❌ Less type-safe

#### 6. Integration dengan Retrofit

**Kotlinx Serialization:**
```kotlin
dependencies {
    implementation("com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter:1.0.0")
}

val json = Json { ignoreUnknownKeys = true }

val retrofit = Retrofit.Builder()
    .baseUrl(BASE_URL)
    .addConverterFactory(json.asConverterFactory("application/json".toMediaType()))
    .build()
```

**Moshi:**
```kotlin
dependencies {
    implementation("com.squareup.retrofit2:converter-moshi:2.9.0")
}

val moshi = Moshi.Builder()
    .add(KotlinJsonAdapterFactory())
    .build()

val retrofit = Retrofit.Builder()
    .baseUrl(BASE_URL)
    .addConverterFactory(MoshiConverterFactory.create(moshi))
    .build()
```

**Gson:**
```kotlin
dependencies {
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
}

val gson = GsonBuilder().create()

val retrofit = Retrofit.Builder()
    .baseUrl(BASE_URL)
    .addConverterFactory(GsonConverterFactory.create(gson))
    .build()
```

#### 7. Handling Complex JSON

**Nested Arrays:**
```kotlin
@Serializable
data class ApiResponse(
    val status: String,
    val data: List<User>
)
```

**Dynamic Keys:**
```kotlin
// JSON: {"user_1": {...}, "user_2": {...}}
val usersMap = Json.decodeFromString<Map<String, User>>(jsonString)
```

**Union Types:**
```kotlin
@Serializable
sealed class Content {
    @Serializable
    data class Text(val text: String) : Content()
    
    @Serializable
    data class Image(val url: String) : Content()
}
```

#### 8. Error Handling
```kotlin
try {
    val user = Json.decodeFromString<User>(jsonString)
} catch (e: SerializationException) {
    // Invalid JSON format
    Log.e("JSON", "Serialization error: ${e.message}")
} catch (e: IllegalArgumentException) {
    // Missing required field
    Log.e("JSON", "Missing field: ${e.message}")
}
```

#### 9. Performance Optimization
- Use code generation (Moshi, Kotlinx)
- Avoid reflection when possible
- Reuse adapter instances
- Stream large JSON files
- Consider ProGuard rules

#### 10. Best Practices
- Use @SerializedName / @SerialName untuk API compatibility
- Provide default values untuk optional fields
- Use nullable types dengan caution
- Validate data setelah deserialization
- Keep models simple dan flat
- Separate API models dari domain models
- Use sealed classes untuk polymorphic types
- Handle unknown JSON keys gracefully
- Version your API models

#### 11. Hands-on Practice
- Parse complex JSON responses
- Implement custom serializers
- Handle nested objects dan arrays
- Error handling untuk invalid JSON
- Integration dengan Retrofit
- Performance testing different libraries
- Testing serialization/deserialization