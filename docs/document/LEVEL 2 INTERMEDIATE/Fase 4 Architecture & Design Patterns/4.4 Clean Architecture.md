# ğŸ—ï¸ Panduan Lengkap: Clean Architecture di Android

## ğŸš€ Pengantar: Arsitektur Bersih untuk Aplikasi Android yang Scalable

Bayangkan kamu adalah seorang arsitek perangkat lunak ğŸ›ï¸:
- **Clean Architecture** seperti rencana dasar gedung yang kuat dan fleksibel
- **Lapisan-lapisan terpisah** seperti lantai-lantai dalam gedung bertingkat
- **Dependency Rule** seperti sistem satu arah yang menjaga struktur tetap konsisten

Dengan Clean Architecture, kamu bisa membangun aplikasi yang tahan lama, mudah diuji, dan mudah dipelihara!

## ğŸ“š Daftar Isi Pembelajaran
1. [ğŸŒŸ Pengenalan Clean Architecture](#1ï¸âƒ£-pengenalan-clean-architecture-ğŸŒŸ)
2. [ğŸ§± Prinsip-prinsip Clean Architecture](#2ï¸âƒ£-prinsip-prinsip-clean-architecture-ğŸ§±)
3. [ğŸ”„ Aturan Ketergantungan (Dependency Rule)](#3ï¸âƒ£-aturan-ketergantungan-dependency-rule-ğŸ”„)
4. [ğŸ—ï¸ Lapisan Aplikasi (Layers)](#4ï¸âƒ£-lapisan-aplikasi-layers-ğŸ—ï¸)
5. [ğŸ§  Domain Layer (Inti)](#5ï¸âƒ£-domain-layer-inti-ğŸ§ )
6. [ğŸ“± Presentation Layer (Tampilan)](#6ï¸âƒ£-presentation-layer-tampilan-ğŸ“±)
7. [ğŸ’¾ Data Layer (Data)](#7ï¸âƒ£-data-layer-data-ğŸ’¾)
8. [ğŸ”— Mapping Antar Lapisan](#8ï¸âƒ£-mapping-antar-lapisan-ğŸ”—)
9. [ğŸ§ª Testing di Clean Architecture](#9ï¸âƒ£-testing-di-clean-architecture-ğŸ§ª)
10. [âœ¨ Best Practices](#1ï¸âƒ£0ï¸âƒ£-best-practices-âœ¨)
11. [ğŸ”¨ Hands-on Project](#1ï¸âƒ£1ï¸âƒ£-hands-on-project-ğŸ”¨)
12. [ğŸ¯ Kesimpulan](#ğŸ¯-kesimpulan)

---

## 1ï¸âƒ£ Pengenalan Clean Architecture ğŸŒŸ

### Konsep Dasar
Clean Architecture seperti rencana dasar rumah tahan gempa ğŸ  yang dirancang oleh Uncle Bob (Robert C. Martin) - seorang legenda dalam dunia software development!

### Apa itu Clean Architecture dan mengapa penting?
**Clean Architecture** adalah pola arsitektur perangkat lunak yang memisahkan aplikasi menjadi beberapa lapisan dengan aturan ketergantungan yang jelas. Tujuannya adalah untuk menciptakan aplikasi yang:

- **Independen dari framework**: Tidak terikat pada teknologi tertentu
- **Testable**: Mudah diuji tanpa framework atau UI
- **Independent dari UI**: UI bisa diganti tanpa mempengaruhi inti logika
- **Independent dari database**: Database bisa diganti tanpa perubahan besar
- **Independent dari external agencies**: Aplikasi tidak ditentukan oleh eksternal API

### Evolusi Clean Architecture:
```
1. Monolithic â†’ Semua kod di satu tempat
2. Layered Architecture â†’ Dipisah-pisah tapi saling tergantung
3. Clean Architecture â†’ Lapisan terpisah dengan aturan jelas
```

### Diagram Clean Architecture:
```
Outer Layer â†’   Presentation (UI, ViewModel)  
                â”‚
                â”‚ (depends on)
                â†“
                Domain (Use Cases, Models, Repositories) â† Core Layer
                â†‘
                â”‚ (depends on)
                Data (Repositories, Data Sources, Database, API)
 â† Outer Layer
```

### Perbedaan Clean Architecture vs Layered Architecture:

| Pattern | Dependency | Testability | Flexibility |
|---------|------------|-------------|-------------|
| **Layered** | Bisa saling tergantung | Terbatas | Rendah |
| **Clean** | Satu arah ke dalam | Sangat baik | Sangat tinggi |

### Keunggulan Clean Architecture untuk Android Development:
1. **Separation of Concerns**: Setiap lapisan punya tanggung jawab sendiri
2. **Testability**: Bisa test logika tanpa Android Framework
3. **Maintainability**: Perubahan tidak merambat ke lapisan lain
4. **Scalability**: Bisa dikembangkan tanpa merusak struktur
5. **Framework Independence**: Bisa ganti framework tanpa merusak inti

---

## 2ï¸âƒ£ Prinsip-prinsip Clean Architecture ğŸ§±

### Konsep dari Uncle Bob
Clean Architecture diperkenalkan oleh **Robert C. Martin (Uncle Bob)** dengan tujuan menciptakan sistem yang:
- **Independen dari framework**: Tidak ditentukan oleh framework
- **Testable**: Bisa diuji tanpa UI, database, atau service eksternal
- **Independent dari UI**: UI bisa diganti tanpa mempengaruhi bisnis rule
- **Independent dari database**: Bisnis rule tidak terikat dengan database
- **Independent dari external agencies**: Aplikasi tidak ditentukan oleh eksternal API

### SOLID Principles Integration:
```
S - Single Responsibility Principle
O - Open/Closed Principle
L - Liskov Substitution Principle
I - Interface Segregation Principle
D - Dependency Inversion Principle
```

### Implementasi Contoh Sederhana:

**domain/model/User.kt**
```kotlin
package com.example.cleanarchitecture.domain.model

/**
 * Domain Model - model murni tanpa dependensi Android
 */
data class User(
    val id: String,
    val name: String,
    val email: String,
    val isActive: Boolean = true
)
```

**domain/repository/UserRepository.kt**
```kotlin
package com.example.cleanarchitecture.domain.repository

import com.example.cleanarchitecture.domain.model.User
import kotlinx.coroutines.flow.Flow

/**
 * Repository Interface - didefinisikan oleh Domain Layer
 * Berisi kontrak untuk manajemen data
 */
interface UserRepository {
    suspend fun getUsers(): List<User>
    suspend fun getUserById(id: String): User?
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
    fun getUsersStream(): Flow<List<User>>
}
```

**domain/usecase/GetUsersUseCase.kt**
```kotlin
package com.example.cleanarchitecture.domain.usecase

import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.repository.UserRepository

/**
 * Use Case - berisi logika bisnis
 * Bergantung hanya pada Repository interface, bukan implementasi
 */
class GetUsersUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(): List<User> {
        return userRepository.getUsers()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Clean Architecture seperti Gedung Bertingkat:**
- **Lantai Dasar (Domain)**: Pintu masuk utama (inti logika bisnis)
- **Lantai 1 (Presentation)**: Tempat orang datang (UI/ViewModel)
- **Lantai 2 (Data)**: Sumber daya dan layanan (API/Database)
- **Jalur satu arah**: Semua lantai hanya bisa berkomunikasi ke bawah

**Independence from Frameworks:**
- Domain layer tidak bergantung pada Android Framework
- Bisa digunakan di platform lain (iOS, Web, Server)
- Murni Kotlin atau Java

**Separation of Concerns:**
- Domain: Logika bisnis dan model
- Presentation: Tampilan dan interaksi UI
- Data: Pengelolaan data dari berbagai sumber

---

## 3ï¸âƒ£ Aturan Ketergantungan (Dependency Rule) ğŸ”„

### Konsep Dasar
Dependency Rule seperti aturan lalu lintas satu arah ğŸš¦ untuk dependensi dalam Clean Architecture!

### Aturan Ketergantungan Inti:
```
Outer Layer â†’ Inner Layer (Bergantung)
Inner Layer â†’ Outer Layer (TIDAK BERGANTUNG)
```

### Penjelasan Detil:
1. **Outer Layer (Presentation & Data)** bergantung pada **Inner Layer (Domain)**
2. **Inner Layer (Domain)** tidak boleh bergantung pada **Outer Layer**
3. **Domain Layer** adalah pusat arsitektur, tidak terikat ke luar
4. Semua dependensi mengarah **ke dalam (inward)**

### Diagram Dependency Flow:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Presentation    â”‚
â”‚ ViewModel, UI   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ (depends on)
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Domain          â”‚ â†â”€ Pusat arsitektur
â”‚ Use Cases,      â”‚
â”‚ Models,         â”‚
â”‚ Repository      â”‚
â”‚ Interfaces      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ (depends on)
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Data            â”‚
â”‚ Repository,     â”‚
â”‚ DataSource,     â”‚
â”‚ API, Database   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Contoh Kode - Dependency Rule:

**domain/usecase/GetUserUseCase.kt**
```kotlin
package com.example.cleanarchitecture.domain.usecase

import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.repository.UserRepository

/**
 * âœ… BENAR: UseCase bergantung ke Repository Interface
 * (Inner layer bergantung ke inner layer lain)
 */
class GetUserUseCase(
    private val userRepository: UserRepository  // Interface dari domain
) {
    suspend operator fun invoke(userId: String): User? {
        return userRepository.getUserById(userId)
    }
}
```

**âŒ SALAH: Contoh pelanggaran Dependency Rule**
```kotlin
// JANGAN LAKUKAN INI!
class GetUserUseCase(
    private val apiService: UserService,  // Bergantung ke outer layer!
    private val database: AppDatabase      // Bergantung ke outer layer!
) {
    // Ini melanggar aturan karena Domain bergantung ke Data
}
```

### Dependency Inversion Principle:
- **High-level modules** tidak boleh bergantung pada **low-level modules**
- Keduanya seharusnya **bergantung pada abstraksi**
- Abstraksi tidak boleh bergantung pada detail, detail yang bergantung pada abstraksi

### Plugin Architecture:
- Outer layers seperti plugin yang bisa diganti
- Inner layer sebagai inti tidak berubah
- Bisa ganti UI, Database, atau API tanpa ubah Domain

### ğŸ“ Penjelasan Konsep:
**Dependency Rule seperti Sungai:**
- **Air mengalir satu arah** dari hulu ke hilir
- **Hulu (Inner)** tidak terpengaruh oleh **Hilir (Outer)**
- **Hulu (Domain)** adalah sumber, **Hilir (Presentation/Data)** adalah penerima

**Keunggulan Dependency Rule:**
- **Flexibility**: Bisa ganti lapisan luar tanpa sentuh inti
- **Testing**: Bisa mock lapisan luar untuk test lapisan dalam
- **Maintainability**: Perubahan tidak merambat ke lapisan lain
- **Scalability**: Bisa kembangkan lapisan luar independen

---

## 4ï¸âƒ£ Lapisan Aplikasi (Layers) ğŸ—ï¸

### Konsep Dasar
Clean Architecture terdiri dari 3 lapisan utama seperti gedung bertingkat ğŸ¢, masing-masing memiliki tanggung jawab spesifik!

### Struktur Lapisan:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Presentation    â”‚ â† UI, ViewModel (Outer Layer)
â”‚                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Domain          â”‚ â† Use Cases, Models (Core Layer)
â”‚                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Data            â”‚ â† Repository, DataSource (Outer Layer)
â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1. Presentation Layer (Lapisan Luar)
- **Tanggung jawab**: Tampilan dan interaksi pengguna
- **Berisi**: Activity, Fragment, Composables, ViewModels
- **Tidak berisi**: Logika bisnis murni
- **Bergantung pada**: Domain (Use Cases, Models)

### 2. Domain Layer (Lapisan Inti)
- **Tanggung jawab**: Inti logika bisnis dan aturan aplikasi
- **Berisi**: Use Cases, Domain Models, Repository Interfaces
- **Tidak bergantung pada**: Android Framework atau teknologi eksternal
- **Pusat dari**: seluruh arsitektur

### 3. Data Layer (Lapisan Luar)
- **Tanggung jawab**: Pengelolaan data dari berbagai sumber
- **Berisi**: Repository Implementations, Data Sources, DTOs
- **Bergantung pada**: Domain (Repository Interfaces)
- **Mengimplementasi**: kontrak dari Domain Layer

### Contoh Struktur Package:

```
app/src/main/java/com/example/cleanarchitecture/
â”œâ”€â”€ presentation/
â”‚   â”œâ”€â”€ home/
â”‚   â”‚   â”œâ”€â”€ HomeScreen.kt
â”‚   â”‚   â”œâ”€â”€ HomeViewModel.kt
â”‚   â”‚   â””â”€â”€ HomeUiState.kt
â”‚   â”œâ”€â”€ profile/
â”‚   â”‚   â”œâ”€â”€ ProfileScreen.kt
â”‚   â”‚   â””â”€â”€ ProfileViewModel.kt
â”‚   â””â”€â”€ common/
â”‚       â””â”€â”€ components/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ usecase/
â”‚   â”‚   â”œâ”€â”€ GetUserUseCase.kt
â”‚   â”‚   â””â”€â”€ GetUsersUseCase.kt
â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â”œâ”€â”€ User.kt
â”‚   â”‚   â””â”€â”€ UserUiModel.kt
â”‚   â””â”€â”€ repository/
â”‚       â””â”€â”€ UserRepository.kt
â””â”€â”€ data/
    â”œâ”€â”€ repository/
    â”‚   â””â”€â”€ UserRepositoryImpl.kt
    â”œâ”€â”€ source/
    â”‚   â”œâ”€â”€ local/
    â”‚   â”‚   â”œâ”€â”€ UserLocalDataSource.kt
    â”‚   â”‚   â””â”€â”€ AppDatabase.kt
    â”‚   â””â”€â”€ remote/
    â”‚       â”œâ”€â”€ UserRemoteDataSource.kt
    â”‚       â””â”€â”€ ApiService.kt
    â””â”€â”€ mapper/
        â””â”€â”€ UserMapper.kt
```

### Package Structure Alternatif (Feature-based):

```
feature/
â”œâ”€â”€ user/
â”‚   â”œâ”€â”€ presentation/
â”‚   â”‚   â”œâ”€â”€ UserViewModel.kt
â”‚   â”‚   â””â”€â”€ UserScreen.kt
â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ GetUserUseCase.kt
â”‚   â”‚   â””â”€â”€ User.kt
â”‚   â””â”€â”€ data/
â”‚       â”œâ”€â”€ UserRepositoryImpl.kt
â”‚       â””â”€â”€ UserRemoteDataSource.kt
â””â”€â”€ auth/
    â”œâ”€â”€ presentation/
    â”œâ”€â”€ domain/
    â””â”€â”€ data/
```

### ğŸ“ Penjelasan Konsep:
**Lapisan Seperti Gedung Bertingkat:**
- **Lantai 1 (Domain)**: Pondasi dan struktur utama (tidak bisa diganti)
- **Lantai 2 (Presentation)**: Interior yang bisa diubah tanpa sentuh pondasi
- **Lantai 3 (Data)**: Fasilitas luar yang bisa diperbarui

**Keunggulan Struktur Lapisan:**
- **Modular**: Setiap lapisan bisa dikembangkan secara independen
- **Testable**: Bisa test masing-masing lapisan
- **Scalable**: Bisa tambah fitur tanpa ganggu struktur

---

## 5ï¸âƒ£ Domain Layer (Inti) ğŸ§ 

### Konsep Dasar
Domain Layer seperti jantung dari aplikasi â¤ï¸ - berisi logika bisnis murni tanpa dependensi eksternal!

### Pengertian Domain dalam Clean Architecture:
Domain Layer adalah **pintu masuk utama** dari arsitektur. Ini berisi:
- **Use Cases**: Logika bisnis spesifik
- **Domain Models**: Representasi entitas bisnis
- **Repository Interfaces**: Kontrak untuk manajemen data
- **Entities**: Model bisnis murni

### Use Cases/Interactors:

**domain/usecase/GetUsersUseCase.kt**
```kotlin
package com.example.cleanarchitecture.domain.usecase

import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.repository.UserRepository

/**
 * Use Case untuk mendapatkan semua pengguna
 * Mengandung logika bisnis spesifik
 */
class GetUsersUseCase(
    private val userRepository: UserRepository
) {
    /**
     * Operator function untuk memudahkan pemanggilan
     */
    suspend operator fun invoke(): List<User> {
        // Bisa tambah logika bisnis di sini
        val users = userRepository.getUsers()
        
        // Contoh logika bisnis: filter pengguna aktif
        return users.filter { it.isActive }
    }
}
```

**domain/usecase/SaveUserUseCase.kt**
```kotlin
package com.example.cleanarchitecture.domain.usecase

import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.repository.UserRepository
import com.example.cleanarchitecture.domain.validation.DataValidator

/**
 * Use Case untuk menyimpan pengguna dengan validasi
 */
class SaveUserUseCase(
    private val userRepository: UserRepository,
    private val validator: DataValidator = DataValidator
) {
    suspend operator fun invoke(user: User): Result<Unit> {
        // Validasi data sebelum disimpan
        return try {
            val nameValidation = validator.validateName(user.name)
            val emailValidation = validator.validateEmail(user.email)
            
            if (nameValidation !is DataValidator.ValidationResult.Valid ||
                emailValidation !is DataValidator.ValidationResult.Valid) {
                
                return Result.failure(Exception("Validasi gagal"))
            }
            
            userRepository.saveUser(user)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### Domain Models:

**domain/model/User.kt**
```kotlin
package com.example.cleanarchitecture.domain.model

import kotlinx.datetime.LocalDateTime

/**
 * Domain Model - representasi entitas bisnis murni
 * Tidak terikat dengan Android Framework atau teknologi eksternal
 */
data class User(
    val id: String,
    val name: String,
    val email: String,
    val isActive: Boolean = true,
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime
) {
    /**
     * Method domain untuk validasi bisnis
     */
    fun isValidForBusiness(): Boolean {
        return name.isNotBlank() && 
               email.isNotBlank() && 
               email.contains("@")
    }
    
    /**
     * Method domain untuk memperbarui status
     */
    fun withUpdatedStatus(isActive: Boolean): User {
        return this.copy(
            isActive = isActive,
            updatedAt = LocalDateTime.now()
        )
    }
}
```

### Repository Interfaces:

**domain/repository/UserRepository.kt**
```kotlin
package com.example.cleanarchitecture.domain.repository

import com.example.cleanarchitecture.domain.model.User
import kotlinx.coroutines.flow.Flow

/**
 * Interface Repository - didefinisikan oleh Domain Layer
 * Outer layers mengimplementasikan interface ini
 */
interface UserRepository {
    /**
     * Mendapatkan semua pengguna
     */
    suspend fun getUsers(): List<User>
    
    /**
     * Mendapatkan pengguna berdasarkan ID
     */
    suspend fun getUserById(id: String): User?
    
    /**
     * Menyimpan pengguna baru
     */
    suspend fun saveUser(user: User)
    
    /**
     * Memperbarui pengguna
     */
    suspend fun updateUser(user: User)
    
    /**
     * Menghapus pengguna
     */
    suspend fun deleteUser(id: String)
    
    /**
     * Mendapatkan stream pengguna (untuk live updates)
     */
    fun getUsersStream(): Flow<List<User>>
}

/**
 * Repository interface untuk manajemen kebutuhan spesifik
 */
interface UserPreferencesRepository {
    suspend fun saveThemePreference(theme: String)
    suspend fun getThemePreference(): String
    suspend fun isNotificationsEnabled(): Boolean
}
```

### Domain Validation:

**domain/validation/DataValidator.kt**
```kotlin
package com.example.cleanarchitecture.domain.validation

/**
 * Validator murni Kotlin - tidak terikat framework
 */
object DataValidator {
    
    /**
     * Result type untuk validasi
     */
    sealed class ValidationResult {
        object Valid : ValidationResult()
        data class Invalid(val message: String) : ValidationResult()
    }
    
    /**
     * Validasi email
     */
    fun validateEmail(email: String): ValidationResult {
        return if (email.isBlank()) {
            ValidationResult.Invalid("Email tidak boleh kosong")
        } else if (!email.contains("@")) {
            ValidationResult.Invalid("Format email tidak valid")
        } else {
            ValidationResult.Valid
        }
    }
    
    /**
     * Validasi nama
     */
    fun validateName(name: String): ValidationResult {
        return if (name.length < 2) {
            ValidationResult.Invalid("Nama harus minimal 2 karakter")
        } else if (!name.all { it.isLetter() || it.isWhitespace() }) {
            ValidationResult.Invalid("Nama hanya boleh mengandung huruf dan spasi")
        } else {
            ValidationResult.Valid
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Domain Layer seperti Jantung:**
- **Pusat kehidupan aplikasi** - tanpa ini aplikasi tidak bisa berjalan
- **Murni Kotlin/Java** - tidak terikat framework
- **Tidak tahu UI, Database, atau API** - sangat independen
- **Memegang logika bisnis utama** - aturan bisnis yang penting

**Karakteristik Domain Layer:**
- **Framework independent**: Tidak bergantung pada Android, API, atau Database
- **Testable**: Bisa diuji tanpa framework external
- **Pure business logic**: Hanya berisi logika bisnis murni
- **Long lasting**: Tidak akan berubah saat ganti UI atau teknologi luar

---

## 6ï¸âƒ£ Presentation Layer (Tampilan) ğŸ“±

### Konsep Dasar
Presentation Layer seperti wajah dari aplikasi ğŸ‘¤ - tempat pengguna berinteraksi dan melihat informasi!

### Pengertian Presentation dalam Clean Architecture:
Presentation Layer adalah lapisan paling luar yang:
- **Bertanggung jawab hanya untuk menampilkan UI**
- **Tidak mengandung logika bisnis**
- **Menggunakan Use Cases dari Domain Layer**
- **Menampilkan state dari ViewModel**
- **Mengirim event ke ViewModel**

### ViewModel dalam Clean Architecture:

**presentation/home/HomeViewModel.kt**
```kotlin
package com.example.cleanarchitecture.presentation.home

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.usecase.GetUsersUseCase
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * ViewModel untuk layar home
 * Bergantung pada Use Cases dari Domain Layer
 */
class HomeViewModel(
    private val getUsersUseCase: GetUsersUseCase
) : ViewModel() {

    private val _users = MutableStateFlow<List<User>>(emptyList())
    val users: StateFlow<List<User>> = _users.asStateFlow()

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()

    init {
        loadUsers()
    }

    fun loadUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null

            try {
                val userList = getUsersUseCase()  // Panggil Use Case dari Domain
                _users.value = userList
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLoading.value = false
            }
        }
    }

    fun refreshUsers() {
        loadUsers()
    }
}
```

### UI Models (Presentation Models):

**presentation/home/HomeUiState.kt**
```kotlin
package com.example.cleanarchitecture.presentation.home

import com.example.cleanarchitecture.domain.model.User

/**
 * UI State untuk layar home
 * Berbeda dari Domain Model karena kebutuhan tampilan
 */
data class HomeUiState(
    val users: List<UserItemUiModel> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)

/**
 * UI Model untuk item pengguna
 * Disesuaikan dengan kebutuhan tampilan
 */
data class UserItemUiModel(
    val id: String,
    val name: String,
    val email: String,
    val isActive: Boolean,
    val initials: String,  // Tambahan untuk tampilan
    val statusColor: String // Tambahan untuk tampilan
) {
    companion object {
        fun fromDomain(domain: User): UserItemUiModel {
            return UserItemUiModel(
                id = domain.id,
                name = domain.name,
                email = domain.email,
                isActive = domain.isActive,
                initials = domain.name.take(1).uppercase(),
                statusColor = if (domain.isActive) "green" else "red"
            )
        }
    }
}
```

### Jetpack Compose UI:

**presentation/home/HomeScreen.kt**
```kotlin
package com.example.cleanarchitecture.presentation.home

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.example.cleanarchitecture.domain.model.User

/**
 * Composable function untuk layar home
 * Hanya menampilkan data dan menangani event
 */
@Composable
fun HomeScreen(
    viewModel: HomeViewModel,
    modifier: Modifier = Modifier
) {
    val uiState by viewModel.users.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    val error by viewModel.error.collectAsState()

    Column(
        modifier = modifier.fillMaxSize()
    ) {
        TopAppBar(
            title = { Text("Daftar Pengguna") },
            actions = {
                IconButton(onClick = { viewModel.loadUsers() }) {
                    Icon(Icons.Default.Refresh, contentDescription = "Refresh")
                }
            }
        )

        if (isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .wrapContentSize(Alignment.Center)
            ) {
                CircularProgressIndicator()
            }
        } else if (!error.isNullOrEmpty()) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .wrapContentSize(Alignment.Center)
            ) {
                Text("Error: $error")
            }
        } else {
            LazyColumn(
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(uiState) { user ->
                    UserItem(user = user)
                }
            }
        }
    }
}

@Composable
fun UserItem(user: User) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .background(
                        color = if (user.isActive) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline,
                        shape = androidx.compose.foundation.shape.CircleShape
                    ),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = user.name.take(1).uppercase(),
                    color = MaterialTheme.colorScheme.onPrimary
                )
            }

            Spacer(modifier = Modifier.width(16.dp))

            Column {
                Text(
                    text = user.name,
                    style = MaterialTheme.typography.titleMedium
                )
                Text(
                    text = user.email,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}
```

### Main Activity dengan Hilt:

**presentation/MainActivity.kt**
```kotlin
package com.example.cleanarchitecture.presentation

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.cleanarchitecture.presentation.home.HomeScreen
import com.example.cleanarchitecture.presentation.home.HomeViewModel
import com.example.cleanarchitecture.presentation.ui.theme.CleanArchitectureTheme
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            CleanArchitectureTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    val viewModel: HomeViewModel = hiltViewModel()
                    HomeScreen(viewModel = viewModel)
                }
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Presentation Layer seperti Wajah:**
- **Wajah hanya menampilkan** - tidak mengandung logika otak
- **Bagian dari diri** - tapi bisa diganti gaya penampilan
- **Berinteraksi dengan dunia luar** - tempat komunikasi dimulai
- **Tidak tahu bagaimana proses dalam** - hanya menampilkan hasil

**Karakteristik Presentation Layer:**
- **UI focused**: Hanya untuk tampilan dan event
- **Bergantung ke Domain**: Menggunakan Use Cases
- **State management**: Menampilkan state dari ViewModel
- **Framework dependent**: Boleh menggunakan Android Framework

---

## 7ï¸âƒ£ Data Layer (Data) ğŸ’¾

### Konsep Dasar
Data Layer seperti gudang penyimpanan dan distribusi barang ğŸ“¦ - mengelola semua data masuk dan keluar dari aplikasi!

### Pengertian Data dalam Clean Architecture:
Data Layer adalah lapisan paling luar yang:
- **Mengimplementasikan Repository Interfaces dari Domain**
- **Bergantung pada teknologi eksternal** (API, Database, Preferences)
- **Mengelola data dari berbagai sumber**
- **Tidak boleh diakses langsung dari Presentation Layer**

### Repository Implementations:

**data/repository/UserRepositoryImpl.kt**
```kotlin
package com.example.cleanarchitecture.data.repository

import com.example.cleanarchitecture.data.source.local.UserLocalDataSource
import com.example.cleanarchitecture.data.source.remote.UserRemoteDataSource
import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.repository.UserRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

/**
 * Implementasi Repository yang diinginkan oleh Domain Layer
 * Mengkoordinasi data dari berbagai sumber
 */
class UserRepositoryImpl(
    private val remoteDataSource: UserRemoteDataSource,
    private val localDataSource: UserLocalDataSource
) : UserRepository {

    override suspend fun getUsers(): List<User> {
        return try {
            // Coba ambil dari remote terlebih dahulu
            val remoteUsers = remoteDataSource.fetchUsers()
            
            // Cache ke local storage
            remoteUsers.forEach { user ->
                localDataSource.saveUser(user)
            }
            
            remoteUsers
        } catch (e: Exception) {
            // Jika remote gagal, ambil dari cache
            localDataSource.getAllUsers()
        }
    }

    override suspend fun getUserById(id: String): User? {
        return try {
            val remoteUser = remoteDataSource.fetchUserById(id)
            
            // Cache ke local storage
            localDataSource.saveUser(remoteUser)
            
            remoteUser
        } catch (e: Exception) {
            // Jika remote gagal, ambil dari cache
            localDataSource.getUserById(id)
        }
    }

    override suspend fun saveUser(user: User) {
        // Simpan ke remote dan local
        remoteDataSource.createUser(user)
        localDataSource.saveUser(user)
    }

    override suspend fun updateUser(user: User) {
        // Update ke remote dan local
        remoteDataSource.updateUser(user)
        localDataSource.saveUser(user)
    }

    override suspend fun deleteUser(id: String) {
        // Hapus dari remote dan local
        remoteDataSource.deleteUser(id)
        localDataSource.deleteUser(id)
    }

    override fun getUsersStream(): Flow<List<User>> {
        return localDataSource.getAllUsersStream()
    }
}
```

### Data Sources (Remote):

**data/source/remote/UserRemoteDataSource.kt**
```kotlin
package com.example.cleanarchitecture.data.source.remote

import com.example.cleanarchitecture.data.dto.UserDto
import com.example.cleanarchitecture.data.mapper.toDomain
import com.example.cleanarchitecture.domain.model.User
import retrofit2.http.*

/**
 * Data source untuk pengambilan data dari API
 */
interface UserRemoteDataSource {
    
    @GET("users")
    suspend fun fetchUsers(): List<UserDto>
    
    @GET("users/{id}")
    suspend fun fetchUserById(@Path("id") id: String): UserDto
    
    @POST("users")
    suspend fun createUser(@Body user: UserDto): UserDto
    
    @PUT("users/{id}")
    suspend fun updateUser(@Path("id") id: String, @Body user: UserDto): UserDto
    
    @DELETE("users/{id}")
    suspend fun deleteUser(@Path("id") id: String): Boolean
}

/**
 * Implementasi dari interface
 */
class UserRemoteDataSourceImpl(
    private val apiService: UserServiceApi
) : UserRemoteDataSource {
    
    override suspend fun fetchUsers(): List<UserDto> {
        return apiService.getUsers()
    }
    
    override suspend fun fetchUserById(id: String): UserDto {
        return apiService.getUserById(id)
    }
    
    override suspend fun createUser(user: UserDto): UserDto {
        return apiService.createUser(user)
    }
    
    override suspend fun updateUser(id: String, user: UserDto): UserDto {
        return apiService.updateUser(id, user)
    }
    
    override suspend fun deleteUser(id: String): Boolean {
        apiService.deleteUser(id)
        return true
    }
}
```

### Data Sources (Local):

**data/source/local/UserLocalDataSource.kt**
```kotlin
package com.example.cleanarchitecture.data.source.local

import com.example.cleanarchitecture.data.entity.UserEntity
import com.example.cleanarchitecture.data.mapper.toDomain
import com.example.cleanarchitecture.data.mapper.toEntity
import com.example.cleanarchitecture.domain.model.User
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

/**
 * Data source untuk pengelolaan data lokal
 */
interface UserLocalDataSource {
    suspend fun getAllUsers(): List<User>
    suspend fun getUserById(id: String): User?
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
    fun getAllUsersStream(): Flow<List<User>>
}

/**
 * Implementasi data source lokal menggunakan Room
 */
class UserLocalDataSourceImpl(
    private val userDao: UserDao
) : UserLocalDataSource {
    
    override suspend fun getAllUsers(): List<User> {
        return userDao.getAllUsers().map { it.toDomain() }
    }
    
    override suspend fun getUserById(id: String): User? {
        return userDao.getUserById(id)?.toDomain()
    }
    
    override suspend fun saveUser(user: User) {
        userDao.insertUser(user.toEntity())
    }
    
    override suspend fun deleteUser(id: String) {
        userDao.deleteUser(id)
    }
    
    override fun getAllUsersStream(): Flow<List<User>> {
        return userDao.getAllUsersStream().map { entities ->
            entities.map { it.toDomain() }
        }
    }
}
```

### DTOs & Entities:

**data/dto/UserDto.kt**
```kotlin
package com.example.cleanarchitecture.data.dto

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

/**
 * Data Transfer Object - untuk komunikasi API
 */
@Serializable
data class UserDto(
    @SerialName("id")
    val id: String,
    @SerialName("name")
    val name: String,
    @SerialName("email")
    val email: String,
    @SerialName("is_active")
    val isActive: Boolean,
    @SerialName("created_at")
    val createdAt: String,
    @SerialName("updated_at")
    val updatedAt: String
)
```

**data/entity/UserEntity.kt**
```kotlin
package com.example.cleanarchitecture.data.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Database Entity - untuk Room Database
 */
@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey
    val id: String,
    val name: String,
    val email: String,
    val isActive: Boolean = true,
    val createdAt: Long = System.currentTimeMillis(),
    val updatedAt: Long = System.currentTimeMillis()
)
```

### Mappers:

**data/mapper/UserMapper.kt**
```kotlin
package com.example.cleanarchitecture.data.mapper

import com.example.cleanarchitecture.data.dto.UserDto
import com.example.cleanarchitecture.data.entity.UserEntity
import com.example.cleanarchitecture.domain.model.User
import kotlinx.datetime.LocalDateTime
import kotlinx.datetime.toKotlinLocalDateTime

/**
 * Extension functions untuk mapping antar layer
 */
fun UserDto.toDomain(): User {
    return User(
        id = this.id,
        name = this.name,
        email = this.email,
        isActive = this.isActive,
        createdAt = LocalDateTime.parse(this.createdAt),  // Parsing timestamp
        updatedAt = LocalDateTime.parse(this.updatedAt)
    )
}

fun User.toEntity(): UserEntity {
    return UserEntity(
        id = this.id,
        name = this.name,
        email = this.email,
        isActive = this.isActive,
        createdAt = this.createdAt.toJavaLocalDateTime().toEpochSecond() * 1000,
        updatedAt = this.updatedAt.toJavaLocalDateTime().toEpochSecond() * 1000
    )
}

fun UserEntity.toDomain(): User {
    return User(
        id = this.id,
        name = this.name,
        email = this.email,
        isActive = this.isActive,
        createdAt = LocalDateTime.fromEpochMilliseconds(this.createdAt),
        updatedAt = LocalDateTime.fromEpochMilliseconds(this.updatedAt)
    )
}
```

### API Interface:

**data/api/UserServiceApi.kt**
```kotlin
package com.example.cleanarchitecture.data.api

import com.example.cleanarchitecture.data.dto.UserDto
import retrofit2.http.*

/**
 * API Service interface
 */
interface UserServiceApi {
    
    @GET("users")
    suspend fun getUsers(): List<UserDto>
    
    @GET("users/{id}")
    suspend fun getUserById(@Path("id") id: String): UserDto
    
    @POST("users")
    suspend fun createUser(@Body user: UserDto): UserDto
    
    @PUT("users/{id}")
    suspend fun updateUser(@Path("id") id: String, @Body user: UserDto): UserDto
    
    @DELETE("users/{id}")
    suspend fun deleteUser(@Path("id") id: String): UserDto
}
```

### ğŸ“ Penjelasan Konsep:
**Data Layer seperti Gudang Logistik:**
- **Pusat distribusi data** - mengatur arus data masuk dan keluar
- **Berbagai sumber** - API, Database, Preferences, Cache
- **Manajemen cache** - menyimpan data lokal untuk performa
- **Koordinasi antar sumber** - memilih sumber terbaik

**Karakteristik Data Layer:**
- **Framework dependent**: Boleh menggunakan teknologi eksternal
- **Mengimplementasi kontrak Domain**: Interface dari Domain Layer
- **Tidak tahu tentang UI**: Fokus hanya ke data management
- **Bergantung ke teknologi luar**: API, Database, Preferences

---

## 8ï¸âƒ£ Mapping Antar Lapisan ğŸ”—

### Konsep Dasar
Mapping seperti penerjemah bahasa ğŸ—£ï¸ - mengubah data dari satu format ke format lain sesuai kebutuhan masing-masing lapisan!

### Jenis-jenis Mapping dalam Clean Architecture:

```
API DTO â†’ Data Entity â†’ Domain Model â†’ UI Model
  (Remote)   (Local)     (Core)      (Presentation)
```

### Alur Mapping Lengkap:

**data/mapper/UserMapper.kt**
```kotlin
package com.example.cleanarchitecture.data.mapper

import com.example.cleanarchitecture.data.dto.UserDto
import com.example.cleanarchitecture.data.entity.UserEntity
import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.presentation.home.UserItemUiModel

/**
 * Mapper komplit untuk User dari API ke UI
 */
object UserMapper {
    
    /**
     * Mapping dari API DTO ke Domain Model
     */
    fun UserDto.toDomain(): User {
        return User(
            id = this.id,
            name = this.name,
            email = this.email,
            isActive = this.isActive,
            createdAt = parseTimestamp(this.createdAt),
            updatedAt = parseTimestamp(this.updatedAt)
        )
    }
    
    /**
     * Mapping dari Domain Model ke Database Entity
     */
    fun User.toEntity(): UserEntity {
        return UserEntity(
            id = this.id,
            name = this.name,
            email = this.email,
            isActive = this.isActive,
            createdAt = this.createdAt.toEpochMilliseconds(),
            updatedAt = this.updatedAt.toEpochMilliseconds()
        )
    }
    
    /**
     * Mapping dari Database Entity ke Domain Model
     */
    fun UserEntity.toDomain(): User {
        return User(
            id = this.id,
            name = this.name,
            email = this.email,
            isActive = this.isActive,
            createdAt = LocalDateTime.fromEpochMilliseconds(this.createdAt),
            updatedAt = LocalDateTime.fromEpochMilliseconds(this.updatedAt)
        )
    }
    
    /**
     * Mapping dari Domain Model ke UI Model
     */
    fun User.toUiModel(): UserItemUiModel {
        return UserItemUiModel(
            id = this.id,
            name = this.name,
            email = this.email,
            isActive = this.isActive,
            initials = this.name.take(1).uppercase(),
            statusColor = if (this.isActive) "green" else "red"
        )
    }
    
    /**
     * Mapping dari list DTO ke list Domain
     */
    fun List<UserDto>.toDomainList(): List<User> {
        return this.map { it.toDomain() }
    }
    
    /**
     * Mapping dari list Domain ke list Entity
     */
    fun List<User>.toEntityList(): List<UserEntity> {
        return this.map { it.toEntity() }
    }
    
    /**
     * Mapping dari list Entity ke list Domain
     */
    fun List<UserEntity>.toDomainList(): List<User> {
        return this.map { it.toDomain() }
    }
    
    /**
     * Mapping dari list Domain ke list UI Model
     */
    fun List<User>.toUiModelList(): List<UserItemUiModel> {
        return this.map { it.toUiModel() }
    }
}
```

### Mapper untuk Produk:

**data/mapper/ProductMapper.kt**
```kotlin
package com.example.cleanarchitecture.data.mapper

import com.example.cleanarchitecture.data.dto.ProductDto
import com.example.cleanarchitecture.data.entity.ProductEntity
import com.example.cleanarchitecture.domain.model.Product
import com.example.cleanarchitecture.domain.model.ProductCategory

/**
 * Mapper untuk Product
 */
fun ProductDto.toDomain(): Product {
    return Product(
        id = this.id,
        name = this.name,
        description = this.description,
        price = this.price,
        category = mapCategoryFromDto(this.category_id),
        imageUrl = this.image_url,
        rating = this.rating,
        inStock = this.in_stock
    )
}

fun Product.toEntity(): ProductEntity {
    return ProductEntity(
        id = this.id,
        name = this.name,
        description = this.description,
        price = this.price,
        categoryId = this.category.ordinal,
        imageUrl = this.imageUrl,
        rating = this.rating,
        inStock = this.inStock
    )
}

fun ProductEntity.toDomain(): Product {
    return Product(
        id = this.id,
        name = this.name,
        description = this.description,
        price = this.price,
        category = mapCategoryFromEntity(this.categoryId),
        imageUrl = this.imageUrl,
        rating = this.rating,
        inStock = this.inStock
    )
}

private fun mapCategoryFromDto(categoryId: Int): ProductCategory {
    return ProductCategory.values()[categoryId]
}

private fun mapCategoryFromEntity(categoryId: Int): ProductCategory {
    return ProductCategory.values()[categoryId]
}
```

### Mapping dengan Error Handling:

**data/mapper/ResultMapper.kt**
```kotlin
package com.example.cleanarchitecture.data.mapper

import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.data.dto.UserDto

/**
 * Mapper dengan error handling
 */
object ResultMapper {
    
    fun safeMapUserDtoToDomain(dto: UserDto?): Result<User> {
        return try {
            if (dto == null) {
                Result.failure(Exception("User DTO is null"))
            } else {
                Result.success(dto.toDomain())
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    fun <T> safeMapToList(
        dtos: List<T>?,
        mapper: (T) -> User
    ): Result<List<User>> {
        return try {
            if (dtos == null) {
                Result.success(emptyList())
            } else {
                val mapped = dtos.map(mapper)
                Result.success(mapped)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### Mapper Sebagai Extension Functions:

**extensions/UserExtensions.kt**
```kotlin
package com.example.cleanarchitecture.extensions

import com.example.cleanarchitecture.data.dto.UserDto
import com.example.cleanarchitecture.data.entity.UserEntity
import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.presentation.home.UserItemUiModel

/**
 * Extension functions untuk mapping
 */
fun UserDto.toDomainModel(): User {
    return User(
        id = this.id,
        name = this.name,
        email = this.email,
        isActive = this.isActive,
        createdAt = LocalDateTime.parse(this.createdAt),
        updatedAt = LocalDateTime.parse(this.updatedAt)
    )
}

fun User.toUiModel(): UserItemUiModel {
    return UserItemUiModel(
        id = this.id,
        name = this.name,
        email = this.email,
        isActive = this.isActive,
        initials = this.name.take(1).uppercase(),
        statusColor = if (this.isActive) "#4CAF50" else "#F44336"
    )
}

fun List<UserDto>.toDomainModels(): List<User> {
    return this.map { it.toDomainModel() }
}

fun List<User>.toUiModels(): List<UserItemUiModel> {
    return this.map { it.toUiModel() }
}
```

### ğŸ“ Penjelasan Konsep:
**Mapping seperti Penerjemah:**
- **Menerjemahkan data** dari format satu ke format lain
- **Setiap lapisan punya kebutuhan format berbeda**
- **Menjaga independensi antar lapisan**
- **Memisahkan perhatian (separation of concerns)**

**Jenis Mapping:**
- **DTO â†’ Domain**: Dari API ke bisnis model
- **Domain â†’ Entity**: Dari bisnis model ke database
- **Entity â†’ Domain**: Dari database ke bisnis model
- **Domain â†’ UI**: Dari bisnis model ke tampilan

---

## 9ï¸âƒ£ Testing di Clean Architecture ğŸ§ª

### Konsep Dasar
Testing dalam Clean Architecture seperti sistem quality assurance ğŸ›¡ï¸ - memastikan setiap bagian berfungsi sesuai harapan secara independen!

### Testing Strategy Per Layer:

```
Domain Layer â†’ Unit Tests (Pure Logic)
Data Layer â†’ Repository & Data Source Tests
Presentation â†’ ViewModel & UI Tests
```

### Domain Layer Testing:

**domain/usecase/GetUsersUseCaseTest.kt**
```kotlin
package com.example.cleanarchitecture.domain.usecase

import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.repository.UserRepository
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.mockk
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class GetUsersUseCaseTest {
    
    private val mockRepository = mockk<UserRepository>()
    private val useCase = GetUsersUseCase(mockRepository)
    
    @Test
    fun `should return users from repository when invoked`() = runTest {
        // Given
        val expectedUsers = listOf(
            User("1", "John Doe", "john@example.com"),
            User("2", "Jane Smith", "jane@example.com")
        )
        
        coEvery { mockRepository.getUsers() } returns expectedUsers
        
        // When
        val result = useCase()
        
        // Then
        assertEquals(expectedUsers, result)
        coVerify { mockRepository.getUsers() }
    }
    
    @Test
    fun `should filter active users only`() = runTest {
        // Given
        val allUsers = listOf(
            User("1", "John Doe", "john@example.com", isActive = true),
            User("2", "Jane Smith", "jane@example.com", isActive = false),
            User("3", "Bob Johnson", "bob@example.com", isActive = true)
        )
        
        coEvery { mockRepository.getUsers() } returns allUsers
        
        // When
        val result = useCase()
        
        // Then
        assertTrue(result.size == 2)
        assertTrue(result.all { it.isActive })
    }
}
```

### Data Layer Testing:

**data/repository/UserRepositoryImplTest.kt**
```kotlin
package com.example.cleanarchitecture.data.repository

import com.example.cleanarchitecture.data.source.local.UserLocalDataSource
import com.example.cleanarchitecture.data.source.remote.UserRemoteDataSource
import com.example.cleanarchitecture.domain.model.User
import io.mockk.*
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals

class UserRepositoryImplTest {
    
    private val mockRemoteDataSource = mockk<UserRemoteDataSource>()
    private val mockLocalDataSource = mockk<UserLocalDataSource>()
    private val repository = UserRepositoryImpl(mockRemoteDataSource, mockLocalDataSource)
    
    @Test
    fun `should fetch users from remote and cache to local when successful`() = runTest {
        // Given
        val remoteUsers = listOf(
            User("1", "John", "john@example.com")
        )
        
        coEvery { mockRemoteDataSource.fetchUsers() } returns remoteUsers
        coEvery { mockLocalDataSource.saveUser(any()) } just runs
        
        // When
        val result = repository.getUsers()
        
        // Then
        assertEquals(remoteUsers, result)
        coVerify { mockRemoteDataSource.fetchUsers() }
        coVerify { mockLocalDataSource.saveUser(any()) }
    }
    
    @Test
    fun `should return cached users when remote fails`() = runTest {
        // Given
        val cachedUsers = listOf(
            User("2", "Cached", "cached@example.com")
        )
        
        coEvery { mockRemoteDataSource.fetchUsers() } throws Exception("Network error")
        coEvery { mockLocalDataSource.getAllUsers() } returns cachedUsers
        
        // When
        val result = repository.getUsers()
        
        // Then
        assertEquals(cachedUsers, result)
        coVerify { mockLocalDataSource.getAllUsers() }
    }
}
```

### Presentation Layer Testing (ViewModel):

**presentation/home/HomeViewModelTest.kt**
```kotlin
package com.example.cleanarchitecture.presentation.home

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.usecase.GetUsersUseCase
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.test.*
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals

class HomeViewModelTest {
    
    @get:Rule
    val instantTaskExecutorRule = InstantTaskExecutorRule()
    
    private val mockGetUsersUseCase = mockk<GetUsersUseCase>()
    private lateinit var viewModel: HomeViewModel
    
    private val testDispatcher = TestCoroutineDispatcher()
    private val testScope = TestScope(testDispatcher)
    
    @BeforeEach
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        viewModel = HomeViewModel(mockGetUsersUseCase)
    }
    
    @AfterEach
    fun tearDown() {
        Dispatchers.resetMain()
        testDispatcher.cleanupTestCoroutines()
    }
    
    @Test
    fun `should update users state when loadUsers is successful`() = testScope.runTest {
        // Given
        val users = listOf(
            User("1", "John", "john@example.com"),
            User("2", "Jane", "jane@example.com")
        )
        
        coEvery { mockGetUsersUseCase() } returns users
        
        // When
        viewModel.loadUsers()
        
        // Then
        // Note: In real implementation, you would collect the StateFlow
        // and verify the values, but for simplicity we're testing the call
        coVerify { mockGetUsersUseCase() }
    }
}
```

### Repository Interface Testing:

**domain/repository/UserRepositoryTest.kt**
```kotlin
package com.example.cleanarchitecture.domain.repository

import com.example.cleanarchitecture.domain.model.User
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.mockk
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals
import kotlin.test.assertNull

class UserRepositoryTest {
    
    private val repository = mockk<UserRepository>()
    
    @Test
    fun `should return user when getUserById is called`() = runTest {
        // Given
        val userId = "1"
        val expectedUser = User(userId, "John", "john@example.com")
        
        coEvery { repository.getUserById(userId) } returns expectedUser
        
        // When
        val result = repository.getUserById(userId)
        
        // Then
        assertEquals(expectedUser, result)
        coVerify { repository.getUserById(userId) }
    }
    
    @Test
    fun `should return null when user not found`() = runTest {
        // Given
        val userId = "invalid"
        
        coEvery { repository.getUserById(userId) } returns null
        
        // When
        val result = repository.getUserById(userId)
        
        // Then
        assertNull(result)
    }
}
```

### Dependency Injection untuk Testing:

**Hilt Testing Module**
```kotlin
package com.example.cleanarchitecture.di

import com.example.cleanarchitecture.domain.repository.UserRepository
import dagger.Module
import dagger.Provides
import dagger.hilt.components.SingletonComponent
import dagger.hilt.testing.TestInstallIn
import io.mockk.mockk
import javax.inject.Singleton

@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RepositoryModule::class]
)
object TestRepositoryModule {
    
    @Provides
    @Singleton
    fun provideUserRepository(): UserRepository = mockk()
}
```

### ğŸ“ Penjelasan Konsep:
**Testing dalam Clean Architecture seperti QA:**
- **Domain Layer**: Testing logika murni tanpa dependensi
- **Data Layer**: Testing manajemen data dan caching
- **Presentation Layer**: Testing UI state dan event handling
- **Independen**: Bisa test masing-masing layer sendiri

**Keunggulan Testing di Clean Architecture:**
- **Modular**: Bisa test setiap bagian secara terpisah
- **Pure Logic**: Domain bisa diuji tanpa framework
- **Mockable**: Mudah mock dependensi
- **Maintainable**: Test tidak rusak saat ganti UI/Database

---

## 1ï¸âƒ£0ï¸âƒ£ Best Practices âœ¨

### Konsep Dasar
Best Practices seperti kode etik pengembangan software ğŸ‘¨â€ğŸ’» - aturan dan pedoman yang memastikan kualitas arsitektur Clean tetap terjaga!

### 1. Naming Convention:

**domain/usecase/GetUserByIdUseCase.kt**
```kotlin
package com.example.cleanarchitecture.domain.usecase

import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.repository.UserRepository

/**
 * Use Case diakhiri dengan "UseCase"
 * Nama deskriptif dan single responsibility
 */
class GetUserByIdUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): User? {
        return userRepository.getUserById(userId)
    }
}
```

### 2. Single Responsibility:

**domain/usecase/SeparateUseCases.kt**
```kotlin
package com.example.cleanarchitecture.domain.usecase

// âŒ SALAH: Use case terlalu banyak tanggung jawab
class UserManagementUseCase {
    // Banyak method dalam satu kelas
}

// âœ… BENAR: Pemisahan tanggung jawab
class GetUsersUseCase(
    private val repository: UserRepository
) {
    suspend operator fun invoke() = repository.getUsers()
}

class SaveUserUseCase(
    private val repository: UserRepository
) {
    suspend operator fun invoke(user: User) = repository.saveUser(user)
}

class DeleteUserUseCase(
    private val repository: UserRepository
) {
    suspend operator fun invoke(userId: String) = repository.deleteUser(userId)
}
```

### 3. Error Handling:

**domain/usecase/UseCaseWithErrorHandling.kt**
```kotlin
package com.example.cleanarchitecture.domain.usecase

import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.repository.UserRepository
import com.example.cleanarchitecture.util.Result

/**
 * Gunakan Result type untuk error handling
 */
class GetUserWithErrorHandlingUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String): Result<User?> {
        return try {
            val user = userRepository.getUserById(userId)
            Result.success(user)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### 4. Dependency Injection:

**di/RepositoryModule.kt**
```kotlin
package com.example.cleanarchitecture.di

import com.example.cleanarchitecture.data.repository.UserRepositoryImpl
import com.example.cleanarchitecture.data.source.local.UserLocalDataSource
import com.example.cleanarchitecture.data.source.remote.UserRemoteDataSource
import com.example.cleanarchitecture.domain.repository.UserRepository
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {
    
    @Provides
    @Singleton
    fun provideUserRepository(
        remoteDataSource: UserRemoteDataSource,
        localDataSource: UserLocalDataSource
    ): UserRepository {
        return UserRepositoryImpl(remoteDataSource, localDataSource)
    }
}
```

### 5. Testing Best Practices:

**domain/usecase/GetUsersUseCase.kt**
```kotlin
package com.example.cleanarchitecture.domain.usecase

import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.repository.UserRepository

/**
 * Use Case dengan interface parameter untuk testing
 */
class GetUsersUseCase(
    private val userRepository: UserRepository  // Gunakan interface, bukan concrete class
) {
    suspend operator fun invoke(): List<User> {
        return userRepository.getUsers()
    }
}
```

### 6. Package Structure:

```
app/src/main/java/com/example/cleanarchitecture/
â”œâ”€â”€ di/                     # Dependency Injection modules
â”‚   â”œâ”€â”€ RepositoryModule.kt
â”‚   â””â”€â”€ NetworkModule.kt
â”œâ”€â”€ domain/                 # Domain layer
â”‚   â”œâ”€â”€ model/             # Domain models
â”‚   â”œâ”€â”€ repository/        # Repository interfaces
â”‚   â””â”€â”€ usecase/           # Use cases
â”œâ”€â”€ data/                   # Data layer
â”‚   â”œâ”€â”€ repository/        # Repository implementations
â”‚   â”œâ”€â”€ source/            # Data sources
â”‚   â”‚   â”œâ”€â”€ local/         # Local data source
â”‚   â”‚   â””â”€â”€ remote/        # Remote data source
â”‚   â”œâ”€â”€ entity/            # Database entities
â”‚   â”œâ”€â”€ dto/               # API DTOs
â”‚   â””â”€â”€ mapper/            # Mapper functions
â””â”€â”€ presentation/           # Presentation layer
    â”œâ”€â”€ home/              # Home feature
    â”œâ”€â”€ profile/           # Profile feature
    â”œâ”€â”€ common/            # Common UI components
    â””â”€â”€ theme/             # Compose themes
```

### 7. Data Flow Pattern:

**presentation/home/HomeViewModel.kt**
```kotlin
package com.example.cleanarchitecture.presentation.home

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.cleanarchitecture.domain.model.User
import com.example.cleanarchitecture.domain.usecase.GetUsersUseCase
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

/**
 * Pattern flow dalam ViewModel
 */
class HomeViewModel(
    private val getUsersUseCase: GetUsersUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(HomeUiState())
    val uiState: StateFlow<HomeUiState> = _uiState.asStateFlow()

    init {
        loadUsers()
    }

    private fun loadUsers() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }
            
            try {
                val users = getUsersUseCase()
                _uiState.update { 
                    it.copy(
                        users = users,
                        isLoading = false,
                        error = null
                    ) 
                }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        error = e.message
                    ) 
                }
            }
        }
    }
}

data class HomeUiState(
    val users: List<User> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)
```

### 8. Validation in Domain:

**domain/validation/UserValidator.kt**
```kotlin
package com.example.cleanarchitecture.domain.validation

/**
 * Validator di domain layer
 */
object UserValidator {
    
    fun validateEmail(email: String): ValidationResult {
        // Validasi di domain layer
        return if (email.isBlank() || !email.contains("@")) {
            ValidationResult.Invalid("Email tidak valid")
        } else {
            ValidationResult.Valid
        }
    }
    
    sealed class ValidationResult {
        object Valid : ValidationResult()
        data class Invalid(val message: String) : ValidationResult()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Best Practices seperti Kode Etik:**
- **Menjaga kualitas dan konsistensi**
- **Mudah dipelihara dan dikembangkan**
- **Meningkatkan kolaborasi tim**
- **Mencegah masalah di masa depan**

**Implementasi yang baik:**
- **Konsisten dengan naming convention**
- **Modular dan single responsibility**
- **Error handling yang baik**
- **Testing yang komprehensif**

---

## 1ï¸âƒ£1ï¸âƒ£ Hands-on Project ğŸ”¨

### Konsep Dasar
Hands-on Project seperti ujian akhir ğŸ“ - implementasi lengkap Clean Architecture dalam aplikasi nyata!

### Project: Task Management App

**Struktur Proyek Lengkap:**

```
taskmanager/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ src/main/
â”‚   â”‚   â”œâ”€â”€ java/com/example/taskmanager/
â”‚   â”‚   â”‚   â”œâ”€â”€ di/                 # Dependency injection
â”‚   â”‚   â”‚   â”œâ”€â”€ domain/             # Domain layer
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ model/          # Task model
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ repository/     # Repository interfaces
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ usecase/        # Use cases
â”‚   â”‚   â”‚   â”œâ”€â”€ data/               # Data layer
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ repository/     # Repository implementations
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ source/         # Data sources
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ local/      # Room database
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ remote/     # API (optional)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ entity/         # Database entities
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dto/            # API DTOs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ mapper/         # Mapping functions
â”‚   â”‚   â”‚   â””â”€â”€ presentation/       # Presentation layer
â”‚   â”‚   â”‚       â”œâ”€â”€ task/           # Task feature
â”‚   â”‚   â”‚       â”œâ”€â”€ common/         # Common components
â”‚   â”‚   â”‚       â””â”€â”€ theme/          # Compose themes
â”‚   â”‚   â””â”€â”€ res/
â”‚   â””â”€â”€ build.gradle.kts
â”œâ”€â”€ build.gradle.kts
â””â”€â”€ settings.gradle.kts
```

### Domain Layer Implementasi:

**domain/model/Task.kt**
```kotlin
package com.example.taskmanager.domain.model

import kotlinx.datetime.LocalDateTime

/**
 * Domain model untuk Task
 */
data class Task(
    val id: String = "",
    val title: String,
    val description: String,
    val priority: Priority,
    val status: Status,
    val dueDate: LocalDateTime?,
    val createdAt: LocalDateTime = LocalDateTime.now(),
    val updatedAt: LocalDateTime = LocalDateTime.now()
) {
    enum class Priority {
        LOW, MEDIUM, HIGH
    }
    
    enum class Status {
        TODO, IN_PROGRESS, COMPLETED
    }
    
    fun isOverdue(currentTime: LocalDateTime = LocalDateTime.now()): Boolean {
        return dueDate != null && dueDate < currentTime && status != Status.COMPLETED
    }
}
```

**domain/usecase/GetTasksUseCase.kt**
```kotlin
package com.example.taskmanager.domain.usecase

import com.example.taskmanager.domain.model.Task
import com.example.taskmanager.domain.repository.TaskRepository

/**
 * Use case untuk mendapatkan semua task
 */
class GetTasksUseCase(
    private val taskRepository: TaskRepository
) {
    suspend operator fun invoke(): List<Task> {
        return taskRepository.getTasks()
    }
}
```

**domain/usecase/CreateTaskUseCase.kt**
```kotlin
package com.example.taskmanager.domain.usecase

import com.example.taskmanager.domain.model.Task
import com.example.taskmanager.domain.repository.TaskRepository
import com.example.taskmanager.domain.validation.TaskValidator

/**
 * Use case untuk membuat task baru dengan validasi
 */
class CreateTaskUseCase(
    private val taskRepository: TaskRepository,
    private val validator: TaskValidator = TaskValidator
) {
    suspend operator fun invoke(task: Task): Result<Unit> {
        return try {
            if (task.title.isBlank()) {
                return Result.failure(Exception("Title tidak boleh kosong"))
            }
            
            taskRepository.saveTask(task.copy(id = generateTaskId()))
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private fun generateTaskId(): String {
        return "task_${System.currentTimeMillis()}"
    }
}
```

### Data Layer Implementasi:

**data/repository/TaskRepositoryImpl.kt**
```kotlin
package com.example.taskmanager.data.repository

import com.example.taskmanager.data.source.local.TaskLocalDataSource
import com.example.taskmanager.domain.model.Task
import com.example.taskmanager.domain.repository.TaskRepository
import kotlinx.coroutines.flow.Flow

/**
 * Implementasi TaskRepository
 */
class TaskRepositoryImpl(
    private val localDataSource: TaskLocalDataSource
) : TaskRepository {
    
    override suspend fun getTasks(): List<Task> {
        return localDataSource.getAllTasks()
    }
    
    override suspend fun getTaskById(id: String): Task? {
        return localDataSource.getTaskById(id)
    }
    
    override suspend fun saveTask(task: Task) {
        localDataSource.saveTask(task)
    }
    
    override suspend fun updateTask(task: Task) {
        localDataSource.updateTask(task)
    }
    
    override suspend fun deleteTask(id: String) {
        localDataSource.deleteTask(id)
    }
    
    override fun getTasksStream(): Flow<List<Task>> {
        return localDataSource.getTasksStream()
    }
}
```

### Presentation Layer Implementasi:

**presentation/task/TaskViewModel.kt**
```kotlin
package com.example.taskmanager.presentation.task

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.taskmanager.domain.model.Task
import com.example.taskmanager.domain.usecase.CreateTaskUseCase
import com.example.taskmanager.domain.usecase.GetTasksUseCase
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

/**
 * ViewModel untuk task management
 */
class TaskViewModel(
    private val getTasksUseCase: GetTasksUseCase,
    private val createTaskUseCase: CreateTaskUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(TaskUiState())
    val uiState: StateFlow<TaskUiState> = _uiState.asStateFlow()
    
    private val _formState = MutableStateFlow(TaskFormState())
    val formState: StateFlow<TaskFormState> = _formState.asStateFlow()
    
    init {
        loadTasks()
    }
    
    private fun loadTasks() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            try {
                val tasks = getTasksUseCase()
                _uiState.update { 
                    it.copy(
                        tasks = tasks,
                        isLoading = false,
                        error = null
                    ) 
                }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        error = e.message
                    ) 
                }
            }
        }
    }
    
    fun createTask() {
        viewModelScope.launch {
            val task = Task(
                title = _formState.value.title,
                description = _formState.value.description,
                priority = _formState.value.priority,
                status = Task.Status.TODO,
                dueDate = _formState.value.dueDate
            )
            
            createTaskUseCase(task).onSuccess {
                // Reset form dan reload tasks
                _formState.value = TaskFormState()
                loadTasks()
            }.onFailure { error ->
                _uiState.update { 
                    it.copy(error = error.message) 
                }
            }
        }
    }
    
    fun updateFormTitle(title: String) {
        _formState.update { it.copy(title = title) }
    }
    
    fun updateFormDescription(description: String) {
        _formState.update { it.copy(description = description) }
    }
    
    fun updateFormPriority(priority: Task.Priority) {
        _formState.update { it.copy(priority = priority) }
    }
    
    fun updateFormDueDate(dueDate: LocalDateTime?) {
        _formState.update { it.copy(dueDate = dueDate) }
    }
}

data class TaskUiState(
    val tasks: List<Task> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)

data class TaskFormState(
    val title: String = "",
    val description: String = "",
    val priority: Task.Priority = Task.Priority.MEDIUM,
    val dueDate: LocalDateTime? = null
)
```

**presentation/task/TaskScreen.kt**
```kotlin
package com.example.taskmanager.presentation.task

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

/**
 * Composable screen untuk task management
 */
@Composable
fun TaskScreen(
    viewModel: TaskViewModel,
    modifier: Modifier = Modifier
) {
    val uiState by viewModel.uiState.collectAsState()
    val formState by viewModel.formState.collectAsState()
    
    Column(
        modifier = modifier.fillMaxSize()
    ) {
        // Create Task Form
        TaskForm(
            formState = formState,
            onTitleChange = { viewModel.updateFormTitle(it) },
            onDescriptionChange = { viewModel.updateFormDescription(it) },
            onPriorityChange = { viewModel.updateFormPriority(it) },
            onCreateTask = { viewModel.createTask() }
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // Task List
        if (uiState.isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else {
            LazyColumn(
                contentPadding = PaddingValues(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(uiState.tasks) { task ->
                    TaskItem(task = task)
                }
            }
        }
    }
}

@Composable
fun TaskForm(
    formState: TaskFormState,
    onTitleChange: (String) -> Unit,
    onDescriptionChange: (String) -> Unit,
    onPriorityChange: (com.example.taskmanager.domain.model.Task.Priority) -> Unit,
    onCreateTask: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            // Title Field
            OutlinedTextField(
                value = formState.title,
                onValueChange = onTitleChange,
                label = { Text("Judul Task") },
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Description Field
            OutlinedTextField(
                value = formState.description,
                onValueChange = onDescriptionChange,
                label = { Text("Deskripsi") },
                modifier = Modifier.fillMaxWidth(),
                maxLines = 3
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Priority Selector
            PrioritySelector(
                selected = formState.priority,
                onSelectionChange = onPriorityChange
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Create Button
            Button(
                onClick = onCreateTask,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Buat Task")
            }
        }
    }
}

@Composable
fun PrioritySelector(
    selected: com.example.taskmanager.domain.model.Task.Priority,
    onSelectionChange: (com.example.taskmanager.domain.model.Task.Priority) -> Unit
) {
    Row(
        modifier = Modifier.fillMaxWidth()
    ) {
        com.example.taskmanager.domain.model.Task.Priority.values().forEach { priority ->
            FilterChip(
                selected = selected == priority,
                onClick = { onSelectionChange(priority) },
                label = { Text(priority.name) }
            )
            Spacer(modifier = Modifier.width(8.dp))
        }
    }
}

@Composable
fun TaskItem(task: com.example.taskmanager.domain.model.Task) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = task.title,
                    style = MaterialTheme.typography.titleMedium
                )
                Text(
                    text = task.description,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Text(
                    text = "Priority: ${task.priority.name}",
                    style = MaterialTheme.typography.bodySmall
                )
            }
            
            Icon(
                imageVector = when (task.status) {
                    com.example.taskmanager.domain.model.Task.Status.COMPLETED -> Icons.Default.CheckCircle
                    else -> Icons.Default.Circle
                },
                contentDescription = "Status",
                tint = when (task.status) {
                    com.example.taskmanager.domain.model.Task.Status.COMPLETED -> MaterialTheme.colorScheme.primary
                    else -> MaterialTheme.colorScheme.outline
                }
            )
        }
    }
}
```

### ğŸ“ Penjelasan Implementasi:
**Proyek Task Manager menerapkan:**
- **Clean Architecture secara penuh**
- **Dependency Rule terjaga**
- **Testing mudah dilakukan**
- **Modular dan scalable**
- **Best practices diikuti**

---

## ğŸ¯ Kesimpulan

Clean Architecture adalah pendekatan arsitektur perangkat lunak yang memberikan struktur kuat dan fleksibel untuk pengembangan aplikasi Android. Dengan memisahkan aplikasi menjadi beberapa lapisan dengan aturan ketergantungan yang jelas, Clean Architecture memberikan sejumlah keunggulan:

### Keunggulan Utama:
1. **Testability**: Logika bisnis bisa diuji tanpa framework eksternal
2. **Maintainability**: Perubahan di satu lapisan tidak mempengaruhi lapisan lain
3. **Scalability**: Aplikasi bisa berkembang tanpa merusak struktur inti
4. **Independence**: Tidak terikat pada framework atau teknologi tertentu
5. **Separation of Concerns**: Setiap lapisan memiliki tanggung jawab jelas

### Tantangan:
- Lebih banyak boilerplate code
- Kurva belajar lebih curam
- Kurang efisien untuk aplikasi sederhana
- Waktu setup lebih lama

Clean Architecture paling cocok untuk aplikasi berskala menengah hingga besar yang memerlukan pengembangan jangka panjang. Untuk aplikasi sederhana, pendekatan lebih langsung mungkin lebih efisien.

Dengan memahami dan menerapkan Clean Architecture dengan benar, developer bisa membangun aplikasi Android yang kuat, mudah dipelihara, dan siap untuk pertumbuhan di masa depan.