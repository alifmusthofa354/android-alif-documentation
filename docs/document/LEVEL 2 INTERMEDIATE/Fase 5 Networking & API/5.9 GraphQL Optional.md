## **5.9 GraphQL (Optional)** (4 hari) ⭐

### **Teknologi Modern:**
- Apollo Client 4
- Queries
- Mutations

### **Teknologi yang Ditinggalkan:**
- REST only

### **Sub-topik Detail:**

#### 1. GraphQL vs REST

**REST Challenges:**
- Over-fetching (too much data)
- Under-fetching (multiple requests)
- Multiple endpoints
- Versioning issues

**GraphQL Advantages:**
✅ Single endpoint
✅ Request exactly what you need
✅ No over/under-fetching
✅ Strong typing
✅ Self-documenting
✅ Real-time with subscriptions

**Example Comparison:**
```
REST:
GET /users/123
GET /users/123/posts
GET /users/123/followers

GraphQL:
POST /graphql
{
  user(id: "123") {
    name
    posts { title }
    followers { name }
  }
}
```

#### 2. GraphQL Basics

**Schema Definition:**
```graphql
type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post!]!
  createdAt: String!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  likes: Int!
}

type Query {
  user(id: ID!): User
  users: [User!]!
  post(id: ID!): Post
  posts(limit: Int, offset: Int): [Post!]!
}

type Mutation {
  createUser(name: String!, email: String!): User!
  updateUser(id: ID!, name: String): User!
  deleteUser(id: ID!): Boolean!
  createPost(title: String!, content: String!): Post!
  likePost(id: ID!): Post!
}

type Subscription {
  postAdded: Post!
  userUpdated(id: ID!): User!
}
```

**Query Example:**
```graphql
query GetUser {
  user(id: "123") {
    name
    email
    posts {
      title
      likes
    }
  }
}
```

**Mutation Example:**
```graphql
mutation CreatePost {
  createPost(
    title: "My First Post"
    content: "Hello World!"
  ) {
    id
    title
    createdAt
  }
}
```

#### 3. Setup Apollo Client

**Dependencies:**
```kotlin
dependencies {
    // Apollo GraphQL
    implementation("com.apollographql.apollo3:apollo-runtime:4.0.0")
    
    // Coroutines support
    implementation("com.apollographql.apollo3:apollo-normalized-cache:4.0.0")
    
    // Optional: SQLite cache
    implementation("com.apollographql.apollo3:apollo-normalized-cache-sqlite:4.0.0")
}

plugins {
    id("com.apollographql.apollo3") version "4.0.0"
}

// Configure Apollo
apollo {
    service("service") {
        packageName.set("com.example.graphql")
        
        // Schema location
        schemaFile.set(file("src/main/graphql/schema.graphqls"))
        
        // Generate Kotlin models
        generateKotlinModels.set(true)
    }
}
```

**Create Apollo Client:**
```kotlin
object ApolloClientProvider {
    private const val BASE_URL = "https://api.example.com/graphql"
    
    val apolloClient: ApolloClient by lazy {
        ApolloClient.Builder()
            .serverUrl(BASE_URL)
            .addHttpHeader("Authorization", "Bearer $token")
            .build()
    }
}
```

#### 4. Writing GraphQL Queries

**Create `.graphql` file:**
```graphql
# GetUsers.graphql
query GetUsers {
  users {
    id
    name
    email
  }
}

# GetUserById.graphql
query GetUserById($id: ID!) {
  user(id: $id) {
    id
    name
    email
    posts {
      id
      title
      likes
    }
  }
}

# GetPosts.graphql
query GetPosts($limit: Int, $offset: Int) {
  posts(limit: $limit, offset: $offset) {
    id
    title
    content
    author {
      name
    }
    likes
  }
}
```

**Execute Query:**
```kotlin
class UserRepository(
    private val apolloClient: ApolloClient
) {
    suspend fun getUsers(): List<User> {
        val response = apolloClient
            .query(GetUsersQuery())
            .execute()
        
        return response.data?.users?.map { user ->
            User(
                id = user.id,
                name = user.name,
                email = user.email
            )
        } ?: emptyList()
    }
    
    suspend fun getUserById(userId: String): User? {
        val response = apolloClient
            .query(GetUserByIdQuery(id = userId))
            .execute()
        
        return response.data?.user?.let { user ->
            User(
                id = user.id,
                name = user.name,
                email = user.email,
                posts = user.posts.map { post ->
                    Post(
                        id = post.id,
                        title = post.title,
                        likes = post.likes
                    )
                }
            )
        }
    }
}
```

#### 5. GraphQL Mutations

**Define Mutations:**
```graphql
# CreateUser.graphql
mutation CreateUser($name: String!, $email: String!) {
  createUser(name: $name, email: $email) {
    id
    name
    email
    createdAt
  }
}

# UpdateUser.graphql
mutation UpdateUser($id: ID!, $name: String) {
  updateUser(id: $id, name: $name) {
    id
    name
    email
  }
}

# CreatePost.graphql
mutation CreatePost($title: String!, $content: String!) {
  createPost(title: $title, content: $content) {
    id
    title
    content
    author {
      name
    }
  }
}

# LikePost.graphql
mutation LikePost($id: ID!) {
  likePost(id: $id) {
    id
    likes
  }
}
```

**Execute Mutations:**
```kotlin
suspend fun createUser(name: String, email: String): User? {
    val response = apolloClient
        .mutation(CreateUserMutation(name = name, email = email))
        .execute()
    
    return response.data?.createUser?.let { user ->
        User(
            id = user.id,
            name = user.name,
            email = user.email
        )
    }
}

suspend fun likePost(postId: String): Post? {
    val response = apolloClient
        .mutation(LikePostMutation(id = postId))
        .execute()
    
    return response.data?.likePost?.let { post ->
        Post(
            id = post.id,
            likes = post.likes
        )
    }
}
```

#### 6. Fragments for Reusability

**Define Fragment:**
```graphql
# UserFragment.graphql
fragment UserDetails on User {
  id
  name
  email
  createdAt
}

# Use Fragment
query GetUser($id: ID!) {
  user(id: $id) {
    ...UserDetails
    posts {
      id
      title
    }
  }
}
```

#### 7. Query Variables & Arguments

**With Variables:**
```graphql
query SearchPosts($keyword: String!, $limit: Int = 10) {
  searchPosts(keyword: $keyword, limit: $limit) {
    id
    title
    content
  }
}
```

**Execute with Variables:**
```kotlin
suspend fun searchPosts(keyword: String, limit: Int = 10): List<Post> {
    val response = apolloClient
        .query(SearchPostsQuery(keyword = keyword, limit = Optional.present(limit)))
        .execute()
    
    return response.data?.searchPosts?.map { post ->
        Post(
            id = post.id,
            title = post.title,
            content = post.content
        )
    } ?: emptyList()
}
```

#### 8. Error Handling

```kotlin
suspend fun getUserSafe(userId: String): Result<User> {
    return try {
        val response = apolloClient
            .query(GetUserByIdQuery(id = userId))
            .execute()
        
        if (response.hasErrors()) {
            val errors = response.errors?.joinToString { it.message }
            Result.Error(Exception(errors ?: "GraphQL error"))
        } else {
            val user = response.data?.user
            if (user != null) {
                Result.Success(user.toUser())
            } else {
                Result.Error(Exception("User not found"))
            }
        }
    } catch (e: ApolloException) {
        Result.Error(e)
    }
}
```

#### 9. Caching with Apollo

**In-Memory Cache:**
```kotlin
val apolloClient = ApolloClient.Builder()
    .serverUrl(BASE_URL)
    .normalizedCache(
        normalizedCacheFactory = MemoryCacheFactory(maxSizeBytes = 10 * 1024 * 1024)
    )
    .build()
```

**SQLite Cache:**
```kotlin
val apolloClient = ApolloClient.Builder()
    .serverUrl(BASE_URL)
    .normalizedCache(
        normalizedCacheFactory = SqlNormalizedCacheFactory(
            context = context,
            name = "apollo.db"
        )
    )
    .build()
```

**Cache Policies:**
```kotlin
// Cache first
val response = apolloClient
    .query(GetUsersQuery())
    .fetchPolicy(FetchPolicy.CacheFirst)
    .execute()

// Network only
val response = apolloClient
    .query(GetUsersQuery())
    .fetchPolicy(FetchPolicy.NetworkOnly)
    .execute()

// Cache and network
val response = apolloClient
    .query(GetUsersQuery())
    .fetchPolicy(FetchPolicy.CacheAndNetwork)
    .execute()
```

#### 10. Watching Queries (Reactive)

```kotlin
fun watchUsers(): Flow<List<User>> {
    return apolloClient
        .query(GetUsersQuery())
        .watch()
        .map { response ->
            response.data?.users?.map { it.toUser() } ?: emptyList()
        }
}

// In ViewModel
val

users: StateFlow<List<User>> = repository
    .watchUsers()
    .stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = emptyList()
    )
```

#### 11. GraphQL Subscriptions (Real-Time)

**Define Subscription:**
```graphql
subscription OnPostAdded {
  postAdded {
    id
    title
    author {
      name
    }
  }
}
```

**Setup WebSocket:**
```kotlin
val apolloClient = ApolloClient.Builder()
    .serverUrl("https://api.example.com/graphql")
    .subscriptionNetworkTransport(
        WebSocketNetworkTransport.Builder()
            .serverUrl("wss://api.example.com/graphql")
            .build()
    )
    .build()
```

**Subscribe:**
```kotlin
fun subscribeToNewPosts(): Flow<Post> {
    return apolloClient
        .subscription(OnPostAddedSubscription())
        .toFlow()
        .map { response ->
            response.data?.postAdded?.let { post ->
                Post(
                    id = post.id,
                    title = post.title,
                    authorName = post.author.name
                )
            }
        }
        .filterNotNull()
}

// Collect in ViewModel
init {
    viewModelScope.launch {
        repository.subscribeToNewPosts().collect { newPost ->
            // Update UI with new post
            _posts.value = _posts.value + newPost
        }
    }
}
```

#### 12. Pagination

**Cursor-Based Pagination:**
```graphql
query GetPosts($after: String, $limit: Int!) {
  posts(after: $after, limit: $limit) {
    edges {
      node {
        id
        title
        content
      }
      cursor
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
```

**Implementation:**
```kotlin
class PostPagingSource(
    private val apolloClient: ApolloClient
) : PagingSource<String, Post>() {
    
    override suspend fun load(params: LoadParams<String>): LoadResult<String, Post> {
        return try {
            val response = apolloClient
                .query(
                    GetPostsQuery(
                        after = Optional.presentIfNotNull(params.key),
                        limit = params.loadSize
                    )
                )
                .execute()
            
            val data = response.data?.posts
            val posts = data?.edges?.map { it.node.toPost() } ?: emptyList()
            
            LoadResult.Page(
                data = posts,
                prevKey = null,
                nextKey = if (data?.pageInfo?.hasNextPage == true) {
                    data.pageInfo.endCursor
                } else null
            )
        } catch (e: Exception) {
            LoadResult.Error(e)
        }
    }
    
    override fun getRefreshKey(state: PagingState<String, Post>): String? = null
}
```

#### 13. Optimistic Updates

```kotlin
suspend fun likePostOptimistic(postId: String) {
    apolloClient
        .mutation(LikePostMutation(id = postId))
        .optimisticUpdates(
            GetPostByIdQuery(id = postId) to  GetPostByIdQuery.Data {
                post = post?.copy(likes = post.likes + 1)
            }
        )
        .execute()
}
```

#### 14. Best Practices
✅ Use fragments untuk reusability
✅ Request only needed fields
✅ Implement proper error handling
✅ Use caching appropriately
✅ Leverage subscriptions untuk real-time
✅ Implement pagination
✅ Use variables for dynamic queries
✅ Type-safe with generated code
✅ Monitor query performance
✅ Handle network errors gracefully

#### 15. Hands-on Project
- Setup Apollo Client
- Write queries & mutations
- Implement caching
- Real-time subscriptions
- Pagination
- Error handling
- Integration dengan ViewModel & UI

---
