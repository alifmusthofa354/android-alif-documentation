## **4.5 SOLID Principles** (3 hari) ⭐⭐⭐

### **Teknologi Modern:**
- Single Responsibility
- Open/Closed
- Liskov Substitution
- Interface Segregation
- Dependency Inversion

### **Teknologi yang Ditinggalkan:**
- -

### **Sub-topik Detail:**

#### 1. SOLID Principles Overview
- Pengenalan SOLID by Uncle Bob
- Mengapa SOLID penting
- SOLID dan Clean Code
- SOLID dalam OOP
- SOLID di Kotlin/Android
- Code quality dan maintainability

#### 2. Single Responsibility Principle (SRP)
**Konsep:**
- One class = one reason to change
- One class = one responsibility
- High cohesion

**Android Examples:**
```kotlin
// ❌ BAD: Multiple responsibilities
class UserManager {
    fun loginUser() { }
    fun saveToDatabase() { }
    fun sendAnalytics() { }
}

// ✅ GOOD: Single responsibility
class LoginUseCase { }
class UserRepository { }
class AnalyticsTracker { }
```

**Aplikasi:**
- ViewModel: hanya manage UI state
- Repository: hanya data access
- Use Case: hanya satu business logic
- Separation of concerns

**Code Smell:**
- God classes (terlalu banyak methods)
- Mixed concerns
- Hard to name class

#### 3. Open/Closed Principle (OCP)
**Konsep:**
- Open for extension
- Closed for modification
- Use abstraction dan polymorphism

**Android Examples:**
```kotlin
// ❌ BAD: Modify class untuk extend
class PaymentProcessor {
    fun process(type: String) {
        when(type) {
            "credit" -> processCreditCard()
            "debit" -> processDebitCard()
            // Need to modify untuk add new type
        }
    }
}

// ✅ GOOD: Extend tanpa modify
interface PaymentMethod {
    fun process()
}

class CreditCardPayment : PaymentMethod {
    override fun process() { }
}

class DebitCardPayment : PaymentMethod {
    override fun process() { }
}

// New payment method = new class, no modification
class PayPalPayment : PaymentMethod {
    override fun process() { }
}
```

**Aplikasi:**
- Strategy pattern
- Interface-based programming
- Inheritance dengan override
- Plugin architecture

#### 4. Liskov Substitution Principle (LSP)
**Konsep:**
- Subtype harus substitutable untuk base type
- Child class tidak break parent behavior
- Proper inheritance hierarchy

**Android Examples:**
```kotlin
// ❌ BAD: Square breaks Rectangle behavior
open class Rectangle(
    open val width: Int,
    open val height: Int
) {
    open fun area() = width * height
}

class Square(override val width: Int) : Rectangle(width, width) {
    override val height: Int get() = width
    // Breaks LSP: can't independently set width/height
}

// ✅ GOOD: Proper abstraction
interface Shape {
    fun area(): Int
}

class Rectangle(val width: Int, val height: Int) : Shape {
    override fun area() = width * height
}

class Square(val side: Int) : Shape {
    override fun area() = side * side
}
```

**Aplikasi:**
- Careful dengan inheritance
- Composition over inheritance
- Behavioral consistency
- Contract compliance

#### 5. Interface Segregation Principle (ISP)
**Konsep:**
- Many specific interfaces > one general interface
- Clients tidak forced untuk depend on unused methods
- Small, focused interfaces

**Android Examples:**
```kotlin
// ❌ BAD: Fat interface
interface DataManager {
    fun fetchFromNetwork()
    fun saveToDatabase()
    fun cacheData()
    fun clearCache()
    fun syncData()
}

// Client hanya perlu fetch tapi dapat semua methods

// ✅ GOOD: Segregated interfaces
interface NetworkDataSource {
    fun fetchFromNetwork()
}

interface LocalDataSource {
    fun saveToDatabase()
}

interface CacheManager {
    fun cacheData()
    fun clearCache()
}

// Client pick yang needed
class Repository(
    private val network: NetworkDataSource,
    private val local: LocalDataSource
)
```

**Aplikasi:**
- Role interfaces
- Client-specific interfaces
- Focused contracts
- Easier testing

#### 6. Dependency Inversion Principle (DIP)
**Konsep:**
- High-level modules tidak depend on low-level modules
- Both depend on abstractions
- Abstractions tidak depend on details
- Details depend on abstractions

**Android Examples:**
```kotlin
// ❌ BAD: Direct dependency
class UserViewModel {
    private val repository = UserRepositoryImpl() // Concrete class
}

// ✅ GOOD: Depend on abstraction
interface UserRepository {
    suspend fun getUser(): User
}

class UserRepositoryImpl : UserRepository {
    override suspend fun getUser(): User { }
}

class UserViewModel(
    private val repository: UserRepository // Interface
) {
    // Can inject any implementation
}
```

**Aplikasi:**
- Repository interfaces di domain
- Dependency Injection
- Testability dengan mocks
- Loose coupling

#### 7. SOLID dalam Android Architecture
**ViewModel:**
- SRP: Hanya manage UI state
- OCP: Extendable behavior
- DIP: Depend on Use Case interfaces

**Repository:**
- SRP: Data access only
- ISP: Specific repository interfaces
- DIP: Depend on data source interfaces

**Use Cases:**
- SRP: One business logic
- OCP: New use case = new class
- DIP: Depend on repository interfaces

#### 8. Code Refactoring dengan SOLID
**Identifying Violations:**
- Large classes → SRP violation
- Hard to extend → OCP violation
- Fragile inheritance → LSP violation
- Fat interfaces → ISP violation
- Tight coupling → DIP violation

**Refactoring Steps:**
- Extract responsibilities → SRP
- Create abstractions → OCP
- Fix inheritance → LSP
- Split interfaces → ISP
- Inject dependencies → DIP

#### 9. SOLID and Design Patterns
- Strategy Pattern → OCP
- Template Method → OCP, LSP
- Adapter Pattern → ISP
- Factory Pattern → DIP
- Repository Pattern → DIP

#### 10. Testing Benefits
- SRP: Easy to test one thing
- OCP: Test extension without changing tests
- LSP: Substitute mocks easily
- ISP: Mock only what's needed
- DIP: Inject test doubles

#### 11. Common Pitfalls
- Over-engineering
- Premature abstraction
- Too many interfaces
- Analysis paralysis
- Dogmatic application

#### 12. Practical Guidelines
- Apply pragmatically
- Start simple, refactor when needed
- Balance dengan deadlines
- Team agreement
- Code reviews untuk enforce

#### 13. Hands-on Exercises
- Identify SOLID violations in code
- Refactor code untuk apply SOLID
- Design new features dengan SOLID
- Code review checklist
- Real-world scenarios

---
