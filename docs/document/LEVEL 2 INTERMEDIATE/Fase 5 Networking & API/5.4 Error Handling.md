

# ğŸš’ Panduan Lengkap: Error Handling di Android

## ğŸš€ Pengantar: Rencana Darurat untuk Aplikasi yang Tangguh

Bayangkan kamu adalah seorang pemadam kebakaran profesional ğŸš’:
- **Error Handling** seperti rencana darurat yang lengkap untuk berbagai situasi
- **Try-catch** seperti alat pemadam kebakaran portabel untuk keadaan darurat kecil
- **Result Wrapper** seperti mobil pemadam kebakaran yang terorganisir dengan berbagai peralatan
- **Sealed Classes** seperti panel kontrol yang menunjukkan status operasi dengan jelas

Dengan menguasai Error Handling, kamu bisa membuat aplikasi yang tangguh, andal, dan memberikan pengalaman pengguna yang lebih baik!

## ğŸ“š Daftar Isi Pembelajaran
1. [ğŸ”¥ Jenis-Jenis Error](#1ï¸âƒ£-jenis-jenis-error-ğŸ”¥)
2. [ğŸ§¯ Dasar Try-Catch](#2ï¸âƒ£-dasar-try-catch-ğŸ§¯)
3. [ğŸš’ Result Wrapper Pattern](#3ï¸âƒ£-result-wrapper-pattern-ğŸš’)
4. [ğŸ“ Safe API Call Wrapper](#4ï¸âƒ£-safe-api-call-wrapper-ğŸ“)
5. [ğŸ“„ Model Error Response](#5ï¸âƒ£-model-error-response-ğŸ“„)
6. [ğŸš¦ Menangani Kode Status HTTP](#6ï¸âƒ£-menangani-kode-status-http-ğŸš¦)
7. [âš ï¸ Custom Exceptions](#7ï¸âƒ£-custom-exceptions-âš ï¸)
8. [ğŸ›ï¸ Sealed Classes untuk State Management](#8ï¸âƒ£-sealed-classes-untuk-state-management-ğŸ›ï¸)
9. [ğŸ”„ Retry Logic](#9ï¸âƒ£-retry-logic-ğŸ”„)
10. [ğŸ’¬ Pesan Error untuk Pengguna](#1ï¸âƒ£0ï¸âƒ£-pesan-error-untuk-pengguna-ğŸ’¬)
11. [ğŸ“ Logging Errors](#1ï¸âƒ£1ï¸âƒ£-logging-errors-ğŸ“)
12. [ğŸ—„ï¸ Error Handling di Repository Layer](#1ï¸âƒ£2ï¸âƒ£-error-handling-di-repository-layer-ğŸ—„ï¸)
13. [ğŸ§  Error Handling di ViewModel](#1ï¸âƒ£3ï¸âƒ£-error-handling-di-viewmodel-ğŸ§ )
14. [ğŸŒ Global Error Handler](#1ï¸âƒ£4ï¸âƒ£-global-error-handler-ğŸŒ)
15. [ğŸ­ Production-Ready Error Handling](#1ï¸âƒ£5ï¸âƒ£-production-ready-error-handling-ğŸ­)
16. [âœ¨ Best Practices](#1ï¸âƒ£6ï¸âƒ£-best-practices-âœ¨)
17. [ğŸ”¨ Hands-on Exercises](#1ï¸âƒ£7ï¸âƒ£-hands-on-exercises-ğŸ”¨)
18. [ğŸ¯ Kesimpulan](#ğŸ¯-kesimpulan)

---

## 1ï¸âƒ£ Jenis-Jenis Error ğŸ”¥

### Konsep Dasar
Jenis-jenis Error seperti berbagai jenis kebakaran ğŸ”¥ - setiap jenis membutuhkan penanganan yang berbeda dan peralatan yang tepat!

### Kategori Error:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  NETWORK ERROR  â”‚    â”‚   HTTP ERROR    â”‚    â”‚  PARSING ERROR  â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ - No internet   â”‚    â”‚ - 4xx Client    â”‚    â”‚ - Invalid JSON   â”‚
â”‚ - Timeout       â”‚    â”‚ - 5xx Server    â”‚    â”‚ - Type mismatch  â”‚
â”‚ - SSL/TLS       â”‚    â”‚                 â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                       â”‚                       â”‚
        â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ APPLICATION     â”‚    â”‚   BUSINESS      â”‚    â”‚   VALIDATION    â”‚
â”‚ ERRORS          â”‚    â”‚   ERRORS        â”‚    â”‚   ERRORS        â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ - Null pointer  â”‚    â”‚ - Logic errors  â”‚    â”‚ - Input errors  â”‚
â”‚ - Index out of  â”‚    â”‚ - Constraints   â”‚    â”‚ - Format errors â”‚
â”‚   bounds        â”‚    â”‚                 â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Network Errors:
- **No Internet Connection**: Tidak ada koneksi jaringan
- **Timeout**: Permintaan terlalu lama tidak ada respons
- **SSL/TLS Errors**: Masalah keamanan koneksi
- **DNS Resolution Failures**: Tidak dapat menemukan alamat server
- **Connection Refused**: Server menolak koneksi

### HTTP Errors:
- **4xx Client Errors**: Kesalahan dari sisi client
  - 400 Bad Request: Permintaan tidak valid
  - 401 Unauthorized: Memerlukan autentikasi
  - 403 Forbidden: Tidak memiliki izin
  - 404 Not Found: Sumber daya tidak ditemukan
  - 422 Unprocessable Entity: Data tidak valid
- **5xx Server Errors**: Kesalahan dari sisi server
  - 500 Internal Server Error: Error internal server
  - 502 Bad Gateway: Gateway tidak valid
  - 503 Service Unavailable: Layanan tidak tersedia

### Parsing Errors:
- **Invalid JSON Format**: Format JSON tidak valid
- **Missing Required Fields**: Field yang wajib tidak ada
- **Type Mismatch**: Tipe data tidak sesuai

### Application Errors:
- **Business Logic Errors**: Kesalahan logika bisnis
- **Validation Errors**: Kesalahan validasi data
- **Custom Exceptions**: Exception kustom

### ğŸ“ Penjelasan Konsep:
**Jenis-Jenis Error seperti Berbagai Jenis Kebakaran:**
- **Network Errors**: Kebakaran karena listrik konslet
- **HTTP Errors**: Kebakaran karena gas bocor
- **Parsing Errors**: Kebakaran karena korsleting peralatan
- **Application Errors**: Kebakaran karena kelalaian manusia

**Strategi Penanganan:**
1. Identifikasi jenis error
2. Pilih metode penanganan yang tepat
3. Sediakan pesan error yang jelas
4. Implementasikan fallback mechanism
5. Log error untuk debugging

---

## 2ï¸âƒ£ Dasar Try-Catch ğŸ§¯

### Konsep Dasar
Try-catch seperti alat pemadam kebakaran portabel ğŸ§¯ - alat pertama yang digunakan saat terjadi keadaan darurat kecil!

### Basic Try-Catch:
```kotlin
suspend fun getUsers(): List<User> {
    return try {
        apiService.getUsers()
    } catch (e: Exception) {
        // Handle error
        emptyList()
    }
}
```

### Menangkap Exception Spesifik:
```kotlin
suspend fun getUsers(): List<User> {
    return try {
        apiService.getUsers()
    } catch (e: HttpException) {
        // HTTP error (4xx, 5xx)
        when (e.code()) {
            401 -> handleUnauthorized()
            404 -> handleNotFound()
            500 -> handleServerError()
            else -> handleGenericHttpError(e)
        }
        emptyList()
    } catch (e: IOException) {
        // Network error (no internet, timeout)
        handleNetworkError(e)
        emptyList()
    } catch (e: JsonSyntaxException) {
        // JSON parsing error
        handleParsingError(e)
        emptyList()
    } catch (e: Exception) {
        // Unknown error
        handleUnknownError(e)
        emptyList()
    }
}
```

### Try-Catch dengan Finally:
```kotlin
suspend fun getUsers(): List<User> {
    var users = emptyList<User>()
    
    try {
        users = apiService.getUsers()
    } catch (e: Exception) {
        handleError(e)
    } finally {
        // Blok ini akan selalu dieksekusi, baik ada error atau tidak
        hideLoadingIndicator()
    }
    
    return users
}
```

### Try-Catch untuk Expression:
```kotlin
val users = try {
    apiService.getUsers()
} catch (e: Exception) {
    emptyList()
}
```

### ğŸ“ Penjelasan Konsep:
**Try-catch seperti Alat Pemadam Kebakaran Portabel:**
- **Try**: Menggunakan alat untuk memadam api
- **Catch**: Menangkap berbagai jenis api
- **Finally**: Membersihkan area setelah api padam
- **Specific Exceptions**: Jenis alat pemadam yang berbeda untuk api yang berbeda

**Best Practices:**
- Tangkap exception yang paling spesifik terlebih dahulu
- Jangan tangkap `Exception` secara umum jika bisa dihindari
- Gunakan `finally` untuk cleanup
- Berikan pesan error yang informatif
- Log error untuk debugging

---

## 3ï¸âƒ£ Result Wrapper Pattern ğŸš’

### Konsep Dasar
Result Wrapper Pattern seperti mobil pemadam kebakaran profesional ğŸš’ - terorganisir dengan berbagai peralatan untuk setiap situasi!

### Sealed Class Approach:
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()
    object Loading : Result<Nothing>()
}

// Penggunaan di Repository
suspend fun getUsers(): Result<List<User>> {
    return try {
        val users = apiService.getUsers()
        Result.Success(users)
    } catch (e: Exception) {
        Result.Error(e)
    }
}

// Penggunaan di ViewModel
viewModelScope.launch {
    _uiState.value = Result.Loading
    val result = repository.getUsers()
    _uiState.value = result
}

// Penggunaan di UI
when (val state = uiState.value) {
    is Result.Loading -> ShowLoading()
    is Result.Success -> ShowData(state.data)
    is Result.Error -> ShowError(state.exception.message)
}
```

### Enhanced Result dengan Error Details:
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    
    sealed class Error : Result<Nothing>() {
        data class Network(val message: String) : Error()
        data class Http(val code: Int, val message: String) : Error()
        data class Generic(val exception: Exception) : Error()
    }
    
    object Loading : Result<Nothing>()
}

// Penggunaan di Repository
suspend fun getUsers(): Result<List<User>> {
    return try {
        val users = apiService.getUsers()
        Result.Success(users)
    } catch (e: HttpException) {
        Result.Error.Http(e.code(), e.message ?: "HTTP Error")
    } catch (e: IOException) {
        Result.Error.Network("Network error: ${e.message}")
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}

// Penggunaan di UI
when (val state = uiState.value) {
    is Result.Loading -> ShowLoading()
    is Result.Success -> ShowData(state.data)
    is Result.Error.Network -> ShowNetworkError(state.message)
    is Result.Error.Http -> ShowHttpError(state.code, state.message)
    is Result.Error.Generic -> ShowGenericError(state.exception.message)
}
```

### Kotlin Result Type (Standard Library):
```kotlin
suspend fun getUsers(): kotlin.Result<List<User>> {
    return try {
        val users = apiService.getUsers()
        kotlin.Result.success(users)
    } catch (e: Exception) {
        kotlin.Result.failure(e)
    }
}

// Penggunaan
repository.getUsers()
    .onSuccess { users ->
        // Handle success
    }
    .onFailure { exception ->
        // Handle error
    }
```

### ğŸ“ Penjelasan Konsep:
**Result Wrapper Pattern seperti Mobil Pemadam Kebakaran Profesional:**
- **Success**: Kompartemen untuk peralatan yang berhasil digunakan
- **Error**: Kompartemen untuk peralatan yang gagal digunakan
- **Loading**: Kompartemen untuk peralatan yang sedang disiapkan
- **Enhanced Error**: Jenis-jenis peralatan untuk berbagai jenis keadaan darurat

**Keunggulan Result Wrapper:**
- **Type Safety**: Mencegah error pada runtime
- **Clarity**: Jelas memisahkan antara sukses dan error
- **Flexibility**: Dapat dikustomisasi untuk berbagai jenis error
- **Consistency**: Format yang konsisten untuk semua operasi

**Best Practices:**
- Gunakan sealed class untuk representasi state
- Pisahkan jenis error untuk penanganan yang lebih spesifik
- Gunakan Result wrapper di Repository layer
- Gunakan when expression di UI layer
- Pertimbangkan untuk menggunakan Kotlin Result untuk kasus sederhana

---

## 4ï¸âƒ£ Safe API Call Wrapper ğŸ“

### Konsep Dasar
Safe API Call Wrapper seperti protokol panggilan darurat standar ğŸ“ - prosedur yang dapat digunakan ulang untuk setiap keadaan darurat!

### Implementasi Safe API Call:
```kotlin
suspend fun <T> safeApiCall(
    apiCall: suspend () -> T
): Result<T> {
    return try {
        Result.Success(apiCall())
    } catch (e: HttpException) {
        Result.Error.Http(e.code(), e.message())
    } catch (e: IOException) {
        Result.Error.Network("Network error: ${e.message}")
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}

// Penggunaan di Repository
suspend fun getUsers() = safeApiCall {
    apiService.getUsers()
}

suspend fun getUserById(userId: Int) = safeApiCall {
    apiService.getUserById(userId)
}

suspend fun createUser(user: User) = safeApiCall {
    apiService.createUser(user)
}
```

### Safe API Call dengan Callback:
```kotlin
suspend fun <T> safeApiCall(
    onError: ((Exception) -> Unit)? = null,
    apiCall: suspend () -> T
): Result<T> {
    return try {
        Result.Success(apiCall())
    } catch (e: HttpException) {
        val error = Result.Error.Http(e.code(), e.message())
        onError?.invoke(e)
        error
    } catch (e: IOException) {
        val error = Result.Error.Network("Network error: ${e.message}")
        onError?.invoke(e)
        error
    } catch (e: Exception) {
        val error = Result.Error.Generic(e)
        onError?.invoke(e)
        error
    }
}

// Penggunaan di Repository
suspend fun getUsers() = safeApiCall(
    onError = { logError("getUsers", it) }
) {
    apiService.getUsers()
}
```

### Safe API Call dengan Retry:
```kotlin
suspend fun <T> safeApiCallWithRetry(
    times: Int = 3,
    apiCall: suspend () -> T
): Result<T> {
    repeat(times - 1) { attempt ->
        try {
            return Result.Success(apiCall())
        } catch (e: IOException) {
            // Retry only for network errors
            if (attempt < times - 1) {
                delay(1000L * (attempt + 1)) // Exponential backoff
            }
        } catch (e: Exception) {
            return Result.Error.Generic(e)
        }
    }
    
    return try {
        Result.Success(apiCall())
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}

// Penggunaan di Repository
suspend fun getUsers() = safeApiCallWithRetry(times = 3) {
    apiService.getUsers()
}
```

### ğŸ“ Penjelasan Konsep:
**Safe API Call Wrapper seperti Protokol Panggilan Darurat Standar:**
- **Reusable**: Dapat digunakan untuk berbagai jenis keadaan darurat
- **Consistent**: Prosedur yang sama untuk setiap panggilan
- **Flexible**: Dapat dikustomisasi untuk kebutuhan spesifik
- **Reliable**: Menangani berbagai jenis error dengan baik

**Keunggulan Safe API Call:**
- **DRY (Don't Repeat Yourself)**: Menghindari duplikasi kode
- **Consistency**: Format error yang konsisten
- **Maintainability**: Mudah dipelihara dan diperbarui
- **Testability**: Mudah untuk di-testing

**Best Practices:**
- Buat safe API call yang reusable
- Tangani exception yang paling umum
- Pertimbangkan untuk menambahkan retry mechanism
- Gunakan callback untuk logging atau tracking
- Pisahkan logic retry dari logic error handling

---

## 5ï¸âƒ£ Model Error Response ğŸ“„

### Konsep Dasar
Model Error Response seperti laporan insiden kebakaran ğŸ“„ - dokumen yang terstruktur untuk mencatat detail kejadian!

### API Error Response Format:
```kotlin
// Format error response dari API
data class ErrorResponse(
    @SerializedName("code")
    val code: String,
    
    @SerializedName("message")
    val message: String,
    
    @SerializedName("field")
    val field: String? = null,
    
    @SerializedName("details")
    val details: Map<String, Any>? = null
)

// Contoh JSON:
// {
//   "code": "VALIDATION_ERROR",
//   "message": "Invalid input data",
//   "field": "email",
//   "details": {
//     "min_length": 5,
//     "provided": 3
//   }
// }
```

### Parsing Error Body:
```kotlin
fun parseErrorBody(errorBody: ResponseBody?): String {
    return try {
        val error = Gson().fromJson(
            errorBody?.string(),
            ErrorResponse::class.java
        )
        error.message
    } catch (e: Exception) {
        "Unknown error occurred"
    }
}

// Penggunaan dengan Retrofit
@GET("users")
suspend fun getUsers(): Response<List<User>>

// Di Repository
suspend fun getUsers(): Result<List<User>> {
    return try {
        val response = apiService.getUsers()
        
        if (response.isSuccessful) {
            val users = response.body() ?: emptyList()
            Result.Success(users)
        } else {
            val errorMessage = parseErrorBody(response.errorBody())
            Result.Error.Generic(Exception(errorMessage))
        }
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}
```

### Enhanced Error Parsing:
```kotlin
fun parseErrorBody(errorBody: ResponseBody?): ErrorResponse? {
    return try {
        Gson().fromJson(
            errorBody?.string(),
            ErrorResponse::class.java
        )
    } catch (e: Exception) {
        null
    }
}

// Penggunaan di Repository
suspend fun getUsers(): Result<List<User>> {
    return try {
        val response = apiService.getUsers()
        
        if (response.isSuccessful) {
            val users = response.body() ?: emptyList()
            Result.Success(users)
        } else {
            val errorResponse = parseErrorBody(response.errorBody())
            
            when (response.code()) {
                400 -> {
                    val message = errorResponse?.message ?: "Bad Request"
                    Result.Error.Http(400, message)
                }
                422 -> {
                    val message = errorResponse?.message ?: "Validation Error"
                    val field = errorResponse?.field
                    Result.Error.Validation(message, field)
                }
                else -> {
                    val message = errorResponse?.message ?: "HTTP Error"
                    Result.Error.Http(response.code(), message)
                }
            }
        }
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Model Error Response seperti Laporan Insiden Kebakaran:**
- **Code**: Kode klasifikasi insiden
- **Message**: Deskripsi singkat insiden
- **Field**: Lokasi spesifik masalah
- **Details**: Informasi tambahan tentang insiden

**Keunggulan Error Response Model:**
- **Structured**: Format yang terstruktur dan konsisten
- **Informative**: Memberikan informasi detail tentang error
- **Parseable**: Mudah di-parsing menjadi objek
- **User-Friendly**: Dapat dikonversi menjadi pesan yang user-friendly

**Best Practices:**
- Buat model error yang terstruktur
- Parsing error body dengan aman
- Tangani berbagai jenis status code
- Konversi error response menjadi Result wrapper
- Sediakan pesan error yang user-friendly

---

## 6ï¸âƒ£ Menangani Kode Status HTTP ğŸš¦

### Konsep Dasar
Menangani Kode Status HTTP seperti sistem rambu lalu lintas ğŸš¦ - memberikan instruksi jelas tentang apa yang harus dilakukan!

### Handling HTTP Status Codes:
```kotlin
suspend fun makeApiCall(): Result<User> {
    return try {
        val response = apiService.getUser()
        
        if (response.isSuccessful) {
            val user = response.body()
            if (user != null) {
                Result.Success(user)
            } else {
                Result.Error.Generic(Exception("Empty response body"))
            }
        } else {
            when (response.code()) {
                400 -> Result.Error.Http(400, "Bad Request")
                401 -> Result.Error.Http(401, "Unauthorized")
                403 -> Result.Error.Http(403, "Forbidden")
                404 -> Result.Error.Http(404, "Not Found")
                422 -> {
                    val errorMsg = parseErrorBody(response.errorBody())
                    Result.Error.Http(422, errorMsg)
                }
                in 500..599 -> Result.Error.Http(response.code(), "Server Error")
                else -> Result.Error.Http(response.code(), "HTTP ${response.code()}")
            }
        }
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}
```

### HTTP Status Code Handler:
```kotlin
object HttpErrorHandler {
    fun handle(response: Response<*>): Result.Error {
        return when (response.code()) {
            400 -> Result.Error.Http(400, "Invalid request. Please check your input.")
            401 -> Result.Error.Http(401, "Authentication required. Please log in.")
            403 -> Result.Error.Http(403, "You don't have permission to access this resource.")
            404 -> Result.Error.Http(404, "The requested resource was not found.")
            408 -> Result.Error.Http(408, "Request timeout. Please try again.")
            409 -> Result.Error.Http(409, "Conflict with the current state of the resource.")
            422 -> {
                val errorMsg = parseErrorBody(response.errorBody())
                Result.Error.Http(422, errorMsg ?: "Invalid data provided.")
            }
            429 -> Result.Error.Http(429, "Too many requests. Please try again later.")
            500 -> Result.Error.Http(500, "Internal server error. Please try again later.")
            502 -> Result.Error.Http(502, "Bad gateway. Please try again later.")
            503 -> Result.Error.Http(503, "Service unavailable. Please try again later.")
            504 -> Result.Error.Http(504, "Gateway timeout. Please try again later.")
            else -> Result.Error.Http(response.code(), "HTTP ${response.code()}: ${response.message()}")
        }
    }
    
    private fun parseErrorBody(errorBody: ResponseBody?): String? {
        return try {
            val error = Gson().fromJson(
                errorBody?.string(),
                ErrorResponse::class.java
            )
            error.message
        } catch (e: Exception) {
            null
        }
    }
}

// Penggunaan di Repository
suspend fun getUser(userId: Int): Result<User> {
    return try {
        val response = apiService.getUser(userId)
        
        if (response.isSuccessful) {
            val user = response.body()
            if (user != null) {
                Result.Success(user)
            } else {
                Result.Error.Generic(Exception("Empty response body"))
            }
        } else {
            HttpErrorHandler.handle(response)
        }
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Menangani Kode Status HTTP seperti Sistem Rambu Lalu Lintas:**
- **2xx (Success)**: Jalan aman, lanjutkan
- **3xx (Redirection)**: Belok ke arah lain
- **4xx (Client Error)**: Kesalahan dari pengemudi
- **5xx (Server Error)**: Masalah di jalan

**Strategi Penanganan:**
1. Periksa status code
2. Pilih pesan error yang sesuai
3. Konversi ke Result wrapper
4. Tampilkan pesan yang user-friendly
5. Log error untuk debugging

**Best Practices:**
- Tangani status code yang umum (400, 401, 403, 404, 500)
- Parsing error body untuk informasi detail
- Sediakan pesan error yang user-friendly
- Konversi ke Result wrapper untuk konsistensi
- Log error untuk debugging

---

## 7ï¸âƒ£ Custom Exceptions âš ï¸

### Konsep Dasar
Custom Exceptions seperti peralatan khusus untuk jenis kebakaran tertentu âš ï¸ - alat yang dirancang khusus untuk menangani masalah spesifik!

### Network Exceptions:
```kotlin
// Network exceptions
class NoInternetException(message: String = "No internet connection") 
    : IOException(message)

class TimeoutException(message: String = "Request timeout") 
    : IOException(message)

class SSLException(message: String = "SSL/TLS error") 
    : IOException(message)

class ServerUnreachableException(message: String = "Server is unreachable") 
    : IOException(message)
```

### Business Logic Exceptions:
```kotlin
// Business logic exceptions
class InvalidCredentialsException(message: String = "Invalid email or password") 
    : Exception(message)

class UserNotFoundException(userId: Int) 
    : Exception("User with ID $userId not found")

class InsufficientPermissionsException(message: String = "Insufficient permissions") 
    : Exception(message)

class ResourceAlreadyExistsException(resource: String, id: String) 
    : Exception("$resource with ID $id already exists")
```

### Validation Exceptions:
```kotlin
// Validation exceptions
class ValidationException(val errors: Map<String, String>) 
    : Exception("Validation failed: ${errors.values.joinToString()}")

class EmailFormatException(email: String) 
    : Exception("Email format is invalid: $email")

class PasswordFormatException 
    : Exception("Password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, and one number")

class RequiredFieldException(fieldName: String) 
    : Exception("Field $fieldName is required")
```

### Custom Exception Handler:
```kotlin
object ExceptionHandler {
    fun handle(exception: Exception): Result.Error {
        return when (exception) {
            is NoInternetException -> Result.Error.Network(exception.message ?: "No internet connection")
            is TimeoutException -> Result.Error.Network(exception.message ?: "Request timeout")
            is HttpException -> Result.Error.Http(exception.code(), exception.message ?: "HTTP Error")
            is ValidationException -> Result.Error.Validation(exception.message)
            is InvalidCredentialsException -> Result.Error.Http(401, exception.message)
            is UserNotFoundException -> Result.Error.Http(404, exception.message)
            is ResourceAlreadyExistsException -> Result.Error.Http(409, exception.message)
            else -> Result.Error.Generic(exception)
        }
    }
}

// Penggunaan di Repository
suspend fun login(email: String, password: String): Result<User> {
    return try {
        if (email.isBlank() || password.isBlank()) {
            throw RequiredFieldException("email or password")
        }
        
        if (!isValidEmail(email)) {
            throw EmailFormatException(email)
        }
        
        val user = apiService.login(email, password)
        Result.Success(user)
    } catch (e: Exception) {
        ExceptionHandler.handle(e)
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Custom Exceptions seperti Peralatan Khusus untuk Jenis Kebakaran Tertentu:**
- **Network Exceptions**: Alat untuk kebakaran listrik
- **Business Logic Exceptions**: Alat untuk kebakaran gas
- **Validation Exceptions**: Alat untuk kebakaran karena kelalaian

**Keunggulan Custom Exceptions:**
- **Specificity**: Lebih spesifik untuk jenis error tertentu
- **Clarity**: Lebih jelas dalam menggambarkan masalah
- **Handling**: Lebih mudah untuk menangani error secara spesifik
- **Debugging**: Lebih mudah untuk debugging

**Best Practices:**
- Buat custom exception untuk jenis error spesifik
- Sediakan pesan error yang jelas
- Gunakan inheritance untuk exception yang terkait
- Buat exception handler untuk konsistensi
- Gunakan custom exception di business logic

---

## 8ï¸âƒ£ Sealed Classes untuk State Management ğŸ›ï¸

### Konsep Dasar
Sealed Classes untuk State Management seperti panel kontrol komando darurat ğŸ›ï¸ - menunjukkan status operasi dengan jelas dan terstruktur!

### UI State dengan Sealed Class:
```kotlin
sealed class UiState<out T> {
    object Idle : UiState<Nothing>()
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(
        val message: String,
        val code: Int? = null,
        val throwable: Throwable? = null
    ) : UiState<Nothing>()
}
```

### Implementasi di ViewModel:
```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    
    private val _userState = MutableStateFlow<UiState<User>>(UiState.Idle)
    val userState: StateFlow<UiState<User>> = _userState.asStateFlow()
    
    fun loadUser(userId: Int) {
        viewModelScope.launch {
            _userState.value = UiState.Loading
            
            when (val result = repository.getUser(userId)) {
                is Result.Success -> {
                    _userState.value = UiState.Success(result.data)
                }
                is Result.Error -> {
                    _userState.value = UiState.Error(
                        message = result.exception.toUserFriendlyMessage(),
                        throwable = result.exception
                    )
                }
            }
        }
    }
    
    fun refreshUser() {
        loadUser(getCurrentUserId())
    }
}
```

### Implementasi di Compose UI:
```kotlin
@Composable
fun UserProfileScreen(
    viewModel: UserViewModel = hiltViewModel()
) {
    val userState by viewModel.userState.collectAsState()
    
    when (val state = userState) {
        UiState.Idle -> {
            // Initial state, show nothing or a placeholder
        }
        UiState.Loading -> {
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        }
        is UiState.Success -> {
            UserProfileContent(user = state.data)
        }
        is UiState.Error -> {
            ErrorMessage(
                message = state.message,
                onRetry = { viewModel.refreshUser() }
            )
        }
    }
}

@Composable
fun ErrorMessage(
    message: String,
    onRetry: () -> Unit
) {
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = message,
            color = MaterialTheme.colorScheme.error,
            textAlign = TextAlign.Center
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = onRetry) {
            Text("Retry")
        }
    }
}
```

### Enhanced UI State:
```kotlin
sealed class UiState<out T> {
    object Idle : UiState<Nothing>()
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    
    sealed class Error : UiState<Nothing>() {
        data class Network(
            val message: String,
            val onRetry: () -> Unit
        ) : Error()
        
        data class Http(
            val code: Int,
            val message: String,
            val onRetry: () -> Unit
        ) : Error()
        
        data class Validation(
            val message: String,
            val field: String? = null
        ) : Error()
        
        data class Generic(
            val message: String,
            val onRetry: () -> Unit
        ) : Error()
    }
}

// Implementasi di ViewModel
fun loadUser(userId: Int) {
    viewModelScope.launch {
        _userState.value = UiState.Loading
        
        when (val result = repository.getUser(userId)) {
            is Result.Success -> {
                _userState.value = UiState.Success(result.data)
            }
            is Result.Error.Network -> {
                _userState.value = UiState.Error.Network(
                    message = result.message,
                    onRetry = { loadUser(userId) }
                )
            }
            is Result.Error.Http -> {
                _userState.value = UiState.Error.Http(
                    code = result.code,
                    message = result.message,
                    onRetry = { loadUser(userId) }
                )
            }
            is Result.Error.Validation -> {
                _userState.value = UiState.Error.Validation(
                    message = result.message,
                    field = result.field
                )
            }
            else -> {
                _userState.value = UiState.Error.Generic(
                    message = result.exception.message ?: "Unknown error",
                    onRetry = { loadUser(userId) }
                )
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Sealed Classes untuk State Management seperti Panel Kontrol Komando Darurat:**
- **Idle**: Status siaga
- **Loading**: Status persiapan
- **Success**: Status berhasil
- **Error**: Status dengan berbagai jenis masalah

**Keunggulan Sealed Classes untuk State:**
- **Type Safety**: Mencegah state yang tidak valid
- **Exhaustive**: Memastikan semua state ditangani
- **Clarity**: Jelas memisahkan antara state yang berbeda
- **Flexibility**: Dapat dikustomisasi untuk berbagai jenis state

**Best Practices:**
- Gunakan sealed class untuk representasi state UI
- Pisahkan jenis error untuk penanganan yang lebih spesifik
- Sediakan callback untuk retry di state error
- Gunakan when expression di UI layer
- Pertimbangkan untuk menggunakan StateFlow untuk state yang observable

---

## 9ï¸âƒ£ Retry Logic ğŸ”„

### Konsep Dasar
Retry Logic seperti upaya pemadaman berulang kali ğŸ”„ - mencoba kembali dengan strategi yang lebih baik jika upaya pertama gagal!

### Retry dengan Exponential Backoff:
```kotlin
suspend fun <T> retryWithExponentialBackoff(
    times: Int = 3,
    initialDelay: Long = 1000,
    maxDelay: Long = 10000,
    factor: Double = 2.0,
    block: suspend () -> T
): T {
    var currentDelay = initialDelay
    
    repeat(times - 1) { attempt ->
        try {
            return block()
        } catch (e: Exception) {
            Log.w("Retry", "Attempt ${attempt + 1} failed: ${e.message}")
        }
        delay(currentDelay)
        currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)
    }
    
    return block() // Last attempt
}

// Penggunaan
val users = retryWithExponentialBackoff(times = 3) {
    apiService.getUsers()
}
```

### Conditional Retry:
```kotlin
suspend fun <T> retryIO(
    times: Int = 3,
    block: suspend () -> T
): T {
    repeat(times - 1) {
        try {
            return block()
        } catch (e: IOException) {
            // Retry only for network errors
            delay(1000)
        } catch (e: HttpException) {
            // Don't retry for HTTP errors
            throw e
        }
    }
    return block()
}

// Penggunaan
val users = retryIO(times = 3) {
    apiService.getUsers()
}
```

### Retry dengan Result Wrapper:
```kotlin
suspend fun <T> retryWithResult(
    times: Int = 3,
    initialDelay: Long = 1000,
    maxDelay: Long = 10000,
    factor: Double = 2.0,
    block: suspend () -> T
): Result<T> {
    var currentDelay = initialDelay
    
    repeat(times - 1) { attempt ->
        try {
            val result = block()
            return Result.Success(result)
        } catch (e: IOException) {
            Log.w("Retry", "Attempt ${attempt + 1} failed: ${e.message}")
            delay(currentDelay)
            currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)
        } catch (e: Exception) {
            return Result.Error.Generic(e)
        }
    }
    
    return try {
        val result = block()
        Result.Success(result)
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}

// Penggunaan di Repository
suspend fun getUsers(): Result<List<User>> {
    return retryWithResult(times = 3) {
        apiService.getUsers()
    }
}
```

### Retry dengan Custom Predicate:
```kotlin
suspend fun <T> retryIf(
    times: Int = 3,
    initialDelay: Long = 1000,
    maxDelay: Long = 10000,
    factor: Double = 2.0,
    shouldRetry: (Exception) -> Boolean = { true },
    block: suspend () -> T
): Result<T> {
    var currentDelay = initialDelay
    
    repeat(times - 1) { attempt ->
        try {
            val result = block()
            return Result.Success(result)
        } catch (e: Exception) {
            if (!shouldRetry(e)) {
                return Result.Error.Generic(e)
            }
            
            Log.w("Retry", "Attempt ${attempt + 1} failed: ${e.message}")
            delay(currentDelay)
            currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)
        }
    }
    
    return try {
        val result = block()
        Result.Success(result)
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}

// Penggunaan di Repository
suspend fun getUsers(): Result<List<User>> {
    return retryIf(
        times = 3,
        shouldRetry = { e -> e is IOException } // Only retry for network errors
    ) {
        apiService.getUsers()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Retry Logic seperti Upaya Pemadaman Berulang Kali:**
- **Exponential Backoff**: Menunggu lebih lama setiap kali mencoba
- **Conditional Retry**: Mencoba kembali hanya untuk jenis error tertentu
- **Result Wrapper**: Mengembalikan hasil yang konsisten
- **Custom Predicate**: Menentukan kapan harus mencoba kembali

**Strategi Retry:**
1. Tentukan jenis error yang bisa di-retry
2. Gunakan exponential backoff untuk menghindari overload
3. Batasi jumlah percobaan
4. Log setiap percobaan untuk debugging
5. Pertimbangkan untuk menampilkan indikator loading

**Best Practices:**
- Gunakan exponential backoff untuk menghindari server overload
- Retry hanya untuk error yang mungkin berhasil (network errors)
- Jangan retry untuk error yang tidak akan berhasil (HTTP 4xx)
- Batasi jumlah percobaan untuk menghindari infinite loop
- Tampilkan indikator loading saat mencoba kembali

---

## 1ï¸âƒ£0ï¸âƒ£ Pesan Error untuk Pengguna ğŸ’¬

### Konsep Dasar
Pesan Error untuk Pengguna seperti instruksi evakuasi yang jelas ğŸ’¬ - memberikan informasi yang mudah dimengerti tentang apa yang terjadi dan apa yang harus dilakukan!

### Konversi Exception ke Pesan User-Friendly:
```kotlin
fun Throwable.toUserFriendlyMessage(): String {
    return when (this) {
        is HttpException -> when (code()) {
            400 -> "Permintaan tidak valid. Silakan periksa input Anda."
            401 -> "Sesi Anda telah berakhir. Silakan masuk kembali."
            403 -> "Anda tidak memiliki izin untuk mengakses ini."
            404 -> "Konten yang diminta tidak ditemukan."
            408 -> "Permintaan terlalu lama. Silakan coba lagi."
            409 -> "Konflik dengan status saat ini. Silakan refresh dan coba lagi."
            422 -> "Data yang dimasukkan tidak valid. Silakan periksa kembali."
            429 -> "Terlalu banyak permintaan. Silakan coba lagi nanti."
            in 500..599 -> "Kesalahan server. Silakan coba lagi nanti."
            else -> "Terjadi kesalahan. Silakan coba lagi."
        }
        is IOException -> "Kesalahan jaringan. Silakan periksa koneksi Anda."
        is JsonSyntaxException -> "Format data tidak valid."
        is TimeoutException -> "Permintaan terlalu lama. Silakan coba lagi."
        is NoInternetException -> "Tidak ada koneksi internet. Silakan periksa pengaturan jaringan Anda."
        is ValidationException -> message ?: "Data tidak valid."
        is InvalidCredentialsException -> "Email atau kata sandi salah."
        else -> message ?: "Terjadi kesalahan yang tidak terduga."
    }
}
```

### Pesan Error dengan Aksi:
```kotlin
data class ErrorAction(
    val message: String,
    val actionText: String? = null,
    val action: (() -> Unit)? = null
)

fun Throwable.toUserFriendlyErrorAction(): ErrorAction {
    return when (this) {
        is NoInternetException -> ErrorAction(
            message = "Tidak ada koneksi internet.",
            actionText = "Pengaturan",
            action = { openNetworkSettings() }
        )
        is HttpException -> when (code()) {
            401 -> ErrorAction(
                message = "Sesi Anda telah berakhir.",
                actionText = "Masuk",
                action = { navigateToLogin() }
            )
            403 -> ErrorAction(
                message = "Anda tidak memiliki izin untuk mengakses ini.",
                actionText = "Hubungi Admin",
                action = { contactAdmin() }
            )
            else -> ErrorAction(
                message = "Terjadi kesalahan. Silakan coba lagi.",
                actionText = "Coba Lagi",
                action = { retryLastOperation() }
            )
        }
        else -> ErrorAction(
            message = this.toUserFriendlyMessage(),
            actionText = "Coba Lagi",
            action = { retryLastOperation() }
        )
    }
}
```

### Pesan Error di UI:
```kotlin
@Composable
fun ErrorMessage(
    error: Throwable,
    onRetry: (() -> Unit)? = null
) {
    val errorAction = error.toUserFriendlyErrorAction()
    
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = Icons.Default.Error,
            contentDescription = null,
            tint = MaterialTheme.colorScheme.error,
            modifier = Modifier.size(48.dp)
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        Text(
            text = errorAction.message,
            color = MaterialTheme.colorScheme.error,
            textAlign = TextAlign.Center,
            modifier = Modifier.padding(horizontal = 16.dp)
        )
        
        if (errorAction.actionText != null && errorAction.action != null) {
            Spacer(modifier = Modifier.height(16.dp))
            
            Button(onClick = errorAction.action) {
                Text(errorAction.actionText)
            }
        } else if (onRetry != null) {
            Spacer(modifier = Modifier.height(16.dp))
            
            Button(onClick = onRetry) {
                Text("Coba Lagi")
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Pesan Error untuk Pengguna seperti Instruksi Evakuasi yang Jelas:**
- **Clear**: Pesan yang mudah dimengerti
- **Actionable**: Memberikan instruksi tentang apa yang harus dilakukan
- **Contextual**: Sesuai dengan konteks error
- **Helpful**: Membantu pengguna menyelesaikan masalah

**Strategi Pesan Error:**
1. Konversi exception ke pesan yang user-friendly
2. Sediakan aksi yang relevan
3. Gunakan bahasa yang mudah dimengerti
4. Hindari istilah teknis
5. Tampilkan pesan error di UI dengan jelas

**Best Practices:**
- Konversi exception ke pesan yang user-friendly
- Sediakan aksi yang relevan
- Gunakan bahasa yang mudah dimengerti
- Hindari istilah teknis
- Tampilkan pesan error di UI dengan jelas

---

## 1ï¸âƒ£1ï¸âƒ£ Logging Errors ğŸ“

### Konsep Dasar
Logging Errors seperti catatan insiden kebakaran ğŸ“ - mencatat detail kejadian untuk analisis dan perbaikan di masa depan!

### Logging Errors:
```kotlin
object ErrorLogger {
    fun logError(tag: String, message: String, throwable: Throwable?) {
        if (BuildConfig.DEBUG) {
            // Log untuk debug build
            Log.e(tag, message, throwable)
        } else {
            // Kirim ke crash reporting di production
            // Firebase Crashlytics, Sentry, dll.
            FirebaseCrashlytics.getInstance().apply {
                recordException(throwable ?: Exception(message))
                setCustomKey("tag", tag)
                setCustomKey("message", message)
            }
        }
    }
    
    fun logNetworkError(tag: String, url: String, method: String, throwable: Throwable?) {
        val message = "Network error: $method $url"
        logError(tag, message, throwable)
    }
    
    fun logHttpError(tag: String, url: String, method: String, code: Int, message: String?) {
        val errorMessage = "HTTP error: $method $url - $code $message"
        logError(tag, errorMessage, null)
    }
}

// Penggunaan di Repository
suspend fun getUsers(): Result<List<User>> {
    return try {
        val users = apiService.getUsers()
        Result.Success(users)
    } catch (e: HttpException) {
        ErrorLogger.logHttpError("UserRepository", "users", "GET", e.code(), e.message())
        Result.Error.Http(e.code(), e.message())
    } catch (e: IOException) {
        ErrorLogger.logNetworkError("UserRepository", "users", "GET", e)
        Result.Error.Network("Network error: ${e.message}")
    } catch (e: Exception) {
        ErrorLogger.logError("UserRepository", "Failed to get users", e)
        Result.Error.Generic(e)
    }
}
```

### Logging dengan Metadata:
```kotlin
object ErrorLogger {
    fun logError(
        tag: String,
        message: String,
        throwable: Throwable?,
        metadata: Map<String, Any> = emptyMap()
    ) {
        if (BuildConfig.DEBUG) {
            // Log untuk debug build
            Log.e(tag, message, throwable)
            metadata.forEach { (key, value) ->
                Log.d(tag, "$key: $value")
            }
        } else {
            // Kirim ke crash reporting di production
            FirebaseCrashlytics.getInstance().apply {
                recordException(throwable ?: Exception(message))
                setCustomKey("tag", tag)
                setCustomKey("message", message)
                metadata.forEach { (key, value) ->
                    setCustomKey(key, value.toString())
                }
            }
        }
    }
}

// Penggunaan di Repository
suspend fun getUser(userId: Int): Result<User> {
    return try {
        val user = apiService.getUser(userId)
        Result.Success(user)
    } catch (e: HttpException) {
        ErrorLogger.logError(
            tag = "UserRepository",
            message = "Failed to get user",
            throwable = e,
            metadata = mapOf(
                "userId" to userId,
                "httpCode" to e.code(),
                "httpMessage" to e.message()
            )
        )
        Result.Error.Http(e.code(), e.message())
    } catch (e: Exception) {
        ErrorLogger.logError(
            tag = "UserRepository",
            message = "Failed to get user",
            throwable = e,
            metadata = mapOf(
                "userId" to userId
            )
        )
        Result.Error.Generic(e)
    }
}
```

### Logging dengan Prioritas:
```kotlin
object ErrorLogger {
    fun logVerbose(tag: String, message: String) {
        if (BuildConfig.DEBUG) {
            Log.v(tag, message)
        }
    }
    
    fun logDebug(tag: String, message: String) {
        if (BuildConfig.DEBUG) {
            Log.d(tag, message)
        }
    }
    
    fun logInfo(tag: String, message: String) {
        Log.i(tag, message)
    }
    
    fun logWarning(tag: String, message: String) {
        Log.w(tag, message)
    }
    
    fun logError(tag: String, message: String, throwable: Throwable?) {
        if (BuildConfig.DEBUG) {
            Log.e(tag, message, throwable)
        } else {
            FirebaseCrashlytics.getInstance().apply {
                recordException(throwable ?: Exception(message))
                setCustomKey("tag", tag)
                setCustomKey("message", message)
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Logging Errors seperti Catatan Insiden Kebakaran:**
- **Debug Build**: Log lokal untuk analisis
- **Production**: Kirim ke crash reporting
- **Metadata**: Informasi tambahan untuk debugging
- **Prioritas**: Tingkat keparahan error

**Strategi Logging:**
1. Log error di debug build
2. Kirim ke crash reporting di production
3. Sertakan metadata untuk debugging
4. Gunakan prioritas yang sesuai
5. Jangan log informasi sensitif

**Best Practices:**
- Log error dengan jelas
- Sertakan metadata untuk debugging
- Gunakan crash reporting di production
- Jangan log informasi sensitif
- Gunakan prioritas yang sesuai

---

## 1ï¸âƒ£2ï¸âƒ£ Error Handling di Repository Layer ğŸ—„ï¸

### Konsep Dasar
Error Handling di Repository Layer seperti sistem cadangan air ğŸ—„ï¸ - menyediakan sumber daya alternatif jika sumber utama gagal!

### Repository dengan Error Handling:
```kotlin
class UserRepository(
    private val apiService: ApiService,
    private val userDao: UserDao
) {
    suspend fun getUser(userId: Int): Result<User> {
        return try {
            // Coba ambil dari API
            val user = apiService.getUser(userId)
            
            // Cache ke database lokal
            userDao.insertUser(user)
            
            Result.Success(user)
        } catch (e: IOException) {
            // Network error - coba dari database lokal
            try {
                val cachedUser = userDao.getUserById(userId)
                if (cachedUser != null) {
                    Result.Success(cachedUser)
                } else {
                    Result.Error.Network("No internet connection and no cached data")
                }
            } catch (dbError: Exception) {
                Result.Error.Generic(e)
            }
        } catch (e: Exception) {
            Result.Error.Generic(e)
        }
    }
    
    suspend fun getUsers(): Result<List<User>> {
        return try {
            // Coba ambil dari API
            val users = apiService.getUsers()
            
            // Cache ke database lokal
            userDao.insertAllUsers(users)
            
            Result.Success(users)
        } catch (e: IOException) {
            // Network error - coba dari database lokal
            try {
                val cachedUsers = userDao.getAllUsers()
                if (cachedUsers.isNotEmpty()) {
                    Result.Success(cachedUsers)
                } else {
                    Result.Error.Network("No internet connection and no cached data")
                }
            } catch (dbError: Exception) {
                Result.Error.Generic(e)
            }
        } catch (e: Exception) {
            Result.Error.Generic(e)
        }
    }
    
    suspend fun refreshUsers(): Result<List<User>> {
        return try {
            // Selalu ambil dari API untuk refresh
            val users = apiService.getUsers()
            
            // Update cache
            userDao.deleteAllUsers()
            userDao.insertAllUsers(users)
            
            Result.Success(users)
        } catch (e: Exception) {
            Result.Error.Generic(e)
        }
    }
}
```

### Repository dengan Fallback Strategy:
```kotlin
class UserRepository(
    private val apiService: ApiService,
    private val userDao: UserDao
) {
    suspend fun getUsers(refresh: Boolean = false): Result<List<User>> {
        // Jika refresh, selalu ambil dari API
        if (refresh) {
            return try {
                val users = apiService.getUsers()
                userDao.deleteAllUsers()
                userDao.insertAllUsers(users)
                Result.Success(users)
            } catch (e: Exception) {
                Result.Error.Generic(e)
            }
        }
        
        // Coba dari API dulu
        return try {
            val users = apiService.getUsers()
            userDao.deleteAllUsers()
            userDao.insertAllUsers(users)
            Result.Success(users)
        } catch (e: IOException) {
            // Network error - coba dari database lokal
            try {
                val cachedUsers = userDao.getAllUsers()
                if (cachedUsers.isNotEmpty()) {
                    Result.Success(cachedUsers)
                } else {
                    Result.Error.Network("No internet connection and no cached data")
                }
            } catch (dbError: Exception) {
                Result.Error.Generic(e)
            }
        } catch (e: Exception) {
            Result.Error.Generic(e)
        }
    }
}
```

### Repository dengan Retry Logic:
```kotlin
class UserRepository(
    private val apiService: ApiService,
    private val userDao: UserDao
) {
    suspend fun getUsers(): Result<List<User>> {
        return retryWithResult(times = 3) {
            try {
                val users = apiService.getUsers()
                userDao.deleteAllUsers()
                userDao.insertAllUsers(users)
                users
            } catch (e: IOException) {
                // Network error - coba dari database lokal
                val cachedUsers = userDao.getAllUsers()
                if (cachedUsers.isNotEmpty()) {
                    cachedUsers
                } else {
                    throw e
                }
            }
        }.let { result ->
            when (result) {
                is Result.Success -> result
                is Result.Error -> {
                    // Jika semua retry gagal, coba dari database lokal
                    try {
                        val cachedUsers = userDao.getAllUsers()
                        if (cachedUsers.isNotEmpty()) {
                            Result.Success(cachedUsers)
                        } else {
                            result
                        }
                    } catch (dbError: Exception) {
                        result
                    }
                }
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Error Handling di Repository Layer seperti Sistem Cadangan Air:**
- **Primary Source**: Sumber utama (API)
- **Fallback Source**: Sumber cadangan (database lokal)
- **Refresh**: Memperbarui sumber cadangan
- **Retry**: Mencoba kembali jika gagal

**Strategi Repository:**
1. Coba ambil dari API
2. Jika gagal, coba dari database lokal
3. Cache data dari API ke database lokal
4. Sediakan method untuk refresh data
5. Implementasikan retry logic untuk network errors

**Best Practices:**
- Gunakan database lokal sebagai fallback
- Cache data dari API ke database lokal
- Sediakan method untuk refresh data
- Implementasikan retry logic untuk network errors
- Pisahkan logic antara API dan database lokal

---

## 1ï¸âƒ£3ï¸âƒ£ Error Handling di ViewModel ğŸ§ 

### Konsep Dasar
Error Handling di ViewModel seperti komandan operasi pemadaman ğŸ§  - mengatur strategi dan komunikasi dengan tim!

### ViewModel dengan Error Handling:
```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UiState<List<User>>>(UiState.Idle)
    val uiState: StateFlow<UiState<List<User>>> = _uiState.asStateFlow()
    
    fun loadUsers() {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            
            when (val result = repository.getUsers()) {
                is Result.Success -> {
                    _uiState.value = UiState.Success(result.data)
                }
                is Result.Error.Network -> {
                    _uiState.value = UiState.Error.Network(
                        message = result.message,
                        onRetry = { loadUsers() }
                    )
                }
                is Result.Error.Http -> {
                    _uiState.value = UiState.Error.Http(
                        code = result.code,
                        message = result.message,
                        onRetry = { loadUsers() }
                    )
                }
                is Result.Error.Validation -> {
                    _uiState.value = UiState.Error.Validation(
                        message = result.message,
                        field = result.field
                    )
                }
                else -> {
                    _uiState.value = UiState.Error.Generic(
                        message = result.exception.message ?: "Unknown error",
                        onRetry = { loadUsers() }
                    )
                }
            }
        }
    }
    
    fun refreshUsers() {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            
            when (val result = repository.refreshUsers()) {
                is Result.Success -> {
                    _uiState.value = UiState.Success(result.data)
                }
                is Result.Error -> {
                    _uiState.value = UiState.Error.Generic(
                        message = result.exception.toUserFriendlyMessage(),
                        onRetry = { refreshUsers() }
                    )
                }
            }
        }
    }
}
```

### ViewModel dengan Error Handling dan Loading States:
```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UiState<List<User>>>(UiState.Idle)
    val uiState: StateFlow<UiState<List<User>>> = _uiState.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    private val _errorMessage = MutableStateFlow<String?>(null)
    val errorMessage: StateFlow<String?> = _errorMessage.asStateFlow()
    
    fun loadUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _errorMessage.value = null
            
            when (val result = repository.getUsers()) {
                is Result.Success -> {
                    _uiState.value = UiState.Success(result.data)
                }
                is Result.Error -> {
                    _errorMessage.value = result.exception.toUserFriendlyMessage()
                }
            }
            
            _isLoading.value = false
        }
    }
    
    fun refreshUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _errorMessage.value = null
            
            when (val result = repository.refreshUsers()) {
                is Result.Success -> {
                    _uiState.value = UiState.Success(result.data)
                }
                is Result.Error -> {
                    _errorMessage.value = result.exception.toUserFriendlyMessage()
                }
            }
            
            _isLoading.value = false
        }
    }
    
    fun clearError() {
        _errorMessage.value = null
    }
}
```

### ViewModel dengan Error Handling dan Retry Logic:
```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UiState<List<User>>>(UiState.Idle)
    val uiState: StateFlow<UiState<List<User>>> = _uiState.asStateState()
    
    private var retryCount = 0
    private val maxRetryCount = 3
    
    fun loadUsers() {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            
            when (val result = repository.getUsers()) {
                is Result.Success -> {
                    _uiState.value = UiState.Success(result.data)
                    retryCount = 0
                }
                is Result.Error.Network -> {
                    if (retryCount < maxRetryCount) {
                        retryCount++
                        delay(1000L * retryCount) // Exponential backoff
                        loadUsers()
                    } else {
                        _uiState.value = UiState.Error.Network(
                            message = result.message,
                            onRetry = { loadUsers() }
                        )
                        retryCount = 0
                    }
                }
                is Result.Error.Http -> {
                    _uiState.value = UiState.Error.Http(
                        code = result.code,
                        message = result.message,
                        onRetry = { loadUsers() }
                    )
                    retryCount = 0
                }
                else -> {
                    _uiState.value = UiState.Error.Generic(
                        message = result.exception.message ?: "Unknown error",
                        onRetry = { loadUsers() }
                    )
                    retryCount = 0
                }
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Error Handling di ViewModel seperti Komandan Operasi Pemadaman:**
- **Strategy**: Menentukan strategi penanganan error
- **Communication**: Mengkomunikasikan state ke UI
- **Retry**: Memutuskan kapan harus mencoba kembali
- **State Management**: Mengatur state loading, error, dan success

**Strategi ViewModel:**
1. Terima Result dari Repository
2. Konversi ke UiState
3. Sediakan callback untuk retry
4. Implementasikan retry logic
5. Komunikasikan state ke UI

**Best Practices:**
- Gunakan StateFlow untuk state yang observable
- Konversi Result ke UiState
- Sediakan callback untuk retry
- Implementasikan retry logic dengan bijak
- Komunikasikan state ke UI dengan jelas

---

## 1ï¸âƒ£4ï¸âƒ£ Global Error Handler ğŸŒ

### Konsep Dasar
Global Error Handler seperti sistem peringatan dini bencana ğŸŒ - mendeteksi dan merespons keadaan darurat di seluruh sistem!

### Global Error Handler:
```kotlin
class GlobalErrorHandler : Thread.UncaughtExceptionHandler {
    
    private val defaultHandler: Thread.UncaughtExceptionHandler? = 
        Thread.getDefaultUncaughtExceptionHandler()
    
    override fun uncaughtException(thread: Thread, throwable: Throwable) {
        // Log error
        ErrorLogger.logError("GlobalErrorHandler", "Uncaught exception", throwable)
        
        // Kirim ke crash reporting
        FirebaseCrashlytics.getInstance().recordException(throwable)
        
        // Panggil default handler
        defaultHandler?.uncaughtException(thread, throwable)
    }
    
    companion object {
        fun handle(exception: Exception, context: Context) {
            when (exception) {
                is HttpException -> when (exception.code()) {
                    401 -> {
                        // Redirect ke login
                        clearTokenAndNavigateToLogin(context)
                    }
                    503 -> {
                        // Tampilkan layanan maintenance
                        showMaintenanceMessage(context)
                    }
                }
                is NoInternetException -> {
                    // Tampilkan pesan no internet
                    Toast.makeText(context, "No internet connection", Toast.LENGTH_SHORT).show()
                }
            }
        }
        
        private fun clearTokenAndNavigateToLogin(context: Context) {
            // Clear token
            PreferenceManager.getDefaultSharedPreferences(context)
                .edit()
                .remove("auth_token")
                .apply()
            
            // Navigate to login
            val intent = Intent(context, LoginActivity::class.java)
            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
            context.startActivity(intent)
        }
        
        private fun showMaintenanceMessage(context: Context) {
            // Tampilkan dialog maintenance
            AlertDialog.Builder(context)
                .setTitle("Maintenance")
                .setMessage("Server is under maintenance. Please try again later.")
                .setPositiveButton("OK") { _, _ -> }
                .setCancelable(false)
                .show()
        }
    }
}
```

### Setup Global Error Handler:
```kotlin
class App : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // Setup global error handler
        Thread.setDefaultUncaughtExceptionHandler(GlobalErrorHandler())
    }
}
```

### Global Error Handler di Activity:
```kotlin
abstract class BaseActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Setup error handler untuk activity
        setupErrorHandler()
    }
    
    private fun setupErrorHandler() {
        // Implementasikan error handling khusus untuk activity
    }
    
    protected fun handleError(exception: Exception) {
        GlobalErrorHandler.handle(exception, this)
    }
}
```

### Global Error Handler di ViewModel:
```kotlin
abstract class BaseViewModel : ViewModel() {
    
    protected fun handleError(exception: Exception) {
        // Log error
        ErrorLogger.logError("BaseViewModel", "Error in ViewModel", exception)
        
        // Kirim ke crash reporting
        FirebaseCrashlytics.getInstance().recordException(exception)
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Global Error Handler seperti Sistem Peringatan Dini Bencana:**
- **Detection**: Mendeteksi error di seluruh aplikasi
- **Response**: Merespons error dengan cara yang sesuai
- **Logging**: Mencatat error untuk analisis
- **Recovery**: Mencoba memulihkan aplikasi dari error

**Strategi Global Error Handler:**
1. Tangkap uncaught exceptions
2. Log error untuk debugging
3. Kirim ke crash reporting
4. Implementasikan recovery strategy
5. Sediakan feedback ke pengguna

**Best Practices:**
- Setup global error handler di Application class
- Log error untuk debugging
- Kirim ke crash reporting
- Implementasikan recovery strategy
- Sediakan feedback ke pengguna

---

## 1ï¸âƒ£5ï¸âƒ£ Production-Ready Error Handling ğŸ­

### Konsep Dasar
Production-Ready Error Handling seperti sistem pemadaman kebakaran modern ğŸ­ - lengkap dengan peralatan canggih dan prosedur yang teruji!

### Complete Error Handling Solution:
```kotlin
// Result wrapper
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    
    sealed class Error : Result<Nothing>() {
        data class Network(val message: String) : Error()
        data class Http(val code: Int, val message: String) : Error()
        data class Validation(val message: String, val field: String? = null) : Error()
        data class Generic(val exception: Exception) : Error()
    }
    
    object Loading : Result<Nothing>()
}

// Safe API call dengan logging dan retry
suspend fun <T> safeApiCall(
    tag: String = "API",
    times: Int = 3,
    initialDelay: Long = 1000,
    maxDelay: Long = 10000,
    factor: Double = 2.0,
    shouldRetry: (Exception) -> Boolean = { it is IOException },
    metadata: Map<String, Any> = emptyMap(),
    apiCall: suspend () -> T
): Result<T> {
    var currentDelay = initialDelay
    
    repeat(times - 1) { attempt ->
        try {
            val result = apiCall()
            ErrorLogger.logDebug(tag, "API call succeeded on attempt ${attempt + 1}")
            return Result.Success(result)
        } catch (e: Exception) {
            if (!shouldRetry(e)) {
                ErrorLogger.logError(
                    tag = tag,
                    message = "API call failed on attempt ${attempt + 1}",
                    throwable = e,
                    metadata = metadata
                )
                return when (e) {
                    is HttpException -> Result.Error.Http(e.code(), e.message())
                    is IOException -> Result.Error.Network("Network error: ${e.message}")
                    else -> Result.Error.Generic(e)
                }
            }
            
            ErrorLogger.logWarning(
                tag = tag,
                message = "API call failed on attempt ${attempt + 1}, retrying in ${currentDelay}ms",
                throwable = e
            )
            delay(currentDelay)
            currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)
        }
    }
    
    return try {
        val result = apiCall()
        ErrorLogger.logDebug(tag, "API call succeeded on final attempt")
        Result.Success(result)
    } catch (e: Exception) {
        ErrorLogger.logError(
            tag = tag,
            message = "API call failed on final attempt",
            throwable = e,
            metadata = metadata
        )
        when (e) {
            is HttpException -> Result.Error.Http(e.code(), e.message())
            is IOException -> Result.Error.Network("Network error: ${e.message}")
            else -> Result.Error.Generic(e)
        }
    }
}

// Repository dengan error handling
class UserRepository(
    private val apiService: ApiService,
    private val userDao: UserDao
) {
    suspend fun getUsers(refresh: Boolean = false): Result<List<User>> {
        return if (refresh) {
            safeApiCall(
                tag = "UserRepository",
                apiCall = { apiService.getUsers() }
            ).also { result ->
                if (result is Result.Success) {
                    try {
                        userDao.deleteAllUsers()
                        userDao.insertAllUsers(result.data)
                    } catch (e: Exception) {
                        ErrorLogger.logError(
                            tag = "UserRepository",
                            message = "Failed to cache users",
                            throwable = e
                        )
                    }
                }
            }
        } else {
            safeApiCall(
                tag = "UserRepository",
                apiCall = { apiService.getUsers() }
            ).also { result ->
                if (result is Result.Success) {
                    try {
                        userDao.deleteAllUsers()
                        userDao.insertAllUsers(result.data)
                    } catch (e: Exception) {
                        ErrorLogger.logError(
                            tag = "UserRepository",
                            message = "Failed to cache users",
                            throwable = e
                        )
                    }
                } else if (result is Result.Error.Network) {
                    // Network error - coba dari database lokal
                    try {
                        val cachedUsers = userDao.getAllUsers()
                        if (cachedUsers.isNotEmpty()) {
                            Result.Success(cachedUsers)
                        } else {
                            result
                        }
                    } catch (dbError: Exception) {
                        ErrorLogger.logError(
                            tag = "UserRepository",
                            message = "Failed to get cached users",
                            throwable = dbError
                        )
                        result
                    }
                }
            }
        }
    }
}

// ViewModel dengan error handling
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UiState<List<User>>>(UiState.Idle)
    val uiState: StateFlow<UiState<List<User>>> = _uiState.asStateFlow()
    
    fun loadUsers(refresh: Boolean = false) {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            
            when (val result = repository.getUsers(refresh)) {
                is Result.Success -> {
                    _uiState.value = UiState.Success(result.data)
                }
                is Result.Error.Network -> {
                    _uiState.value = UiState.Error.Network(
                        message = result.message,
                        onRetry = { loadUsers(refresh) }
                    )
                }
                is Result.Error.Http -> {
                    _uiState.value = UiState.Error.Http(
                        code = result.code,
                        message = result.message,
                        onRetry = { loadUsers(refresh) }
                    )
                }
                is Result.Error.Validation -> {
                    _uiState.value = UiState.Error.Validation(
                        message = result.message,
                        field = result.field
                    )
                }
                is Result.Error.Generic -> {
                    _uiState.value = UiState.Error.Generic(
                        message = result.exception.toUserFriendlyMessage(),
                        onRetry = { loadUsers(refresh) }
                    )
                }
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Production-Ready Error Handling seperti Sistem Pemadaman Kebakaran Modern:**
- **Comprehensive**: Menangani semua jenis error
- **Logging**: Mencatat semua error untuk analisis
- **Retry**: Mencoba kembali dengan strategi yang cerdas
- **Fallback**: Menyediakan sumber daya cadangan
- **User-Friendly**: Memberikan pesan error yang jelas

**Komponen Production-Ready Error Handling:**
1. Result wrapper yang komprehensif
2. Safe API call dengan logging dan retry
3. Repository dengan error handling dan fallback
4. ViewModel dengan error handling dan state management
5. Pesan error yang user-friendly

**Best Practices:**
- Gunakan Result wrapper yang komprehensif
- Implementasikan retry logic dengan bijak
- Sediakan fallback mechanism
- Log semua error untuk debugging
- Konversi exception ke pesan yang user-friendly

---

## 1ï¸âƒ£6ï¸âƒ£ Best Practices âœ¨

### Konsep Dasar
Best Practices seperti buku panduan master âœ¨ - kumpulan aturan dan teknik yang telah terbukti efektif!

### Daftar Best Practices:
1. **Always Handle Errors Explicitly**: Jangan pernah mengabaikan error
2. **Use Sealed Classes untuk State**: Gunakan sealed class untuk representasi state UI
3. **Provide User-Friendly Error Messages**: Sediakan pesan error yang mudah dimengerti
4. **Log Errors untuk Debugging**: Log semua error untuk analisis
5. **Implement Retry Logic Where Appropriate**: Implementasikan retry logic dengan bijak
6. **Cache Data sebagai Fallback**: Gunakan database lokal sebagai fallback
7. **Test Error Scenarios**: Test semua skenario error
8. **Handle Edge Cases**: Tangani kasus-kasus edge (empty responses, null values)
9. **Use Custom Exceptions untuk Better Context**: Gunakan custom exception untuk konteks yang lebih baik
10. **Separate API Models dari Domain Models**: Pisahkan model API dari model domain
11. **Use Sealed Classes untuk Polymorphic Types**: Gunakan sealed class untuk tipe polimorfik
12. **Handle Unknown JSON Keys Gracefully**: Tangani key JSON yang tidak dikenal dengan baik
13. **Version Your API Models**: Buat versi untuk model API
14. **Use Dependency Injection**: Gunakan dependency injection untuk testability
15. **Don't Block UI Thread**: Jangan blok UI thread dengan operasi jaringan

### Contoh Implementasi Best Practices:
```kotlin
// 1. Always Handle Errors Explicitly
suspend fun getUsers(): Result<List<User>> {
    return try {
        val users = apiService.getUsers()
        Result.Success(users)
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}

// 2. Use Sealed Classes untuk State
sealed class UiState<out T> {
    object Idle : UiState<Nothing>()
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(val message: String) : UiState<Nothing>()
}

// 3. Provide User-Friendly Error Messages
fun Throwable.toUserFriendlyMessage(): String {
    return when (this) {
        is HttpException -> when (code()) {
            400 -> "Permintaan tidak valid. Silakan periksa input Anda."
            401 -> "Sesi Anda telah berakhir. Silakan masuk kembali."
            else -> "Terjadi kesalahan. Silakan coba lagi."
        }
        is IOException -> "Kesalahan jaringan. Silakan periksa koneksi Anda."
        else -> message ?: "Terjadi kesalahan yang tidak terduga."
    }
}

// 4. Log Errors untuk Debugging
object ErrorLogger {
    fun logError(tag: String, message: String, throwable: Throwable?) {
        if (BuildConfig.DEBUG) {
            Log.e(tag, message, throwable)
        } else {
            FirebaseCrashlytics.getInstance().recordException(throwable ?: Exception(message))
        }
    }
}

// 5. Implement Retry Logic Where Appropriate
suspend fun <T> retryWithExponentialBackoff(
    times: Int = 3,
    block: suspend () -> T
): T {
    var currentDelay = 1000L
    
    repeat(times - 1) { attempt ->
        try {
            return block()
        } catch (e: IOException) {
            delay(currentDelay)
            currentDelay *= 2
        }
    }
    
    return block()
}

// 6. Cache Data sebagai Fallback
class UserRepository(
    private val apiService: ApiService,
    private val userDao: UserDao
) {
    suspend fun getUsers(): Result<List<User>> {
        return try {
            val users = apiService.getUsers()
            userDao.insertAllUsers(users)
            Result.Success(users)
        } catch (e: IOException) {
            val cachedUsers = userDao.getAllUsers()
            if (cachedUsers.isNotEmpty()) {
                Result.Success(cachedUsers)
            } else {
                Result.Error.Network("No internet connection and no cached data")
            }
        } catch (e: Exception) {
            Result.Error.Generic(e)
        }
    }
}

// 7. Test Error Scenarios
@Test
fun testGetUsersReturnsErrorWhenNetworkFails() {
    // Given
    every { apiService.getUsers() } throws IOException()
    
    // When
    val result = userRepository.getUsers()
    
    // Then
    assertTrue(result is Result.Error.Network)
}

// 8. Handle Edge Cases
suspend fun getUser(userId: Int): Result<User> {
    return try {
        val user = apiService.getUser(userId)
        if (user != null) {
            Result.Success(user)
        } else {
            Result.Error.Http(404, "User not found")
        }
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}

// 9. Use Custom Exceptions untuk Better Context
class UserNotFoundException(userId: Int) : Exception("User with ID $userId not found")

// 10. Separate API Models dari Domain Models
data class UserDto(
    @SerializedName("user_id")
    val id: Int,
    @SerializedName("full_name")
    val name: String
)

data class User(
    val id: Int,
    val name: String
)

fun UserDto.toDomain(): User {
    return User(id, name)
}

// 11. Use Sealed Classes untuk Polymorphic Types
sealed class Response {
    @Serializable
    @SerialName("success")
    data class Success(val data: String) : Response()
    
    @Serializable
    @SerialName("error")
    data class Error(val message: String) : Response()
}

// 12. Handle Unknown JSON Keys Gracefully
val json = Json {
    ignoreUnknownKeys = true
}

// 13. Version Your API Models
data class UserV1(
    @SerializedName("user_id")
    val id: Int,
    @SerializedName("full_name")
    val name: String
)

data class UserV2(
    @SerializedName("user_id")
    val id: Int,
    @SerializedName("full_name")
    val name: String,
    @SerializedName("email")
    val email: String
)

// 14. Use Dependency Injection
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository
) : ViewModel() {
    // ...
}

// 15. Don't Block UI Thread
fun loadUsers() {
    viewModelScope.launch {
        val result = repository.getUsers()
        _uiState.value = result
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Best Practices seperti Buku Panduan Master:**
- **Comprehensive**: Menangani semua aspek error handling
- **Proven**: Teknik yang telah terbukti efektif
- **Consistent**: Konsisten di seluruh aplikasi
- **User-Friendly**: Memberikan pengalaman pengguna yang baik
- **Maintainable**: Mudah dipelihara dan diperbarui

**Best Practices seperti Buku Panduan Master:**
- **Comprehensive**: Menangani semua aspek error handling
- **Proven**: Teknik yang telah terbukti efektif
- **Consistent**: Konsisten di seluruh aplikasi
- **User-Friendly**: Memberikan pengalaman pengguna yang baik
- **Maintainable**: Mudah dipelihara dan diperbarui

**Prinsip Utama:**
- **Explicitness**: Tangani error secara eksplisit
- **Clarity**: Berikan pesan error yang jelas
- **Resilience**: Buat aplikasi yang tangguh
- **User Experience**: Prioritaskan pengalaman pengguna
- **Debugging**: Mudahkan proses debugging

---

## 1ï¸âƒ£7ï¸âƒ£ Hands-on Exercises ğŸ”¨

### Konsep Dasar
Hands-on Exercises seperti simulasi kebakaran ğŸ”¨ - latihan untuk mempersiapkan diri menghadapi situasi darurat yang sebenarnya!

### Daftar Latihan:
1. **Implement Result Wrapper**: Buat sealed class `Result` dengan `Success`, `Error`, dan `Loading`.
2. **Create Custom Exceptions**: Buat custom exception untuk kasus spesifik aplikasi Anda.
3. **Build Error Handling Interceptor**: Buat interceptor untuk menangani error secara global.
4. **Implement Retry Logic**: Implementasikan retry logic dengan exponential backoff.
5. **Test Different Error Scenarios**: Test berbagai skenario error (network, HTTP, parsing).
6. **Create Error UI Components**: Buat komponen UI untuk menampilkan error dan tombol retry.
7. **Integration dengan Repository dan ViewModel**: Integrasikan semua konsep dalam arsitektur MVVM.

### Contoh Implementasi:
**1. Result Wrapper:**
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()
    object Loading : Result<Nothing>()
}
```

**2. Custom Exception:**
```kotlin
class NoInternetException(message: String = "No internet connection") 
    : IOException(message)
```

**3. Error Handling Interceptor:**
```kotlin
class ErrorHandlingInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val response = chain.proceed(request)
        
        when (response.code) {
            401 -> throw UnauthorizedException()
            403 -> throw ForbiddenException()
            404 -> throw NotFoundException()
            in 500..599 -> throw ServerException(response.code)
        }
        
        return response
    }
}
```

**4. Retry Logic:**
```kotlin
suspend fun <T> retryWithExponentialBackoff(
    times: Int = 3,
    block: suspend () -> T
): T {
    var currentDelay = 1000L
    
    repeat(times - 1) { attempt ->
        try {
            return block()
        } catch (e: IOException) {
            delay(currentDelay)
            currentDelay *= 2
        }
    }
    
    return block()
}
```

**5. Test Error Scenarios:**
```kotlin
@Test
fun testGetUsersReturnsErrorWhenNetworkFails() {
    // Given
    every { apiService.getUsers() } throws IOException()
    
    // When
    val result = userRepository.getUsers()
    
    // Then
    assertTrue(result is Result.Error)
}
```

**6. Error UI Components:**
```kotlin
@Composable
fun ErrorMessage(
    message: String,
    onRetry: () -> Unit
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = message)
        Button(onClick = onRetry) {
            Text("Retry")
        }
    }
}
```

**7. Integration dengan Repository dan ViewModel:**
```kotlin
class UserRepository {
    suspend fun getUsers(): Result<List<User>> {
        return try {
            val users = apiService.getUsers()
            Result.Success(users)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
}

class UserViewModel {
    fun loadUsers() {
        viewModelScope.launch {
            _uiState.value = Result.Loading
            
            when (val result = repository.getUsers()) {
                is Result.Success -> _uiState.value = Result.Success(result.data)
                is Result.Error -> _uiState.value = Result.Error(result.exception)
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Hands-on Exercises seperti Simulasi Kebakaran:**
- **Result Wrapper**: Membuat mobil pemadam kebakaran
- **Custom Exceptions**: Membuat alat pemadam khusus
- **Error Handling Interceptor**: Membuat sistem peringatan dini
- **Retry Logic**: Melatih strategi pemadaman berulang
- **Test Scenarios**: Simulasi berbagai jenis kebakaran
- **Error UI Components**: Membuat tanda peringatan evakuasi
- **Integration**: Melakukan simulasi pemadaman skala penuh

**Langkah Praktik:**
1. Pilih skenario yang ingin dilatih
2. Implementasikan solusi
3. Test dengan berbagai kondisi
4. Analisis hasil dan perbaiki
5. Ulangi hingga mahir

**Best Practices:**
- Mulai dengan kasus sederhana
- Tingkatkan kompleksitas secara bertahap
- Test semua skenario error
- Dokumentasikan solusi
- Berbagi pengetahuan dengan tim

---

## ğŸ¯ Kesimpulan

### ğŸŒŸ Apa yang Telah Kita Pelajari:
Kita telah membangun sistem pertahanan yang tangguh untuk aplikasi Android, mampu menghadapi berbagai situasi darurat dengan elegan:

1.  **Jenis-Jenis Error**: Mengidentifikasi dan mengklasifikasikan berbagai jenis masalah yang mungkin terjadi, dari jaringan hingga logika bisnis.
2.  **Dasar Try-Catch**: Menguasai alat paling dasar namun krusial untuk menangkap exception.
3.  **Result Wrapper Pattern**: Membangun struktur yang terorganisir dan type-safe untuk mengelola hasil operasi (sukses, error, loading).
4.  **Safe API Call Wrapper**: Menciptakan fungsi yang dapat digunakan kembali untuk panggilan API yang aman.
5.  **Model Error Response**: Memahami cara mem-parsing pesan error dari server secara terstruktur.
6.  **Menangani Kode Status HTTP**: Merespons berbagai kode status HTTP dengan tepat dan memberikan feedback yang sesuai.
7.  **Custom Exceptions**: Membuat exception khusus untuk memberikan konteks yang lebih jelas tentang masalah.
8.  **Sealed Classes untuk State Management**: Menggunakan sealed class untuk mengelola state UI dengan aman dan jelas.
9.  **Retry Logic**: Menerapkan strategi percobaan kembali yang cerdas untuk meningkatkan keandalan.
10. **Pesan Error untuk Pengguna**: Menerjemahkan error teknis menjadi pesan yang mudah dimengerti dan membantu pengguna.
11. **Logging Errors**: Mencatat insiden untuk analisis dan perbaikan di masa depan.
12. **Error Handling di Repository Layer**: Menerapkan fallback mechanism dengan cache lokal.
13. **Error Handling di ViewModel**: Menghubungkan logic error handling dengan state UI.
14. **Global Error Handler**: Membangun sistem penanganan error tingkat aplikasi.
15. **Production-Ready Error Handling**: Menggabungkan semua konsep menjadi solusi yang lengkap dan andal.

### ğŸš€ Langkah Selanjutnya:
Dengan fondasi error handling yang kuat, aplikasi Anda menjadi jauh lebih tangguh. Langkah selanjutnya adalah:

1.  **Implementasikan di Proyek Nyata**: Terapkan semua pola ini dalam proyek Android yang sedang Anda kerjakan.
2.  **Eksplorasi Crash Reporting**: Integrasikan layanan seperti Firebase Crashlytics atau Sentry untuk monitoring error di production.
3.  **Pelajari Testing**: Tulis unit test dan integration test untuk skenario error.
4.  **Analisis Data**: Gunakan data error yang logged untuk mengidentifikasi area yang perlu diperbaiki dalam aplikasi.
5.  **Optimasi UX**: Terus perbaiki pesan error dan alur recovery berdasarkan feedback pengguna.

### ğŸ¯ Tips untuk Menjadi Ahli Error Handling:
1.  **Pikirkan Pengguna**: Selalu utamakan pengalaman pengguna saat menangani error.
2.  **Jangan Abaikan Error**: Satu error yang diabaikan dapat merusak kepercayaan pengguna.
3.  **Log dengan Bijak**: Log informasi yang cukup untuk debugging, tapi jangan mencatat data sensitif.
4.  **Test Secara Menyeluruh**: Uji tidak hanya "happy path" tetapi juga semua "unhappy path".
5.  **Buatlah Standar**: Tetapkan standar error handling yang konsisten di seluruh tim dan proyek.

Dengan penguasaan penuh atas error handling, Anda tidak lagi hanya membuat aplikasi yang *berfungsi*, tetapi aplikasi yang *andal*, *tangguh*, dan * Profesional*. Aplikasi Anda akan siap menghadapi dunia nyata yang tidak selalu sempurna. Teruslah berlatih, dan aplikasi Anda akan menjadi aplikasi yang dapat diandalkan dalam situasi apa pun