## **5.7 API Authentication** (3 hari) ⭐⭐⭐

### **Teknologi Modern:**
- JWT (JSON Web Tokens)
- OAuth 2.0
- Bearer tokens

### **Teknologi yang Ditinggalkan:**
- Basic auth

### **Sub-topik Detail:**

#### 1. Authentication Basics
- Authentication vs Authorization
- Stateless authentication
- Token-based authentication
- Session vs Token
- Security best practices

#### 2. JWT (JSON Web Tokens)

**JWT Structure:**
```
Header.Payload.Signature

Example:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

**JWT Components:**
- **Header**: Algorithm & token type
- **Payload**: Claims (user data)
- **Signature**: Verify authenticity

**JWT Claims:**
```json
{
  "sub": "1234567890",     // Subject (user ID)
  "name": "John Doe",      // User name
  "iat": 1516239022,       // Issued at
  "exp": 1516242622,       // Expiration
  "roles": ["admin"]       // Custom claims
}
```

#### 3. Login & Token Storage

**Login Request:**
```kotlin
data class LoginRequest(
    val email: String,
    val password: String
)

data class LoginResponse(
    val accessToken: String,
    val refreshToken: String,
    val expiresIn: Long,
    val user: User
)

interface AuthApi {
    @POST("auth/login")
    suspend fun login(@Body request: LoginRequest): LoginResponse
}
```

**Secure Token Storage:**
```kotlin
class TokenManager(private val context: Context) {
    private val prefs = context.getSharedPreferences(
        "auth_prefs",
        Context.MODE_PRIVATE
    )
    
    // Better: Use EncryptedSharedPreferences
    private val encryptedPrefs = EncryptedSharedPreferences.create(
        "encrypted_auth_prefs",
        MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC),
        context,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    
    fun saveTokens(accessToken: String, refreshToken: String) {
        encryptedPrefs.edit()
            .putString("access_token", accessToken)
            .putString("refresh_token", refreshToken)
            .apply()
    }
    
    fun getAccessToken(): String? {
        return encryptedPrefs.getString("access_token", null)
    }
    
    fun getRefreshToken(): String? {
        return encryptedPrefs.getString("refresh_token", null)
    }
    
    fun clearTokens() {
        encryptedPrefs.edit().clear().apply()
    }
}
```

#### 4. Bearer Token Authentication

**Auth Interceptor:**
```kotlin
class AuthInterceptor(
    private val tokenManager: TokenManager
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val original = chain.request()
        
        // Skip authentication for login/register endpoints
        if (original.url().encodedPath().contains("/auth/")) {
            return chain.proceed(original)
        }
        
        val token = tokenManager.getAccessToken()
        
        val request = if (token != null) {
            original.newBuilder()
                .header("Authorization", "Bearer $token")
                .build()
        } else {
            original
        }
        
        return chain.proceed(request)
    }
}

// Setup
val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(AuthInterceptor(tokenManager))
    .build()
```

#### 5. Token Refresh Flow

**Refresh Token:**
```kotlin
data class RefreshTokenRequest(
    val refreshToken: String
)

data class RefreshTokenResponse(
    val accessToken: String,
    val refreshToken: String,
    val expiresIn: Long
)

interface AuthApi {
    @POST("auth/refresh")
    suspend fun refreshToken(
        @Body request: RefreshTokenRequest
    ): RefreshTokenResponse
}
```

**Token Refresh Interceptor:**
```kotlin
class TokenAuthenticator(
    private val tokenManager: TokenManager,
    private val authApi: AuthApi
) : Authenticator {
    
    override fun authenticate(
        route: Route?,
        response: Response
    ): Request? {
        // Check if this is a 401 Unauthorized
        if (response.code() != 401) {
            return null
        }
        
        // Avoid infinite loop
        if (response.request().header("Authorization")?.contains("Bearer") == false) {
            return null
        }
        
        synchronized(this) {
            // Try to refresh token
            val refreshToken = tokenManager.getRefreshToken() ?: return null
            
            try {
                val newTokens = runBlocking {
                    authApi.refreshToken(RefreshTokenRequest(refreshToken))
                }
                
                // Save new tokens
                tokenManager.saveTokens(
                    newTokens.accessToken,
                    newTokens.refreshToken
                )
                
                // Retry request with new token
                return response.request().newBuilder()
                    .header("Authorization", "Bearer ${newTokens.accessToken}")
                    .build()
                    
            } catch (e: Exception) {
                // Refresh failed, clear tokens and redirect to login
                tokenManager.clearTokens()
                // Trigger logout event
                return null
            }
        }
    }
}

// Setup
val okHttpClient = OkHttpClient.Builder()
    .authenticator(TokenAuthenticator(tokenManager, authApi))
    .addInterceptor(AuthInterceptor(tokenManager))
    .build()
```

#### 6. JWT Token Validation
```kotlin
fun isTokenExpired(token: String): Boolean {
    try {
        val parts = token.split(".")
        if (parts.size != 3) return true
        
        // Decode payload (Base64)
        val payload = String(Base64.decode(parts[1], Base64.URL_SAFE))
        val json = JSONObject(payload)
        
        // Check expiration
        val exp = json.getLong("exp")
        val now = System.currentTimeMillis() / 1000
        
        return now >= exp
    } catch (e: Exception) {
        return true
    }
}

// Usage
val token = tokenManager.getAccessToken()
if (token != null && isTokenExpired(token)) {
    // Refresh token
}
```

#### 7. OAuth 2.0 Flow

**Authorization Code Flow:**
```
1. User → Authorization Server (Login)
2. Authorization Server → App (Authorization Code)
3. App → Authorization Server (Exchange code for tokens)
4. Authorization Server → App (Access Token + Refresh Token)
5. App → Resource Server (API calls with Access Token)
```

**Implementation:**
```kotlin
// 1. Redirect to authorization URL
val authUrl = "https://auth.example.com/authorize?" +
    "response_type=code&" +
    "client_id=YOUR_CLIENT_ID&" +
    "redirect_uri=YOUR_REDIRECT_URI&" +
    "scope=read write&" +
    "state=random_state_string"

// Open in browser or WebView
val intent = Intent(Intent.ACTION_VIEW, Uri.parse(authUrl))
startActivity(intent)

// 2. Handle redirect (in Activity with intent-filter)
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    val uri = intent.data
    if (uri != null && uri.toString().startsWith(REDIRECT_URI)) {
        val code = uri.getQueryParameter("code")
        val state = uri.getQueryParameter("state")
        
        // Verify state to prevent CSRF
        if (state == savedState && code != null) {
            // Exchange code for tokens
            exchangeCodeForTokens(code)
        }
    }
}

// 3. Exchange authorization code for tokens
data class TokenRequest(
    val grant_type: String = "authorization_code",
    val code: String,
    val redirect_uri: String,
    val client_id: String,
    val client_secret: String
)

suspend fun exchangeCodeForTokens(code: String) {
    val request = TokenRequest(
        code = code,
        redirect_uri = REDIRECT_URI,
        client_id = CLIENT_ID,
        client_secret = CLIENT_SECRET
    )
    
    val response = authApi.exchangeToken(request)
    tokenManager.saveTokens(response.accessToken, response.refreshToken)
}
```

#### 8. Social Authentication (Google, Facebook)

**Google Sign-In:**
```kotlin
dependencies {
    implementation("com.google.android.gms:play-services-auth:20.7.0")
}

// Google Sign-In
val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
    .requestIdToken(getString(R.string.default_web_client_id))
    .requestEmail()
    .build()

val googleSignInClient = GoogleSignIn.getClient(this, gso)

// Sign in
val signInIntent = googleSignInClient.signInIntent
startActivityForResult(signInIntent, RC_SIGN_IN)

// Handle result
override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    super.onActivityResult(requestCode, resultCode, data)
    
    if (requestCode == RC_SIGN_IN) {
        val task = GoogleSignIn.getSignedInAccountFromIntent(data)
        try {
            val account = task.getResult(ApiException::class.java)
            val idToken = account.idToken
            
            // Send ID token to your backend
            authenticateWithBackend(idToken)
        } catch (e: ApiException) {
            // Handle error
        }
    }
}
```

#### 9. Biometric Authentication
```kotlin
dependencies {
    implementation("androidx.biometric:biometric:1.2.0-alpha05")
}

fun authenticateWithBiometric() {
    val executor = ContextCompat.getMainExecutor(this)
    val biometricPrompt = BiometricPrompt(
        this,
        executor,
        object : BiometricPrompt.AuthenticationCallback() {
            override fun onAuthenticationSucceeded(
                result: BiometricPrompt.AuthenticationResult
            ) {
                // Authentication successful
                // Proceed with sensitive operation
            }
            
            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                // Handle error
            }
            
            override fun onAuthenticationFailed() {
                // Authentication failed
            }
        }
    )
    
    val promptInfo = BiometricPrompt.PromptInfo.Builder()
        .setTitle("Biometric Authentication")
        .setSubtitle("Authenticate to continue")
        .setNegativeButtonText("Cancel")
        .build()
    
    biometricPrompt.authenticate(promptInfo)
}
```

#### 10. Logout
```kotlin
suspend fun logout() {
    try {
        // Optional: Call logout endpoint
        authApi.logout()
    } catch (e: Exception) {
        // Handle error
    } finally {
        // Clear tokens
        tokenManager.clearTokens()
        
        // Clear user data
        // Navigate to login screen
    }
}
```

#### 11. Security Best Practices
✅ Use HTTPS only
✅ Store tokens securely (EncryptedSharedPreferences)
✅ Implement token refresh
✅ Set token expiration
✅ Validate tokens
✅ Use strong passwords
✅ Implement rate limiting
✅ Enable 2FA (Two-Factor Authentication)
✅ Log security events
✅ Handle token revocation

**Never:**
❌ Store tokens in plain text
❌ Log sensitive data
❌ Hardcode credentials
❌ Use HTTP for authentication
❌ Store passwords

#### 12. Complete Auth Flow Example
```kotlin
class AuthRepository(
    private val authApi: AuthApi,
    private val tokenManager: TokenManager
) {
    suspend fun login(email: String, password: String): Result<User> {
        return try {
            val response = authApi.login(LoginRequest(email, password))
            
            // Save tokens
            tokenManager.saveTokens(
                response.accessToken,
                response.refreshToken
            )
            
            Result.Success(response.user)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
    
    suspend fun refreshToken(): Result<Unit> {
        return try {
            val refreshToken = tokenManager.getRefreshToken()
                ?: return Result.Error(Exception("No refresh token"))
            
            val response = authApi.refreshToken(RefreshTokenRequest(refreshToken))
            
            tokenManager.saveTokens(
                response.accessToken,
                response.refreshToken
            )
            
            Result.Success(Unit)
        } catch (e: Exception) {
            // Clear tokens on refresh failure
            tokenManager.clearTokens()
            Result.Error(e)
        }
    }
    
    fun logout() {
        tokenManager.clearTokens()
    }
    
    fun isLoggedIn(): Boolean {
        val token = tokenManager.getAccessToken()
        return token != null && !isTokenExpired(token)
    }
}
```

#### 13. Hands-on Project
- Implement complete auth flow
- JWT token management
- Token refresh mechanism
- Secure token storage
- OAuth 2.0 integration
- Biometric authentication
- Error handling
- Testing auth flows

---
