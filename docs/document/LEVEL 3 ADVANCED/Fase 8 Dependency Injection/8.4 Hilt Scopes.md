## **8.4 Hilt Scopes** (3 hari) ⭐⭐

### **Teknologi Modern:**
- @Singleton
- @ActivityScoped
- @ViewModelScoped
- Component hierarchy

### **Teknologi yang Ditinggalkan:**
- Manual lifecycle management
- Memory leaks from wrong scopes
- Global singletons

### **Sub-topik Detail:**

#### **1. Component Hierarchy**

```
SingletonComponent (Application)
    ↓
ActivityRetainedComponent (ViewModel)
    ↓
ActivityComponent (Activity)
    ↓
FragmentComponent (Fragment)
    ↓
ViewComponent (View)
    ↓
ViewWithFragmentComponent (View with Fragment)
    ↓
ServiceComponent (Service)
```

#### **2. Singleton Scope**

**App-level Dependencies:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object SingletonModule {
    
    @Provides
    @Singleton // Lives for entire app
    fun provideDatabase(
        @ApplicationContext context: Context
    ): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "app_db"
        ).build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .build()
    }
}

// Usage: Same instance everywhere
class UserRepository @Inject constructor(
    private val database: AppDatabase // Same instance
)

class ArticleRepository @Inject constructor(
    private val database: AppDatabase // Same instance
)
```

#### **3. Activity Scope**

**Activity-level Dependencies:**
```kotlin
@Module
@InstallIn(ActivityComponent::class)
object ActivityModule {
    
    @Provides
    @ActivityScoped // Lives for activity lifecycle
    fun provideImagePicker(
        @ActivityContext context: Context
    ): ImagePicker {
        return ImagePicker(context as Activity)
    }
}

@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    
    @Inject
    lateinit var imagePicker: ImagePicker // Scoped to this activity
}
```

#### **4. ViewModel Scope**

**Automatic Scoping:**
```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    // Automatically scoped to ViewModel lifecycle
    // Survives configuration changes
    // Cleared when ViewModel is cleared
}
```

**Shared ViewModel:**
```kotlin
@AndroidEntryPoint
class HostActivity : AppCompatActivity() {
    private val sharedViewModel: SharedViewModel by viewModels()
}

@AndroidEntryPoint
class Fragment1 : Fragment() {
    // Same instance as activity
    private val sharedViewModel: SharedViewModel by activityViewModels()
}

@AndroidEntryPoint
class Fragment2 : Fragment() {
    // Same instance as activity
    private val sharedViewModel: SharedViewModel by activityViewModels()
}
```

#### **5. Fragment Scope**

**Fragment-specific Dependencies:**
```kotlin
@Module
@InstallIn(FragmentComponent::class)
object FragmentModule {
    
    @Provides
    fun provideFragmentHelper(): FragmentHelper {
        return FragmentHelper()
    }
}

@AndroidEntryPoint
class UserFragment : Fragment() {
    
    @Inject
    lateinit var helper: FragmentHelper // New instance per fragment
}
```

#### **6. Service Scope**

**Service Dependencies:**
```kotlin
@Module
@InstallIn(ServiceComponent::class)
object ServiceModule {
    
    @Provides
    fun provideNotificationHelper(
        @ApplicationContext context: Context
    ): NotificationHelper {
        return NotificationHelper(context)
    }
}

@AndroidEntryPoint
class DownloadService : Service() {
    
    @Inject
    lateinit var notificationHelper: NotificationHelper
    
    override fun onBind(intent: Intent?): IBinder? = null
}
```

#### **7. Custom Scopes**

**Define Custom Scope:**
```kotlin
@Scope
@Retention(AnnotationRetention.RUNTIME)
annotation class UserScope

// Create custom component
@UserScope
@DefineComponent(parent = SingletonComponent::class)
interface UserComponent {
    
    @DefineComponent.Builder
    interface Builder {
        fun build(): UserComponent
    }
}

// Install module
@Module
@InstallIn(UserComponent::class)
object UserModule {
    
    @Provides
    @UserScope
    fun provideUserSession(): UserSession {
        return UserSession()
    }
}
```

#### **8. Scope Lifetime Examples**

**Different Lifetimes:**
```kotlin
// Singleton - Lives for entire app
@Singleton
class AppConfig @Inject constructor()

// ActivityScoped - Recreated on config change
@ActivityScoped
class ActivityTracker @Inject constructor()

// ViewModel - Survives config changes
@HiltViewModel
class MyViewModel @Inject constructor()

// No scope - New instance every injection
class TempHelper @Inject constructor()
```

#### **9. Scope Best Practices**

**Memory Management:**
```kotlin
// ✅ GOOD: Scoped appropriately
@Singleton
class Database // Expensive, share across app

@ActivityScoped
class LocationTracker // Tied to activity lifecycle

// ❌ BAD: Wrong scope
@Singleton
class ActivityHelper(private val activity: Activity) // Memory leak!

@ActivityScoped
class AppDatabase // Inefficient, should be singleton
```

#### **10. Testing with Scopes**

**Test Module:**
```kotlin
@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [NetworkModule::class]
)
object TestNetworkModule {
    
    @Provides
    @Singleton
    fun provideApiService(): ApiService {
        return FakeApiService()
    }
}
```

#### **11. Best Practices**
✅ Use @Singleton sparingly
✅ Scope to shortest necessary lifetime
✅ ViewModels automatically scoped correctly
✅ Don't hold activity context in singleton
✅ Use @ActivityScoped for activity-specific needs
✅ Unscoped dependencies created on each injection
✅ Be aware of memory leaks
✅ Test with different scopes

---
