




## **7.6 Cancellability & Concurrency** (3 hari) ⭐⭐⭐

### **Teknologi Modern:**
- Job hierarchy
- Cancellation
- Structured concurrency
- Mutex & Semaphore

### **Teknologi yang Ditinggalkan:**
- Unstructured concurrency
- Manual thread synchronization

### **Sub-topik Detail:**

#### **1. Job Hierarchy & Cancellation**

**Parent-Child Relationship:**
```kotlin
val parentJob = GlobalScope.launch {
    println("Parent started")
    
    val child1 = launch {
        delay(1000)
        println("Child 1 completed")
    }
    
    val child2 = launch {
        delay(2000)
        println("Child 2 completed")
    }
    
    println("Parent waiting for children")
}

// Cancelling parent cancels all children
delay(500)
parentJob.cancel()
// Output: Parent started, Parent waiting for children
// Children are cancelled before completion
```

**Job States:**
```kotlin
val job = launch {
    delay(1000)
}

println("isActive: ${job.isActive}")       // true
println("isCancelled: ${job.isCancelled}") // false
println("isCompleted: ${job.isCompleted}") // false

job.cancel()
println("After cancel:")
println("isActive: ${job.isActive}")       // false
println("isCancelled: ${job.isCancelled}") // true
println("isCompleted: ${job.isCompleted}") // false

job.join() // Wait for cancellation to complete
println("After join:")
println("isCompleted: ${job.isCompleted}") // true
```

**Cancellation Propagation:**
```kotlin
supervisorScope {
    val job1 = launch {
        try {
            delay(Long.MAX_VALUE)
        } finally {
            println("Job 1 cancelled")
        }
    }
    
    val job2 = launch {
        try {
            delay(Long.MAX_VALUE)
        } finally {
            println("Job 2 cancelled")
        }
    }
    
    delay(500)
    job1.cancel() // Only job1 is cancelled
    // job2 continues running
}
```

#### **2. Cooperative Cancellation**

**isActive Check:**
```kotlin
suspend fun doLongRunningWork() {
    repeat(1000) { i ->
        if (!isActive) {
            println("Work cancelled at iteration $i")
            return
        }
        // Do work
        processItem(i)
    }
}

val job = launch {
    doLongRunningWork()
}

delay(100)
job.cancel()
```

**ensureActive:**
```kotlin
suspend fun processLargeDataset(items: List<Item>) {
    items.forEach { item ->
        ensureActive() // Throws CancellationException if cancelled
        processItem(item)
    }
}
```

**yield:**
```kotlin
suspend fun heavyComputation() {
    repeat(1000) { i ->
        yield() // Cooperative cancellation point
        // Heavy CPU work
        complexCalculation(i)
    }
}
```

**Non-Cancellable Operations:**
```kotlin
val job = launch {
    try {
        repeat(1000) { i ->
            delay(100)
            println("Working: $i")
        }
    } finally {
        // Cleanup that must complete
        withContext(NonCancellable) {
            delay(1000)
            saveState()
            println("Cleanup completed")
        }
    }
}

delay(500)
job.cancel()
job.join()
// Cleanup still executes despite cancellation
```

#### **3. Timeouts**

**withTimeout:**
```kotlin
try {
    withTimeout(5000) {
        val data = fetchData()
        processData(data)
    }
} catch (e: TimeoutCancellationException) {
    println("Operation timed out!")
}
```

**withTimeoutOrNull:**
```kotlin
val result = withTimeoutOrNull(5000) {
    fetchData()
}

if (result == null) {
    println("Timeout occurred")
    // Handle timeout
} else {
    processData(result)
}
```

**Custom Timeout Handler:**
```kotlin
suspend fun <T> withTimeoutAndFallback(
    timeMillis: Long,
    fallback: T,
    block: suspend () -> T
): T {
    return withTimeoutOrNull(timeMillis) {
        block()
    } ?: fallback
}

// Usage
val data = withTimeoutAndFallback(
    timeMillis = 5000,
    fallback = Data.default()
) {
    api.fetchData()
}
```

#### **4. Structured Concurrency**

**coroutineScope:**
```kotlin
suspend fun loadUserProfile(userId: String): UserProfile = coroutineScope {
    // All children must complete before returning
    val user = async { userRepository.getUser(userId) }
    val posts = async { postRepository.getUserPosts(userId) }
    val followers = async { followRepository.getFollowers(userId) }
    
    UserProfile(
        user = user.await(),
        posts = posts.await(),
        followers = followers.await()
    )
}
// If any child fails, all are cancelled
```

**supervisorScope:**
```kotlin
suspend fun loadDashboard(): Dashboard = supervisorScope {
    // Children are independent
    val user = async {
        try {
            userRepository.getUser()
        } catch (e: Exception) {
            User.default()
        }
    }
    
    val stats = async {
        try {
            statsRepository.getStats()
        } catch (e: Exception) {
            Stats.empty()
        }
    }
    
    val notifications = async {
        try {
            notificationRepository.getUnread()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    Dashboard(user.await(), stats.await(), notifications.await())
}
// One failure doesn't affect others
```

**Combining Scopes:**
```kotlin
class RepositoryOrchestrator {
    suspend fun loadAllData() = supervisorScope {
        // Independent sections
        val section1 = async {
            coroutineScope {
                // Dependent operations within section
                val a = async { fetchA() }
                val b = async { fetchB() }
                Section1(a.await(), b.await())
            }
        }
        
        val section2 = async {
            coroutineScope {
                val c = async { fetchC() }
                val d = async { fetchD() }
                Section2(c.await(), d.await())
            }
        }
        
        AllData(section1.await(), section2.await())
    }
}
```

#### **5. Concurrency Control**

**async with Controlled Parallelism:**
```kotlin
suspend fun processItems(items: List<Item>): List<Result> {
    return coroutineScope {
        items.chunked(10).flatMap { chunk ->
            chunk.map { item ->
                async {
                    processItem(item)
                }
            }.awaitAll()
        }
    }
}
// Processes 10 items at a time
```

**Sequential vs Parallel:**
```kotlin
// Sequential (slow)
suspend fun loadDataSequential(): Data {
    val user = fetchUser()
    val posts = fetchPosts()
    val comments = fetchComments()
    return Data(user, posts, comments)
}

// Parallel (fast)
suspend fun loadDataParallel(): Data = coroutineScope {
    val user = async { fetchUser() }
    val posts = async { fetchPosts() }
    val comments = async { fetchComments() }
    Data(user.await(), posts.await(), comments.await())
}
```

**Rate Limiting:**
```kotlin
class RateLimiter(
    private val permits: Int,
    private val period: Duration
) {
    private val semaphore = Semaphore(permits)
    private val timestamps = mutableListOf<Long>()
    
    suspend fun <T> execute(block: suspend () -> T): T {
        semaphore.withPermit {
            val now = System.currentTimeMillis()
            
            // Remove old timestamps
            timestamps.removeAll { it < now - period.inWholeMilliseconds }
            
            // Wait if needed
            if (timestamps.size >= permits) {
                val oldest = timestamps.first()
                val waitTime = oldest + period.inWholeMilliseconds - now
                if (waitTime > 0) {
                    delay(waitTime)
                }
            }
            
            timestamps.add(now)
            return block()
        }
    }
}

// Usage
val rateLimiter = RateLimiter(permits = 10, period = 1.seconds)

suspend fun makeApiCall() {
    rateLimiter.execute {
        api.getData()
    }
}
```

#### **6. Mutex & Thread Safety**

**Mutex for Shared State:**
```kotlin
class Counter {
    private var count = 0
    private val mutex = Mutex()
    
    suspend fun increment() {
        mutex.withLock {
            count++
        }
    }
    
    suspend fun getCount(): Int {
        return mutex.withLock {
            count
        }
    }
}

// Usage
val counter = Counter()
coroutineScope {
    repeat(1000) {
        launch {
            counter.increment()
        }
    }
}
println(counter.getCount()) // Always 1000
```

**Mutex vs Synchronized:**
```kotlin
// ❌ Don't use synchronized with suspend functions
class BadCounter {
    private var count = 0
    
    @Synchronized  // Doesn't work with suspend
    suspend fun increment() {
        delay(1)
        count++
    }
}

// ✅ Use Mutex instead
class GoodCounter {
    private var count = 0
    private val mutex = Mutex()
    
    suspend fun increment() {
        mutex.withLock {
            delay(1)
            count++
        }
    }
}
```

**Semaphore for Resource Limiting:**
```kotlin
class ConnectionPool(maxConnections: Int) {
    private val semaphore = Semaphore(maxConnections)
    
    suspend fun <T> useConnection(block: suspend () -> T): T {
        return semaphore.withPermit {
            // Only maxConnections can run simultaneously
            block()
        }
    }
}

// Usage
val pool = ConnectionPool(maxConnections = 5)

suspend fun makeRequest() {
    pool.useConnection {
        // Make network request
        api.getData()
    }
}
```

#### **7. Channels for Communication**

**Basic Channel:**
```kotlin
val channel = Channel<Int>()

launch {
    repeat(5) { i ->
        channel.send(i)
        delay(100)
    }
    channel.close()
}

launch {
    for (value in channel) {
        println("Received: $value")
    }
}
```

**Producer-Consumer:**
```kotlin
fun CoroutineScope.produceNumbers() = produce<Int> {
    repeat(10) { i ->
        send(i)
        delay(100)
    }
}

fun CoroutineScope.processNumbers(numbers: ReceiveChannel<Int>) = launch {
    for (number in numbers) {
        println("Processing: $number")
        delay(200)
    }
}

// Usage
coroutineScope {
    val numbers = produceNumbers()
    repeat(3) {
        processNumbers(numbers)
    }
}
```

**Fan-Out Pattern:**
```kotlin
fun CoroutineScope.produceData() = produce<Data> {
    repeat(100) {
        send(fetchData())
    }
}

suspend fun processData(id: Int, channel: ReceiveChannel<Data>) {
    for (data in channel) {
        println("Processor $id: $data")
        delay(100)
    }
}

// Usage
coroutineScope {
    val dataChannel = produceData()
// Multiple consumers
    repeat(5) { id ->
        launch {
            processData(id, dataChannel)
        }
    }
}
```

#### **8. Advanced Cancellation Patterns**

**Cancellation with Cleanup:**
```kotlin
class DataLoader {
    private var job: Job? = null
    
    fun startLoading() {
        job = CoroutineScope(Dispatchers.Main).launch {
            try {
                val resource = acquireResource()
                try {
                    loadData(resource)
                } finally {
                    withContext(NonCancellable) {
                        releaseResource(resource)
                    }
                }
            } catch (e: CancellationException) {
                // Log cancellation
                Log.d("DataLoader", "Loading cancelled")
                throw e
            }
        }
    }
    
    fun cancel() {
        job?.cancel()
        job = null
    }
}
```

**Cancellation with Callbacks:**
```kotlin
suspend fun fetchWithCallback(url: String): String = suspendCancellableCoroutine { continuation ->
    val callback = object : Callback {
        override fun onSuccess(data: String) {
            continuation.resume(data)
        }
        
        override fun onFailure(error: Exception) {
            continuation.resumeWithException(error)
        }
    }
    
    val call = httpClient.newCall(url, callback)
    
    // Handle cancellation
    continuation.invokeOnCancellation {
        call.cancel()
    }
}
```

#### **9. Testing Concurrency**

**Test Parallel Execution:**
```kotlin
@Test
fun `test parallel execution completes faster`() = runTest {
    val start = System.currentTimeMillis()
    
    coroutineScope {
        launch { delay(1000) }
        launch { delay(1000) }
        launch { delay(1000) }
    }
    
    val duration = System.currentTimeMillis() - start
    assertTrue(duration < 1500) // Should complete in ~1000ms, not 3000ms
}
```

**Test Cancellation:**
```kotlin
@Test
fun `test job cancellation`() = runTest {
    var executedItems = 0
    
    val job = launch {
        repeat(100) {
            delay(10)
            executedItems++
        }
    }
    
    delay(50)
    job.cancel()
    job.join()
    
    assertTrue(executedItems < 100) // Should be cancelled early
}
```

#### **10. Best Practices**
✅ Use structured concurrency
✅ Always handle cancellation properly
✅ Use supervisorScope untuk independent operations
✅ Implement cooperative cancellation dengan yield/ensureActive
✅ Clean up resources dalam finally dengan NonCancellable
✅ Use Mutex untuk shared mutable state
✅ Never suppress CancellationException
✅ Test cancellation scenarios
✅ Use timeouts untuk prevent hanging operations
✅ Limit concurrency dengan Semaphore

#### **11. Common Pitfalls**

**❌ Don't Do:**
```kotlin
// Catching and ignoring cancellation
try {
    delay(1000)
} catch (e: Exception) {
    // BAD: Swallows CancellationException
}

// Using GlobalScope
GlobalScope.launch {
    // BAD: No structured concurrency
}

// Not handling cleanup
launch {
    val resource = acquire()
    useResource(resource)
    // BAD: resource not released on cancellation
}
```

**✅ Do:**
```kotlin
// Proper cancellation handling
try {
    delay(1000)
} catch (e: CancellationException) {
    // Re-throw cancellation
    throw e
} catch (e: Exception) {
    // Handle other exceptions
}

// Use proper scope
lifecycleScope.launch {
    // Cancelled when lifecycle is destroyed
}

// Proper cleanup
launch {
    val resource = acquire()
    try {
        useResource(resource)
    } finally {
        withContext(NonCancellable) {
            release(resource)
        }
    }
}
```

#### **12. Hands-on Exercises**
- Implement parallel data loading dengan controlled concurrency
- Build cancellable long-running operations
- Create resource pool dengan Semaphore
- Implement rate limiter
- Build producer-consumer pattern dengan Channels
- Test cancellation scenarios
- Create cleanup mechanisms untuk resources
- Implement timeout handling strategies
