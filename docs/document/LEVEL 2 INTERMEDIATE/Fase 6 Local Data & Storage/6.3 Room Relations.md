## **6.3 Room Relations** (3 hari) ⭐⭐

### **Teknologi Modern:**
- One-to-many
- Many-to-many

### **Teknologi yang Ditinggalkan:**
- Multiple tables tanpa relasi

### **Sub-topik Detail:**

#### 1. Relationship Basics
- Database normalization
- Foreign keys
- Referential integrity
- Cascade operations
- Junction tables
- Embedded objects

#### 2. One-to-One Relationship

**Entities:**
```kotlin
@Entity(tableName = "users")
data class User(
    @PrimaryKey val userId: Long,
    val userName: String,
    val email: String
)

@Entity(
    tableName = "user_profiles",
    foreignKeys = [
        ForeignKey(
            entity = User::class,
            parentColumns = ["userId"],
            childColumns = ["userId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index("userId")]
)
data class UserProfile(
    @PrimaryKey val profileId: Long,
    val userId: Long,
    val bio: String,
    val avatarUrl: String,
    val phoneNumber: String?
)
```

**Relation:**
```kotlin
data class UserWithProfile(
    @Embedded val user: User,
    @Relation(
        parentColumn = "userId",
        entityColumn = "userId"
    )
    val profile: UserProfile?
)
```

**DAO:**
```kotlin
@Dao
interface UserDao {
    @Transaction
    @Query("SELECT * FROM users WHERE userId = :userId")
    suspend fun getUserWithProfile(userId: Long): UserWithProfile?
    
    @Transaction
    @Query("SELECT * FROM users")
    fun getAllUsersWithProfiles(): Flow<List<UserWithProfile>>
    
    @Insert
    suspend fun insertUser(user: User): Long
    
    @Insert
    suspend fun insertProfile(profile: UserProfile)
    
    @Transaction
    suspend fun insertUserWithProfile(user: User, profile: UserProfile) {
        insertUser(user)
        insertProfile(profile)
    }
}
```

#### 3. One-to-Many Relationship

**Entities:**
```kotlin
@Entity(tableName = "users")
data class User(
    @PrimaryKey val userId: Long,
    val userName: String,
    val email: String
)

@Entity(
    tableName = "posts",
    foreignKeys = [
        ForeignKey(
            entity = User::class,
            parentColumns = ["userId"],
            childColumns = ["authorId"],
            onDelete = ForeignKey.CASCADE,
            onUpdate = ForeignKey.CASCADE
        )
    ],
    indices = [Index("authorId")]
)
data class Post(
    @PrimaryKey(autoGenerate = true)
    val postId: Long = 0,
    val authorId: Long,
    val title: String,
    val content: String,
    val createdAt: Long = System.currentTimeMillis()
)
```

**Relation:**
```kotlin
data class UserWithPosts(
    @Embedded val user: User,
    @Relation(
        parentColumn = "userId",
        entityColumn = "authorId"
    )
    val posts: List<Post>
)
```

**DAO:**
```kotlin
@Dao
interface UserDao {
    @Transaction
    @Query("SELECT * FROM users WHERE userId = :userId")
    suspend fun getUserWithPosts(userId: Long): UserWithPosts?
    
    @Transaction
    @Query("SELECT * FROM users")
    fun getAllUsersWithPosts(): Flow<List<UserWithPosts>>
    
    @Transaction
    @Query("SELECT * FROM users WHERE userName LIKE '%' || :query || '%'")
    fun searchUsersWithPosts(query: String): Flow<List<UserWithPosts>>
}

@Dao
interface PostDao {
    @Insert
    suspend fun insertPost(post: Post): Long
    
    @Query("SELECT * FROM posts WHERE authorId = :userId ORDER BY createdAt DESC")
    fun getPostsByUser(userId: Long): Flow<List<Post>>
    
    @Query("SELECT COUNT(*) FROM posts WHERE authorId = :userId")
    suspend fun getPostCountByUser(userId: Long): Int
}
```

#### 4. Many-to-Many Relationship

**Entities:**
```kotlin
@Entity(tableName = "students")
data class Student(
    @PrimaryKey val studentId: Long,
    val name: String,
    val email: String
)

@Entity(tableName = "courses")
data class Course(
    @PrimaryKey val courseId: Long,
    val courseName: String,
    val credits: Int
)

// Junction Table (Association Entity)
@Entity(
    tableName = "student_course_cross_ref",
    primaryKeys = ["studentId", "courseId"],
    foreignKeys = [
        ForeignKey(
            entity = Student::class,
            parentColumns = ["studentId"],
            childColumns = ["studentId"],
            onDelete = ForeignKey.CASCADE
        ),
        ForeignKey(
            entity = Course::class,
            parentColumns = ["courseId"],
            childColumns = ["courseId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index("studentId"),
        Index("courseId")
    ]
)
data class StudentCourseCrossRef(
    val studentId: Long,
    val courseId: Long,
    val enrollmentDate: Long = System.currentTimeMillis(),
    val grade: String? = null
)
```

**Relations:**
```kotlin
// Student with their courses
data class StudentWithCourses(
    @Embedded val student: Student,
    @Relation(
        parentColumn = "studentId",
        entityColumn = "courseId",
        associateBy = Junction(
            value = StudentCourseCrossRef::class,
            parentColumn = "studentId",
            entityColumn = "courseId"
        )
    )
    val courses: List<Course>
)

// Course with enrolled students
data class CourseWithStudents(
    @Embedded val course: Course,
    @Relation(
        parentColumn = "courseId",
        entityColumn = "studentId",
        associateBy = Junction(
            value = StudentCourseCrossRef::class,
            parentColumn = "courseId",
            entityColumn = "studentId"
        )
    )
    val students: List<Student>
)

// With enrollment details
data class StudentCourseWithDetails(
    @Embedded val student: Student,
    @Relation(
        entity = Course::class,
        parentColumn = "studentId",
        entityColumn = "courseId",
        associateBy = Junction(
            value = StudentCourseCrossRef::class,
            parentColumn = "studentId",
            entityColumn = "courseId"
        )
    )
    val coursesWithDetails: List<CourseEnrollment>
)

data class CourseEnrollment(
    @Embedded val course: Course,
    @Relation(
        parentColumn = "courseId",
        entityColumn = "courseId"
    )
    val enrollmentInfo: StudentCourseCrossRef
)
```

**DAOs:**
```kotlin
@Dao
interface StudentDao {
    @Insert
    suspend fun insertStudent(student: Student)
    
    @Transaction
    @Query("SELECT * FROM students WHERE studentId = :studentId")
    suspend fun getStudentWithCourses(studentId: Long): StudentWithCourses?
    
    @Transaction
    @Query("SELECT * FROM students")
    fun getAllStudentsWithCourses(): Flow<List<StudentWithCourses>>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun enrollStudentInCourse(crossRef: StudentCourseCrossRef)
    
    @Delete
    suspend fun unenrollStudentFromCourse(crossRef: StudentCourseCrossRef)
    
    @Query("""
        SELECT * FROM students
        WHERE studentId IN (
            SELECT studentId FROM student_course_cross_ref
            WHERE courseId = :courseId
        )
    """)
    suspend fun getStudentsInCourse(courseId: Long): List<Student>
}

@Dao
interface CourseDao {
    @Insert
    suspend fun insertCourse(course: Course)
    
    @Transaction
    @Query("SELECT * FROM courses WHERE courseId = :courseId")
    suspend fun getCourseWithStudents(courseId: Long): CourseWithStudents?
    
    @Transaction
    @Query("SELECT * FROM courses")
    fun getAllCoursesWithStudents(): Flow<List<CourseWithStudents>>
    
    @Query("""
        SELECT * FROM courses
        WHERE courseId IN (
            SELECT courseId FROM student_course_cross_ref
            WHERE studentId = :studentId
        )
    """)
    suspend fun getCoursesForStudent(studentId: Long): List<Course>
    
    @Query("""
        SELECT COUNT(*) FROM student_course_cross_ref
        WHERE courseId = :courseId
    """)
    suspend fun getEnrollmentCount(courseId: Long): Int
}

@Dao
interface EnrollmentDao {
    @Query("""
        SELECT * FROM student_course_cross_ref
        WHERE studentId = :studentId AND courseId = :courseId
    """)
    suspend fun getEnrollment(studentId: Long, courseId: Long): StudentCourseCrossRef?
    
    @Update
    suspend fun updateEnrollment(crossRef: StudentCourseCrossRef)
    
    @Query("""
        UPDATE student_course_cross_ref
        SET grade = :grade
        WHERE studentId = :studentId AND courseId = :courseId
    """)
    suspend fun updateGrade(studentId: Long, courseId: Long, grade: String)
}
```

#### 5. Nested Relations

**Complex Entity Structure:**
```kotlin
@Entity(tableName = "users")
data class User(
    @PrimaryKey val userId: Long,
    val userName: String
)

@Entity(
    tableName = "posts",
    foreignKeys = [
        ForeignKey(
            entity = User::class,
            parentColumns = ["userId"],
            childColumns = ["authorId"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class Post(
    @PrimaryKey val postId: Long,
    val authorId: Long,
    val title: String,
    val content: String
)

@Entity(
    tableName = "comments",
    foreignKeys = [
        ForeignKey(
            entity = Post::class,
            parentColumns = ["postId"],
            childColumns = ["postId"],
            onDelete = ForeignKey.CASCADE
        ),
        ForeignKey(
            entity = User::class,
            parentColumns = ["userId"],
            childColumns = ["authorId"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class Comment(
    @PrimaryKey val commentId: Long,
    val postId: Long,
    val authorId: Long,
    val content: String,
    val createdAt: Long
)
```

**Nested Relations:**
```kotlin
// Post with comments
data class PostWithComments(
    @Embedded val post: Post,
    @Relation(
        parentColumn = "postId",
        entityColumn = "postId"
    )
    val comments: List<Comment>
)

// User with posts and their comments
data class UserWithPostsAndComments(
    @Embedded val user: User,
    @Relation(
        entity = Post::class,
        parentColumn = "userId",
        entityColumn = "authorId"
    )
    val posts: List<PostWithComments>
)

// Comment with author info
data class CommentWithAuthor(
    @Embedded val comment: Comment,
    @Relation(
        parentColumn = "authorId",
        entityColumn = "userId"
    )
    val author: User
)

// Post with comments and their authors
data class PostWithCommentsAndAuthors(
    @Embedded val post: Post,
    @Relation(
        entity = Comment::class,
        parentColumn = "postId",
        entityColumn = "postId"
    )
    val comments: List<CommentWithAuthor>
)
```

**DAO:**
```kotlin
@Dao
interface PostDao {
    @Transaction
    @Query("SELECT * FROM posts WHERE postId = :postId")
    suspend fun getPostWithComments(postId: Long): PostWithComments?
    
    @Transaction
    @Query("SELECT * FROM users WHERE userId = :userId")
    suspend fun getUserWithPostsAndComments(userId: Long): UserWithPostsAndComments?
    
    @Transaction
    @Query("SELECT * FROM posts WHERE postId = :postId")
    suspend fun getPostWithCommentsAndAuthors(postId: Long): PostWithCommentsAndAuthors?
}
```

#### 6. Intermediate Entity (Rich Junction Table)

**When Junction Table Has Additional Data:**
```kotlin
@Entity(
    tableName = "playlist_song_cross_ref",
    primaryKeys = ["playlistId", "songId"],
    foreignKeys = [
        ForeignKey(
            entity = Playlist::class,
            parentColumns = ["playlistId"],
            childColumns = ["playlistId"],
            onDelete = ForeignKey.CASCADE
        ),
        ForeignKey(
            entity = Song::class,
            parentColumns = ["songId"],
            childColumns = ["songId"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class PlaylistSongCrossRef(
    val playlistId: Long,
    val songId: Long,
    val addedAt: Long = System.currentTimeMillis(),
    val position: Int, // Order in playlist
    val playCount: Int = 0
)

// Get playlist with songs in order
data class PlaylistWithSongs(
    @Embedded val playlist: Playlist,
    @Relation(
        entity = Song::class,
        parentColumn = "playlistId",
        entityColumn = "songId",
        associateBy = Junction(
            value = PlaylistSongCrossRef::class,
            parentColumn = "playlistId",
            entityColumn = "songId"
        )
    )
    val songs: List<SongWithMetadata>
)

data class SongWithMetadata(
    @Embedded val song: Song,
    @Relation(
        parentColumn = "songId",
        entityColumn = "songId"
    )
    val metadata: PlaylistSongCrossRef?
)

@Dao
interface PlaylistDao {
    @Transaction
    @Query("""
        SELECT s.*, psc.position, psc.playCount, psc.addedAt
        FROM songs s
        INNER JOIN playlist_song_cross_ref psc ON s.songId = psc.songId
        WHERE psc.playlistId = :playlistId
        ORDER BY psc.position ASC
    """)
    fun getSongsInPlaylistOrdered(playlistId: Long): Flow<List<SongWithMetadata>>
    
    @Query("""
        UPDATE playlist_song_cross_ref
        SET position = :newPosition
        WHERE playlistId = :playlistId AND songId = :songId
    """)
    suspend fun updateSongPosition(playlistId: Long, songId: Long, newPosition: Int)
    
    @Query("""
        UPDATE playlist_song_cross_ref
        SET playCount = playCount + 1
        WHERE playlistId = :playlistId AND songId = :songId
    """)
    suspend fun incrementPlayCount(playlistId: Long, songId: Long)
}
```

#### 7. Cascade Operations

**Delete Cascade:**
```kotlin
@Entity(
    tableName = "posts",
    foreignKeys = [
        ForeignKey(
            entity = User::class,
            parentColumns = ["userId"],
            childColumns = ["authorId"],
            onDelete = ForeignKey.CASCADE // Delete posts when user deleted
        )
    ]
)
data class Post(...)

// When you delete a user, all their posts are automatically deleted
@Dao
interface UserDao {
    @Delete
    suspend fun deleteUser(user: User) // Cascades to posts
}
```

**Update Cascade:**
```kotlin
@Entity(
    tableName = "orders",
    foreignKeys = [
        ForeignKey(
            entity = Customer::class,
            parentColumns = ["customerId"],
            childColumns = ["customerId"],
            onUpdate = ForeignKey.CASCADE // Update orders when customer ID changes
        )
    ]
)
data class Order(...)
```

**Set Null:**
```kotlin
@Entity(
    tableName = "posts",
    foreignKeys = [
        ForeignKey(
            entity = User::class,
            parentColumns = ["userId"],
            childColumns = ["authorId"],
            onDelete = ForeignKey.SET_NULL // Set authorId to null when user deleted
        )
    ]
)
data class Post(
    @PrimaryKey val postId: Long,
    val authorId: Long?, // Nullable for SET_NULL
    val title: String
)
```

**Restrict (Default):**
```kotlin
@Entity(
    tableName = "posts",
    foreignKeys = [
        ForeignKey(
            entity = User::class,
            parentColumns = ["userId"],
            childColumns = ["authorId"],
            onDelete = ForeignKey.RESTRICT // Cannot delete user if they have posts
        )
    ]
)
data class Post(...)
```

#### 8. Querying Relations

**Conditional Relations:**
```kotlin
@Dao
interface UserDao {
    // Get users with only published posts
    @Transaction
    @Query("""
        SELECT * FROM users
        WHERE userId IN (
            SELECT DISTINCT authorId FROM posts WHERE isPublished = 1
        )
    """)
    fun getUsersWithPublishedPosts(): Flow<List<UserWithPosts>>
    
    // Get users with post count
    @Query("""
        SELECT u.*, COUNT(p.postId) as postCount
        FROM users u
        LEFT JOIN posts p ON u.userId = p.authorId
        GROUP BY u.userId
    """)
    fun getUsersWithPostCount(): Flow<List<UserPostCount>>
}

data class UserPostCount(
    @Embedded val user: User,
    val postCount: Int
)
```

**Filtering Nested Data:**
```kotlin
@Dao
interface PostDao {
    // Get posts with comments from last 7 days
    @Transaction
    @Query("""
        SELECT * FROM posts
        WHERE postId IN (
            SELECT DISTINCT postId FROM comments
            WHERE createdAt > :sevenDaysAgo
        )
    """)
    fun getPostsWithRecentComments(
        sevenDaysAgo: Long = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000
    ): Flow<List<PostWithComments>>
}
```

#### 9. Performance Optimization

**Indices on Foreign Keys:**
```kotlin
@Entity(
    tableName = "posts",
    foreignKeys = [...],
    indices = [
        Index(value = ["authorId"]), // Index foreign key
        Index(value = ["createdAt"]), // Index for sorting
        Index(value = ["authorId", "createdAt"]) // Composite index
    ]
)
data class Post(...)
```

**Pagination with Relations:**
```kotlin
@Dao
interface PostDao {
    @Transaction
    @Query("""
        SELECT * FROM posts
        ORDER BY createdAt DESC
        LIMIT :limit OFFSET :offset
    """)
    suspend fun getPostsWithCommentsPaginated(
        limit: Int,
        offset: Int
    ): List<PostWithComments>
}
```

**Lazy Loading vs Eager Loading:**
```kotlin
// Eager loading - loads everything at once
@Transaction
@Query("SELECT * FROM users")
fun getAllUsersWithPosts(): Flow<List<UserWithPosts>>

// Lazy loading - load on demand
@Query("SELECT * FROM users")
fun getAllUsers(): Flow<List<User>>

@Query("SELECT * FROM posts WHERE authorId = :userId")
fun getPostsByUser(userId: Long): Flow<List<Post>>
```

#### 10. Best Practices
✅ Always use @Transaction for relation queries
✅ Add indices on foreign key columns
✅ Use appropriate cascade operations
✅ Consider nullable foreign keys when needed
✅ Use junction tables for many-to-many
✅ Implement proper error handling
✅ Test relation queries thoroughly
✅ Consider performance with nested relations
✅ Use Flow for reactive queries
✅ Document complex relationships

#### 11. Common Patterns

**Self-Referencing Relationship (Tree Structure):**
```kotlin
@Entity(
    tableName = "categories",
    foreignKeys = [
        ForeignKey(
            entity = Category::class,
            parentColumns = ["categoryId"],
            childColumns = ["parentId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index("parentId")]
)
data class Category(
    @PrimaryKey val categoryId: Long,
    val name: String,
    val parentId: Long? = null // Self-reference
)

data class CategoryWithSubcategories(
    @Embedded val category: Category,
    @Relation(
        parentColumn = "categoryId",
        entityColumn = "parentId"
    )
    val subcategories: List<Category>
)

@Dao
interface CategoryDao {
    @Transaction
    @Query("SELECT * FROM categories WHERE parentId IS NULL")
    fun getRootCategoriesWithChildren(): Flow<List<CategoryWithSubcategories>>
}
```

#### 12. Testing Relations

```kotlin
@RunWith(AndroidJUnit4::class)
class RelationTest {
    private lateinit var database: AppDatabase
    private lateinit var userDao: UserDao
    private lateinit var postDao: PostDao
    
    @Before
    fun setup() {
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            AppDatabase::class.java
        ).build()
        
        userDao = database.userDao()
        postDao = database.postDao()
    }
    
    @Test
    fun testOneToManyRelation() = runTest {
        // Given
        val user = User(userId = 1, userName = "John", email = "john@test.com")
        val posts = listOf(
            Post(postId = 1, authorId = 1, title = "Post 1", content = "Content 1"),
            Post(postId = 2, authorId = 1, title = "Post 2", content = "Content 2")
        )
        
        // When
        userDao.insertUser(user)
        posts.forEach { postDao.insertPost(it) }
        
        val userWithPosts = userDao.getUserWithPosts(1)
        
        // Then
        assertNotNull(userWithPosts)
        assertEquals(2, userWithPosts?.posts?.size)
    }
    
    @Test
    fun testCascadeDelete() = runTest {
        // Given
        val user = User(userId = 1, userName = "John", email = "john@test.com")
        val post = Post(postId = 1, authorId = 1, title = "Post", content = "Content")
        
        userDao.insertUser(user)
        postDao.insertPost(post)
        
        // When
        userDao.deleteUser(user)
        
        // Then
        val posts = postDao.getPostsByUser(1).first()
        assertTrue(posts.isEmpty())
    }
}
```

#### 13. Hands-on Project
- Implement one-to-one relationship
- Create one-to-many structure
- Build many-to-many with junction table
- Add cascade operations
- Nested relations
- Complex queries
- Performance optimization
- Testing all relationships

---

