## **5.5 Advanced Networking** (3 hari) ⭐⭐⭐

### **Teknologi Modern:**
- Exponential backoff retry
- API throttling
- Cache-Control headers

### **Teknologi yang Ditinggalkan:**
- Simple retry

### **Sub-topik Detail:**

#### 1. Advanced Retry Strategies

**Exponential Backoff:**
```kotlin
suspend fun <T> retryWithExponentialBackoff(
    maxRetries: Int = 3,
    initialDelayMillis: Long = 1000,
    maxDelayMillis: Long = 32000,
    factor: Double = 2.0,
    shouldRetry: (Exception) -> Boolean = { true },
    block: suspend () -> T
): T {
    var currentDelay = initialDelayMillis
    var lastException: Exception? = null
    
    repeat(maxRetries) { attempt ->
        try {
            return block()
        } catch (e: Exception) {
            lastException = e
            
            // Check if we should retry this error
            if (!shouldRetry(e) || attempt == maxRetries - 1) {
                throw e
            }
            
            Log.d("Retry", "Attempt ${attempt + 1} failed. Retrying in ${currentDelay}ms")
            delay(currentDelay)
            
            // Exponential backoff with jitter
            currentDelay = (currentDelay * factor).toLong()
                .coerceAtMost(maxDelayMillis)
                .let { it + Random.nextLong(0, it / 10) } // Add jitter
        }
    }
    
    throw lastException ?: Exception("Max retries exceeded")
}

// Usage
val data = retryWithExponentialBackoff(
    maxRetries = 5,
    shouldRetry = { it is IOException || (it is HttpException && it.code() >= 500) }
) {
    apiService.getData()
}
```

**Retry Interceptor:**
```kotlin
class RetryInterceptor(
    private val maxRetries: Int = 3
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        var response: Response? = null
        var exception: IOException? = null
        
        repeat(maxRetries) { attempt ->
            try {
                response?.close()
                response = chain.proceed(request)
                
                // Retry on server errors (5xx)
                if (response!!.isSuccessful || response!!.code() < 500) {
                    return response!!
                }
            } catch (e: IOException) {
                exception = e
                Log.w("RetryInterceptor", "Request failed, attempt ${attempt + 1}: ${e.message}")
            }
            
            if (attempt < maxRetries - 1) {
                Thread.sleep(1000L * (attempt + 1)) // Linear backoff
            }
        }
        
        // All retries failed
        throw exception ?: IOException("Max retries exceeded")
    }
}

// Add to OkHttp
val client = OkHttpClient.Builder()
    .addInterceptor(RetryInterceptor(maxRetries = 3))
    .build()
```

#### 2. API Rate Limiting & Throttling

**Client-Side Rate Limiting:**
```kotlin
class RateLimiter(
    private val maxRequests: Int,
    private val timeWindowMillis: Long
) {
    private val timestamps = mutableListOf<Long>()
    
    @Synchronized
    suspend fun acquire() {
        val now = System.currentTimeMillis()
        
        // Remove old timestamps
        timestamps.removeAll { now - it > timeWindowMillis }
        
        if (timestamps.size >= maxRequests) {
            val oldestTimestamp = timestamps.first()
            val waitTime = timeWindowMillis - (now - oldestTimestamp)
            delay(waitTime)
            acquire() // Try again
        } else {
            timestamps.add(now)
        }
    }
}

// Usage
class ApiClient {
    private val rateLimiter = RateLimiter(
        maxRequests = 10,
        timeWindowMillis = 60_000 // 10 requests per minute
    )
    
    suspend fun makeRequest() {
        rateLimiter.acquire()
        // Make API call
    }
}
```

**Throttling Interceptor:**
```kotlin
class ThrottlingInterceptor(
    private val minIntervalMillis: Long = 1000
) : Interceptor {
    private var lastRequestTime: Long = 0
    
    @Synchronized
    override fun intercept(chain: Interceptor.Chain): Response {
        val now = System.currentTimeMillis()
        val timeSinceLastRequest = now - lastRequestTime
        
        if (timeSinceLastRequest < minIntervalMillis) {
            val sleepTime = minIntervalMillis - timeSinceLastRequest
            Thread.sleep(sleepTime)
        }
        
        lastRequestTime = System.currentTimeMillis()
        return chain.proceed(chain.request())
    }
}
```

**Handling 429 (Too Many Requests):**
```kotlin
class RateLimitInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        var response = chain.proceed(chain.request())
        
        var retryCount = 0
        while (response.code() == 429 && retryCount < 3) {
            response.close()
            
            // Check for Retry-After header
            val retryAfter = response.header("Retry-After")?.toLongOrNull() ?: 60
            
            Log.d("RateLimit", "Rate limited. Retrying after $retryAfter seconds")
            Thread.sleep(retryAfter * 1000)
            
            response = chain.proceed(chain.request())
            retryCount++
        }
        
        return response
    }
}
```

#### 3. Cache-Control Headers

**HTTP Caching Basics:**
```
Cache-Control: no-cache, no-store, must-revalidate
Cache-Control: public, max-age=3600
Cache-Control: private, max-age=0
Cache-Control: max-age=86400, stale-while-revalidate=86400
```

**Implementing Cache Strategy:**
```kotlin
class CacheInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        
        // Force cache when offline
        val newRequest = if (!isNetworkAvailable()) {
            request.newBuilder()
                .header("Cache-Control", "public, only-if-cached, max-stale=86400")
                .build()
        } else {
            request
        }
        
        val response = chain.proceed(newRequest)
        
        // Cache response for 1 hour when online
        return if (isNetworkAvailable()) {
            response.newBuilder()
                .header("Cache-Control", "public, max-age=3600")
                .removeHeader("Pragma")
                .build()
        } else {
            response
        }
    }
}

// Setup cache
val cacheSize = 10 * 1024 * 1024 // 10 MB
val cache = Cache(context.cacheDir, cacheSize.toLong())

val okHttpClient = OkHttpClient.Builder()
    .cache(cache)
    .addInterceptor(CacheInterceptor())
    .build()
```

**Conditional Requests (ETag):**
```kotlin
class ConditionalCacheInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        
        // Check if we have a cached response with ETag
        val cachedResponse = chain.proceed(request.newBuilder().build())
        val etag = cachedResponse.header("ETag")
        
        return if (etag != null) {
            // Make conditional request
            val conditionalRequest = request.newBuilder()
                .header("If-None-Match", etag)
                .build()
            
            val newResponse = chain.proceed(conditionalRequest)
            
            if (newResponse.code() == 304) {
                // Not modified, use cached response
                cachedResponse.newBuilder()
                    .request(conditionalRequest)
                    .build()
            } else {
                newResponse
            }
        } else {
            cachedResponse
        }
    }
}
```

#### 4. Request/Response Compression

**GZIP Compression:**
```kotlin
class GzipRequestInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val originalRequest = chain.request()
        
        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest)
        }
        
        val compressedRequest = originalRequest.newBuilder()
            .header("Content-Encoding", "gzip")
            .method(originalRequest.method(), gzip(originalRequest.body()!!))
            .build()
        
        return chain.proceed(compressedRequest)
    }
    
    private fun gzip(body: RequestBody): RequestBody {
        return object : RequestBody() {
            override fun contentType() = body.contentType()
            
            override fun contentLength() = -1L // Unknown
            
            override fun writeTo(sink: BufferedSink) {
                val gzipSink = GzipSink(sink).buffer()
                body.writeTo(gzipSink)
                gzipSink.close()
            }
        }
    }
}

// OkHttp automatically handles GZIP response decompression
```

#### 5. Request Timeout Configuration
```kotlin
val okHttpClient = OkHttpClient.Builder()
    .connectTimeout(30, TimeUnit.SECONDS)    // Connection timeout
    .readTimeout(30, TimeUnit.SECONDS)       // Read timeout
    .writeTimeout(30, TimeUnit.SECONDS)      // Write timeout
    .callTimeout(60, TimeUnit.SECONDS)       // Overall timeout
    .build()
```

**Per-Request Timeout:**
```kotlin
interface ApiService {
    @GET("users")
    suspend fun getUsers(): List<User>
    
    @GET("large-data")
    suspend fun getLargeData(): Data
}

// In repository
suspend fun getLargeData(): Data {
    return withTimeout(120_000) { // 2 minutes
        apiService.getLargeData()
    }
}
```

#### 6. Connection Pooling
```kotlin
val connectionPool = ConnectionPool(
    maxIdleConnections = 5,
    keepAliveDuration = 5,
    timeUnit = TimeUnit.MINUTES
)

val okHttpClient = OkHttpClient.Builder()
    .connectionPool(connectionPool)
    .build()
```

#### 7. Certificate Pinning
```kotlin
val certificatePinner = CertificatePinner.Builder()
    .add("api.example.com", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
    .add("api.example.com", "sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=")
    .build()

val okHttpClient = OkHttpClient.Builder()
    .certificatePinner(certificatePinner)
    .build()
```

#### 8. Request Prioritization
```kotlin
enum class Priority {
    LOW, NORMAL, HIGH, IMMEDIATE
}

class PriorityInterceptor : Interceptor {
    private val requestQueue = PriorityQueue<QueuedRequest>(
        compareByDescending { it.priority }
    )
    
    override fun intercept(chain: Interceptor.Chain): Response {
        val priority = chain.request().tag(Priority::class.java) ?: Priority.NORMAL
        
        // Add to queue and process based on priority
        // Implementation details...
        
        return chain.proceed(chain.request())
    }
}

// Usage
@GET("users")
@Tag(Priority.HIGH)
suspend fun getUsers(): List<User>
```

#### 9. Batching Requests
```kotlin
class RequestBatcher(
    private val batchSize: Int = 10,
    private val maxWaitMillis: Long = 1000
) {
    private val pendingRequests = mutableListOf<suspend () -> Unit>()
    private var lastBatchTime = System.currentTimeMillis()
    
    suspend fun addRequest(request: suspend () -> Unit) {
        pendingRequests.add(request)
        
        if (pendingRequests.size >= batchSize || 
            System.currentTimeMillis() - lastBatchTime >= maxWaitMillis) {
            executeBatch()
        }
    }
    
    private suspend fun executeBatch() {
        val batch = pendingRequests.toList()
        pendingRequests.clear()
        lastBatchTime = System.currentTimeMillis()
        
        // Execute all requests in parallel
        coroutineScope {
            batch.forEach { request ->
                launch { request() }
            }
        }
    }
}
```

#### 10. WebSocket for Real-Time Updates (Preview for 5.10)
```kotlin
val request = Request.Builder()
    .url("wss://api.example.com/ws")
    .build()

val webSocket = okHttpClient.newWebSocket(request, object : WebSocketListener() {
    override fun onOpen(webSocket: WebSocket, response: Response) {
        webSocket.send("Hello, Server!")
    }
    
    override fun onMessage(webSocket: WebSocket, text: String) {
        Log.d("WebSocket", "Received: $text")
    }
    
    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
        Log.e("WebSocket", "Error: ${t.message}")
    }
})
```

#### 11. Network Monitoring
```kotlin
class NetworkMonitor(context: Context) {
    private val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) 
        as ConnectivityManager
    
    private val _networkState = MutableStateFlow(NetworkState.UNKNOWN)
    val networkState: StateFlow<NetworkState> = _networkState.asStateFlow()
    
    init {
        val networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                _networkState.value = NetworkState.AVAILABLE
            }
            
            override fun onLost(network: Network) {
                _networkState.value = NetworkState.LOST
            }
        }
        
        connectivityManager.registerDefaultNetworkCallback(networkCallback)
    }
}

enum class NetworkState {
    UNKNOWN, AVAILABLE, LOST
}
```

#### 12. API Versioning Strategies

**URL Versioning:**
```kotlin
/api/v1/users
/api/v2/users
```

**Header Versioning:**
```kotlin
class VersionInterceptor(private val version: String) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request().newBuilder()
            .header("API-Version", version)
            .build()
        return chain.proceed(request)
    }
}
```

#### 13. Performance Monitoring
```kotlin
class PerformanceInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val startTime = System.currentTimeMillis()
        
        val response = chain.proceed(request)
        
        val duration = System.currentTimeMillis() - startTime
        Log.d("Performance", "${request.url()} took ${duration}ms")
        
        // Send to analytics
        Analytics.logNetworkRequest(request.url().toString(), duration)
        
        return response
    }
}
```

#### 14. Circuit Breaker Pattern
```kotlin
class CircuitBreaker(
    private val failureThreshold: Int = 5,
    private val timeoutMillis: Long = 60000
) {
    private var failureCount = 0
    private var lastFailureTime: Long = 0
    private var state = State.CLOSED
    
    enum class State { CLOSED, OPEN, HALF_OPEN }
    
    suspend fun <T> execute(block: suspend () -> T): T {
        when (state) {
            State.OPEN -> {
                if (System.currentTimeMillis() - lastFailureTime > timeoutMillis) {
                    state = State.HALF_OPEN
                } else {
                    throw CircuitBreakerOpenException()
                }
            }
            State.HALF_OPEN, State.CLOSED -> {}
        }
        
        return try {
            val result = block()
            onSuccess()
            result
        } catch (e: Exception) {
            onFailure()
            throw e
        }
    }

private fun onSuccess() {
        failureCount = 0
        state = State.CLOSED
    }
    
    private fun onFailure() {
        failureCount++
        lastFailureTime = System.currentTimeMillis()
        if (failureCount >= failureThreshold) {
            state = State.OPEN
        }
    }
}
```

#### 15. Best Practices
✅ Implement exponential backoff untuk retry
✅ Use rate limiting untuk avoid API abuse
✅ Cache responses appropriately
✅ Monitor network performance
✅ Handle offline scenarios gracefully
✅ Compress large payloads
✅ Configure timeouts properly
✅ Use connection pooling
✅ Implement circuit breaker untuk resilience
✅ Log network metrics

#### 16. Hands-on Project
- Implement retry with exponential backoff
- Create rate limiting system
- Setup caching strategy
- Build network monitor
- Performance tracking
- Integration dengan real API

---

