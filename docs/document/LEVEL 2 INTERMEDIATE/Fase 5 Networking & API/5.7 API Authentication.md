

# ğŸ” Panduan Lengkap: API Authentication di Android

## ğŸš€ Pengantar: Sistem Keamanan Digital Modern

Bayangkan kamu adalah seorang kepala keamanan digital ğŸ”:
- **API Authentication** seperti sistem keamanan berlapis untuk gedung pencakar langit
- **JWT** seperti kunci akses digital yang unik dan tidak dapat dipalsukan
- **OAuth 2.0** seperti sistem izin masuk dengan berbagai tingkat akses
- **Bearer Tokens** seperti kartu akses yang harus dibawa setiap kali memasuki ruangan

Dengan menguasai API Authentication, kamu bisa membuat aplikasi yang aman, melindungi data pengguna, dan mengelola akses dengan bijaksana!

## ğŸ“š Daftar Isi Pembelajaran
1. [ğŸ”‘ Dasar-dasar Authentication](#1ï¸âƒ£-dasar-dasar-authentication-ğŸ”‘)
2. [ğŸ« JWT (JSON Web Tokens)](#2ï¸âƒ£-jwt-json-web-tokens-ğŸ«)
3. [ğŸ” Login & Penyimpanan Token](#3ï¸âƒ£-login--penyimpanan-token-ğŸ”)
4. [ğŸŸ Bearer Token Authentication](#4ï¸âƒ£-bearer-token-authentication-ğŸŸ)
5. [ğŸ”„ Alur Refresh Token](#5ï¸âƒ£-alur-refresh-token-ğŸ”„)
6. [âœ… Validasi Token JWT](#6ï¸âƒ£-validasi-token-jwt-âœ…)
7. [ğŸŒ OAuth 2.0 Flow](#7ï¸âƒ£-oauth-20-flow-ğŸŒ)
8. [ğŸ‘¥ Social Authentication](#8ï¸âƒ£-social-authentication-ğŸ‘¥)
9. [ğŸ‘† Biometric Authentication](#9ï¸âƒ£-biometric-authentication-ğŸ‘†)
10. [ğŸšª Logout](#1ï¸âƒ£0ï¸âƒ£-logout-ğŸšª)
11. [ğŸ›¡ï¸ Security Best Practices](#1ï¸âƒ£1ï¸âƒ£-security-best-practices-ğŸ›¡ï¸)
12. [ğŸ—ï¸ Contoh Alur Authentication Lengkap](#1ï¸âƒ£2ï¸âƒ£-contoh-alur-authentication-lengkap-ğŸ—ï¸)
13. [ğŸ”¨ Hands-on Project](#1ï¸âƒ£3ï¸âƒ£-hands-on-project-ğŸ”¨)
14. [ğŸ¯ Kesimpulan](#ğŸ¯-kesimpulan)

---

## 1ï¸âƒ£ Dasar-dasar Authentication ğŸ”‘

### Konsep Dasar
Authentication seperti sistem keamanan berlapis ğŸ”‘ - setiap lapisan memiliki fungsi spesifik untuk memastikan hanya orang yang berwenang yang dapat mengakses sumber daya!

### Authentication vs Authorization:
**Authentication (Autentikasi):**
- Proses verifikasi identitas pengguna
- "Siapa kamu?"
- Contoh: Login dengan email dan password

**Authorization (Otorisasi):**
- Proses verifikasi hak akses pengguna
- "Apa yang boleh kamu lakukan?"
- Contoh: Pengguna biasa tidak dapat menghapus data pengguna lain

### Stateless Authentication:
**Stateless Authentication:**
- Server tidak menyimpan status sesi
- Setiap request harus berisi informasi autentikasi
- Lebih skalabel dan cocok untuk arsitektur mikroservice

### Token-based Authentication:
**Token-based Authentication:**
- Server mengeluarkan token setelah login berhasil
- Token berisi informasi tentang pengguna
- Token dikirim dengan setiap request berikutnya
- Server memvalidasi token untuk setiap request

### Session vs Token:
| Aspek | Session-based | Token-based |
|-------|---------------|-------------|
| **Storage** | Server | Client |
| **Scalability** | Terbatas | Tinggi |
| **State** | Stateful | Stateless |
| **Mobile Support** | Buruk | Baik |
| **Security** | Rentan terhadap CSRF | Lebih aman |

### ğŸ“ Penjelasan Konsep:
**Authentication seperti Sistem Keamanan Berlapis:**
- **Autentikasi**: Pintu masuk utama
- **Otorisasi**: Kunci untuk setiap ruangan
- **Stateless**: Tidak ada ingatan tentang siapa yang masuk sebelumnya
- **Token**: Kartu akses yang unik

**Keunggulan Token-based Authentication:**
- **Scalability**: Tidak membebani server dengan penyimpanan sesi
- **Mobile-friendly**: Cocok untuk aplikasi mobile
- **Cross-domain**: Dapat digunakan di berbagai domain
- **Stateless**: Cocok untuk arsitektur modern

**Best Practices:**
- Gunakan token-based authentication untuk aplikasi modern
- Pisahkan antara autentikasi dan otorisasi
- Gunakan HTTPS untuk semua komunikasi
- Implementasikan token expiration
- Gunakan refresh token untuk pengalaman pengguna yang lebih baik

---

## 2ï¸âƒ£ JWT (JSON Web Tokens) ğŸ«

### Konsep Dasar
JWT seperti kunci akses digital yang unik ğŸ« - berisi informasi pengguna dalam format yang aman dan tidak dapat dipalsukan!

### Struktur JWT:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Header      â”‚     Payload     â”‚    Signature    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Contoh JWT:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### Komponen JWT:
**Header:**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
- `alg`: Algoritma yang digunakan untuk menandatangani (HMAC SHA256)
- `typ`: Tipe token (JWT)

**Payload:**
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622,
  "roles": ["admin"]
}
```
- `sub`: Subject (ID pengguna)
- `name`: Nama pengguna
- `iat`: Diterbitkan pada (waktu pembuatan)
- `exp`: Kedaluwaktu (waktu kadaluarsa)
- `roles`: Peran pengguna (custom claim)

**Signature:**
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```
- Digunakan untuk memverifikasi bahwa token tidak diubah
- Dibuat menggunakan secret key yang hanya diketahui server

### Claims dalam JWT:
**Standard Claims:**
- `iss` (Issuer): Penerbit token
- `sub` (Subject): Subjek token (biasanya ID pengguna)
- `aud` (Audience): Penerima token
- `exp` (Expiration Time): Waktu kadaluarsa
- `nbf` (Not Before): Token tidak valid sebelum waktu ini
- `iat` (Issued At): Token diterbitkan pada waktu ini
- `jti` (JWT ID): ID unik untuk token

**Custom Claims:**
```json
{
  "roles": ["admin", "user"],
  "permissions": ["read", "write"],
  "department": "IT"
}
```

### ğŸ“ Penjelasan Konsep:
**JWT seperti Kunci Akses Digital:**
- **Header**: Informasi tentang kunci (jenis dan algoritma)
- **Payload**: Informasi tentang pemegang kunci (nama, peran, dll)
- **Signature**: Tanda tangan unik yang membuktikan keaslian kunci

**Keunggulan JWT:**
- **Compact**: Ukuran kecil, mudah dikirim
- **Self-contained**: Berisi semua informasi yang diperlukan
- **Secure**: Ditandatangani secara kriptografis
- **Standard**: Mengikuti standar industri (RFC 7519)

**Best Practices:**
- Gunakan algoritma yang kuat (HS256 atau RS256)
- Tetapkan waktu kadaluarsa yang singkat
- Jangan simpan informasi sensitif dalam payload
- Gunakan HTTPS untuk transmisi token
- Validasi semua claim yang diterima

---

## 3ï¸âƒ£ Login & Penyimpanan Token ğŸ”

### Konsep Dasar
Login & Penyimpanan Token seperti proses pendaftaran anggota dan penyimpanan kartu akses ğŸ” - memverifikasi identitas dan memberikan akses sementara!

### Login Request:
**data/model/auth/LoginRequest.kt:**
```kotlin
package com.example.auth.data.model

data class LoginRequest(
    val email: String,
    val password: String
)
```

### Login Response:
**data/model/auth/LoginResponse.kt:**
```kotlin
package com.example.auth.data.model

data class LoginResponse(
    val accessToken: String,
    val refreshToken: String,
    val expiresIn: Long,
    val tokenType: String,
    val user: User
)
```

### API Service:
**network/AuthApiService.kt:**
```kotlin
package com.example.auth.network

import com.example.auth.data.model.LoginRequest
import com.example.auth.data.model.LoginResponse
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.POST

interface AuthApiService {
    @POST("auth/login")
    suspend fun login(@Body request: LoginRequest): Response<LoginResponse>
    
    @POST("auth/refresh")
    suspend fun refreshToken(@Body refreshToken: RefreshTokenRequest): Response<RefreshTokenResponse>
}
```

### Token Manager:
**data/manager/TokenManager.kt:**
```kotlin
package com.example.auth.data.manager

import android.content.Context
import android.content.SharedPreferences
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey

class TokenManager(context: Context) {
    private val prefs: SharedPreferences = EncryptedSharedPreferences.create(
        "auth_prefs",
        MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build(),
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    
    fun saveTokens(accessToken: String, refreshToken: String) {
        prefs.edit()
            .putString("access_token", accessToken)
            .putString("refresh_token", refreshToken)
            .apply()
    }
    
    fun getAccessToken(): String? {
        return prefs.getString("access_token", null)
    }
    
    fun getRefreshToken(): String? {
        return prefs.getString("refresh_token", null)
    }
    
    fun clearTokens() {
        prefs.edit()
            .remove("access_token")
            .remove("refresh_token")
            .apply()
    }
    
    fun isAccessTokenExpired(): Boolean {
        val token = getAccessToken() ?: return true
        
        return try {
            val parts = token.split(".")
            if (parts.size != 3) return true
            
            val payload = String(android.util.Base64.decode(parts[1], android.util.Base64.URL_SAFE))
            val json = org.json.JSONObject(payload)
            
            val exp = json.getLong("exp")
            val now = System.currentTimeMillis() / 1000
            
            now >= exp
        } catch (e: Exception) {
            true
        }
    }
}
```

### Repository:
**data/repository/AuthRepository.kt:**
```kotlin
package com.example.auth.data.repository

import com.example.auth.data.manager.TokenManager
import com.example.auth.data.model.LoginRequest
import com.example.auth.data.model.LoginResponse
import com.example.auth.network.AuthApiService
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class AuthRepository(
    private val apiService: AuthApiService,
    private val tokenManager: TokenManager
) {
    suspend fun login(email: String, password: String): Flow<Result<LoginResponse>> = flow {
        try {
            val response = apiService.login(LoginRequest(email, password))
            
            if (response.isSuccessful) {
                val loginResponse = response.body()
                
                if (loginResponse != null) {
                    tokenManager.saveTokens(
                        loginResponse.accessToken,
                        loginResponse.refreshToken
                    )
                    emit(Result.Success(loginResponse))
                } else {
                    emit(Result.Error(Exception("Empty response")))
                }
            } else {
                emit(Result.Error(Exception("Login failed: ${response.code()}")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    fun isLoggedIn(): Boolean {
        val token = tokenManager.getAccessToken()
        return token != null && !tokenManager.isAccessTokenExpired()
    }
    
    fun logout() {
        tokenManager.clearTokens()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Login & Penyimpanan Token seperti Pendaftaran Anggota:**
- **Login Request**: Formulir pendaftaran
- **Login Response**: Kartu akses yang diterbitkan
- **Token Manager**: Brankas penyimpanan kartu akses
- **Repository**: Petugas yang mengelola proses pendaftaran

**Keamanan Token Storage:**
- **EncryptedSharedPreferences**: Menyimpan token dengan enkripsi
- **MasterKey**: Kunci utama untuk enkripsi
- **AES256**: Algoritma enkripsi yang kuat

**Best Practices:**
- Gunakan EncryptedSharedPreferences untuk menyimpan token
- Jangan simpan token di tempat yang tidak aman
- Implementasikan token expiration
- Gunakan refresh token untuk memperbarui akses
- Bersihkan token saat logout

---

## 4ï¸âƒ£ Bearer Token Authentication ğŸŸ

### Konsep Dasar
Bearer Token Authentication seperti menunjukkan kartu akses di setiap pintu ğŸŸ - setiap permintaan harus disertai dengan token yang valid!

### Auth Interceptor:
**network/interceptor/AuthInterceptor.kt:**
```kotlin
package com.example.auth.network.interceptor

import com.example.auth.data.manager.TokenManager
import okhttp3.Interceptor
import okhttp3.Response

class AuthInterceptor(
    private val tokenManager: TokenManager
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val originalRequest = chain.request()
        
        // Skip authentication for login and refresh endpoints
        if (originalRequest.url().encodedPath().contains("/auth/")) {
            return chain.proceed(originalRequest)
        }
        
        val token = tokenManager.getAccessToken()
        
        val request = if (token != null) {
            originalRequest.newBuilder()
                .header("Authorization", "Bearer $token")
                .build()
        } else {
            originalRequest
        }
        
        return chain.proceed(request)
    }
}
```

### Network Module:
**di/NetworkModule.kt:**
```kotlin
package com.example.auth.di

import com.example.auth.data.manager.TokenManager
import com.example.auth.network.AuthApiService
import com.example.auth.network.interceptor.AuthInterceptor
import com.example.auth.network.interceptor.TokenAuthenticator
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import okhttp3.OkHttpClient
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideAuthApiService(retrofit: Retrofit): AuthApiService {
        return retrofit.create(AuthApiService::class.java)
    }
    
    @Provides
    @Singleton
    fun provideOkHttpClient(
        tokenManager: TokenManager,
        tokenAuthenticator: TokenAuthenticator
    ): OkHttpClient {
        return OkHttpClient.Builder()
            .addInterceptor(AuthInterceptor(tokenManager))
            .authenticator(tokenAuthenticator)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Bearer Token Authentication seperti Menunjukkan Kartu Akses:**
- **Auth Interceptor**: Penjaga yang memeriksa kartu akses di setiap pintu
- **Authorization Header**: Tempat kartu akses ditunjukkan
- **Skip Authentication**: Pintu khusus yang tidak memerlukan kartu akses
- **Token Manager**: Manajer kartu akses

**Alur Kerja Bearer Token:**
1. Client membuat request
2. Auth interceptor menambahkan header Authorization dengan Bearer token
3. Server memvalidasi token
4. Jika valid, server memproses request
5. Jika tidak valid, server mengembalikan error 401

**Best Practices:**
- Gunakan interceptor untuk menambahkan token secara otomatis
- Lewati autentikasi untuk endpoint login dan refresh
- Gunakan HTTPS untuk transmisi token
- Tangani error 401 dengan refresh token
- Bersihkan token saat logout

---

## 5ï¸âƒ£ Alur Refresh Token ğŸ”„

### Konsep Dasar
Alur Refresh Token seperti proses perpanjang kartu akses ğŸ”„ - memperbarui kartu akses yang akan kadaluarsa tanpa memaksa pengguna login kembali!

### Refresh Token Request:
**data/model/auth/RefreshTokenRequest.kt:**
```kotlin
package com.example.auth.data.model

data class RefreshTokenRequest(
    val refreshToken: String
)
```

**data/model/auth/RefreshTokenResponse.kt:**
```kotlin
package com.example.auth.data.model

data class RefreshTokenResponse(
    val accessToken: String,
    val refreshToken: String,
    val expiresIn: Long,
    val tokenType: String
)
```

### Token Authenticator:
**network/interceptor/TokenAuthenticator.kt:**
```kotlin
package com.example.auth.network.interceptor

import com.example.auth.data.manager.TokenManager
import com.example.auth.network.AuthApiService
import kotlinx.coroutines.runBlocking
import okhttp3.Authenticator
import okhttp3.Request
import okhttp3.Response
import okhttp3.Route

class TokenAuthenticator(
    private val tokenManager: TokenManager,
    private val authApiService: AuthApiService
) : Authenticator {
    
    override fun authenticate(route: Route?, response: Response): Request? {
        // Check if this is a 401 Unauthorized response
        if (response.code() != 401) {
            return null
        }
        
        // Check if this request already has an Authorization header
        val originalRequest = response.request()
        if (originalRequest.header("Authorization") == null) {
            return null
        }
        
        // Synchronize to prevent multiple concurrent refresh attempts
        synchronized(this) {
            // Get the refresh token
            val refreshToken = tokenManager.getRefreshToken() ?: return null
            
            try {
                // Try to refresh the token
                val refreshResponse = runBlocking {
                    authApiService.refreshToken(RefreshTokenRequest(refreshToken))
                }
                
                if (refreshResponse.isSuccessful) {
                    val newTokens = refreshResponse.body()
                    
                    if (newTokens != null) {
                        // Save the new tokens
                        tokenManager.saveTokens(
                            newTokens.accessToken,
                            newTokens.refreshToken
                        )
                        
                        // Retry the original request with the new token
                        return originalRequest.newBuilder()
                            .header("Authorization", "Bearer ${newTokens.accessToken}")
                            .build()
                    }
                }
            } catch (e: Exception) {
                // Refresh failed, clear tokens and redirect to login
                tokenManager.clearTokens()
            }
        }
        
        // All refresh attempts failed, clear tokens and redirect to login
        tokenManager.clearTokens()
        return null
    }
}
```

### Repository dengan Refresh:
**data/repository/AuthRepository.kt:**
```kotlin
package com.example.auth.data.repository

import com.example.auth.data.manager.TokenManager
import com.example.auth.data.model.LoginRequest
import com.example.auth.data.model.LoginResponse
import com.example.auth.data.model.RefreshTokenRequest
import com.example.auth.data.model.RefreshTokenResponse
import com.example.auth.network.AuthApiService
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class AuthRepository(
    private val apiService: AuthApiService,
    private val tokenManager: TokenManager
) {
    // ... login method from previous section ...
    
    suspend fun refreshToken(): Flow<Result<RefreshTokenResponse>> = flow {
        try {
            val refreshToken = tokenManager.getRefreshToken()
                ?: throw Exception("No refresh token available")
            
            val response = apiService.refreshToken(RefreshTokenRequest(refreshToken))
            
            if (response.isSuccessful) {
                val refreshResponse = response.body()
                
                if (refreshResponse != null) {
                    tokenManager.saveTokens(
                        refreshResponse.accessToken,
                        refreshResponse.refreshToken
                    )
                    emit(Result.Success(refreshResponse))
                } else {
                    emit(Result.Error(Exception("Empty response")))
                }
            } else {
                emit(Result.Error(Exception("Token refresh failed: ${response.code()}")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    fun logout() {
        tokenManager.clearTokens()
    }
    
    fun isLoggedIn(): Boolean {
        val token = tokenManager.getAccessToken()
        return token != null && !tokenManager.isAccessTokenExpired()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Alur Refresh Token seperti Proses Perpanjang Kartu Akses:**
- **401 Response**: Indikator bahwa kartu akses telah kadaluarsa
- **Token Authenticator**: Petugas yang memperbarui kartu akses
- **Refresh Token**: Kartu akses khusus untuk memperbarui kartu akses utama
- **Synchronization**: Mencegah beberapa upaya refresh secara bersamaan

**Alur Kerja Refresh Token:**
1. Request gagal dengan status 401
2. Token authenticator menangkap error
3. Token authenticator mencoba refresh token
4. Jika berhasil, token baru disimpan dan request diulang
5. Jika gagal, token dibersihkan dan pengguna harus login kembali

**Best Practices:**
- Gunakan authenticator untuk refresh token otomatis
- Synchronisasi proses refresh untuk mencegah duplikasi
- Bersihkan token jika refresh gagal
- Gunakan refresh token dengan masa kadaluarsa yang lebih lama
- Implementasikan logout yang membersihkan semua token

---

## 6ï¸âƒ£ Validasi Token JWT âœ…

### Konsep Dasar
Validasi Token JWT seperti pemeriksaan keaslian kartu akses âœ… - memastikan kartu akses asli dan belum kadaluarsa!

### Validasi Token:
**util/JwtUtils.kt:**
```kotlin
package com.example.auth.util

import android.util.Base64
import org.json.JSONObject
import java.lang.Exception

object JwtUtils {
    
    fun isTokenExpired(token: String): Boolean {
        return try {
            val parts = token.split(".")
            if (parts.size != 3) return true
            
            val payload = String(Base64.decode(parts[1], Base64.URL_SAFE or Base64.NO_PADDING or Base64.NO_WRAP))
            val json = JSONObject(payload)
            
            val exp = json.getLong("exp")
            val now = System.currentTimeMillis() / 1000
            
            now >= exp
        } catch (e: Exception) {
            true
        }
    }
    
    fun getUserIdFromToken(token: String): String? {
        return try {
            val parts = token.split(".")
            if (parts.size != 3) return null
            
            val payload = String(Base64.decode(parts[1], Base64.URL_SAFE or Base64.NO_PADDING or Base64.NO_WRAP))
            val json = JSONObject(payload)
            
            json.getString("sub")
        } catch (e: Exception) {
            null
        }
    }
    
    fun getUserRolesFromToken(token: String): List<String>? {
        return try {
            val parts = token.split(".")
            if (parts.size != 3) return null
            
            val payload = String(Base64.decode(parts[1], Base64.URL_SAFE or Base64.NO_PADDING or Base64.NO_WRAP))
            val json = JSONObject(payload)
            
            val roles = json.getJSONArray("roles")
            val rolesList = mutableListOf<String>()
            
            for (i in 0 until roles.length()) {
                rolesList.add(roles.getString(i))
            }
            
            rolesList
        } catch (e: Exception) {
            null
        }
    }
    
    fun isTokenValid(token: String): Boolean {
        return try {
            val parts = token.split(".")
            if (parts.size != 3) return false
            
            // Check header
            val header = String(Base64.decode(parts[0], Base64.URL_SAFE or Base64.NO_PADDING or Base64.NO_WRAP))
            val headerJson = JSONObject(header)
            val alg = headerJson.getString("alg")
            val typ = headerJson.getString("typ")
            
            if (alg != "HS256" || typ != "JWT") return false
            
            // Check payload
            val payload = String(Base64.decode(parts[1], Base64.URL_SAFE or Base64.NO_PADDING or Base64.NO_WRAP))
            val payloadJson = JSONObject(payload)
            
            // Check expiration
            val exp = payloadJson.getLong("exp")
            val now = System.currentTimeMillis() / 1000
            
            if (now >= exp) return false
            
            // Check not before
            if (payloadJson.has("nbf")) {
                val nbf = payloadJson.getLong("nbf")
                if (now < nbf) return false
            }
            
            true
        } catch (e: Exception) {
            false
        }
    }
}
```

### Token Manager dengan Validasi:
**data/manager/TokenManager.kt:**
```kotlin
package com.example.auth.data.manager

import android.content.Context
import android.content.SharedPreferences
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey
import com.example.auth.util.JwtUtils

class TokenManager(context: Context) {
    private val prefs: SharedPreferences = EncryptedSharedPreferences.create(
        "auth_prefs",
        MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build(),
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    
    fun saveTokens(accessToken: String, refreshToken: String) {
        // Validate access token before saving
        if (!JwtUtils.isTokenValid(accessToken)) {
            throw Exception("Invalid access token")
        }
        
        prefs.edit()
            .putString("access_token", accessToken)
            .putString("refresh_token", refreshToken)
            .apply()
    }
    
    fun getAccessToken(): String? {
        val token = prefs.getString("access_token", null)
        
        // Validate token before returning
        return if (token != null && JwtUtils.isTokenValid(token)) {
            token
        } else {
            null
        }
    }
    
    fun getRefreshToken(): String? {
        return prefs.getString("refresh_token", null)
    }
    
    fun clearTokens() {
        prefs.edit()
            .remove("access_token")
            .remove("refresh_token")
            .apply()
    }
    
    fun isAccessTokenExpired(): Boolean {
        val token = getAccessToken()
        return token == null || JwtUtils.isTokenExpired(token)
    }
    
    fun getUserId(): String? {
        val token = getAccessToken()
        return if (token != null) JwtUtils.getUserIdFromToken(token) else null
    }
    
    fun getUserRoles(): List<String>? {
        val token = getAccessToken()
        return if (token != null) JwtUtils.getUserRolesFromToken(token) else null
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Validasi Token JWT seperti Pemeriksaan Keaslian Kartu Akses:**
- **Token Structure**: Memeriksa struktur token (header, payload, signature)
- **Expiration**: Memeriksa waktu kadaluarsa
- **Algorithm**: Memeriksa algoritma penandatanganan
- **Claims**: Memeriksa informasi dalam token

**Alur Validasi:**
1. Pisahkan token menjadi tiga bagian (header, payload, signature)
2. Decode header dan payload dari Base64
3. Validasi struktur dan konten
4. Periksa waktu kadaluarsa
5. Kembalikan hasil validasi

**Best Practices:**
- Validasi token sebelum digunakan
- Periksa waktu kadaluarsa secara berkala
- Gunakan algoritma yang kuat untuk penandatanganan
- Jangan percaya pada token dari sumber tidak terpercaya
- Implementasikan validasi di sisi klien dan server

---

## 7ï¸âƒ£ OAuth 2.0 Flow ğŸŒ

### Konsep Dasar
OAuth 2.0 seperti sistem izin masuk dengan berbagai tingkat akses ğŸŒ - memungkinkan aplikasi pihak ketiga mengakses data pengguna dengan izin terbatas!

### Alur OAuth 2.0:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   USER     â”‚    â”‚   CLIENT    â”‚    â”‚  AUTH       â”‚    â”‚  RESOURCE    â”‚
â”‚             â”‚    â”‚             â”‚    â”‚   SERVER    â”‚    â”‚   SERVER     â”‚
â”‚             â”‚    â”‚             â”‚    â”‚             â”‚    â”‚             â”‚
â”‚ 1. Authorizeâ”‚â”€â”€â”€â–¶â”‚ 2. Redirect  â”‚â”€â”€â”€â–¶â”‚ 3. Exchange   â”‚â”€â”€â”€â–¶â”‚ 4. Access     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                   â”‚                   â”‚
        â–¼                   â–¼                   â–¼
   Authorization      Authorization        Access Token
        Code               Code              (JWT)
```

### Implementasi OAuth 2.0:
**data/model/oauth/OAuthConfig.kt:**
```kotlin
package com.example.auth.data.model.oauth

object OAuthConfig {
    const val CLIENT_ID = "your_client_id"
    const val CLIENT_SECRET = "your_client_secret"
    const val REDIRECT_URI = "yourapp://callback"
    const val AUTH_URI = "https://auth.example.com/oauth/authorize"
    const val TOKEN_URI = "https://auth.example.com/oauth/token"
    const val SCOPE = "read write"
    const val RESPONSE_TYPE = "code"
    const val GRANT_TYPE = "authorization_code"
}
```

**data/model/oauth/OAuthRequest.kt:**
```kotlin
package com.example.auth.data.model.oauth

data class TokenRequest(
    val grantType: String = OAuthConfig.GRANT_TYPE,
    val code: String,
    val redirectUri: String = OAuthConfig.REDIRECT_URI,
    val clientId: String = OAuthConfig.CLIENT_ID,
    val clientSecret: String = OAuthConfig.CLIENT_SECRET
)

data class RefreshTokenRequest(
    val grantType: String = "refresh_token",
    val refreshToken: String,
    val clientId: String = OAuthConfig.CLIENT_ID,
    val clientSecret: String = OAuthConfig.CLIENT_SECRET
)
```

**data/model/oauth/OAuthResponse.kt:**
```kotlin
package com.example.auth.data.model.oauth

data class TokenResponse(
    val accessToken: String,
    val refreshToken: String,
    val expiresIn: Long,
    val tokenType: String,
    val scope: String
)
```

**network/OAuthApiService.kt:**
```kotlin
package com.example.auth.network

import com.example.auth.data.model.oauth.RefreshTokenRequest
import com.example.auth.data.model.oauth.TokenRequest
import com.example.auth.data.model.oauth.TokenResponse
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.Field
import retrofit2.http.FormUrlEncoded
import retrofit2.http.POST

interface OAuthApiService {
    @FormUrlEncoded
    @POST("oauth/token")
    suspend fun exchangeCodeForToken(
        @Field("grant_type") grantType: String,
        @Field("code") code: String,
        @Field("redirect_uri") redirectUri: String,
        @Field("client_id") clientId: String,
        @Field("client_secret") clientSecret: String
    ): Response<TokenResponse>
    
    @FormUrlEncoded
    @POST("oauth/token")
    suspend fun refreshToken(
        @Field("grant_type") grantType: String,
        @Field("refresh_token") refreshToken: String,
        @Field("client_id") clientId: String,
        @Field("client_secret") clientSecret: String
    ): Response<TokenResponse>
}
```

**OAuth Repository:**
**data/repository/OAuthRepository.kt:**
```kotlin
package com.example.auth.data.repository

import com.example.auth.data.manager.TokenManager
import com.example.auth.data.model.oauth.RefreshTokenRequest
import com.example.auth.data.model.oauth.TokenResponse
import com.example.auth.network.OAuthApiService
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class OAuthRepository(
    private val apiService: OAuthApiService,
    private val tokenManager: TokenManager
) {
    fun exchangeCodeForTokens(code: String): Flow<Result<TokenResponse>> = flow {
        try {
            val response = apiService.exchangeCodeForToken(
                grantType = "authorization_code",
                code = code,
                redirectUri = "yourapp://callback",
                clientId = "your_client_id",
                clientSecret = "your_client_secret"
            )
            
            if (response.isSuccessful) {
                val tokenResponse = response.body()
                
                if (tokenResponse != null) {
                    tokenManager.saveTokens(
                        tokenResponse.accessToken,
                        tokenResponse.refreshToken
                    )
                    emit(Result.Success(tokenResponse))
                } else {
                    emit(Result.Error(Exception("Empty response")))
                }
            } else {
                emit(Result.Error(Exception("Token exchange failed: ${response.code()}")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    fun refreshToken(): Flow<Result<TokenResponse>> = flow {
        try {
            val refreshToken = tokenManager.getRefreshToken()
                ?: throw Exception("No refresh token available")
            
            val response = apiService.refreshToken(
                grantType = "refresh_token",
                refreshToken = refreshToken,
                clientId = "your_client_id",
                clientSecret = "your_client_secret"
            )
            
            if (response.isSuccessful) {
                val tokenResponse = response.body()
                
                if (tokenResponse != null) {
                    tokenManager.saveTokens(
                        tokenResponse.accessToken,
                        tokenResponse.refreshToken
                    )
                    emit(Result.Success(tokenResponse))
                } else {
                    emit(Result.Error(Exception("Empty response")))
                }
            } else {
                emit(Result.Error(Exception("Token refresh failed: ${response.code()}")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**OAuth 2.0 seperti Sistem Izin Masuk Berlapis:**
- **User**: Pemegang akun yang memberikan izin
- **Client**: Aplikasi pihak ketiga yang meminta izin
- **Authorization Server**: Server yang mengelola izin
- **Resource Server**: Server yang menyediakan data

**Alur Kerja OAuth 2.0:**
1. User mengizinkan client mengakses data
2. Client menerima authorization code
3. Client menukar authorization code dengan access token
4. Client menggunakan access token untuk mengakses data

**Best Practices:**
- Gunakan HTTPS untuk semua komunikasi OAuth
- Simpan client secret dengan aman
- Gunakan state parameter untuk mencegah CSRF
- Validasi redirect URI
- Implementasikan token refresh untuk pengalaman pengguna yang lebih baik

---

## 8ï¸âƒ£ Social Authentication ğŸ‘¥

### Konsep Dasar
Social Authentication seperti menggunakan jasa keamanan pihak ketiga ğŸ‘¥ - memanfaatkan sistem keamanan yang sudah ada (Google, Facebook, dll) untuk proses autentikasi!

### Google Sign-In:
**build.gradle.kts (Module: app):**
```kotlin
dependencies {
    implementation("com.google.android.gms:play-services-auth:20.7.0")
    implementation("com.google.android.gms:play-services-identity:18.1.0")
}
```

**GoogleSignInHelper.kt:**
```kotlin
package com.example.auth.helper

import android.app.Activity
import android.content.Context
import com.google.android.gms.auth.api.identity.BeginSignInRequest
import com.google.android.gms.auth.api.identity.Identity
import com.google.android.gms.auth.api.identity.SignInClient
import com.google.android.gms.auth.api.identity.SignInCredential
import com.google.android.gms.common.api.ApiException
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.tasks.await

class GoogleSignInHelper(private val context: Context) {
    private val oneTapClient = Identity.getSignInClient(context)
    private val signInClient = Identity.getSignInClient(context)
    
    suspend fun signIn(): SignInCredential? {
        return try {
            oneTapClient.beginSignIn(
                beginSignInRequest = BeginSignInRequest.builder()
                    .setGoogleIdTokenRequestOptions(
                        BeginSignInRequest.GoogleIdTokenRequestOptions.builder()
                            .setSupported(true)
                            .setServerClientId("your-web-client-id")
                            .setFilterByAuthorizedAccounts(true)
                            .build()
                    )
                    .setAutoSelectEnabled(false)
                    .build()
            ).await()
        } catch (e: Exception) {
            if (e is CancellationException) {
                null
            } else {
                throw e
            }
        }
    }
    
    suspend fun signOut() {
        try {
            oneTapClient.signOut()
            signInClient.signOut()
        } catch (e: Exception) {
            // Handle error
        }
    }
    
    suspend fun getSignedInAccount(): SignInCredential? {
        return try {
            signInClient.silentSignIn().await()
        } catch (e: Exception) {
            null
        }
    }
}
```

**GoogleSignInRepository.kt:**
```kotlin
package com.example.auth.data.repository

import com.example.auth.data.manager.TokenManager
import com.example.auth.helper.GoogleSignInHelper
import com.google.android.gms.auth.api.identity.SignInCredential
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class GoogleSignInRepository(
    private val tokenManager: TokenManager,
    private val authApiService: AuthApiService
) {
    private val googleSignInHelper = GoogleSignInHelper(context)
    
    suspend fun signInWithGoogle(): Flow<Result<String>> = flow {
        try {
            val credential = googleSignInHelper.signIn()
            
            if (credential != null) {
                val idToken = credential.googleIdToken
                    ?: throw Exception("No ID token")
                
                // Send ID token to your backend
                val response = authApiService.signInWithGoogle(idToken)
                
                if (response.isSuccessful) {
                    val loginResponse = response.body()
                    
                    if (loginResponse != null) {
                        tokenManager.saveTokens(
                            loginResponse.accessToken,
                            loginResponse.refreshToken
                        )
                        emit(Result.Success(loginResponse.user.email))
                    } else {
                        emit(Result.Error(Exception("Empty response")))
                    }
                } else {
                    emit(Result.Error(Exception("Google sign-in failed: ${response.code()}")))
                }
            } else {
                emit(Result.Error(Exception("No credential")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    suspend fun signOut() {
        googleSignInHelper.signOut()
        tokenManager.clearTokens()
    }
    
    fun isSignedIn(): Boolean {
        return tokenManager.isLoggedIn()
    }
}
```

### Facebook Login:
**build.gradle.kts (Module: app):**
```kotlin
dependencies {
    implementation("com.facebook.android:facebook-login:16.2.0")
}
```

**FacebookSignInHelper.kt:**
```kotlin
package com.example.auth.helper

import android.content.Context
import com.facebook.AccessToken
import com.facebook.CallbackManager
import com.facebook.FacebookCallback
import com.facebook.FacebookException
import com.facebook.login.LoginManager
import com.facebook.login.LoginResult

class FacebookSignInHelper(private val context: Context) {
    private val callbackManager = CallbackManager.Factory.create()
    private val loginManager = LoginManager.getInstance()
    
    fun signIn(callback: FacebookCallback<LoginResult>) {
        loginManager.logInWithReadPermissions(context, callbackManager, callback, "email")
    }
    
    fun signOut() {
        loginManager.logOut()
    }
    
    fun isLoggedIn(): Boolean {
        return AccessToken.getCurrentAccessToken() != null
    }
    
    fun getAccessToken(): String? {
        return AccessToken.getCurrentAccessToken()?.token
    }
}
```

**FacebookSignInRepository.kt:**
```kotlin
package com.example.auth.data.repository

import com.example.auth.data.manager.TokenManager
import com.example.auth.helper.FacebookSignInHelper
import com.facebook.login.LoginResult
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class FacebookSignInRepository(
    private val tokenManager: TokenManager,
    private val authApiService: AuthApiService
) {
    private val facebookSignInHelper = FacebookSignInHelper(context)
    
    fun signInWithFacebook(): Flow<Result<String>> = flow {
        try {
            facebookSignInHelper.signIn(object : FacebookCallback<LoginResult>() {
                override fun onSuccess(result: LoginResult) {
                    // Handle success
                }
                
                override fun onCancel() {
                    // Handle cancel
                }
                
                override fun onError(error: FacebookException) {
                    // Handle error
                }
            })
            
            val accessToken = facebookSignInHelper.getAccessToken()
                ?: throw Exception("No access token")
            
            // Send access token to your backend
            val response = authApiService.signInWithFacebook(accessToken)
            
            if (response.isSuccessful) {
                val loginResponse = response.body()
                
                if (loginResponse != null) {
                    tokenManager.saveTokens(
                        loginResponse.accessToken,
                        loginResponse.refreshToken
                    )
                    emit(Result.Success(loginResponse.user.email))
                } else {
                    emit(Result.Error(Exception("Empty response")))
                }
            } else {
                emit(Result.Error(Exception("Facebook sign-in failed: ${response.code()}")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    fun signOut() {
        facebookSignInHelper.signOut()
        tokenManager.clearTokens()
    }
    
    fun isLoggedIn(): Boolean {
        return facebookSignInHelper.isLoggedIn() && tokenManager.isLoggedIn()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Social Authentication seperti Menggunakan Jasa Keamanan Pihak Ketiga:**
- **Google Sign-In**: Menggunakan akun Google untuk autentikasi
- **Facebook Login**: Menggunakan akun Facebook untuk autentikasi
- **ID Token**: Token yang berisi informasi pengguna
- **Access Token**: Token untuk mengakses API

**Alur Kerja Social Authentication:**
1. User memilih untuk login dengan akun sosial
2. Aplikasi membuka UI login sosial
3. User mengizinkan akses ke akunnya
4. Aplikasi menerima token dari penyedia layanan
5. Aplikasi mengirim token ke backend untuk validasi
6. Backend menghasilkan token aplikasi dan mengembalikannya ke aplikasi

**Best Practices:**
- Gunakan ID token untuk validasi di backend
- Jangan simpan token sosial di perangkat
- Implementasikan logout yang membersihkan semua token
- Validasi token di backend untuk keamanan tambahan
- Gunakan HTTPS untuk semua komunikasi

---

## 9ï¸âƒ£ Biometric Authentication ğŸ‘†

### Konsep Dasar
Biometric Authentication seperti menggunakan sidik jari atau wajah sebagai kunci akses ğŸ‘† - menambahkan lapisan keamanan ekstra untuk operasi sensitif!

### Biometric Authentication:
**build.gradle.kts (Module: app):**
```kotlin
dependencies {
    implementation("androidx.biometric:biometric:1.2.0-alpha05")
}
```

**BiometricHelper.kt:**
```kotlin
package com.example.auth.helper

import android.content.Context
import androidx.biometric.BiometricManager
import androidx.biometric.BiometricPrompt
import androidx.core.content.ContextCompat
import androidx.fragment.app.FragmentActivity
import kotlinx.coroutines.CancellableContinuation
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey

class BiometricHelper(private val context: Context) {
    private val biometricManager = BiometricManager.from(context)
    
    fun isBiometricAvailable(): Boolean {
        return biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG)
    }
    
    suspend fun authenticate(
        title: String,
        subtitle: String,
        description: String,
        negativeButtonText: String
    ): Boolean = withContext(Dispatchers.Main) {
        if (!isBiometricAvailable()) {
            return false
        }
        
        return try {
            suspendCancellableCoroutine { continuation ->
                val promptInfo = BiometricPrompt.PromptInfo.Builder()
                    .setTitle(title)
                    .setSubtitle(subtitle)
                    .setDescription(description)
                    .setNegativeButtonText(negativeButtonText)
                    .build()
                
                val cipher = getCipher()
                val secretKey = getOrCreateSecretKey()
                
                cipher.init(Cipher.ENCRYPT_MODE, secretKey)
                
                val biometricPrompt = BiometricPrompt(
                    context as FragmentActivity,
                    promptInfo,
                    object : BiometricPrompt.AuthenticationCallback {
                        override fun onAuthenticationSucceeded(
                            result: BiometricPrompt.AuthenticationResult
                        ) {
                            continuation.resume(true)
                        }
                        
                        override fun onAuthenticationFailed(
                            error: CharSequence
                        ) {
                            continuation.resume(false)
                        }
                        
                        override fun onAuthenticationError(
                            error: Int,
                            errString: CharSequence
                        ) {
                            continuation.resume(false)
                        }
                        
                        override fun onCanceled() {
                            continuation.resume(false)
                        }
                    }
                )
                
                biometricPrompt.authenticate(promptInfo, cipher)
            }
        } catch (e: Exception) {
            false
        }
    }
    
    private fun getCipher(): Cipher {
        val transformation = "AES/CBC/PKCS7Padding"
        return Cipher.getInstance(transformation)
    }
    
    private fun getOrCreateSecretKey(): SecretKey {
        val keyAlias = "biometric_secret_key"
        val keyStore = java.security.KeyStore.getInstance("AndroidKeyStore")
        
        if (!keyStore.containsAlias(keyAlias)) {
            val keyGenerator = KeyGenerator.getInstance("AES")
            keyGenerator.init(256)
            return keyGenerator.generateKey()
        }
        
        return keyStore.getKey(keyAlias, null) as SecretKey
    }
}
```

**BiometricRepository.kt:**
```kotlin
package com.example.auth.data.repository

import com.example.auth.helper.BiometricHelper
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class BiometricRepository(
    private val biometricHelper: BiometricHelper
) {
    fun authenticateWithBiometric(): Flow<Result<Boolean>> = flow {
        try {
            val result = biometricHelper.authenticate(
                title = "Biometric Authentication",
                subtitle = "Authenticate to continue",
                description = "Use your fingerprint or face to authenticate",
                negativeButtonText = "Cancel"
            )
            
            if (result) {
                emit(Result.Success(true))
            } else {
                emit(Result.Error(Exception("Biometric authentication failed")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    fun isBiometricAvailable(): Boolean {
        return biometricHelper.isBiometricAvailable()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Biometric Authentication seperti Sidik Jari atau Wajah sebagai Kunci Akses:**
- **BiometricManager**: Manajer untuk autentikasi biometrik
- **BiometricPrompt**: UI untuk autentikasi biometrik
- **Cipher**: Algoritma enkripsi untuk keamanan
- **SecretKey**: Kunci rahasia untuk enkripsi

**Alur Kerja Biometric Authentication:**
1. Aplikasi memeriksa ketersediaan autentikasi biometrik
2. Aplikasi menampilkan prompt biometrik
3. User mengautentikasi dengan sidik jari atau wajah
4. Sistem biometrik memverifikasi identitas
5. Aplikasi melanjutkan operasi jika autentikasi berhasil

**Best Practices:**
- Gunakan autentikasi biometrik untuk operasi sensitif
- Jangan gunakan biometrik sebagai satu-satunya metode autentikasi
- Berikan opsi alternatif jika biometrik tidak tersedia
- Gunakan enkripsi yang kuat untuk data sensitif
- Jangan simpan data biometrik di perangkat

---

## 1ï¸âƒ£0ï¸âƒ£ Logout ğŸšª

### Konsep Dasar
Logout seperti proses keluar dari gedung pencakar langit ğŸšª - membersihkan semua akses dan mengembalikan ke pintu masuk!

### Logout Implementation:
**data/repository/AuthRepository.kt:**
```kotlin
package com.example.auth.data.repository

import com.example.auth.data.manager.TokenManager
import com.example.auth.network.AuthApiService
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class AuthRepository(
    private val apiService: AuthApiService,
    private val tokenManager: TokenManager
) {
    // ... login and refresh methods from previous sections ...
    
    suspend fun logout(): Flow<Result<Unit>> = flow {
        try {
            // Optional: Call logout endpoint
            val response = apiService.logout()
            
            if (!response.isSuccessful) {
                emit(Result.Error(Exception("Logout failed: ${response.code()}")))
                return@flow
            }
            
            // Clear tokens regardless of API response
            tokenManager.clearTokens()
            
            emit(Result.Success(Unit))
        } catch (e: Exception) {
            // Still clear tokens on error
            tokenManager.clearTokens()
            emit(Result.Error(e))
        }
    }
    
    fun clearLocalData() {
        tokenManager.clearTokens()
        // Clear other user data if needed
    }
}
```

### Logout ViewModel:
**presentation/viewmodel/AuthViewModel.kt:**
```kotlin
package com.example.auth.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.auth.data.repository.AuthRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class AuthViewModel @Inject constructor(
    private val authRepository: AuthRepository
) : ViewModel() {
    
    private val _logoutState = MutableStateFlow<LogoutState>(LogoutState.Idle)
    val logoutState: StateFlow<LogoutState> = _logoutState.asStateFlow()
    
    fun logout() {
        viewModelScope.launch {
            _logoutState.value = LogoutState.Loading
            
            authRepository.logout().collect { result ->
                when (result) {
                    is Result.Success -> {
                        _logoutState.value = LogoutState.Success
                    }
                    is Result.Error -> {
                        _logoutState.value = LogoutState.Error(result.exception.message ?: "Unknown error")
                    }
                }
            }
        }
    }
}

sealed class LogoutState {
    object Idle : LogoutState()
    object Loading : LogoutState()
    object Success : LogoutState()
    data class Error(val message: String) : LogoutState()
}
```

### Logout UI:
**presentation/screen/ProfileScreen.kt:**
```kotlin
package com.example.auth.presentation.screen

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.auth.presentation.viewmodel.AuthViewModel

@Composable
fun ProfileScreen(
    onNavigateToLogin: () -> Unit,
    viewModel: AuthViewModel = hiltViewModel()
) {
    val logoutState by viewModel.logoutState.collectAsState()
    
    Column(
        modifier = Modifier.fillMaxSize()
        .padding(16.dp)
    ) {
        // Profile content...
        
        Spacer(modifier = Modifier.weight(1f))
        
        Button(
            onClick = { viewModel.logout() },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Logout")
        }
        
        when (val state = logoutState) {
            is LogoutState.Loading -> {
                Box(
                    modifier = Modifier.fillMaxWidth(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
            is LogoutState.Success -> {
                LaunchedEffect(Unit) {
                    onNavigateToLogin()
                }
            }
            is LogoutState.Error -> {
                Text(
                    text = "Logout failed: ${state.message}",
                    color = MaterialTheme.colorScheme.error,
                    modifier = Modifier.padding(top = 8.dp)
                )
            }
            LogoutState.Idle -> {
                // Do nothing
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Logout seperti Proses Keluar dari Gedung Pencakar Langit:**
- **Logout API**: Memberitahu server untuk menghapus sesi
- **Clear Tokens**: Membersihkan token lokal
- **Navigate to Login**: Mengarahkan pengguna ke layar login
- **State Management**: Mengelola status logout

**Alur Kerja Logout:**
1. User menekan tombol logout
2. Aplikasi memanggil API logout (opsional)
3. Aplikasi membersihkan token lokal
4. Aplikasi mengarahkan pengguna ke layar login
5. Semua data pengguna dibersihkan

**Best Practices:**
- Selalu bersihkan token lokal saat logout
- Panggil API logout jika tersedia
- Berikan feedback visual kepada pengguna
- Arahkan pengguna ke layar login
- Bersihkan semua data pengguna sensitif

---

## 1ï¸âƒ£1ï¸âƒ£ Security Best Practices ğŸ›¡ï¸

### Konsep Dasar
Security Best Practices seperti sistem keamanan berlapis ğŸ›¡ï¸ - setiap lapisan memiliki fungsi spesifik untuk memastikan keamanan data dan akses!

### Daftar Best Practices:
- âœ… Gunakan HTTPS untuk semua komunikasi
- âœ… Simpan token dengan aman (EncryptedSharedPreferences)
- âœ… Implementasikan token refresh
- âœ… Tetapkan waktu kadaluarsa token
- âœ… Validasi token
- âœ… Gunakan password yang kuat
- âœ… Implementasikan rate limiting
- âœ… Aktifkan 2FA (Two-Factor Authentication)
- âœ… Log kejadian keamanan
- âœ… Tangani pencabutan token

### HTTPS Implementation:
**network/NetworkModule.kt:**
```kotlin
package com.example.auth.di

import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import okhttp3.CertificatePinner
import okhttp3.OkHttpClient
import okhttp3.TlsVersion
import okhttp3.logging.HttpLoggingInterceptor
import java.util.concurrent.TimeUnit
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        val certificatePinner = CertificatePinner.Builder()
            .add("api.example.com", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
            .build()
        
        return OkHttpClient.Builder()
            .certificatePinner(certificatePinner)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
```

### Secure Token Storage:
**data/manager/SecureTokenManager.kt:**
```kotlin
package com.example.auth.data.manager

import android.content.Context
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey

class SecureTokenManager(context: Context) {
    private val prefs = EncryptedSharedPreferences.create(
        "auth_prefs",
        MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build(),
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    
    fun saveTokens(accessToken: String, refreshToken: String) {
        prefs.edit()
            .putString("access_token", accessToken)
            .putString("refresh_token", refreshToken)
            .apply()
    }
    
    fun getAccessToken(): String? {
        return prefs.getString("access_token", null)
    }
    
    fun getRefreshToken(): String? {
        return prefs.getString("refresh_token", null)
    }
    
    fun clearTokens() {
        prefs.edit()
            .remove("access_token")
            .remove("refresh_token")
            .apply()
    }
}
```

### Rate Limiting:
**network/interceptor/RateLimitInterceptor.kt:**
```kotlin
package com.example.auth.network.interceptor

import okhttp3.Interceptor
import okhttp3.Response

class RateLimitInterceptor : Interceptor {
    private val requestCounts = mutableMapOf<String, Int>()
    private val requestWindow = 60_000L // 1 minute
    
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val endpoint = request.url().encodedPath()
        
        val currentCount = requestCounts[endpoint] ?: 0
        val currentTime = System.currentTimeMillis()
        
        if (currentCount >= 10) {
            val windowStart = requestCounts["${endpoint}_window"] ?: 0L
            
            if (currentTime - windowStart < requestWindow) {
                throw RateLimitException("Too many requests. Please try again later.")
            } else {
                requestCounts[endpoint] = 0
                requestCounts["${endpoint}_window"] = currentTime
            }
        }
        
        requestCounts[endpoint] = currentCount + 1
        if (!requestCounts.containsKey("${endpoint}_window")) {
            requestCounts["${endpoint}_window"] = currentTime
        }
        
        return chain.proceed(request)
    }
    
    class RateLimitException(message: String) : Exception(message)
}
```

### Two-Factor Authentication:
**data/model/auth/TwoFactorAuthRequest.kt:**
```kotlin
package com.example.auth.data.model

data class TwoFactorAuthRequest(
    val userId: String,
    val code: String
)
```

**data/model/auth/TwoFactorAuthResponse.kt:**
```kotlin
package com.example.auth.data.model

data class TwoFactorAuthResponse(
    val success: Boolean,
    val token: String?
)
```

### ğŸ“ Penjelasan Konsep:
**Security Best Practices seperti Sistem Keamanan Berlapis:**
- **HTTPS**: Lapisan enkripsi untuk semua komunikasi
- **Token Storage**: Brankas penyimpanan token yang aman
- **Token Refresh**: Mekanisme perpanjang akses
- **Token Expiration**: Waktu kadaluarsa token
- **Token Validation**: Pemeriksaan keaslian token
- **Strong Passwords**: Kata sandi yang sulit ditebak
- **Rate Limiting**: Pembatasan jumlah permintaan
- **2FA**: Autentikasi dua faktor
- **Security Logging**: Pencatatan kejadian keamanan
- **Token Revocation**: Pembatalan token yang dicurigai

**Strategi Keamanan:**
1. Gunakan HTTPS untuk semua komunikasi
2. Simpan token dengan enkripsi
3. Implementasikan token refresh
4. Tetapkan waktu kadaluarsa token
5. Validasi token di sisi klien dan server
6. Gunakan password yang kuat
7. Implementasikan rate limiting
8. Aktifkan 2FA untuk keamanan tambahan
9. Log kejadian keamanan untuk monitoring
10. Tangani pencabutan token

**Best Practices:**
- Prioritaskan keamanan data pengguna
- Gunakan library dan framework yang terpercaya
- Tetap update dengan patch keamanan
- Lakukan audit keamanan secara berkala
- Edukasi pengguna tentang praktik keamanan

---

## 1ï¸âƒ£2ï¸âƒ£ Contoh Alur Authentication Lengkap ğŸ—ï¸

### Konsep Dasar
Contoh Alur Authentication Lengkap seperti sistem keamanan gedung pencakar langit yang lengkap ğŸ—ï¸ - dari pintu masuk hingga setiap lantai dengan keamanan berlapis!

### Complete Auth Flow:
**data/repository/CompleteAuthRepository.kt:**
```kotlin
package com.example.auth.data.repository

import com.example.auth.data.manager.TokenManager
import com.example.auth.data.model.LoginRequest
import com.example.auth.data.model.LoginResponse
import com.example.auth.network.AuthApiService
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class CompleteAuthRepository(
    private val apiService: AuthApiService,
    private val tokenManager: TokenManager
) {
    suspend fun login(email: String, password: String): Flow<Result<LoginResponse>> = flow {
        try {
            val response = apiService.login(LoginRequest(email, password))
            
            if (response.isSuccessful) {
                val loginResponse = response.body()
                
                if (loginResponse != null) {
                    tokenManager.saveTokens(
                        loginResponse.accessToken,
                        loginResponse.refreshToken
                    )
                    emit(Result.Success(loginResponse))
                } else {
                    emit(Result.Error(Exception("Empty response")))
                }
            } else {
                emit(Result.Error(Exception("Login failed: ${response.code()}")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    suspend fun refreshToken(): Flow<Result<Unit>> = flow {
        try {
            val refreshToken = tokenManager.getRefreshToken()
                ?: throw Exception("No refresh token available")
            
            val response = apiService.refreshToken(refreshToken)
            
            if (response.isSuccessful) {
                val refreshResponse = response.body()
                
                if (refreshResponse != null) {
                    tokenManager.saveTokens(
                        refreshResponse.accessToken,
                        refreshResponse.refreshToken
                    )
                    emit(Result.Success(Unit))
                } else {
                    emit(Result.Error(Exception("Empty response")))
                }
            } else {
                emit(Result.Error(Exception("Token refresh failed: ${response.code()}")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    suspend fun logout(): Flow<Result<Unit>> = flow {
        try {
            val response = apiService.logout()
            
            if (!response.isSuccessful) {
                emit(Result.Error(Exception("Logout failed: ${response.code()}")))
                return@flow
            }
            
            tokenManager.clearTokens()
            emit(Result.Success(Unit))
        } catch (e: Exception) {
            tokenManager.clearTokens()
            emit(Result.Error(e))
        }
    }
    
    fun isLoggedIn(): Boolean {
        val token = tokenManager.getAccessToken()
        return token != null && !tokenManager.isAccessTokenExpired()
    }
    
    fun logout() {
        tokenManager.clearTokens()
    }
}
```

### Complete Auth ViewModel:
**presentation/viewmodel/CompleteAuthViewModel.kt:**
```kotlin
package com.example.auth.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.auth.data.model.LoginResponse
import com.example.auth.data.repository.CompleteAuthRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class CompleteAuthViewModel @Inject constructor(
    private val authRepository: CompleteAuthRepository
) : ViewModel() {
    
    private val _loginState = MutableStateFlow<LoginState>(LoginState.Idle)
    val loginState: StateFlow<LoginState> = _loginState.asStateFlow()
    
    private val _logoutState = MutableStateFlow<LogoutState>(LogoutState.Idle)
    val logoutState: StateFlow<LogoutState> = _logoutState.asStateFlow()
    
    fun login(email: String, password: String) {
        viewModelScope.launch {
            _loginState.value = LoginState.Loading
            
            authRepository.login(email, password).collect { result ->
                when (result) {
                    is Result.Success -> {
                        _loginState.value = LoginState.Success(result.data)
                    }
                    is Result.Error -> {
                        _loginState.value = LoginState.Error(result.exception.message ?: "Unknown error")
                    }
                }
            }
        }
    }
    
    fun logout() {
        viewModelScope.launch {
            _logoutState.value = LogoutState.Loading
            
            authRepository.logout().collect { result ->
                when (result) {
                    is Result.Success -> {
                        _logoutState.value = LogoutState.Success
                    }
                    is Result.Error -> {
                        _logoutState.value = LogoutState.Error(result.exception.message ?: "Unknown error")
                    }
                }
            }
        }
    }
    
    fun refreshToken() {
        viewModelScope.launch {
            authRepository.refreshToken().collect { result ->
                when (result) {
                    is Result.Success -> {
                        // Token refreshed successfully
                    }
                    is Result.Error -> {
                        // Token refresh failed, user needs to login again
                        _loginState.value = LoginState.Error("Session expired. Please login again.")
                    }
                }
            }
        }
    }
}

sealed class LoginState {
    object Idle : LoginState()
    object Loading : LoginState()
    data class Success(val user: LoginResponse) : LoginState()
    data class Error(val message: String) : LoginState()
}

sealed class LogoutState {
    object Idle : LogoutState()
    object Loading : LogoutState()
    object Success : LogoutState()
    data class Error(val message: String) : LogoutState()
}
```

### Complete Auth UI:
**presentation/screen/LoginScreen.kt:**
```kotlin
package com.example.auth.presentation.screen

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.auth.presentation.viewmodel.CompleteAuthViewModel

@Composable
fun LoginScreen(
    onNavigateToHome: () -> Unit,
    viewModel: CompleteAuthViewModel = hiltViewModel()
) {
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    
    val loginState by viewModel.loginState.collectAsState()
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = "Login",
            style = MaterialTheme.typography.head
		) {
            var email by remember { mutableStateOf("") }
            var password by remember { mutableStateOf("") }
            
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                OutlinedTextField(
                    value = email,
                    onValue = { email = it },
                    label = "Email",
                    modifier = Modifier.fillMaxWidth()
                )
                
                OutlinedTextField(
                    value = password,
                    onValue = { password = it },
                    label = "Password",
                    visualTransformation = PasswordVisualTransformation(),
                    visualTransformation = PasswordVisualTransformation()
                )
                
                Spacer(modifier = Modifier.height(8.dp)
                
                Button(
                    onClick = {
                        viewModel.login(email, password)
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Login")
                }
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Contoh Alur Authentication Lengkap:**
- **Login**: Proses pendaftaran anggota baru
- **Token Storage**: Penyimpanan kartu akses dengan aman
- **Refresh**: Memperbarui kartu akses yang kadaluarsa
- **Logout**: Proses keluar dari aplikasi

**Alur Kerja:**
1. User memasukkan email dan password
2. Aplikasi mengirim kredensial ke server
3. Server memverifikasi kredensial
4. Jika berhasil, server mengeluarkan JWT token
5. Aplikasi menyimpan token dengan aman
6. User diarahkan ke halaman utama

**Best Practices:**
- Gunakan EncryptedSharedPreferences untuk menyimpan token
- Implementasikan token refresh
- Gunakan HTTPS untuk semua komunikasi
- Validasi token sebelum digunakan
- Bersihkan token saat logout
- Gunakan token expiration

---

## 1ï¸âƒ£3ï¸âƒ£ Contoh Alur Authentication Lengkap ğŸ—ï¸

### Konsep Dasar
Contoh Alur Authentication Lengkap seperti sistem keamanan berlapis ğŸ—ï¸ - dari pintu masuk hingga keluar dengan aman!

### Complete Auth Flow:
**data/model/auth/User.kt:**
```kotlin
package com.example.auth.data.model

data class User(
    val id: Int,
    val name: String,
    val email: String,
    val isActive: Boolean = true,
    val createdAt: String,
    val updatedAt: String
)
```

**data/model/auth/LoginRequest.kt:**
```kotlin
package com.example.auth.data.model

data class LoginRequest(
    val email: String,
    val password: String
)
```

**data/model/auth/LoginResponse.kt:**
```kend
package com.example.auth.data.model

data class LoginResponse(
    val accessToken: String,
    val refreshToken: String,
    val expiresIn: Long,
    val tokenType: String,
    val user: User
)
```

**network/AuthApiService.kt:**
```kotlin
package com.example.auth.network

import com.example.auth.data.model.LoginRequest
import com.example.auth.data.model.LoginResponse
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.POST

interface AuthApiService {
    @POST("auth/login")
    suspend fun login(@Body request: LoginRequest): Response<LoginResponse>
    
    @POST("auth/refresh")
    suspend fun refreshToken(@Body request: RefreshTokenRequest): Response<RefreshTokenResponse>
    
    @POST("auth/logout")
    suspend fun logout(): Response<Unit>
}
```

**data/model/auth/RefreshTokenRequest.kt:**
```kotlin
package com.example.auth.data.model

data class RefreshTokenRequest(
    val refreshToken: String
)
```

**data/model/auth/RefreshTokenResponse.kt:**
```kotlin
package com.example.auth.data.model

data class RefreshTokenResponse(
    val accessToken: String,
    val refreshToken: String,
    val expiresIn: Long,
    val tokenType: String
)
```

### Complete Repository:
**data/repository/CompleteAuthRepository.kt:**
```kotlin
package com.example.auth.data.repository

import com.example.auth.data.manager.TokenManager
import com.example.auth.data.model.LoginRequest
import com.example.auth.data.model.LoginResponse
import com.example.auth.network.AuthApiService
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

class CompleteAuthRepository(
    private val apiService: AuthApiService,
    private val tokenManager: TokenManager
) {
    suspend fun login(email: String, password: String): Flow<Result<LoginResponse>> = flow {
        try {
            val response = apiService.login(LoginRequest(email, password))
            
            if (response.isSuccessful) {
                val loginResponse = response.body()
                
                if (loginResponse != null) {
                    tokenManager.saveTokens(
                        loginResponse.accessToken,
                        loginResponse.refreshToken
                    )
                    emit(Result.Success(loginResponse))
                } else {
                    emit(Result.Error(Exception("Empty response"))
                }
            } else {
                emit(Result.Error(Exception("Login failed: ${response.code()}")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    suspend fun refreshToken(): Flow<Result<Unit>> = flow {
        try {
            val refreshToken = tokenManager.getRefreshToken()
                ?: throw Exception("No refresh token available")
            
            val response = apiService.refreshToken(RefreshTokenRequest(refreshToken))
            
            if (response.isSuccessful) {
                val refreshResponse = response.body()
                
                if (refreshResponse != null) {
                    tokenManager.saveTokens(
                        refreshResponse.accessToken,
                        refreshResponse.refreshToken
                    )
                    emit(Result.Success(Unit))
                } else {
                    emit(Result.Error(Exception("Empty response"))
                }
            } else {
                emit(Result.Error(Exception("Token refresh failed: ${response.code()}")))
            }
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    suspend fun logout(): Flow<Result<Unit>> = flow {
        try {
            // Optional: Call logout endpoint
            val response = apiService.logout()
            
            // Clear tokens regardless of API response
            tokenManager.clearTokens()
            
            emit(Result.Success(Unit))
        } catch (e: Exception) {
            emit(Result.Error(e))
        }
    }
    
    fun isLoggedIn(): Boolean {
        val token = tokenManager.getAccessToken()
        return token != null && !tokenManager.isAccessTokenExpired()
    }
}
```

### Complete ViewModel:
**presentation/viewmodel/CompleteAuthViewModel.kt:**
```kotlin
package com.example.auth.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.lifecycle.viewModelScope
import com.example.auth.data.repository.CompleteAuthRepository
import com.example.auth.presentation.ui.state.AuthUiState
import com.example.auth.presentation.ui.state.AuthUiState.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class CompleteAuthViewModel @Inject constructor(
    private val authRepository: CompleteAuthRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<AuthUiState>(AuthUiState.Idle)
    val uiState: StateFlow<AuthUiState> = _uiState.asStateFlow()
    
    private val _logoutState = MutableStateFlow<LogoutState>(LogoutState.Idle)
    val logoutState: StateFlow<LogoutState> = _logoutState.asStateFlow()
    
    init {
        checkAuthState()
    }
    
    private fun checkAuthState() {
        viewModelScope.launch {
            _uiState.value = if (authRepository.isLoggedIn()) {
                AuthUiState.Authenticated
            } else {
                AuthUiState.Unauthenticated
            }
        }
    }
    
    fun login(email: String, password: String) {
        viewModelScope.launch {
            _uiState.value = AuthUiState.Loading
            
            authRepository.login(email, password).collect { result ->
                when (result) {
                    is Result.Success -> {
                        _uiState.value = AuthUiState.Authenticated
                    }
                    is Result.Error -> {
                        _uiState.value = AuthUiState.Error(result.exception.message ?: "Unknown error")
                    }
                }
            }
        }
    }
    
    fun logout() {
        viewModelScope.launch {
            _logoutState.value = LogoutState.Loading
            
            authRepository.logout().collect { result ->
                when (result) {
                    is Result.Success -> {
                        _logoutState.value = LogoutState.Success
                    }
                    is Result.Error -> {
                        _logoutState.value = LogoutState.Error(result.exception.message ?: "Unknown error"
                    }
                }
            }
        }
    }
    
    fun clearError() {
        _uiState.value = AuthUiState.Idle
    }
}

sealed class AuthUiState {
    object Idle : AuthUiState()
    object Loading : AuthUiState()
    data class Authenticated : AuthUiState()
    data class Error(val message: String) : AuthUiState()
}

sealed class LogoutState {
    object Idle : LogoutState()
    object Loading : LogoutState()
    object Success : LogoutState()
    data class Error(val message: String) : LogoutState()
}
```

### Complete UI:
**presentation/screen/LoginScreen.kt:**
```kotlin
package com.example.auth.presentation.screen

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.text.input.KeyboardOptions
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import com.example.auth.presentation.viewmodel.CompleteAuthViewModel
import com.example.auth.presentation.ui.state.AuthUiState
import kotlinx.coroutines.flow.collectAsState
import kotlinx.coroutines.launch

@Composable
fun LoginScreen(
    onNavigateToHome: () -> Unit,
    viewModel: CompleteAuthViewModel = hiltViewModel()
) {
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var passwordVisible by remember { mutableStateOf(false) }
    
    val uiState by viewModel.uiState.collectAsState()
    
    LaunchedEffect(Unit) {
        viewModel.checkAuthState()
    }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        when (val state = uiState) {
            is AuthUiState.Idle -> {
                // Show login form
            }
            is AuthUiState.Loading -> {
                LoadingIndicator()
            }
            is AuthUiState.Authenticated -> {
                LaunchedEffect(Unit) {
                    onNavigateToHome()
                }
            }
            is AuthUiState.Error -> {
                // Show error message
            }
        }
    }
    
    Column(
        modifier = Modifier
            .padding(horizontalAlignment = Alignment.CenterHorizontally,
        ) {
            if (uiState is AuthUiState.Loading) {
                LoadingIndicator()
            }
            
            if (uiState is AuthUiState.Idle || uiState is AuthUiState.Error) {
                LoginForm(
                    email = email,
                    password = password,
                    passwordVisible = passwordVisible,
                    onEmailChange = { email = it },
                    onPasswordChange = { password = it },
                    onLogin = { 
                        viewModel.login(email, password)
                    },
                    onLogin = { passwordVisible = true },
                    onLogin = { passwordVisible = false
                    },
                    modifier = Modifier.weight(1f)
                )
            }
        }
    }
    
    @Composable
    fun LoginForm(
        email: String,
        password: String,
        onEmailChange: (String) -> Unit,
        passwordVisible: Boolean,
        onLogin: (String, String) -> Unit,
        onLogin: (String, String) -> Unit,
        onLogin: (Boolean) -> Unit
    ) {
    var email by remember { mutableStateOf("") }
    var passwordVisible by remember { mutableStateOf(false) }
    
    @Composable
    fun LoadingIndicator() {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            CircularProgressIndicator()
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Contoh Alur Authentication Lengkap seperti Sistem Keamanan Berlapis:**
- **Login**: Proses pendaftaran anggota baru
- **Token Storage**: Penyimpanan kartu akses dengan aman
- **Refresh**: Memperbarui kartu akses yang akan kadaluarsa
- **Logout**: Proses keluar dari aplikasi

**Alur Kerja:**
1. User memasukkan kredensial
2. Aplikasi mengirim kredensial ke server
3. Server memverifikasi kredensial
4. Jika berhasil, server mengeluarkan JWT token
5. Aplikasi menyimpan token dengan aman
6. User diarahkan ke halaman utama

**Best Practices:**
- Gunakan EncryptedSharedPreferences untuk menyimpan token
- Implementasikan token refresh
- Gunakan HTTPS untuk semua komunikasi
- Validasi token sebelum digunakan
- Bersihkan token saat logout

---

## 1ï¸âƒ£3ï¸âƒ£ Hands-on Project ğŸ”¨

### Konsep Dasar
Hands-on Project seperti proyek konstruksi sistem keamanan berlapis ğŸ”¨ - menerapkan semua teori dalam aplikasi yang fungsional!

### Daftar Proyek:
- Implementasikan sistem autentikasi lengkap
- Buat UI login dan register
- Implementasikan token refresh
- Tambahkan social authentication
- Implementasikan biometric authentication
- Test berbagai skenario autentikasi

### Langkah Proyek:
1. Buat proyek baru dengan Hilt dan Retrofit
2. Implementasikan sistem token management
3. Buat UI login dan register
4. Implementasikan token refresh
5. Tambahkan social authentication
6. Implementasikan biometric authentication
7. Test berbagai skenario

### ğŸ“ Penjelasan Konsep:
**Hands-on Project seperti Proyek Konstruksi Sistem Keamanan Berlapis:**
- **Struktur**: Mengikuti arsitektur MVVM yang bersih
- **Integration**: Mengintegrasikan semua komponen dengan baik
- **Testing**: Memastikan semua skenario

**Alur Kerja:**
1. Buat proyek baru dengan Hilt dan Retrofit
2. Implementasikan sistem token management
3. Buat UI dengan Jetpack Compose
4. Implementasikan semua jenis autentikasi
5. Test semua skenario
6. Deploy aplikasi

**Best Practices:**
- Gunakan Hilt untuk dependency injection
- Pisahkan tanggung jawab antar lapisan
- Gunakan best practices untuk keamanan
- Test semua skenario autentikasi
- Implementasikan error handling yang baik

---

## ğŸ¯ Kesimpulan

### ğŸŒŸ Apa yang Telah Kita Pelajari:
Kita telah membangun sistem keamanan berlapis yang lengkap, dari konsep dasar hingga implementasi lengkap!

1. **Dasar-dasar Authentication**: Memahami konsep dasar autentikasi dan pentingnya
2. **JWT**: Menggunakan JWT untuk token yang aman dan tidak dapat dipalsukan
3. **Login & Token Storage**: Implementasi proses login dan penyimpanan token yang aman
4. **Bearer Token**: Menambahkan token ke setiap request
5. **Token Refresh**: Memperbarui token yang kadaluarsa
6. **OAuth 2.0**: Menggunakan sistem izin multi-level untuk izin masuk
7. **Social Authentication**: Menggunakan jasa keamanan yang sudah ada
8. **Biometric Authentication**: Menambahkan lapisan keamanan ekstra

### ğŸš€ Langkah Selanjutnya:
Setelah memahami sistem keamanan berlapis, Anda siap untuk:
1. **Mengintegrasikan keamanan API modern dengan keamanan
2. Membangun aplikasi yang aman dan andal
3. Mengimplementasikan fitur-fitur lanjutan
4. Menguasai keamanan perusahaan
5. Menjadi ahli dalam keamanan digital

---

## ğŸ¯ Tips untuk Menjadi Ahli API Authentication:
1. **Selalu gunakan HTTPS untuk semua komunikasi**
2. **Simpan token dengan aman**
3. Implementasikan token refresh
4. Validasi token sebelum digunakan
5. Gunakan best practices keamanan
6. Selalu update dengan perkembangan teknologi
7. Ikuti standar industri
8. Jangan pernah abaikan keamanan

Dengan pemahaman yang kuat tentang API Authentication, Anda sekarang memiliki fondasi yang kokoh untuk membangun aplikasi yang aman dan andal.

---