## **4.6 Design Patterns** (4 hari) ⭐⭐

### **Teknologi Modern:**
- Factory
- Builder
- Observer
- Singleton
- Adapter patterns

### **Teknologi yang Ditinggalkan:**
- -

### **Sub-topik Detail:**

#### 1. Design Patterns Overview
- Apa itu Design Patterns
- Gang of Four (GoF) patterns
- Creational, Structural, Behavioral
- Patterns di Android
- Kapan menggunakan patterns
- Anti-patterns yang harus dihindari

#### 2. Creational Patterns

**Factory Pattern:**
```kotlin
// Problem: Complex object creation
interface Animal {
    fun makeSound()
}

class Dog : Animal {
    override fun makeSound() = println("Woof")
}

class Cat : Animal {
    override fun makeSound() = println("Meow")
}

// Factory
object AnimalFactory {
    fun createAnimal(type: String): Animal {
        return when(type) {
            "dog" -> Dog()
            "cat" -> Cat()
            else -> throw IllegalArgumentException()
        }
    }
}

// Usage
val animal = AnimalFactory.createAnimal("dog")
```

**Use Cases:**
- ViewModelFactory
- Repository creation
- Different implementations based on config

**Builder Pattern:**
```kotlin
// Problem: Complex object dengan many parameters
class User private constructor(
    val name: String,
    val email: String,
    val age: Int?,
    val phone: String?,
    val address: String?
) {
    class Builder {
        private var name: String = ""
        private var email: String = ""
        private var age: Int? = null
        private var phone: String? = null
        private var address: String? = null
        
        fun name(name: String) = apply { this.name = name }
        fun email(email: String) = apply { this.email = email }
        fun age(age: Int) = apply { this.age = age }
        fun phone(phone: String) = apply { this.phone = phone }
        fun address(address: String) = apply { this.address = address }
        
        fun build() = User(name, email, age, phone, address)
    }
}

// Usage
val user = User.Builder()
    .name("John")
    .email("john@example.com")
    .age(30)
    .build()
```

**Use Cases:**
- Retrofit builder
- Room database builder
- AlertDialog builder
- Complex configuration objects

**Singleton Pattern:**
```kotlin
// Kotlin way
object DatabaseHelper {
    fun getDatabase(): Database { }
}

// Java way (avoid in Kotlin)
class DatabaseHelper private constructor() {
    companion object {
        @Volatile
        private var instance: DatabaseHelper? = null
        
        fun getInstance(): DatabaseHelper {
            return instance ?: synchronized(this) {
                instance ?: DatabaseHelper().also { instance = it }
            }
        }
    }
}
```

**Caveats di Android:**
- Memory leaks dengan Context
- Testing difficulties
- Hidden dependencies
- Prefer DI over Singleton

#### 3. Structural Patterns

**Adapter Pattern:**
```kotlin
// Problem: Incompatible interfaces
interface MediaPlayer {
    fun play(fileName: String)
}

class Mp3Player : MediaPlayer {
    override fun play(fileName: String) {
        println("Playing mp3: $fileName")
    }
}

// Legacy class dengan different interface
class VlcPlayer {
    fun playVlc(fileName: String) {
        println("Playing vlc: $fileName")
    }
}

// Adapter
class VlcAdapter(private val vlcPlayer: VlcPlayer) : MediaPlayer {
    override fun play(fileName: String) {
        vlcPlayer.playVlc(fileName)
    }
}

// Usage
val player: MediaPlayer = VlcAdapter(VlcPlayer())
player.play("movie.vlc")
```

**Use Cases:**
- RecyclerView.Adapter
- Wrapping legacy code
- Third-party library integration

**Decorator Pattern:**
```kotlin
interface Coffee {
    fun cost(): Double
    fun description(): String
}

class SimpleCoffee : Coffee {
    override fun cost() = 5.0
    override fun description() = "Simple Coffee"
}

abstract class CoffeeDecorator(
    private val coffee: Coffee
) : Coffee {
    override fun cost() = coffee.cost()
    override fun description() = coffee.description()
}

class MilkDecorator(coffee: Coffee) : CoffeeDecorator(coffee) {
    override fun cost() = super.cost() + 1.5
    override fun description() = super.description() + ", Milk"
}

// Usage
val coffee: Coffee = MilkDecorator(SimpleCoffee())
println("${coffee.description()} costs ${coffee.cost()}")
```

#### 4. Behavioral Patterns

**Observer Pattern:**
```kotlin
// Problem: One-to-many dependency
interface Observer {
    fun update(data: String)
}

class Subject {
    private val observers = mutableListOf<Observer>()
    
    fun attach(observer: Observer) {
        observers.add(observer)
    }
    
    fun detach(observer: Observer) {
        observers.remove(observer)
    }
    
    fun notify(data: String) {
        observers.forEach { it.update(data) }
    }
}

// Android equivalent: LiveData, Flow
```

**Use Cases:**
- LiveData observers
- Flow collectors
- Event bus
- Callback patterns

**Strategy Pattern:**
```kotlin
// Problem: Different algorithms, runtime selection
interface PaymentStrategy {
    fun pay(amount: Double)
}

class CreditCardPayment : PaymentStrategy {
    override fun pay(amount: Double) {
        println("Paid $amount via Credit Card")
    }
}

class PayPalPayment : PaymentStrategy {
    override fun pay(amount: Double) {
        println("Paid $amount via PayPal")
    }
}

class ShoppingCart(private var paymentStrategy: PaymentStrategy) {
    fun setPaymentStrategy(strategy: PaymentStrategy) {
        paymentStrategy = strategy
    }
    
    fun checkout(amount: Double) {
        paymentStrategy.pay(amount)
    }
}

// Usage
val cart = ShoppingCart(CreditCardPayment())
cart.checkout(100.0)
cart.setPaymentStrategy(PayPalPayment())
cart.checkout(200.0)
```

**Use Cases:**
- Different sorting algorithms
- Payment methods
- Authentication strategies
- Validation rules

**State Pattern:**
```kotlin
// Problem: Object behavior berubah based on state
interface State {
    fun handle(context: Context)
}

class Context {
    private var state: State = StateA()
    
    fun setState(state: State) {
        this.state = state
    }
    
    fun request() {
        state.handle(this)
    }
}

class StateA : State {
    override fun handle(context: Context) {
        println("Handling in State A")
        context.setState(StateB())
    }
}

class StateB : State {
    override fun handle(context: Context) {
        println("Handling in State B")
        context.setState(StateA())
    }
}
```

**Use Cases:**
- UI states (Loading, Success, Error)
- Player states (Playing, Paused, Stopped)
- Connection states
- Sealed classes di Kotlin

#### 5. Android-Specific Patterns

**ViewHolder Pattern:**
```kotlin
class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    private val textView: TextView = itemView.findViewById(R.id.textView)
    
    fun bind(data: String) {
        textView.text = data
    }
}
```

**Repository Pattern:**
- Already covered in 4.2
- Abstraction untuk data access
- Single source of truth

**Delegation Pattern:**
```kotlin
interface Printer {
    fun print()
}

class ConsolePrinter : Printer {
    override fun print() {
        println("Printing to console")
    }
}

class Document(printer: Printer) : Printer by printer

// Kotlin property delegation
class User {
    var name: String by Delegates.observable("") { prop, old, new ->
        println("Name changed from $old to $new")
    }
}
```

#### 6. Pattern Combinations
- Factory + Singleton
- Strategy + Factory
- Observer + Singleton
- Builder + Factory
- Decorator + Strategy

#### 7. When to Use Patterns
**DO use patterns when:**
- Problem fits pattern perfectly
- Code becomes more maintainable
- Team understands the pattern
- Future extensibility needed

**DON'T use patterns when:**
- Over-engineering simple problems
- Team unfamiliar with pattern
- Adds unnecessary complexity
- YAGNI (You Aren't Gonna Need It)

#### 8. Anti-Patterns
- God Object
- Spaghetti Code
- Lava Flow (dead code)
- Golden Hammer (use same pattern everywhere)
- Premature Optimization
- Magic Numbers/Strings

#### 9. Patterns dalam Real Android Apps
- MVVM = Observer + Repository
- Clean Architecture = Layers + DIP
- Retrofit = Builder + Factory + Adapter
- Room = Builder + DAO + Repository
- RecyclerView = Adapter + ViewHolder + Observer

#### 10. Testing dengan Patterns
- Factory: Easy to create test objects
- Strategy: Easy to test different strategies
- Observer: Test notifications
- Adapter: Test conversions
- Repository: Mock implementations

#### 11. Hands-on Exercises
- Identify patterns dalam existing code
- Implement Factory pattern
- Implement Strategy pattern
- Refactor code dengan patterns
- Build mini-project using multiple patterns
- Code review: Pattern usage

#### 12. Resources & Further Learning
- Gang of Four book
- Head First Design Patterns
- Refactoring Guru website
- Android-specific pattern examples
- Open-source apps analysis

---


