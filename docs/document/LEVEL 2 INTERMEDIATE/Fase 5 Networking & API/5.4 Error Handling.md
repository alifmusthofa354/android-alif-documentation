## **5.4 Error Handling** (3 hari) ⭐⭐⭐

### **Teknologi Modern:**
- Try-catch
- Result wrapper
- Sealed classes

### **Teknologi yang Ditinggalkan:**
- Ignoring errors

### **Sub-topik Detail:**

#### 1. Network Error Types

**Network Errors:**
- No internet connection
- Timeout (connect, read, write)
- SSL/TLS errors
- DNS resolution failures
- Connection refused

**HTTP Errors:**
- 4xx Client Errors (400, 401, 403, 404, 422)
- 5xx Server Errors (500, 502, 503)

**Parsing Errors:**
- Invalid JSON format
- Missing required fields
- Type mismatch

**Application Errors:**
- Business logic errors
- Validation errors
- Custom exceptions

#### 2. Try-Catch Basics
```kotlin
suspend fun getUsers(): List<User> {
    return try {
        apiService.getUsers()
    } catch (e: Exception) {
        // Handle error
        emptyList()
    }
}
```

**Catching Specific Exceptions:**
```kotlin
try {
    val users = apiService.getUsers()
    // Success
} catch (e: HttpException) {
    // HTTP error (4xx, 5xx)
    when (e.code()) {
        401 -> handleUnauthorized()
        404 -> handleNotFound()
        500 -> handleServerError()
    }
} catch (e: IOException) {
    // Network error (no internet, timeout)
    handleNetworkError()
} catch (e: JsonSyntaxException) {
    // JSON parsing error
    handleParsingError()
} catch (e: Exception) {
    // Unknown error
    handleUnknownError()
}
```

#### 3. Result Wrapper Pattern

**Sealed Class Approach:**
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()
    object Loading : Result<Nothing>()
}

// Usage
suspend fun getUsers(): Result<List<User>> {
    return try {
        val users = apiService.getUsers()
        Result.Success(users)
    } catch (e: Exception) {
        Result.Error(e)
    }
}

// In ViewModel
viewModelScope.launch {
    _uiState.value = Result.Loading
    val result = repository.getUsers()
    _uiState.value = result
}

// In UI
when (val state = uiState.value) {
    is Result.Loading -> ShowLoading()
    is Result.Success -> ShowData(state.data)
    is Result.Error -> ShowError(state.exception.message)
}
```

**Enhanced Result with Error Details:**
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    
    sealed class Error : Result<Nothing>() {
        data class Network(val message: String) : Error()
        data class Http(val code: Int, val message: String) : Error()
        data class Generic(val exception: Exception) : Error()
    }
    
    object Loading : Result<Nothing>()
}
```

**Kotlin Result Type (Standard Library):**
```kotlin
suspend fun getUsers(): kotlin.Result<List<User>> {
    return try {
        val users = apiService.getUsers()
        kotlin.Result.success(users)
    } catch (e: Exception) {
        kotlin.Result.failure(e)
    }
}

// Usage
repository.getUsers()
    .onSuccess { users ->
        // Handle success
    }
    .onFailure { exception ->
        // Handle error
    }
```

#### 4. Safe API Call Wrapper
```kotlin
suspend fun <T> safeApiCall(
    apiCall: suspend () -> T
): Result<T> {
    return try {
        Result.Success(apiCall())
    } catch (e: HttpException) {
        Result.Error.Http(e.code(), e.message())
    } catch (e: IOException) {
        Result.Error.Network("Network error: ${e.message}")
    } catch (e: Exception) {
        Result.Error.Generic(e)
    }
}

// Usage
suspend fun getUsers() = safeApiCall {
    apiService.getUsers()
}
```

#### 5. Error Response Models
```kotlin
// API error response format
data class ErrorResponse(
    val code: String,
    val message: String,
    val field: String? = null,
    val details: Map<String, Any>? = null
)

// Parse error body
fun parseErrorBody(errorBody: ResponseBody?): String {
    return try {
        val error = Gson().fromJson(
            errorBody?.string(),
            ErrorResponse::class.java
        )
        error.message
    } catch (e: Exception) {
        "Unknown error occurred"
    }
}
```

#### 6. Handling HTTP Status Codes
```kotlin
suspend fun makeApiCall(): Result<User> {
    return try {
        val response = apiService.getUser()
        
        if (response.isSuccessful) {
            val user = response.body()
            if (user != null) {
                Result.Success(user)
            } else {
                Result.Error(Exception("Empty response body"))
            }
        } else {
            when (response.code()) {
                400 -> Result.Error(Exception("Bad Request"))
                401 -> Result.Error(Exception("Unauthorized"))
                403 -> Result.Error(Exception("Forbidden"))
                404 -> Result.Error(Exception("Not Found"))
                422 -> {
                    val errorMsg = parseErrorBody(response.errorBody())
                    Result.Error(Exception(errorMsg))
                }
                in 500..599 -> Result.Error(Exception("Server Error"))
                else -> Result.Error(Exception("HTTP ${response.code()}"))
            }
        }
    } catch (e: Exception) {
        Result.Error(e)
    }
}
```

#### 7. Custom Exceptions
```kotlin
// Network exceptions
class NoInternetException(message: String = "No internet connection") 
    : IOException(message)

class TimeoutException(message: String = "Request timeout") 
    : IOException(message)

// Business logic exceptions
class InvalidCredentialsException(message: String = "Invalid email or password") 
    : Exception(message)

class UserNotFoundException(userId: Int) 
    : Exception("User with ID $userId not found")

// Validation exceptions
class ValidationException(val errors: Map<String, String>) 
    : Exception("Validation failed")
```

#### 8. Sealed Classes for State Management
```kotlin
sealed class UiState<out T> {
    object Idle : UiState<Nothing>()
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(
        val message: String,
        val code: Int? = null,
        val throwable: Throwable? = null
    ) : UiState<Nothing>()
}

// In ViewModel
private val _userState = MutableStateFlow<UiState<User>>(UiState.Idle)
val userState: StateFlow<UiState<User>> = _userState.asStateFlow()

fun loadUser(userId: Int) {
    viewModelScope.launch {
        _userState.value = UiState.Loading
        
        when (val result = repository.getUser(userId)) {
            is Result.Success -> {
                _userState.value = UiState.Success(result.data)
            }
            is Result.Error -> {
                _userState.value = UiState.Error(
                    message = result.exception.message ?: "Unknown error",
                    throwable = result.exception
                )
            }
        }
    }
}

// In Compose UI
when (val state = userState.collectAsState().value) {
    UiState.Idle -> { /* Initial state */ }
    UiState.Loading -> CircularProgressIndicator()
    is UiState.Success -> UserProfile(state.data)
    is UiState.Error -> ErrorMessage(state.message)
}
```

#### 9. Retry Logic
```kotlin
suspend fun <T> retryWithExponentialBackoff(
    times: Int = 3,
    initialDelay: Long = 1000,
    maxDelay: Long = 10000,
    factor: Double = 2.0,
    block: suspend () -> T
): T {
    var currentDelay = initialDelay
    
    repeat(times - 1) { attempt ->
        try {
            return block()
        } catch (e: Exception) {
            Log.w("Retry", "Attempt ${attempt + 1} failed: ${e.message}")
        }
        delay(currentDelay)
        currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)
    }
    
    return block() // Last attempt
}

// Usage
val users = retryWithExponentialBackoff {
    apiService.getUsers()
}
```

**Conditional Retry:**
```kotlin
suspend fun <T> retryIO(
    times: Int = 3,
    block: suspend () -> T
): T {
    repeat(times - 1) {
        try {
            return block()
        } catch (e: IOException) {
            // Retry only for network errors
            delay(1000)
        }
    }
    return block()
}
```

#### 10. Error Messages for Users
```kotlin
fun Throwable.toUserFriendlyMessage(): String {
    return when (this) {
        is HttpException -> when (code()) {
            400 -> "Invalid request. Please check your input."
            401 -> "Please log in again."
            403 -> "You don't have permission to access this."
            404 -> "The requested content was not found."
            500 -> "Server error. Please try again later."
            else -> "Something went wrong. Please try again."
        }
        is IOException -> "Network error. Please check your connection."
        is JsonSyntaxException -> "Invalid data format."
        else -> message ?: "An unexpected error occurred."
    }
}

// Usage
catch (e: Exception) {
    _errorMessage.value = e.toUserFriendlyMessage()
}
```

#### 11. Logging Errors
```kotlin
fun logError(tag: String, message: String, throwable: Throwable?) {
    if (BuildConfig.DEBUG) {
        Log.e(tag, message, throwable)
    }
    
    // Send to crash reporting in production
    // Firebase Crashlytics, Sentry, etc.
    // FirebaseCrashlytics.getInstance().recordException(throwable ?: Exception(message))
}

// Usage
catch (e: Exception) {
    logError("UserRepository", "Failed to load user", e)
}
```

#### 12. Error Handling in Repository Layer
```kotlin
class UserRepository(
    private val apiService: ApiService,
    private val userDao: UserDao
) {
    suspend fun getUser(userId: Int): Result<User> {
        return try {
            // Try to get from API
            val user = apiService.getUser(userId)
            
            // Cache to database
            userDao.insert(user)
            
            Result.Success(user)
        } catch (e: IOException) {
            // Network error - try local database
            try {
                val cachedUser = userDao.getUser(userId)
                if (cachedUser != null) {
                    Result.Success(cachedUser)
                } else {
                    Result.Error(NoInternetException())
                }
            } catch (dbError: Exception) {
                Result.Error(e)
            }
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
}
```

#### 13. Error Handling in ViewModel
```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UiState<User>>(UiState.Idle)
    val uiState: StateFlow<UiState<User>> = _uiState.asStateFlow()
    
    fun loadUser(userId: Int) {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            
            when (val result = repository.getUser(userId)) {
                is Result.Success -> {
                    _uiState.value = UiState.Success(result.data)
                }
                is Result.Error -> {
                    _uiState.value = UiState.Error(
                        message = result.exception.toUserFriendlyMessage()
                    )
                }
            }
        }
    }
    
    fun retry() {
        // Retry last operation
    }
}
```

#### 14. Global Error Handler (Optional)
```kotlin
class GlobalErrorHandler {
    companion object {
        fun handle(exception: Exception, context: Context) {
            when (exception) {
                is HttpException -> when (exception.code()) {
                    401 -> {
                        // Redirect to login
                        clearTokenAndNavigateToLogin(context)
                    }
                    503 -> {
                        // Show maintenance screen
                        showMaintenanceMessage(context)
                    }
                }
                is NoInternetException -> {
                    Toast.makeText(context, "No internet", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
}
```

#### 15. Production-Ready Error Handling
```kotlin
// Complete example
suspend fun <T> safeApiCall(
    onError: ((Exception) -> Unit)? = null,
    apiCall: suspend () -> T
): Result<T> {
    return try {
        Result.Success(apiCall())
    } catch (e: HttpException) {
        val error = when (e.code()) {
            401 -> Exception("Session expired. Please login again.")
            404 -> Exception("Resource not found.")
            422 -> Exception(parseErrorBody(e.response()?.errorBody()))
            in 500..599 -> Exception("Server error. Please try again later.")
            else -> Exception("Something went wrong.")
        }
        logError("API", "HTTP Error ${e.code()}", e)
        onError?.invoke(error)
        Result.Error(error)
    } catch (e: IOException) {
        val error = NoInternetException()
        logError("API", "Network error", e)
        onError?.invoke(error)
        Result.Error(error)
    } catch (e: Exception) {
        logError("API", "Unknown error", e)
        onError?.invoke(e)
        Result.Error(e)
    }
}
```

#### 16. Best Practices
✅ Always handle errors explicitly
✅ Use sealed classes untuk state
✅ Provide user-friendly error messages
✅ Log errors untuk debugging
✅ Implement retry logic where appropriate
✅ Cache data sebagai fallback
✅ Test error scenarios
✅ Handle edge cases (empty responses, null values)
✅ Use custom exceptions untuk better context
✅ Document error handling strategy

#### 17. Hands-on Exercises
- Implement Result wrapper
- Create custom exceptions
- Build error handling interceptor
- Implement retry logic
- Test different error scenarios
- Create error UI components
- Integration dengan Repository dan ViewModel

---
