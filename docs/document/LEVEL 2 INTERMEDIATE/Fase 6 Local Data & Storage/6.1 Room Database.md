## **6.1 Room Database** (1 minggu) ⭐⭐⭐

### **Teknologi Modern:**
- Room
- DAO
- Entity
- Database

### **Teknologi yang Ditinggalkan:**
- Raw SQLite

### **Sub-topik Detail:**

#### 1. Pengenalan Room Database
- Apa itu Room
- SQLite wrapper dengan compile-time verification
- Bagian dari Android Jetpack
- Keuntungan Room vs Raw SQLite
- Architecture Components integration
- Type safety & SQL validation

**Mengapa Room:**
✅ Compile-time SQL verification
✅ Less boilerplate code
✅ Observable queries (LiveData, Flow)
✅ Migration support
✅ Coroutines support
✅ Type converters

#### 2. Setup Room

**Dependencies:**
```kotlin
dependencies {
    // Room
    implementation("androidx.room:room-runtime:2.6.1")
    implementation("androidx.room:room-ktx:2.6.1")
    kapt("androidx.room:room-compiler:2.6.1")
    
    // Optional: Room testing
    testImplementation("androidx.room:room-testing:2.6.1")
    
    // Optional: Paging 3 Integration
    implementation("androidx.room:room-paging:2.6.1")
}

plugins {
    id("kotlin-kapt")
}
```

#### 3. Entity (Table Definition)

**Basic Entity:**
```kotlin
@Entity(tableName = "users")
data class User(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    
    @ColumnInfo(name = "user_name")
    val name: String,
    
    val email: String,
    
    val age: Int,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long = System.currentTimeMillis()
)
```

**Entity Annotations:**
```kotlin
@Entity(
    tableName = "posts",
    indices = [
        Index(value = ["user_id"]),
        Index(value = ["title", "created_at"])
    ],
    foreignKeys = [
        ForeignKey(
            entity = User::class,
            parentColumns = ["id"],
            childColumns = ["user_id"],
            onDelete = ForeignKey.CASCADE,
            onUpdate = ForeignKey.CASCADE
        )
    ]
)
data class Post(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    
    @ColumnInfo(name = "user_id")
    val userId: Long,
    
    val title: String,
    
    val content: String,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long = System.currentTimeMillis(),
    
    @Ignore
    val tempData: String? = null // Not stored in DB
)
```

**Composite Primary Key:**
```kotlin
@Entity(
    tableName = "user_post_cross_ref",
    primaryKeys = ["user_id", "post_id"]
)
data class UserPostCrossRef(
    @ColumnInfo(name = "user_id")
    val userId: Long,
    
    @ColumnInfo(name = "post_id")
    val postId: Long
)
```

#### 4. DAO (Data Access Object)

**Basic DAO:**
```kotlin
@Dao
interface UserDao {
    // Insert
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(user: User): Long
    
    @Insert
    suspend fun insertAll(users: List<User>)
    
    // Update
    @Update
    suspend fun update(user: User)
    
    // Delete
    @Delete
    suspend fun delete(user: User)
    
    @Query("DELETE FROM users WHERE id = :userId")
    suspend fun deleteById(userId: Long)
    
    @Query("DELETE FROM users")
    suspend fun deleteAll()
    
    // Query - Single item
    @Query("SELECT * FROM users WHERE id = :userId")
    suspend fun getUserById(userId: Long): User?
    
    @Query("SELECT * FROM users WHERE email = :email")
    suspend fun getUserByEmail(email: String): User?
    
    // Query - List
    @Query("SELECT * FROM users")
    suspend fun getAllUsers(): List<User>
    
    @Query("SELECT * FROM users WHERE age >= :minAge")
    suspend fun getUsersOlderThan(minAge: Int): List<User>
    
    @Query("SELECT * FROM users ORDER BY created_at DESC LIMIT :limit")
    suspend fun getRecentUsers(limit: Int): List<User>
}
```

**DAO with Flow (Reactive):**
```kotlin
@Dao
interface UserDao {
    // Observe single item
    @Query("SELECT * FROM users WHERE id = :userId")
    fun getUserByIdFlow(userId: Long): Flow<User?>
    
    // Observe list
    @Query("SELECT * FROM users ORDER BY name ASC")
    fun getAllUsersFlow(): Flow<List<User>>
    
    // Observe count
    @Query("SELECT COUNT(*) FROM users")
    fun getUserCount(): Flow<Int>
    
    // Complex query with Flow
    @Query("""
        SELECT * FROM users 
        WHERE name LIKE '%' || :searchQuery || '%' 
        ORDER BY created_at DESC
    """)
    fun searchUsers(searchQuery: String): Flow<List<User>>
}
```

**DAO with LiveData:**
```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAllUsersLiveData(): LiveData<List<User>>
    
    @Query("SELECT * FROM users WHERE id = :userId")
    fun getUserByIdLiveData(userId: Long): LiveData<User?>
}
```

**Complex Queries:**
```kotlin
@Dao
interface PostDao {
    // JOIN query
    @Query("""
        SELECT posts.* FROM posts
        INNER JOIN users ON posts.user_id = users.id
        WHERE users.name = :userName
    """)
    fun getPostsByUserName(userName: String): Flow<List<Post>>
    
    // Aggregate functions
    @Query("SELECT COUNT(*) FROM posts WHERE user_id = :userId")
    suspend fun getPostCountByUser(userId: Long): Int
    
    @Query("SELECT AVG(LENGTH(content)) FROM posts")
    suspend fun getAveragePostLength(): Double
    
    // Grouping
    @Query("""
        SELECT user_id, COUNT(*) as post_count 
        FROM posts 
        GROUP BY user_id
    """)
    suspend fun getPostCountPerUser(): List<UserPostCount>
    
    // LIKE search
    @Query("SELECT * FROM posts WHERE title LIKE '%' || :keyword || '%'")
    fun searchPosts(keyword: String): Flow<List<Post>>
    
    // IN clause
    @Query("SELECT * FROM posts WHERE id IN (:postIds)")
    suspend fun getPostsByIds(postIds: List<Long>): List<Post>
    
    // Date range
    @Query("""
        SELECT * FROM posts 
        WHERE created_at BETWEEN :startDate AND :endDate
        ORDER BY created_at DESC
    """)
    suspend fun getPostsInDateRange(startDate: Long, endDate: Long): List<Post>
}
```

**Transactions:**
```kotlin
@Dao
interface UserDao {
    @Transaction
    suspend fun updateUserAndPosts(user: User, posts: List<Post>) {
        update(user)
        posts.forEach { post ->
            postDao.update(post)
        }
    }
    
    @Transaction
    @Query("SELECT * FROM users WHERE id = :userId")
    suspend fun getUserWithPosts(userId: Long): UserWithPosts
}
```

#### 5. Database Class

**Database Definition:**
```kotlin
@Database(
    entities = [
        User::class,
        Post::class,
        Comment::class
    ],
    version = 1,
    exportSchema = true
)
@TypeConverters(Converters::class)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
    abstract fun postDao(): PostDao
    abstract fun commentDao(): CommentDao
    
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        
        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_database"
                )
                    .fallbackToDestructiveMigration() // For development
                    .build()
                INSTANCE = instance
                instance
            }
        }
    }
}
```

**With Hilt:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "app_database"
        ).build()
    }
    
    @Provides
    fun provideUserDao(database: AppDatabase): UserDao {
        return database.userDao()
    }
    
    @Provides
    fun providePostDao(database: AppDatabase): PostDao {
        return database.postDao()
    }
}
```

#### 6. Type Converters

**For Complex Types:**
```kotlin
class Converters {
    // Date conversion
    @TypeConverter
    fun fromTimestamp(value: Long?): Date? {
        return value?.let { Date(it) }
    }
    
    @TypeConverter
    fun dateToTimestamp(date: Date?): Long? {
        return date?.time
    }
    
    // List conversion
    @TypeConverter
    fun fromStringList(value: String?): List<String>? {
        return value?.split(",")?.map { it.trim() }
    }
    
    @TypeConverter
    fun toStringList(list: List<String>?): String? {
        return list?.joinToString(",")
    }
    
    // JSON conversion
    @TypeConverter
    fun fromJson(value: String?): Address? {
        return value?.let { Gson().fromJson(it, Address::class.java) }
    }
    
    @TypeConverter
    fun toJson(address: Address?): String? {
        return Gson().toJson(address)
    }
}

// Use in Entity
@Entity(tableName = "users")
data class User(
    @PrimaryKey val id: Long,
    val name: String,
    val tags: List<String>, // Converted automatically
    val address: Address,   // Converted automatically
    val createdAt: Date     // Converted automatically
)
```

#### 7. Relationships

**One-to-Many:**
```kotlin
// Parent entity
@Entity(tableName = "users")
data class User(
    @PrimaryKey val id: Long,
    val name: String
)

// Child entity
@Entity(
    tableName = "posts",
    foreignKeys = [
        ForeignKey(
            entity = User::class,
            parentColumns = ["id"],
            childColumns = ["user_id"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class Post(
    @PrimaryKey val id: Long,
    @ColumnInfo(name = "user_id") val userId: Long,
    val title: String
)

// Relation class
data class UserWithPosts(
    @Embedded val user: User,
    @Relation(
        parentColumn = "id",
        entityColumn = "user_id"
    )
    val posts: List<Post>
)

// Query
@Dao
interface UserDao {
    @Transaction
    @Query("SELECT * FROM users WHERE id = :userId")
    suspend fun getUserWithPosts(userId: Long): UserWithPosts
    
    @Transaction
    @Query("SELECT * FROM users")
    fun getAllUsersWithPosts(): Flow<List<UserWithPosts>>
}
```

**Many-to-Many:**
```kotlin
// Entity 1
@Entity(tableName = "students")
data class Student(
    @PrimaryKey val id: Long,
    val name: String
)

// Entity 2
@Entity(tableName = "courses")
data class Course(
    @PrimaryKey val id: Long,
    val title: String
)

// Junction table
@Entity(
    tableName = "student_course_cross_ref",
    primaryKeys = ["student_id", "course_id"],
    foreignKeys = [
        ForeignKey(
            entity = Student::class,
            parentColumns = ["id"],
            childColumns = ["student_id"]
        ),
        ForeignKey(
            entity = Course::class,
            parentColumns = ["id"],
            childColumns = ["course_id"]
        )
    ]
)
data class StudentCourseCrossRef(
    @ColumnInfo(name = "student_id") val studentId: Long,
    @ColumnInfo(name = "course_id") val courseId: Long
)

// Relations
data class StudentWithCourses(
    @Embedded val student: Student,
    @Relation(
        parentColumn = "id",
        entityColumn = "id",
        associateBy = Junction(
            value = StudentCourseCrossRef::class,
            parentColumn = "student_id",
            entityColumn = "course_id"
        )
    )
    val courses: List<Course>
)

data class CourseWithStudents(
    @Embedded val course: Course,
    @Relation(
        parentColumn = "id",
        entityColumn = "id",
        associateBy = Junction(
            value = StudentCourseCrossRef::class,
            parentColumn = "course_id",
            entityColumn = "student_id"
        )
    )
    val students: List<Student>
)

// DAO
@Dao
interface StudentDao {
    @Transaction
    @Query("SELECT * FROM students WHERE id = :studentId")
    suspend fun getStudentWithCourses(studentId: Long): StudentWithCourses
    
    @Insert
    suspend fun enrollStudentInCourse(crossRef: StudentCourseCrossRef)
    
    @Delete
    suspend fun unenrollStudentFromCourse(crossRef: StudentCourseCrossRef)
}
```

**Nested Relations:**
```kotlin
data class UserWithPostsAndComments(
    @Embedded val user: User,
    @Relation(
        entity = Post::class,
        parentColumn = "id",
        entityColumn = "user_id"
    )
    val posts: List<PostWithComments>
)

data class PostWithComments(
    @Embedded val post: Post,
    @Relation(
        parentColumn = "id",
        entityColumn = "post_id"
    )
    val comments: List<Comment>
)
```

#### 8. Database Migration

**Version 1 to 2:**
```kotlin
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Add new column
        database.execSQL("ALTER TABLE users ADD COLUMN phone TEXT")
    }
}

val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Create new table
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS profiles (
                id INTEGER PRIMARY KEY NOT NULL,
                user_id INTEGER NOT NULL,
                bio TEXT,
                FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE
            )
        """)
        
        // Create index
        database.execSQL("CREATE INDEX index_profiles_user_id ON profiles(user_id)")
    }
}

// Apply migrations
Room.databaseBuilder(context, AppDatabase::class.java, "app_database")
    .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
    .build()
```

**Complex Migration:**
```kotlin
val MIGRATION_3_4 = object : Migration(3, 4) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Rename table (SQLite doesn't support RENAME COLUMN)
        
        // 1. Create new table with correct schema
        database.execSQL("""
            CREATE TABLE users_new (
                id INTEGER PRIMARY KEY NOT NULL,
                full_name TEXT NOT NULL,
                email TEXT NOT NULL
            )
        """)
        
        // 2. Copy data from old table
        database.execSQL("""
            INSERT INTO users_new (id, full_name, email)
            SELECT id, name, email FROM users
        """)
        
        // 3. Drop old table
        database.execSQL("DROP TABLE users")
        
        // 4. Rename new table
        database.execSQL("ALTER TABLE users_new RENAME TO users")
    }
}
```

#### 9. Testing Room Database

**In-Memory Database for Tests:**
```kotlin
@RunWith(AndroidJUnit4::class)
class UserDaoTest {
    private lateinit var database: AppDatabase
    private lateinit var userDao: UserDao
    
    @Before
    fun setup() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        database = Room.inMemoryDatabaseBuilder(
            context,
            AppDatabase::class.java
        ).build()
        userDao = database.userDao()
    }
    
    @After
    fun teardown() {
        database.close()
    }
    
    @Test
    fun insertAndGetUser() = runTest {
        // Given
        val user = User(id = 1, name = "John Doe", email = "john@example.com", age = 30)
        
        // When
        userDao.insert(user)
        val retrieved = userDao.getUserById(1)
        
        // Then
        assertEquals(user, retrieved)
    }
    
    @Test
    fun updateUser() = runTest {
        // Given
        val user = User(id = 1, name = "John Doe", email = "john@example.com", age = 30)
        userDao.insert(user)
        
        // When
        val updated = user.copy(name = "Jane Doe")
        userDao.update(updated)
        val retrieved = userDao.getUserById(1)
        
        // Then
        assertEquals("Jane Doe", retrieved?.name)
    }
    
    @Test
    fun deleteUser() = runTest {
        // Given
        val user = User(id = 1, name = "John Doe", email = "john@example.com", age = 30)
        userDao.insert(user)
        
        // When
        userDao.delete(user)
        val retrieved = userDao.getUserById(1)
        
        // Then
        assertNull(retrieved)
    }
    
    @Test
    fun queryUsersFlow() = runTest {
        // Given
        val users = listOf(
            User(id = 1, name = "John", email = "john@example.com", age = 30),
            User(id = 2, name = "Jane", email = "jane@example.com", age = 25)
        )
        userDao.insertAll(users)
        
        // When & Then
        userDao.getAllUsersFlow().test {
            val result = awaitItem()
            assertEquals(2, result.size)
            assertEquals("John", result[0].name)
        }
    }
}
```

#### 10. Best Practices
✅ Use Flow for reactive queries
✅ Use suspend functions untuk one-shot operations
✅ Always use @Transaction untuk multiple operations
✅ Index frequently queried columns
✅ Use foreign keys untuk data integrity
✅ Implement proper migrations
✅ Test database operations
✅ Use Type Converters untuk complex types
✅ Avoid blocking main thread
✅ Use proper relationship annotations

#### 11. Performance Optimization
```kotlin
// Use indices
@Entity(
    tableName = "users",
    indices = [
        Index(value = ["email"], unique = true),
        Index(value = ["created_at"]),
        Index(value = ["name", "age"])
    ]
)
data class User(...)

// Pagination untuk large datasets
@Query("SELECT * FROM posts ORDER BY created_at DESC LIMIT :limit OFFSET :offset")
suspend fun getPostsPaginated(limit: Int, offset: Int): List<Post>

// Use projection untuk select specific columns
data class UserNameAndEmail(
    val name: String,
    val email: String
)

@Query("SELECT name, email FROM users")
suspend fun getUserNamesAndEmails(): List<UserNameAndEmail>
```

#### 12. Hands-on Exercises
- Create database dengan multiple entities
- Implement all CRUD operations
- Setup relationships (one-to-many, many-to-many)
- Write complex queries
- Implement migrations
- Write unit tests
- Performance optimization dengan indices
- Type converters untuk custom types

---
