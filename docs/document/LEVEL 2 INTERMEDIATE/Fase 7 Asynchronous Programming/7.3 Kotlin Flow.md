## **7.3 Kotlin Flow** (1 minggu) ⭐⭐⭐

### **Teknologi Modern:**
- Flow
- StateFlow
- SharedFlow
- Operators (map, filter, combine)

### **Teknologi yang Ditinggalkan:**
- LiveData (masih digunakan tapi Flow lebih powerful)
- RxJava Observables

### **Sub-topik Detail:**

#### **1. Pengenalan Kotlin Flow**
- Apa itu Flow
- Cold streams vs Hot streams
- Flow vs LiveData vs RxJava
- Asynchronous stream of data
- Built on top of coroutines
- Type-safe & null-safe

**Mengapa Flow:**
✅ Reactive streams dengan coroutines
✅ Powerful operators
✅ Cold by default (lazy)
✅ Cancellation support
✅ Exception handling
✅ Backpressure handling
✅ Testing support

#### **2. Creating Flows**

**flow Builder:**
```kotlin
fun simple(): Flow<Int> = flow {
    for (i in 1..3) {
        delay(1000) // Simulate async work
        emit(i) // Emit value
    }
}

// Usage
lifecycleScope.launch {
    simple().collect { value ->
        println("Received: $value")
    }
}
```

**flowOf:**
```kotlin
val numbersFlow: Flow<Int> = flowOf(1, 2, 3, 4, 5)

lifecycleScope.launch {
    numbersFlow.collect { 
        println(it)
    }
}
```

**asFlow:**
```kotlin
// From List
val listFlow: Flow<String> = listOf("A", "B", "C").asFlow()

// From Range
val rangeFlow: Flow<Int> = (1..10).asFlow()

// From Sequence
val sequenceFlow = generateSequence(1) { it + 1 }.asFlow()
```

**channelFlow:**
```kotlin
fun numbers(): Flow<Int> = channelFlow {
    repeat(3) { i ->
        delay(1000)
        send(i) // Use send instead of emit
    }
}
```

**callbackFlow (untuk callback-based APIs):**
```kotlin
fun locationUpdates(context: Context): Flow<Location> = callbackFlow {
    val locationManager = context.getSystemService<LocationManager>()!!
    
    val callback = object : LocationListener {
        override fun onLocationChanged(location: Location) {
            trySend(location) // Send location updates
        }
        
        override fun onProviderEnabled(provider: String) {}
        override fun onProviderDisabled(provider: String) {}
    }
    
    locationManager.requestLocationUpdates(
        LocationManager.GPS_PROVIDER,
        1000,
        0f,
        callback
    )
    
    awaitClose {
        // Cleanup when flow is cancelled
        locationManager.removeUpdates(callback)
    }
}
```

#### **3. Flow Operators**

**Transformation Operators:**
```kotlin
// map
val doubledFlow = (1..5).asFlow()
    .map { it * 2 }

// transform (emit multiple values)
val transformedFlow = (1..3).asFlow()
    .transform { value ->
        emit("Start $value")
        delay(100)
        emit("End $value")
    }

// mapNotNull
val validatedFlow = userInputFlow
    .mapNotNull { input ->
        if (input.isValid()) input.clean() else null
    }
```

**Filtering Operators:**
```kotlin
// filter
val evenNumbers = (1..10).asFlow()
    .filter { it % 2 == 0 }

// filterNot
val oddNumbers = (1..10).asFlow()
    .filterNot { it % 2 == 0 }

// filterNotNull
val nonNullFlow = flowWithNulls
    .filterNotNull()

// distinctUntilChanged
val uniqueFlow = flow {
    emit(1)
    emit(1)
    emit(2)
    emit(2)
    emit(1)
}.distinctUntilChanged() // Emits: 1, 2, 1

// debounce (untuk search)
val searchFlow = searchQueryFlow
    .debounce(300) // Wait 300ms after last emission
    .filter { it.length >= 3 }
```

**Combining Flows:**
```kotlin
// combine (latest values from both)
val combined = combine(
    userFlow,
    settingsFlow
) { user, settings ->
    UserProfile(user, settings)
}

// zip (pair values in order)
val zipped = userNamesFlow.zip(userAgesFlow) { name, age ->
    User(name, age)
}

// flatMapConcat (sequential)
val ordersFlow = userIdFlow
    .flatMapConcat { userId ->
        getOrdersForUser(userId)
    }

// flatMapMerge (concurrent)
val allOrdersFlow = userIdsFlow
    .flatMapMerge { userId ->
        getOrdersForUser(userId)
    }

// flatMapLatest (cancel previous)
val searchResultsFlow = searchQueryFlow
    .flatMapLatest { query ->
        searchRepository.search(query)
    }
```

**Size Operators:**
```kotlin
// take
val firstThree = numbersFlow.take(3)

// drop
val afterFirst Two = numbersFlow.drop(2)

// takeWhile
val lessThanFive = numbersFlow.takeWhile { it < 5 }

// dropWhile
val afterFirstNegative = numbersFlow.dropWhile { it >= 0 }
```

**Collection Operators:**
```kotlin
// toList
val list = numbersFlow.toList()

// toSet
val set = numbersFlow.toSet()

// first
val firstValue = numbersFlow.first()

// firstOrNull
val maybeFirst = numbersFlow.firstOrNull()

// single (expects exactly one)
val singleValue = singleFlow.single()

// reduce
val sum = numbersFlow.reduce { acc, value -> acc + value }

// fold
val sumWithInitial = numbersFlow.fold(0) { acc, value -> acc + value }
```

#### **4. StateFlow**

**Creating StateFlow:**
```kotlin
class CounterViewModel : ViewModel() {
    private val _counter = MutableStateFlow(0)
    val counter: StateFlow<Int> = _counter.asStateFlow()
    
    fun increment() {
        _counter.value += 1
    }
    
    fun decrement() {
        _counter.update { it - 1 } // Safer for concurrent updates
    }
}
```

**Collecting StateFlow:**
```kotlin
class MainActivity : AppCompatActivity() {
    private val viewModel: CounterViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.counter.collect { count ->
                    textView.text = count.toString()
                }
            }
        }
    }
}
```

**Compose with StateFlow:**
```kotlin
@Composable
fun CounterScreen(viewModel: CounterViewModel = viewModel()) {
    val count by viewModel.counter.collectAsState()
    
    Column {
        Text("Count: $count")
        Button(onClick = { viewModel.increment() }) {
            Text("Increment")
        }
    }
}
```

**Complex State:**
```kotlin
data class UiState(
    val isLoading: Boolean = false,
    val data: List<Item> = emptyList(),
    val error: String? = null
)

class ItemsViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState.asStateFlow()
    
    fun loadItems() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }
            
            try {
                val items = repository.getItems()
                _uiState.update { 
                    it.copy(isLoading = false, data = items)
                }
            } catch (e: Exception) {
                _uiState.update {
                    it.copy(isLoading = false, error = e.message)
                }
            }
        }
    }
}
```

#### **5. SharedFlow**

**Creating SharedFlow:**
```kotlin
class EventBus {
    private val _events = MutableSharedFlow<Event>()
    val events: SharedFlow<Event> = _events.asSharedFlow()
    
    suspend fun postEvent(event: Event) {
        _events.emit(event)
    }
}
```

**SharedFlow with Replay:**
```kotlin
class NotificationManager {
    // Keep last 3 notifications
    private val _notifications = MutableSharedFlow<Notification>(
        replay = 3,
        onBufferOverflow = BufferOverflow.DROP_OLDEST
    )
    val notifications: SharedFlow<Notification> = _notifications.asSharedFlow()
    
    suspend fun notify(notification: Notification) {
        _notifications.emit(notification)
    }
}
```

**One-Time Events:**
```kotlin
sealed class UiEvent {
    data class ShowToast(val message: String) : UiEvent()
    data class Navigate(val route: String) : UiEvent()
    object ShowLoading : UiEvent()
}

class MyViewModel : ViewModel() {
    private val _events = MutableSharedFlow<UiEvent>()
    val events: SharedFlow<UiEvent> = _events.asSharedFlow()
    
    fun onButtonClick() {
        viewModelScope.launch {
            _events.emit(UiEvent.ShowToast("Button clicked"))
        }
    }
}

// In Activity/Fragment
lifecycleScope.launch {
    repeatOnLifecycle(Lifecycle.State.STARTED) {
        viewModel.events.collect { event ->
            when (event) {
                is UiEvent.ShowToast -> showToast(event.message)
                is UiEvent.Navigate -> navigate(event.route)
                UiEvent.ShowLoading -> showLoading()
            }
        }
    }
}
```

#### **6. Flow Context & Dispatchers**

**flowOn:**
```kotlin
fun loadData(): Flow<Data> = flow {
    // This runs on IO dispatcher
    val data = database.getData()
    emit(data)
}.flowOn(Dispatchers.IO)

// Collect on Main
lifecycleScope.launch {
    loadData().collect { data ->
        // This runs on Main
        updateUI(data)
    }
}
```

**Multiple flowOn:**
```kotlin
fun processData(): Flow<Result> = flow {
    emit(fetchFromNetwork())
}
    .map { processData(it) }
    .flowOn(Dispatchers.Default) // Processing on Default
    .flowOn(Dispatchers.IO) // Network on IO
```

#### **7. Exception Handling**

**catch Operator:**
```kotlin
fun loadData(): Flow<Data> = flow {
    emit(repository.getData())
}.catch { exception ->
    // Handle exception
    emit(Data.empty())
    // Or re-throw
    // throw exception
}

// Usage
loadData()
    .catch { e -> 
        println("Error: ${e.message}")
    }
    .collect { data ->
        updateUI(data)
    }
```

**try-catch in collect:**
```kotlin
lifecycleScope.launch {
    try {
        dataFlow.collect { data ->
            updateUI(data)
        }
    } catch (e: Exception) {
        showError(e)
    }
}
```

**retry:**
```kotlin
fun loadData(): Flow<Data> = flow {
    emit(repository.getData())
}.retry(retries = 3) { cause ->
    // Retry on IOException only
    cause is IOException
}

// With delay
fun loadDataWithRetry(): Flow<Data> = flow {
    emit(repository.getData())
}.retryWhen { cause, attempt ->
    if (cause is IOException && attempt < 3) {
        delay(1000 * attempt) // Exponential backoff
        true
    } else {
        false
    }
}
```

#### **8. Flow Lifecycle**

**onStart:**
```kotlin
dataFlow
    .onStart {
        emit(LoadingState)
        println("Flow started")
    }
    .collect { data ->
        println("Data: $data")
    }
```

**onCompletion:**
```kotlin
dataFlow
    .onCompletion { cause ->
        if (cause == null) {
            println("Flow completed successfully")
        } else {
            println("Flow completed with error: $cause")
        }
    }
    .collect { data ->
        println("Data: $data")
    }
```

**onEach:**
```kotlin
dataFlow
    .onEach { data ->
        println("About to emit: $data")
    }
    .collect { data ->
        updateUI(data)
    }
```

#### **9. Buffering & Conflation**

**buffer:**
```kotlin
// Producer faster than consumer
flow {
    repeat(10) {
        emit(it)
        delay(100) // Produce every 100ms
    }
}
    .buffer() // Buffer emissions
    .collect { value ->
        delay(300) // Consume every 300ms
        println(value)
    }
```

**conflate:**
```kotlin
// Keep only latest value
flow {
    repeat(10) {
        emit(it)
        delay(100)
    }
}
    .conflate() // Skip intermediate values
    .collect { value ->
        delay(300)
        println(value) // Prints: 0, 3, 6, 9
    }
```

**collectLatest:**
```kotlin
// Cancel previous collection
searchQueryFlow
    .collectLatest { query ->
        // Cancel previous search
        searchRepository.search(query)
    }
```

#### **10. Testing Flows**

**Test Flow Emissions:**
```kotlin
@Test
fun `test flow emissions`() = runTest {
    val flow = flow {
        emit(1)
        emit(2)
        emit(3)
    }
    
    val results = flow.toList()
    assertEquals(listOf(1, 2, 3), results)
}
```

**Test with Turbine:**
```kotlin
@Test
fun `test user flow with turbine`() = runTest {
    repository.getUserFlow("123").test {
        assertEquals(UiState.Loading, awaitItem())
        assertEquals(UiState.Success(user), awaitItem())
        awaitComplete()
    }
}
```

**Test StateFlow:**
```kotlin
@Test
fun `test counter increment`() = runTest {
    val viewModel = CounterViewModel()
    
    assertEquals(0, viewModel.counter.value)
    
    viewModel.increment()
    assertEquals(1, viewModel.counter.value)
    
    viewModel.increment()
    assertEquals(2, viewModel.counter.value)
}
```

#### **11. Best Practices**
✅ Use StateFlow untuk state management
✅ Use SharedFlow untuk events
✅ Use flowOn untuk specify context
✅ Handle exceptions dengan catch
✅ Use conflate/collectLatest untuk fast producers
✅ Collect dalam repeatOnLifecycle
✅ Test flows dengan runTest
✅ Use cold flows untuk one-shot operations
✅ Avoid creating flows in composables
✅ Cancel flows properly

#### **12. Common Patterns**

**Search Pattern:**
```kotlin
class SearchViewModel : ViewModel() {
    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()
    
    val searchResults: StateFlow<List<Item>> = searchQuery
        .debounce(300)
        .filter { it.length >= 3 }
        .flatMapLatest { query ->
            repository.search(query)
                .catch { emit(emptyList()) }
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
    
    fun onSearchQueryChanged(query: String) {
        _searchQuery.value = query
    }
}
```

**Repository Pattern:**
```kotlin
class ProductRepository(
    private val api: ApiService,
    private val dao: ProductDao
) {
    fun getProducts(): Flow<List<Product>> = flow {
        // Emit cached data first
        emit(dao.getAllProducts())
        
        // Then fetch fresh data
        val fresh = api.getProducts()
        dao.insertAll(fresh)
        emit(fresh)
    }.catch { e ->
        // On error, emit cached data
        emit(dao.getAllProducts())
    }
    
    fun getProduct(id: String): Flow<Product> = flow {
        val cached = dao.getProduct(id)
        if (cached != null) {
            emit(cached)
        }
        
        val fresh = api.getProduct(id)
        dao.insert(fresh)
        emit(fresh)
    }
}
```

**Combining Multiple Sources:**
```kotlin
class DashboardViewModel : ViewModel() {
    val dashboardData: StateFlow<DashboardData> = combine(
        userRepository.getCurrentUser(),
        statsRepository.getStats(),
        notificationRepository.getUnreadCount()
    ) { user, stats, unreadCount ->
        DashboardData(user, stats, unreadCount)
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = DashboardData.Loading
    )
}
```

#### **13. Hands-on Exercises**
- Buat search feature dengan debounce
- Implement StateFlow untuk state management
- Create event handling dengan SharedFlow
- Build repository dengan Flow
- Implement retry logic
- Handle errors dengan catch operator
- Test flows dengan Turbine
- Create combining flows pattern
- Implement pagination dengan Flow

---
