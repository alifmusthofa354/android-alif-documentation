# üõ°Ô∏è Panduan Lengkap: SOLID Principles di Android

## üöÄ Pengantar: Dasar-dasar Kode yang Kuat dan Fleksibel

Bayangkan kamu adalah seorang arsitek perangkat lunak üèóÔ∏è:
- **SOLID Principles** seperti aturan emas dalam arsitektur perangkat lunak
- **Kelas dan fungsi** seperti komponen bangunan yang harus kokoh
- **Abstraksi dan interfaces** seperti sistem modular dalam konstruksi

Dengan memahami SOLID Principles, kamu bisa membangun aplikasi Android yang kuat, fleksibel, dan mudah dipelihara!

## üìö Daftar Isi Pembelajaran
1. [üåü Pengenalan SOLID Principles](#1Ô∏è‚É£-pengenalan-solid-principles-üåü)
2. [üß© Single Responsibility Principle (SRP)](#2Ô∏è‚É£-single-responsibility-principle-srp-üß©)
3. [üîì Open/Closed Principle (OCP)](#3Ô∏è‚É£-openclosed-principle-ocp-üîì)
4. [üîÑ Liskov Substitution Principle (LSP)](#4Ô∏è‚É£-liskov-substitution-principle-lsp-üîÑ)
5. [üìè Interface Segregation Principle (ISP)](#5Ô∏è‚É£-interface-segregation-principle-isp-üìè)
6. [üîÑ Dependency Inversion Principle (DIP)](#6Ô∏è‚É£-dependency-inversion-principle-dip-üîÑ)
7. [üèóÔ∏è SOLID dalam Android Architecture](#7Ô∏è‚É£-solid-dalam-android-architecture-üèóÔ∏è)
8. [üîß Code Refactoring dengan SOLID](#8Ô∏è‚É£-code-refactoring-dengan-solid-üîß)
9. [üéØ SOLID dan Design Patterns](#9Ô∏è‚É£-solid-dan-design-patterns-üéØ)
10. [üß™ Testing Benefits](#1Ô∏è‚É£0Ô∏è‚É£-testing-benefits-üß™)
11. [‚ö†Ô∏è Common Pitfalls](#1Ô∏è‚É£1Ô∏è‚É£-common-pitfalls-‚ö†Ô∏è)
12. [‚ú® Practical Guidelines](#1Ô∏è‚É£2Ô∏è‚É£-practical-guidelines-‚ú®)
13. [üî® Hands-on Exercises](#1Ô∏è‚É£3Ô∏è‚É£-hands-on-exercises-üî®)
14. [üéØ Kesimpulan](#üéØ-kesimpulan)

---

## 1Ô∏è‚É£ Pengenalan SOLID Principles üåü

### Konsep Dasar
SOLID Principles seperti kode etik para programmer profesional üë®‚Äçüíª - serangkaian prinsip yang memastikan kode kita tetap sehat dan mudah dipelihara seiring waktu!

### Pengenalan SOLID by Uncle Bob:
SOLID adalah akronim dari lima prinsip dasar dalam pemrograman berorientasi objek yang diperkenalkan oleh **Robert C. Martin (Uncle Bob)**:

- **S** - Single Responsibility Principle
- **O** - Open/Closed Principle  
- **L** - Liskov Substitution Principle
- **I** - Interface Segregation Principle
- **D** - Dependency Inversion Principle

### Mengapa SOLID Penting:
1. **Mudah Dipelihara**: Kode lebih mudah diubah tanpa rusak
2. **Mudah Diuji**: Unit test lebih mudah dibuat dan dijalankan
3. **Mudah Dipahami**: Struktur kode lebih jelas dan logis
4. **Mudah Diperluas**: Fitur baru bisa ditambahkan tanpa merusak yang ada
5. **Kualitas Kode Tinggi**: Mengurangi bug dan meningkatkan keandalan

### SOLID dan Clean Code:
```
SOLID ‚Üí Clean Code ‚Üí Better Software
  ‚Üì         ‚Üì           ‚Üì
Tata aturan  Kode bersih  Aplikasi baik
```

### SOLID dalam Pemrograman Berorientasi Objek:
- **Encapsulation**: Menyembunyikan detail implementasi
- **Inheritance**: Pewarisan sifat dan perilaku
- **Polymorphism**: Banyak bentuk dari satu interface
- **Abstraction**: Menyembunyikan kompleksitas

### SOLID di Kotlin/Android:
```kotlin
// SOLID principles bekerja dengan baik di Kotlin karena:
// 1. Extension functions untuk menambah perilaku
// 2. Data classes untuk representasi data
// 3. Sealed classes untuk hierarki terbatas
// 4. Interface dengan default implementation
// 5. Null safety untuk menghindari NullPointerException
```

### Code Quality dan Maintainability:
SOLID membantu mengatasi **masalah-masalah umum dalam pengembangan software**:
- **God Classes**: Kelas yang terlalu besar dan kompleks
- **Tight Coupling**: Ketergantungan antar komponen yang terlalu erat
- **Rigid Code**: Kode yang susah diubah
- **Fragile Code**: Kode yang mudah rusak saat diubah

### Implementasi Sederhana:

**domain/usecase/SimpleUseCase.kt**
```kotlin
package com.example.solidprinciples.domain.usecase

import com.example.solidprinciples.domain.model.User
import com.example.solidprinciples.domain.repository.UserRepository

/**
 * Contoh implementasi sederhana dari SOLID principles
 * di dalam sebuah Use Case
 */
class GetUserUseCase(
    private val repository: UserRepository
) {
    /**
     * Single Responsibility: hanya satu tanggung jawab
     * - Mendapatkan user berdasarkan ID
     */
    suspend operator fun invoke(userId: String): User? {
        return repository.getUserById(userId)
    }
}
```

**domain/repository/UserRepository.kt**
```kotlin
package com.example.solidprinciples.domain.repository

import com.example.solidprinciples.domain.model.User

/**
 * Interface yang menerapkan ISP (Interface Segregation Principle)
 * - Fokus pada satu tanggung jawab: manajemen data user
 */
interface UserRepository {
    suspend fun getUserById(id: String): User?
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
}
```

### üéì Penjelasan Konsep:
**SOLID seperti Aturan Dasar Bangunan:**
- **Sama seperti arsitek punya aturan konstruksi**, programmer punya SOLID
- **Membangun pondasi yang kuat** untuk aplikasi yang tahan lama
- **Mudah direnovasi dan diperluas** tanpa harus membongkar semuanya

**Keunggulan SOLID:**
- **Modular**: Setiap bagian punya tanggung jawab sendiri
- **Testable**: Bisa diuji secara terpisah
- **Maintainable**: Mudah dipelihara dan diubah
- **Extensible**: Mudah ditambah fitur baru

---

## 2Ô∏è‚É£ Single Responsibility Principle (SRP) üß©

### Konsep Dasar
Single Responsibility Principle seperti spesialisasi pekerjaan üß∞ - satu orang hanya satu tugas penting!

### Definisi SRP:
> Sebuah kelas seharusnya hanya memiliki **satu alasan untuk berubah**.
> Atau dengan kata lain, **satu kelas hanya memiliki satu tanggung jawab**.

### Prinsip Inti:
- **High Cohesion**: Semua method dan property dalam kelas memiliki hubungan erat
- **Low Coupling**: Tidak bergantung pada banyak hal lain
- **Focused Purpose**: Mengerjakan satu hal dan mengerjakannya dengan baik

### Contoh Android - Violation vs Compliant:

**‚ùå BAD: Multiple Responsibilities (God Class)**
```kotlin
package com.example.solidprinciples.bad

import android.util.Log
import java.io.File
import java.io.FileWriter

/**
 * God Class - melanggar SRP
 * Punya terlalu banyak tanggung jawab
 */
class UserManager {
    
    // Tanggung jawab 1: Login user
    fun loginUser(username: String, password: String): Boolean {
        // Validasi credentials
        if (username.isBlank() || password.isBlank()) {
            return false
        }
        
        // Simulasi login
        Log.d("UserManager", "Logging in user: $username")
        return true
    }
    
    // Tanggung jawab 2: Simpan data ke database
    fun saveUserToDatabase(userData: String) {
        // Simulasi simpan ke database
        Log.d("UserManager", "Saving to database: $userData")
    }
    
    // Tanggung jawab 3: Kirim analytics
    fun sendAnalyticsEvent(event: String) {
        // Simulasi kirim analytics
        Log.d("UserManager", "Sending analytics: $event")
    }
    
    // Tanggung jawab 4: Simpan log ke file
    fun logToFile(message: String) {
        // Simulasi simpan log ke file
        val file = File("app.log")
        FileWriter(file, true).use { writer ->
            writer.write("$message\n")
        }
    }
    
    // Tanggung jawab 5: Validasi format data
    fun validateEmail(email: String): Boolean {
        return email.contains("@") && email.contains(".")
    }
}
```

**‚úÖ GOOD: Single Responsibility**
```kotlin
package com.example.solidprinciples.good

import android.util.Log
import java.io.File
import java.io.FileWriter

/**
 * 1. Login Use Case - hanya fokus pada login
 */
class LoginUseCase {
    fun execute(username: String, password: String): LoginResult {
        if (username.isBlank() || password.isBlank()) {
            return LoginResult.Failure("Credentials cannot be blank")
        }
        
        // Simulasi validasi login
        if (isValidCredentials(username, password)) {
            return LoginResult.Success(username)
        } else {
            return LoginResult.Failure("Invalid credentials")
        }
    }
    
    private fun isValidCredentials(username: String, password: String): Boolean {
        // Validasi credentials (misalnya ke server)
        return username == "admin" && password == "password"
    }
}

sealed class LoginResult {
    data class Success(val username: String) : LoginResult()
    data class Failure(val message: String) : LoginResult()
}

/**
 * 2. User Repository - hanya fokus pada data access
 */
interface UserRepository {
    suspend fun saveUser(userData: UserData)
    suspend fun getUserById(userId: String): UserData?
    suspend fun deleteUser(userId: String)
}

class UserRepositoryImpl : UserRepository {
    override suspend fun saveUser(userData: UserData) {
        // Simulasi save ke database
        Log.d("UserRepository", "Saving user: ${userData.id}")
    }
    
    override suspend fun getUserById(userId: String): UserData? {
        // Simulasi fetch dari database
        Log.d("UserRepository", "Getting user: $userId")
        return null
    }
    
    override suspend fun deleteUser(userId: String) {
        // Simulasi delete dari database
        Log.d("UserRepository", "Deleting user: $userId")
    }
}

/**
 * 3. Analytics Service - hanya fokus pada analytics
 */
interface AnalyticsService {
    fun logEvent(eventName: String, properties: Map<String, Any> = emptyMap())
}

class FirebaseAnalyticsService : AnalyticsService {
    override fun logEvent(eventName: String, properties: Map<String, Any>) {
        // Simulasi kirim ke Firebase Analytics
        Log.d("AnalyticsService", "Logging event: $eventName with $properties")
    }
}

/**
 * 4. Logger Service - hanya fokus pada logging
 */
interface Logger {
    fun log(message: String)
    fun logError(message: String, throwable: Throwable? = null)
}

class FileLogger : Logger {
    override fun log(message: String) {
        val file = File("app.log")
        FileWriter(file, true).use { writer ->
            writer.write("[INFO] ${System.currentTimeMillis()}: $message\n")
        }
    }
    
    override fun logError(message: String, throwable: Throwable?) {
        val file = File("app.log")
        val errorLog = buildString {
            append("[ERROR] ${System.currentTimeMillis()}: $message")
            if (throwable != null) {
                append(" - Exception: ${throwable.message}")
            }
            append("\n")
        }
        FileWriter(file, true).use { writer ->
            writer.write(errorLog)
        }
    }
}

/**
 * Data class untuk model user
 */
data class UserData(
    val id: String,
    val name: String,
    val email: String,
    val createdAt: Long = System.currentTimeMillis()
)
```

### Aplikasi SRP dalam Android Architecture:

**ViewModel: Hanya Manajemen State UI**
```kotlin
package com.example.solidprinciples.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.solidprinciples.domain.model.User
import com.example.solidprinciples.domain.usecase.GetUserUseCase
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * ViewModel murni untuk manajemen state UI
 * - Tidak punya logika bisnis
 * - Hanya mengelola state untuk UI
 * - Menggunakan Use Cases untuk operasi domain
 */
class UserViewModel(
    private val getUserUseCase: GetUserUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow<UserUiState>(UserUiState.Loading)
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()

    fun loadUser(userId: String) {
        viewModelScope.launch {
            _uiState.value = UserUiState.Loading
            
            try {
                val user = getUserUseCase(userId)
                _uiState.value = if (user != null) {
                    UserUiState.Success(user)
                } else {
                    UserUiState.Error("User not found")
                }
            } catch (e: Exception) {
                _uiState.value = UserUiState.Error(e.message ?: "Unknown error")
            }
        }
    }
}

sealed class UserUiState {
    object Loading : UserUiState()
    data class Success(val user: User) : UserUiState()
    data class Error(val message: String) : UserUiState()
}
```

**Repository: Hanya Akses Data**
```kotlin
package com.example.solidprinciples.repository

import com.example.solidprinciples.domain.model.User
import com.example.solidprinciples.datasource.local.UserLocalDataSource
import com.example.solidprinciples.datasource.remote.UserRemoteDataSource

/**
 * Repository hanya sebagai gateway untuk manajemen data
 * - Tidak punya logika bisnis
 * - Hanya mengkoordinasikan sumber data
 * - Mengimplementasi kontrak dari domain layer
 */
class UserRepositoryImpl(
    private val remoteDataSource: UserRemoteDataSource,
    private val localDataSource: UserLocalDataSource
) : UserRepository {

    override suspend fun getUserById(id: String): User? {
        // Coba ambil dari remote dulu
        return try {
            val user = remoteDataSource.fetchUserById(id)
            // Cache ke local
            localDataSource.saveUser(user)
            user
        } catch (e: Exception) {
            // Jika remote gagal, ambil dari cache
            localDataSource.getUserById(id)
        }
    }

    override suspend fun saveUser(user: User) {
        remoteDataSource.saveUser(user)
        localDataSource.saveUser(user)
    }

    override suspend fun deleteUser(id: String) {
        remoteDataSource.deleteUser(id)
        localDataSource.deleteUser(id)
    }
}
```

**Use Case: Satu Business Logic**
```kotlin
package com.example.solidprinciples.usecase

import com.example.solidprinciples.domain.model.User
import com.example.solidprinciples.domain.repository.UserRepository

/**
 * Use Case dengan satu tanggung jawab: mendapatkan user
 */
class GetUserUseCase(
    private val repository: UserRepository
) {
    suspend operator fun invoke(userId: String): User? {
        return repository.getUserById(userId)
    }
}

/**
 * Use Case lain untuk tanggung jawab berbeda
 */
class CreateUserUseCase(
    private val repository: UserRepository
) {
    suspend operator fun invoke(userData: UserData): Result<String> {
        return try {
            val user = User(
                id = generateId(),
                name = userData.name,
                email = userData.email
            )
            repository.saveUser(user)
            Result.success(user.id)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private fun generateId(): String {
        return "user_${System.currentTimeMillis()}"
    }
}

data class UserData(
    val name: String,
    val email: String
)
```

### Code Smell yang Menunjukkan Pelanggaran SRP:

**1. God Classes:**
```kotlin
// ‚ùå God Class - terlalu besar dan kompleks
class GodClass {
    // Puluhan method dari berbagai domain
    fun handleNetwork() { }
    fun handleDatabase() { }
    fun handleUI() { }
    fun handleAnalytics() { }
    fun handleLogging() { }
    // ... banyak method lainnya
}
```

**2. Mixed Concerns:**
```kotlin
// ‚ùå Campur aduk concern
class MixedClass {
    // Data access logic
    fun saveToDatabase() { }
    
    // Business logic
    fun calculateTax() { }
    
    // UI logic
    fun updateUI() { }
    
    // Network logic
    fun makeApiCall() { }
}
```

**3. Hard to Name Class:**
```kotlin
// ‚ùå Sulit memberi nama yang jelas
class UserManagerUtilServiceHelper { // Nama yang menunjukkan banyak tanggung jawab
    // Banyak method yang tidak terkait
}
```

### üéì Penjelasan Konsep:
**SRP seperti Spesialisasi Kerja:**
- **Satu dokter satu spesialisasi** - tidak semua penyakit ditangani oleh satu dokter
- **Satu departemen satu fungsi** - HR tidak ngurus teknis, teknis tidak ngurus HR
- **Satu kelas satu tanggung jawab** - kohesi tinggi, coupling rendah

**Manfaat SRP:**
- **Easier to understand**: Setiap kelas punya satu tujuan jelas
- **Easier to test**: Testing lebih mudah karena fokus
- **Less likely to break**: Perubahan tidak mempengaruhi banyak bagian
- **Better reusability**: Kelas bisa digunakan di tempat lain

---

## 3Ô∏è‚É£ Open/Closed Principle (OCP) üîì

### Konsep Dasar
Open/Closed Principle seperti sistem modular üîß - bisa ditambahkan tanpa membongkar yang sudah ada!

### Definisi OCP:
> Software entities (classes, modules, functions, etc.) should be **open for extension** but **closed for modification**.

Artinya:
- **Open for Extension**: Bisa menambahkan fitur baru
- **Closed for Modification**: Tidak perlu mengubah kode yang sudah ada

### Prinsip Inti:
- **Ekstensi tanpa modifikasi**: Tambah fitur baru tanpa merusak yang lama
- **Gunakan abstraksi**: Interface dan abstract class sebagai kontrak
- **Gunakan polimorfisme**: Berbagai implementasi dari satu interface

### Contoh Android - Violation vs Compliant:

**‚ùå BAD: Need to modify for extension**
```kotlin
package com.example.solidprinciples.bad

/**
 * PaymentProcessor melanggar OCP
 * Harus dimodifikasi setiap kali ada metode pembayaran baru
 */
class PaymentProcessor {
    
    fun processPayment(type: String, amount: Double): PaymentResult {
        return when (type) {
            "credit_card" -> processCreditCard(amount)
            "debit_card" -> processDebitCard(amount)
            "paypal" -> processPayPal(amount)
            "bank_transfer" -> processBankTransfer(amount)
            // Setiap kali ada metode pembayaran baru,
            // kita harus modifikasi kelas ini
            else -> PaymentResult.Failure("Unsupported payment method")
        }
    }
    
    private fun processCreditCard(amount: Double): PaymentResult {
        // Proses pembayaran kartu kredit
        return PaymentResult.Success("Credit card payment of $$amount processed")
    }
    
    private fun processDebitCard(amount: Double): PaymentResult {
        // Proses pembayaran kartu debit
        return PaymentResult.Success("Debit card payment of $$amount processed")
    }
    
    private fun processPayPal(amount: Double): PaymentResult {
        // Proses pembayaran PayPal
        return PaymentResult.Success("PayPal payment of $$amount processed")
    }
    
    private fun processBankTransfer(amount: Double): PaymentResult {
        // Proses pembayaran transfer bank
        return PaymentResult.Success("Bank transfer of $$amount processed")
    }
}

sealed class PaymentResult {
    data class Success(val message: String) : PaymentResult()
    data class Failure(val message: String) : PaymentResult()
}
```

**‚úÖ GOOD: Extend without modification**
```kotlin
package com.example.solidprinciples.good

/**
 * PaymentMethod interface - kontrak untuk semua metode pembayaran
 * Mengikuti OCP: bisa ditambah implementasi baru tanpa modifikasi
 */
interface PaymentMethod {
    fun validate(): ValidationResult
    fun process(amount: Double): PaymentResult
    fun getFee(amount: Double): Double
}

/**
 * Hasil validasi
 */
sealed class ValidationResult {
    object Success : ValidationResult()
    data class Failure(val message: String) : ValidationResult()
}

/**
 * Implementasi untuk kartu kredit
 */
class CreditCardPayment(
    private val cardNumber: String,
    private val cvv: String,
    private val expiryDate: String
) : PaymentMethod {
    
    override fun validate(): ValidationResult {
        if (cardNumber.length != 16) {
            return ValidationResult.Failure("Invalid card number")
        }
        if (cvv.length != 3) {
            return ValidationResult.Failure("Invalid CVV")
        }
        return ValidationResult.Success
    }
    
    override fun process(amount: Double): PaymentResult {
        val validation = validate()
        if (validation is ValidationResult.Failure) {
            return PaymentResult.Failure(validation.message)
        }
        
        // Proses pembayaran kartu kredit
        return PaymentResult.Success("Credit card payment of $$amount processed")
    }
    
    override fun getFee(amount: Double): Double {
        return amount * 0.029 + 0.30 // 2.9% + $0.30
    }
}

/**
 * Implementasi untuk PayPal
 */
class PayPalPayment(
    private val email: String,
    private val password: String
) : PaymentMethod {
    
    override fun validate(): ValidationResult {
        if (!email.contains("@")) {
            return ValidationResult.Failure("Invalid email")
        }
        if (password.length < 8) {
            return ValidationResult.Failure("Password too short")
        }
        return ValidationResult.Success
    }
    
    override fun process(amount: Double): PaymentResult {
        val validation = validate()
        if (validation is ValidationResult.Failure) {
            return PaymentResult.Failure(validation.message)
        }
        
        // Proses pembayaran PayPal
        return PaymentResult.Success("PayPal payment of $$amount processed")
    }
    
    override fun getFee(amount: Double): Double {
        return amount * 0.034 + 0.49 // 3.4% + $0.49
    }
}

/**
 * Implementasi untuk transfer bank
 */
class BankTransferPayment(
    private val bankAccount: String,
    private val routingNumber: String
) : PaymentMethod {
    
    override fun validate(): ValidationResult {
        if (bankAccount.length !in 10..20) {
            return ValidationResult.Failure("Invalid bank account number")
        }
        if (routingNumber.length != 9) {
            return ValidationResult.Failure("Invalid routing number")
        }
        return ValidationResult.Success
    }
    
    override fun process(amount: Double): PaymentResult {
        val validation = validate()
        if (validation is ValidationResult.Failure) {
            return PaymentResult.Failure(validation.message)
        }
        
        // Proses transfer bank
        return PaymentResult.Success("Bank transfer of $$amount processed")
    }
    
    override fun getFee(amount: Double): Double {
        return 0.25 // Flat fee
    }
}

/**
 * PaymentProcessor yang tidak perlu dimodifikasi
 * saat ada metode pembayaran baru
 */
class PaymentProcessor {
    
    fun processPayment(paymentMethod: PaymentMethod, amount: Double): PaymentResult {
        // Kita bisa memproses semua jenis pembayaran
        // tanpa mengubah kelas ini
        return paymentMethod.process(amount)
    }
    
    fun calculateTotalCost(baseAmount: Double, paymentMethod: PaymentMethod): Double {
        // Termasuk fee
        return baseAmount + paymentMethod.getFee(baseAmount)
    }
}
```

**‚úÖ Easy Extension - Tambah metode pembayaran baru tanpa modifikasi:**
```kotlin
/**
 * Implementasi baru untuk cryptocurrency
 * Tidak perlu mengubah PaymentProcessor atau interface
 */
class CryptoPayment(
    private val walletAddress: String,
    private val privateKey: String
) : PaymentMethod {
    
    override fun validate(): ValidationResult {
        if (walletAddress.length < 26) {
            return ValidationResult.Failure("Invalid wallet address")
        }
        // Validasi private key
        return ValidationResult.Success
    }
    
    override fun process(amount: Double): PaymentResult {
        val validation = validate()
        if (validation is ValidationResult.Failure) {
            return PaymentResult.Failure(validation.message)
        }
        
        // Proses pembayaran cryptocurrency
        return PaymentResult.Success("Crypto payment of $$amount processed")
    }
    
    override fun getFee(amount: Double): Double {
        return 0.001 // Biaya jaringan sangat rendah
    }
}
```

### Aplikasi OCP dalam Android:

**Strategy Pattern untuk Sorting:**
```kotlin
package com.example.solidprinciples.sorting

/**
 * Interface untuk strategi sorting
 */
interface SortingStrategy<T> {
    fun sort(items: List<T>): List<T>
}

/**
 * Strategi sorting berdasarkan nama
 */
class NameSortingStrategy : SortingStrategy<User> {
    override fun sort(items: List<User>): List<User> {
        return items.sortedBy { it.name }
    }
}

/**
 * Strategi sorting berdasarkan usia
 */
class AgeSortingStrategy : SortingStrategy<User> {
    override fun sort(items: List<User>): List<User> {
        return items.sortedBy { it.age }
    }
}

/**
 * Strategi sorting berdasarkan tanggal dibuat
 */
class CreationDateSortingStrategy : SortingStrategy<User> {
    override fun sort(items: List<User>): List<User> {
        return items.sortedBy { it.createdAt }
    }
}

/**
 * Service yang menggunakan strategi sorting
 * Bisa ditambah strategi baru tanpa modifikasi
 */
class UserSortingService {
    fun sortUsers(users: List<User>, strategy: SortingStrategy<User>): List<User> {
        return strategy.sort(users)
    }
}

data class User(
    val id: String,
    val name: String,
    val age: Int,
    val createdAt: Long = System.currentTimeMillis()
)
```

**Template Method Pattern:**
```kotlin
package com.example.solidprinciples.template

/**
 * Abstract processor yang mendefinisikan alur
 * tetapi memungkinkan implementasi spesifik
 */
abstract class DataProcessor<T> {
    
    // Metode template - tidak bisa diubah
    fun process(data: T): ProcessingResult {
        return try {
            // Langkah-langkah yang selalu sama
            val validatedData = validate(data)
            val transformedData = transform(validatedData)
            val processedData = performProcessing(transformedData)
            
            ProcessingResult.Success(processedData)
        } catch (e: Exception) {
            ProcessingResult.Error(e.message ?: "Unknown error")
        }
    }
    
    // Metode yang harus diimplementasi oleh subclass
    protected abstract fun validate(data: T): T
    protected abstract fun transform(data: T): T
    protected abstract fun performProcessing(data: T): String
    
    // Metode yang bisa di-override (opsional)
    protected open fun logProcessing(data: T) {
        println("Processing data: $data")
    }
}

/**
 * Processor spesifik untuk user data
 */
class UserDataProcessor : DataProcessor<UserData>() {
    
    override fun validate(data: UserData): UserData {
        if (data.name.isBlank()) {
            throw IllegalArgumentException("Name cannot be blank")
        }
        if (data.email.isBlank() || !data.email.contains("@")) {
            throw IllegalArgumentException("Invalid email")
        }
        return data
    }
    
    override fun transform(data: UserData): UserData {
        // Normalisasi data
        return data.copy(
            name = data.name.trim().capitalize(),
            email = data.email.trim().lowercase()
        )
    }
    
    override fun performProcessing(data: UserData): String {
        // Proses data user spesifik
        return "Processed user: ${data.name} (${data.email})"
    }
}

/**
 * Processor spesifik untuk order data
 */
class OrderDataProcessor : DataProcessor<OrderData>() {
    
    override fun validate(data: OrderData): OrderData {
        if (data.items.isEmpty()) {
            throw IllegalArgumentException("Order must have items")
        }
        if (data.totalAmount <= 0) {
            throw IllegalArgumentException("Invalid order amount")
        }
        return data
    }
    
    override fun transform(data: OrderData): OrderData {
        // Transformasi order
        return data.copy(
            totalAmount = data.totalAmount.coerceAtLeast(0.0),
            processedAt = System.currentTimeMillis()
        )
    }
    
    override fun performProcessing(data: OrderData): String {
        // Proses order spesifik
        return "Processed order with ${data.items.size} items, total: $${data.totalAmount}"
    }
}

data class UserData(
    val name: String,
    val email: String
)

data class OrderData(
    val items: List<String>,
    val totalAmount: Double,
    val processedAt: Long = 0
)

sealed class ProcessingResult {
    data class Success<T>(val data: T) : ProcessingResult()
    data class Error(val message: String) : ProcessingResult()
}
```

### OCP dalam Repository Pattern:
```kotlin
package com.example.solidprinciples.repository

/**
 * Generic repository interface
 */
interface Repository<T, ID> {
    suspend fun findById(id: ID): T?
    suspend fun save(entity: T): T
    suspend fun deleteById(id: ID): Boolean
    suspend fun findAll(): List<T>
}

/**
 * Repository spesifik untuk user
 */
class UserRepository : Repository<User, String> {
    override suspend fun findById(id: String): User? {
        // Implementasi spesifik user
        return null
    }
    
    override suspend fun save(entity: User): User {
        // Implementasi spesifik user
        return entity
    }
    
    override suspend fun deleteById(id: String): Boolean {
        // Implementasi spesifik user
        return true
    }
    
    override suspend fun findAll(): List<User> {
        // Implementasi spesifik user
        return emptyList()
    }
}

/**
 * Repository spesifik untuk post
 */
class PostRepository : Repository<Post, String> {
    override suspend fun findById(id: String): Post? {
        // Implementasi spesifik post
        return null
    }
    
    override suspend fun save(entity: Post): Post {
        // Implementasi spesifik post
        return entity
    }
    
    override suspend fun deleteById(id: String): Boolean {
        // Implementasi spesifik post
        return true
    }
    
    override suspend fun findAll(): List<Post> {
        // Implementasi spesifik post
        return emptyList()
    }
}

data class User(val id: String, val name: String)
data class Post(val id: String, val title: String)
```

### üéì Penjelasan Konsep:
**OCP seperti Sistem Plugin:**
- **Seperti sistem operasi** yang bisa ditambahkan aplikasi baru
- **Seperti alat dengan slot** yang bisa masukkan berbagai attachment
- **Seperti API** yang bisa dipakai oleh berbagai layanan

**Manfaat OCP:**
- **Extensibility**: Mudah ditambah fitur baru
- **Stability**: Kode lama tidak rusak
- **Maintainability**: Tidak perlu mengubah semua tempat
- **Flexibility**: Bisa menggunakan berbagai implementasi

---

## 4Ô∏è‚É£ Liskov Substitution Principle (LSP) üîÑ

### Konsep Dasar
Liskov Substitution Principle seperti kontrak kerja yang harus dipenuhi oleh semua pekerja üë∑‚Äç‚ôÇÔ∏è - semua anak kelas harus bisa menggantikan induknya!

### Definisi LSP:
> Objects of a superclass shall be replaceable with objects of its subclasses without breaking the application.

Artinya:
- **Subtype harus bisa menggantikan supertype**
- **Child class tidak boleh merusak behavior parent class**
- **Kontrak harus dipenuhi oleh semua implementasi**

### Prinsip Inti:
- **Behavioral Subtyping**: Subclass harus menjaga behavior parent
- **Contract Compliance**: Implementasi harus sesuai kontrak
- **No Surprise**: Penggunaan subclass harus sama dengan parent

### Contoh Android - Violation vs Compliant:

**‚ùå BAD: Square breaks Rectangle behavior**
```kotlin
package com.example.solidprinciples.bad

/**
 * Contoh klasik yang melanggar LSP
 * Square mencoba memperluas Rectangle tapi rusak
 */
open class Rectangle(
    open var width: Int,
    open var height: Int
) {
    open fun area(): Int {
        return width * height
    }
    
    open fun perimeter(): Int {
        return 2 * (width + height)
    }
}

class Square(width: Int) : Rectangle(width, width) {
    
    // Melanggar LSP: tidak bisa mengganti width dan height secara independen
    override var width: Int
        get() = super.width
        set(value) {
            super.width = value
            super.height = value // Mengubah height juga! Melanggar ekspektasi
        }
    
    override var height: Int
        get() = super.height
        set(value) {
            super.height = value
            super.width = value // Mengubah width juga! Melanggar ekspektasi
        }
    
    // Area masih benar, tapi behavior rusak
    override fun area(): Int {
        return width * width // width dan height selalu sama
    }
}

/**
 * Fungsi yang menggunakan Rectangle
 * Akan rusak jika diberi Square karena behavior tidak sesuai ekspektasi
 */
fun calculateProperties(rectangle: Rectangle) {
    rectangle.width = 10
    rectangle.height = 5
    
    // Ekspektasi: luas = 10 * 5 = 50
    // Jika rectangle adalah Square, hasilnya akan salah
    println("Area: ${rectangle.area()}") // Jika Square, hasilnya 25, bukan 50!
    println("Dimensions: ${rectangle.width} x ${rectangle.height}")
}
```

**‚úÖ GOOD: Proper abstraction**
```kotlin
package com.example.solidprinciples.good

/**
 * Interface yang mendefinisikan kontrak bentuk
 * Tidak ada asumsi tentang implementasi spesifik
 */
interface Shape {
    fun area(): Double
    fun perimeter(): Double
}

/**
 * Rectangle dengan implementasi sendiri
 * Tidak ada hubungan inheritance yang membingungkan
 */
class Rectangle(
    private val width: Double,
    private val height: Double
) : Shape {
    override fun area(): Double = width * height
    override fun perimeter(): Double = 2 * (width + height)
    
    // Method spesifik Rectangle
    fun isSquare(): Boolean = width == height
}

/**
 * Square sebagai implementasi terpisah
 * Tidak mencoba menjadi Rectangle palsu
 */
class Square(private val side: Double) : Shape {
    override fun area(): Double = side * side
    override fun perimeter(): Double = 4 * side
    
    // Method spesifik Square
    fun getSide(): Double = side
}

/**
 * Circle sebagai implementasi lain
 */
class Circle(private val radius: Double) : Shape {
    override fun area(): Double = Math.PI * radius * radius
    override fun perimeter(): Double = 2 * Math.PI * radius
    
    fun getRadius(): Double = radius
}

/**
 * Fungsi yang bisa menggunakan semua bentuk
 * Karena semua mengikuti kontrak yang sama
 */
fun calculateShapeProperties(shape: Shape) {
    println("Area: ${shape.area()}")
    println("Perimeter: ${shape.perimeter()}")
}
```

### Contoh Lebih Kompleks - Repository Pattern:

**‚ùå BAD: Repository melanggar kontrak**
```kotlin
package com.example.solidprinciples.bad

/**
 * Repository interface standar
 */
interface UserRepository {
    suspend fun findById(id: String): User?
    suspend fun save(user: User): User
    suspend fun delete(id: String): Boolean
}

/**
 * Implementasi yang melanggar kontrak
 */
class MockUserRepository : UserRepository {
    private val users = mutableMapOf<String, User>()
    
    override suspend fun findById(id: String): User? {
        return users[id]
    }
    
    /**
     * Melanggar kontrak: seharusnya menyimpan dan return user,
     * tapi malah melempar exception untuk user spesifik
     */
    override suspend fun save(user: User): User {
        if (user.email.contains("test.com")) {
            throw IllegalStateException("Test emails not allowed in production mock!")
        }
        users[user.id] = user
        return user
    }
    
    /**
     * Melanggar kontrak: seharusnya return boolean untuk keberhasilan,
     * tapi selalu return true
     */
    override suspend fun delete(id: String): Boolean {
        users.remove(id)
        return true // Selalu return true, bahkan jika user tidak ada
    }
}
```

**‚úÖ GOOD: Implementasi yang memenuhi kontrak**
```kotlin
package com.example.solidprinciples.good

/**
 * Repository interface standar
 */
interface UserRepository {
    suspend fun findById(id: String): User?
    suspend fun save(user: User): User
    suspend fun delete(id: String): Boolean
}

/**
 * Base class untuk implementasi repository
 */
abstract class BaseRepository<T, ID> {
    protected abstract fun validateEntity(entity: T): ValidationResult
}

/**
 * Implementasi untuk database
 */
class DatabaseUserRepository : UserRepository {
    // Simulasi database
    private val database = mutableMapOf<String, User>()
    
    override suspend fun findById(id: String): User? {
        return database[id]
    }
    
    override suspend fun save(user: User): User {
        // Validasi sebelum menyimpan
        validateUser(user)
        database[user.id] = user
        return user
    }
    
    override suspend fun delete(id: String): Boolean {
        val existed = database.containsKey(id)
        database.remove(id)
        return existed // Return apakah benar-benar dihapus
    }
    
    private fun validateUser(user: User) {
        if (user.id.isBlank()) {
            throw IllegalArgumentException("User ID cannot be blank")
        }
        if (user.email.isBlank() || !user.email.contains("@")) {
            throw IllegalArgumentException("Invalid email")
        }
    }
}

/**
 * Implementasi untuk cache
 * Mengikuti kontrak yang sama seperti DatabaseUserRepository
 */
class CacheUserRepository : UserRepository {
    private val cache = mutableMapOf<String, User>()
    
    override suspend fun findById(id: String): User? {
        return cache[id]
    }
    
    /**
     * Implementasi save yang sesuai kontrak
     * Tapi dengan behavior caching
     */
    override suspend fun save(user: User): User {
        validateUser(user)
        cache[user.id] = user
        return user
    }
    
    override suspend fun delete(id: String): Boolean {
        val existed = cache.containsKey(id)
        cache.remove(id)
        return existed
    }
    
    private fun validateUser(user: User) {
        if (user.id.isBlank()) {
            throw IllegalArgumentException("User ID cannot be blank")
        }
        if (user.email.isBlank() || !user.email.contains("@")) {
            throw IllegalArgumentException("Invalid email")
        }
    }
}

/**
 * Implementasi untuk remote API
 * Juga mengikuti kontrak yang sama
 */
class RemoteUserRepository : UserRepository {
    private val apiService = MockApiService()
    
    override suspend fun findById(id: String): User? {
        return apiService.getUser(id)
    }
    
    override suspend fun save(user: User): User {
        validateUser(user)
        val savedUser = apiService.saveUser(user)
        return savedUser
    }
    
    override suspend fun delete(id: String): Boolean {
        return apiService.deleteUser(id)
    }
    
    private fun validateUser(user: User) {
        if (user.id.isBlank()) {
            throw IllegalArgumentException("User ID cannot be blank")
        }
        if (user.email.isBlank() || !user.email.contains("@")) {
            throw IllegalArgumentException("Invalid email")
        }
    }
}

/**
 * Service mock untuk simulasi API
 */
class MockApiService {
    suspend fun getUser(id: String): User? {
        // Simulasi API call
        return User(id, "User $id", "$id@example.com")
    }
    
    suspend fun saveUser(user: User): User {
        // Simulasi API call
        return user
    }
    
    suspend fun deleteUser(id: String): Boolean {
        // Simulasi API call
        return true
    }
}
```

### Contoh Android - View Components:

**‚ùå BAD: Custom view melanggar kontrak**
```kotlin
package com.example.solidprinciples.bad

import android.content.Context
import android.util.AttributeSet
import android.view.View
import android.widget.Button

/**
 * Button khusus yang melanggar ekspektasi
 */
class SpecialButton @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : Button(context, attrs, defStyleAttr) {
    
    /**
     * Melanggar kontrak onClick: seharusnya hanya eksekusi callback,
     * tapi malah mengubah behavior fundamental
     */
    override fun setOnClickListener(l: OnClickListener?) {
        super.setOnClickListener { view ->
            // Tambahkan behavior yang tidak diharapkan
            performSpecialAction()
            l?.onClick(view)
        }
    }
    
    private fun performSpecialAction() {
        // Aksi yang tidak seharusnya dilakukan oleh button
        // Tapi dipaksa ke semua listener
    }
}
```

**‚úÖ GOOD: View yang mengikuti kontrak**
```kotlin
package com.example.solidprinciples.good

import android.content.Context
import android.util.AttributeSet
import android.view.View
import android.widget.Button

/**
 * Button yang memperluas fungsi tanpa melanggar kontrak
 */
class EnhancedButton @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : Button(context, attrs, defStyleAttr) {
    
    // Properti tambahan
    private var onEnhancedClick: ((View) -> Unit)? = null
    private var animationEnabled: Boolean = true
    
    /**
     * Mengikuti kontrak onClick, tidak merusak behavior
     */
    override fun setOnClickListener(l: OnClickListener?) {
        super.setOnClickListener { view ->
            // Tambahkan efek tambahan TANPA merusak kontrak
            if (animationEnabled) {
                animateClick()
            }
            l?.onClick(view)
            onEnhancedClick?.invoke(view) // Callback tambahan opsional
        }
    }
    
    fun setOnEnhancedClickListener(listener: (View) -> Unit) {
        this.onEnhancedClick = listener
    }
    
    fun setAnimationEnabled(enabled: Boolean) {
        this.animationEnabled = enabled
    }
    
    private fun animateClick() {
        // Animasi ringan, tidak merusak kontrak
        scaleX = 0.95f
        scaleY = 0.95f
        post {
            scaleX = 1.0f
            scaleY = 1.0f
        }
    }
}
```

### LSP dalam Use Cases:

**‚ùå BAD: Use Case melanggar kontrak**
```kotlin
package com.example.solidprinciples.bad

/**
 * Interface use case standar
 */
interface GetUserUseCase {
    suspend operator fun invoke(userId: String): User?
}

/**
 * Implementasi yang melanggar kontrak
 */
class LoggingGetUserUseCase(
    private val repository: UserRepository,
    private val logger: Logger
) : GetUserUseCase {
    
    override suspend fun invoke(userId: String): User? {
        logger.log("Fetching user: $userId")
        
        val user = repository.findById(userId)
        
        if (user == null) {
            // Melanggar kontrak: melempar exception saat user tidak ditemukan
            // Harusnya return null sesuai kontrak
            throw UserNotFoundException("User $userId not found")
        }
        
        logger.log("User fetched successfully: ${user.name}")
        return user
    }
}

class UserNotFoundException(message: String) : Exception(message)
```

**‚úÖ GOOD: Use Case mengikuti kontrak**
```kotlin
package com.example.solidprinciples.good

/**
 * Interface use case standar
 * Tidak memberi asumsi tentang exception
 */
interface GetUserUseCase {
    suspend operator fun invoke(userId: String): User?
}

/**
 * Implementasi dengan logging, tapi tetap mengikuti kontrak
 */
class LoggingGetUserUseCase(
    private val repository: UserRepository,
    private val logger: Logger
) : GetUserUseCase {
    
    override suspend fun invoke(userId: String): User? {
        logger.log("Fetching user: $userId")
        
        return try {
            val user = repository.findById(userId)
            if (user != null) {
                logger.log("User fetched successfully: ${user.name}")
            } else {
                logger.log("User not found: $userId")
            }
            user
        } catch (e: Exception) {
            logger.logError("Error fetching user $userId: ${e.message}")
            null // Tetap return null sesuai kontrak, tidak lempar exception
        }
    }
}

/**
 * Interface untuk logging
 */
interface Logger {
    fun log(message: String)
    fun logError(message: String, throwable: Throwable? = null)
}
```

### üéì Penjelasan Konsep:
**LSP seperti Kontrak Kerja:**
- **Seperti kontrak kerja** yang harus dipenuhi semua karyawan
- **Seperti standar industri** yang harus diikuti semua perusahaan
- **Seperti interface hukum** yang harus dipatuhi semua pihak

**Indikator Pelanggaran LSP:**
- **instanceof checks**: Tanda bahwa behavior berbeda-beda
- **Downcasting**: Tanda bahwa implementasi tidak seragam  
- **Exception tidak terduga**: Tanda bahwa kontrak dilanggar
- **Behavior yang berbeda**: Output yang tidak konsisten

**Manfaat LSP:**
- **Substitutability**: Bisa ganti implementasi dengan aman
- **Predictability**: Behavior konsisten dan dapat diprediksi
- **Maintainability**: Tidak ada kejutan saat mengganti implementasi
- **Testability**: Mudah test karena behavior terjaga

---

## 5Ô∏è‚É£ Interface Segregation Principle (ISP) üìè

### Konsep Dasar
Interface Segregation Principle seperti spesialisasi pekerjaan üíº - buat interface kecil yang fokus dibanding interface besar yang serba bisa!

### Definisi ISP:
> Clients should not be forced to depend on interfaces they do not use.

Artinya:
- **Banyak interface kecil** > satu interface besar
- **Client hanya butuh interface yang diperlukan**
- **Hindari "fat interfaces"** (interface terlalu besar)

### Prinsip Inti:
- **Role-based Interfaces**: Interface berdasarkan peran
- **Client-specific Contracts**: Interface sesuai kebutuhan client
- **Focused Responsibilities**: Setiap interface punya satu tanggung jawab

### Contoh Android - Violation vs Compliant:

**‚ùå BAD: Fat Interface**
```kotlin
package com.example.solidprinciples.bad

/**
 * Fat interface - satu interface dengan banyak method
 * Client dipaksa mengimplementasi semua method, bahkan yang tidak digunakan
 */
interface DataManager {
    // Network operations
    suspend fun fetchFromNetwork(): String
    suspend fun uploadToNetwork(data: String): Boolean
    suspend fun checkNetworkConnectivity(): Boolean
    
    // Database operations
    suspend fun saveToDatabase(data: String): Long
    suspend fun readFromDatabase(id: Long): String
    suspend fun deleteFromDatabase(id: Long): Boolean
    suspend fun clearDatabase(): Boolean
    
    // Cache operations
    suspend fun cacheData(key: String, data: String): Boolean
    suspend fun getCachedData(key: String): String?
    suspend fun clearCache(): Boolean
    
    // File operations
    suspend fun saveToFile(filename: String, data: String): Boolean
    suspend fun readFromFile(filename: String): String?
    suspend fun deleteFile(filename: String): Boolean
    
    // Analytics operations
    suspend fun logEvent(event: String, properties: Map<String, Any>): Boolean
    suspend fun setUserProperty(property: String, value: String): Boolean
}

/**
 * Client hanya butuh network operations, tapi dipaksa implementasi semua
 */
class NetworkOnlyClient : DataManager {
    override suspend fun fetchFromNetwork(): String {
        // Implementasi yang dibutuhkan
        return "data"
    }
    
    override suspend fun uploadToNetwork(data: String): Boolean {
        // Implementasi yang dibutuhkan
        return true
    }
    
    override suspend fun checkNetworkConnectivity(): Boolean {
        // Implementasi yang dibutuhkan
        return true
    }
    
    // SEMUA INI HARUS DIIMPLEMENTASI MESKIPUN TIDAK DIGUNAKAN!
    override suspend fun saveToDatabase(data: String): Long { TODO() }
    override suspend fun readFromDatabase(id: Long): String { TODO() }
    override suspend fun deleteFromDatabase(id: Long): Boolean { TODO() }
    override suspend fun clearDatabase(): Boolean { TODO() }
    
    override suspend fun cacheData(key: String, data: String): Boolean { TODO() }
    override suspend fun getCachedData(key: String): String? { TODO() }
    override suspend fun clearCache(): Boolean { TODO() }
    
    override suspend fun saveToFile(filename: String, data: String): Boolean { TODO() }
    override suspend fun readFromFile(filename: String): String? { TODO() }
    override suspend fun deleteFile(filename: String): Boolean { TODO() }
    
    override suspend fun logEvent(event: String, properties: Map<String, Any>): Boolean { TODO() }
    override suspend fun setUserProperty(property: String, value: String): Boolean { TODO() }
}
```

**‚úÖ GOOD: Segregated Interfaces**
```kotlin
package com.example.solidprinciples.good

/**
 * Interface spesifik untuk network operations
 */
interface NetworkDataSource {
    suspend fun fetch(): String
    suspend fun upload(data: String): Boolean
    suspend fun isNetworkAvailable(): Boolean
}

/**
 * Interface spesifik untuk database operations
 */
interface DatabaseDataSource {
    suspend fun save(data: String): Long
    suspend fun read(id: Long): String
    suspend fun delete(id: Long): Boolean
    suspend fun clear(): Boolean
}

/**
 * Interface spesifik untuk cache operations
 */
interface CacheManager {
    suspend fun put(key: String, data: String): Boolean
    suspend fun get(key: String): String?
    suspend fun clear(): Boolean
}

/**
 * Interface spesifik untuk file operations
 */
interface FileManager {
    suspend fun write(filename: String, data: String): Boolean
    suspend fun read(filename: String): String?
    suspend fun delete(filename: String): Boolean
}

/**
 * Interface spesifik untuk analytics
 */
interface AnalyticsService {
    suspend fun logEvent(event: String, properties: Map<String, Any>)
    suspend fun setUserProperty(property: String, value: String)
}

/**
 * Client hanya menggabungkan interface yang diperlukan
 */
class NetworkOnlyClient(
    private val networkSource: NetworkDataSource
) {
    suspend fun fetchData(): String {
        return networkSource.fetch()
    }
    
    suspend fun uploadData(data: String): Boolean {
        return networkSource.upload(data)
    }
    
    suspend fun checkConnectivity(): Boolean {
        return networkSource.isNetworkAvailable()
    }
}

/**
 * Client kompleks yang butuh beberapa sumber data
 */
class ComplexDataClient(
    private val networkSource: NetworkDataSource,
    private val databaseSource: DatabaseDataSource,
    private val cacheManager: CacheManager
) {
    suspend fun getDataWithFallback(): String {
        // Coba dari cache dulu
        var data = cacheManager.get("data_key")
        
        if (data == null) {
            // Jika tidak ada di cache, coba dari database
            data = try {
                databaseSource.read(1)
            } catch (e: Exception) {
                null
            }
            
            if (data == null) {
                // Jika tidak ada di database, ambil dari network
                data = networkSource.fetch()
                // Simpan ke cache
                cacheManager.put("data_key", data)
            }
        }
        
        return data
    }
}
```

### Aplikasi ISP dalam Repository Pattern:

**‚ùå BAD: Repository interface terlalu besar**
```kotlin
package com.example.solidprinciples.bad

/**
 * Repository interface yang mencoba menangani semua operasi
 */
interface UniversalRepository<T, ID> {
    // CRUD operations
    suspend fun findById(id: ID): T?
    suspend fun findAll(): List<T>
    suspend fun save(entity: T): T
    suspend fun update(entity: T): T
    suspend fun delete(id: ID): Boolean
    suspend fun deleteAll(): Boolean
    
    // Search operations
    suspend fun findByProperty(property: String, value: Any): List<T>
    suspend fun findByName(name: String): List<T>
    suspend fun findByEmail(email: String): List<T>
    
    // Aggregate operations
    suspend fun count(): Long
    suspend fun existsById(id: ID): Boolean
    
    // Bulk operations
    suspend fun saveAll(entities: List<T>): List<T>
    suspend fun deleteAllById(ids: List<ID>): Boolean
    
    // Custom operations
    suspend fun findWithFilter(filter: Map<String, Any>): List<T>
    suspend fun customQuery(query: String, params: Map<String, Any>): List<T>
}

/**
 * Implementasi untuk user tapi dipaksa implementasi semua method
 */
class UserUniversalRepository : UniversalRepository<User, String> {
    override suspend fun findById(id: String): User? { TODO() }
    override suspend fun findAll(): List<User> { TODO() }
    override suspend fun save(entity: User): User { TODO() }
    override suspend fun update(entity: User): User { TODO() }
    override suspend fun delete(id: String): Boolean { TODO() }
    override suspend fun deleteAll(): Boolean { TODO() }
    
    // Banyak method lain yang tidak perlu diimplementasi
    override suspend fun findByProperty(property: String, value: Any): List<User> { TODO() }
    override suspend fun findByName(name: String): List<User> { TODO() }
    // ... dan seterusnya
}
```

**‚úÖ GOOD: Segregated repository interfaces**
```kotlin
package com.example.solidprinciples.good

/**
 * Interface dasar CRUD
 */
interface CrudRepository<T, ID> {
    suspend fun findById(id: ID): T?
    suspend fun findAll(): List<T>
    suspend fun save(entity: T): T
    suspend fun update(entity: T): T
    suspend fun delete(id: ID): Boolean
}

/**
 * Interface untuk operasi pencarian
 */
interface QueryRepository<T> {
    suspend fun findByProperty(property: String, value: Any): List<T>
    suspend fun findByName(name: String): List<T>
}

/**
 * Interface untuk operasi agregasi
 */
interface AggregateRepository<T> {
    suspend fun count(): Long
    suspend fun existsById(id: String): Boolean
}

/**
 * Interface untuk operasi bulk
 */
interface BulkRepository<T> {
    suspend fun saveAll(entities: List<T>): List<T>
    suspend fun deleteAllById(ids: List<String>): Boolean
}

/**
 * Repository interface komposit untuk user
 * Hanya menggabungkan yang dibutuhkan
 */
interface UserRepository : 
    CrudRepository<User, String>,
    QueryRepository<User>,
    AggregateRepository<User>

/**
 * Implementasi repository
 */
class UserDatabaseRepository : UserRepository {
    // CRUD operations
    override suspend fun findById(id: String): User? {
        // Implementasi database
        return null
    }
    
    override suspend fun findAll(): List<User> {
        // Implementasi database
        return emptyList()
    }
    
    override suspend fun save(entity: User): User {
        // Implementasi database
        return entity
    }
    
    override suspend fun update(entity: User): User {
        // Implementasi database
        return entity
    }
    
    override suspend fun delete(id: String): Boolean {
        // Implementasi database
        return true
    }
    
    // Query operations
    override suspend fun findByProperty(property: String, value: Any): List<User> {
        // Implementasi database
        return emptyList()
    }
    
    override suspend fun findByName(name: String): List<User> {
        // Implementasi database
        return emptyList()
    }
    
    // Aggregate operations
    override suspend fun count(): Long {
        // Implementasi database
        return 0
    }
    
    override suspend fun existsById(id: String): Boolean {
        // Implementasi database
        return false
    }
}
```

### ISP dalam View Models:

**‚ùå BAD: ViewModel interface terlalu besar**
```kotlin
package com.example.solidprinciples.bad

/**
 * Interface ViewModel terlalu besar dan kompleks
 */
interface BaseViewModel {
    fun initState()
    fun loadData()
    fun saveData()
    fun updateData()
    fun deleteData()
    fun validateData(): Boolean
    fun showError(message: String)
    fun showSuccess(message: String)
    fun showLoading()
    fun hideLoading()
    fun navigateTo(destination: String)
    fun handleUserAction(action: String)
    fun logUserAction(action: String)
    fun trackAnalytics(event: String)
    fun cacheViewState()
    fun restoreViewState()
}
```

**‚úÖ GOOD: Interface tersegmentasi**
```kotlin
package com.example.solidprinciples.good

/**
 * Interface untuk manajemen state
 */
interface StateManager<T> {
    fun initState(): T
    fun updateState(newState: T)
    fun getCurrentState(): T
}

/**
 * Interface untuk operasi data
 */
interface DataOperations<T> {
    suspend fun loadData(): T
    suspend fun saveData(data: T): Boolean
    suspend fun updateData(data: T): Boolean
}

/**
 * Interface untuk validasi
 */
interface DataValidator<T> {
    fun validate(data: T): ValidationResult
}

/**
 * Interface untuk UI event
 */
interface UiEventEmitter {
    fun showError(message: String)
    fun showSuccess(message: String)
    fun showLoading()
    fun hideLoading()
}

/**
 * Interface untuk navigasi
 */
interface Navigator {
    fun navigateTo(destination: String, args: Map<String, Any> = emptyMap())
}

/**
 * Interface komposit untuk User ViewModel
 */
interface UserViewModel : 
    StateManager<UserUiState>,
    DataOperations<User>,
    DataValidator<User>,
    UiEventEmitter,
    Navigator

/**
 * Implementasi konkret
 */
class UserViewModelImpl(
    private val userRepository: UserRepository,
    private val analyticsService: AnalyticsService
) : UserViewModel {
    
    private var currentState: UserUiState = UserUiState.Idle
    
    override fun initState(): UserUiState = UserUiState.Idle
    
    override fun updateState(newState: UserUiState) {
        currentState = newState
    }
    
    override fun getCurrentState(): UserUiState = currentState
    
    override suspend fun loadData(): User {
        showLoading()
        try {
            val user = userRepository.findById("current_user") ?: throw Exception("User not found")
            showSuccess("User loaded successfully")
            return user
        } catch (e: Exception) {
            showError(e.message ?: "Failed to load user")
            throw e
        } finally {
            hideLoading()
        }
    }
    
    override suspend fun saveData(data: User): Boolean {
        val validation = validate(data)
        if (validation !is ValidationResult.Success) {
            showError("Validation failed: ${validation.message}")
            return false
        }
        
        return try {
            userRepository.save(data)
            true
        } catch (e: Exception) {
            showError(e.message ?: "Failed to save user")
            false
        }
    }
    
    override fun validate(data: User): ValidationResult {
        return when {
            data.name.isBlank() -> ValidationResult.Failure("Name cannot be empty")
            data.email.isBlank() || !data.email.contains("@") -> ValidationResult.Failure("Invalid email")
            else -> ValidationResult.Success
        }
    }
    
    override fun showError(message: String) {
        // Handle show error
    }
    
    override fun showSuccess(message: String) {
        // Handle show success
    }
    
    override fun showLoading() {
        currentState = UserUiState.Loading
    }
    
    override fun hideLoading() {
        if (currentState is UserUiState.Loading) {
            currentState = UserUiState.Idle
        }
    }
    
    override fun navigateTo(destination: String, args: Map<String, Any>) {
        // Handle navigation
    }
}

sealed class UserUiState {
    object Idle : UserUiState()
    object Loading : UserUiState()
    data class Error(val message: String) : UserUiState()
    data class Success(val data: User) : UserUiState()
}

sealed class ValidationResult {
    object Success : ValidationResult()
    data class Failure(val message: String) : ValidationResult()
}
```

### ISP dalam Service Architecture:

**‚úÖ GOOD: Service interfaces tersegmentasi**
```kotlin
package com.example.solidprinciples.good

/**
 * Interface untuk notification service
 */
interface NotificationService {
    suspend fun showNotification(title: String, message: String)
    suspend fun scheduleNotification(title: String, message: String, time: Long)
    suspend fun cancelNotification(id: String)
}

/**
 * Interface untuk location service
 */
interface LocationService {
    suspend fun getCurrentLocation(): Location?
    suspend fun startLocationTracking()
    suspend fun stopLocationTracking()
}

/**
 * Interface untuk connectivity service
 */
interface ConnectivityService {
    suspend fun isNetworkAvailable(): Boolean
    suspend fun isWifiAvailable(): Boolean
    suspend fun getNetworkType(): NetworkType
}

/**
 * Interface untuk storage service
 */
interface StorageService {
    suspend fun saveData(key: String, data: String)
    suspend fun loadData(key: String): String?
    suspend fun clearData(key: String)
}

/**
 * Enum untuk tipe jaringan
 */
enum class NetworkType {
    WIFI, CELLULAR, NONE
}

/**
 * Data class untuk lokasi
 */
data class Location(
    val latitude: Double,
    val longitude: Double,
    val accuracy: Float,
    val timestamp: Long
)

/**
 * Client yang hanya butuh notification
 */
class AlertService(
    private val notificationService: NotificationService
) {
    suspend fun showAlert(title: String, message: String) {
        notificationService.showNotification(title, message)
    }
}

/**
 * Client yang butuh beberapa services
 */
class LocationAlertService(
    private val locationService: LocationService,
    private val notificationService: NotificationService,
    private val connectivityService: ConnectivityService
) {
    suspend fun startLocationBasedAlerts() {
        if (!connectivityService.isNetworkAvailable()) {
            notificationService.showNotification(
                "Connection Required", 
                "Network connection needed for location alerts"
            )
            return
        }
        
        locationService.startLocationTracking()
        // Implementasi logic untuk alerts berbasis lokasi
    }
}
```

### üéì Penjelasan Konsep:
**ISP seperti Spesialisasi Profesi:**
- **Seperti dokter spesialis** - dokter jantung tidak perlu bisa operasi otak
- **Seperti departemen perusahaan** - HR tidak perlu tahu teknis IT secara lengkap
- **Seperti interface kerja** - masing-masing pihak hanya perlu kontrak yang relevan

**Manfaat ISP:**
- **Smaller Interfaces**: Lebih mudah dipahami dan diimplementasi
- **Less Coupling**: Client tidak terikat ke method yang tidak digunakan
- **Better Testability**: Mudah mock hanya method yang dibutuhkan
- **Easier Refactoring**: Perubahan interface kecil tidak mempengaruhi banyak client

---

## 6Ô∏è‚É£ Dependency Inversion Principle (DIP) üîÑ

### Konsep Dasar
Dependency Inversion Principle seperti sistem modular üîå - komponen tingkat tinggi tidak tergantung pada komponen tingkat rendah, keduanya tergantung pada abstraksi!

### Definisi DIP:
> 1. High-level modules should not depend on low-level modules. Both should depend on abstractions.
> 2. Abstractions should not depend on details. Details should depend on abstractions.

Artinya:
- **Modul tingkat tinggi** tidak boleh tergantung pada modul tingkat rendah
- **Keduanya harus tergantung pada abstraksi**
- **Abstraksi tidak tergantung pada detail implementasi**
- **Detail implementasi tergantung pada abstraksi**

### Prinsip Inti:
- **Abstraction over Implementation**: Gunakan interface, bukan konkrit
- **Inversion of Control**: Balikkan pengendalian dari bawah ke atas
- **Loose Coupling**: Ketergantungan lemah antar komponen
- **Testability**: Mudah diganti dengan mock untuk testing

### Contoh Android - Violation vs Compliant:

**‚ùå BAD: Direct dependency (tight coupling)**
```kotlin
package com.example.solidprinciples.bad

/**
 * High-level module - UserViewModel
 * Melanggar DIP karena tergantung pada implementasi konkrit
 */
class UserViewModel {
    // Tergantung langsung pada implementasi konkrit
    private val repository = UserRepositoryImpl()
    private val apiService = UserApiServiceImpl()
    private val localDatabase = SQLiteUserDatabase()
    
    suspend fun loadUser(userId: String) {
        // Menggunakan implementasi langsung - tidak fleksibel
        val user = repository.getUserById(userId)
        // ...
    }
    
    suspend fun saveUser(user: User) {
        // Tergantung pada implementasi spesifik
        repository.saveUser(user)
    }
}

/**
 * Low-level modules
 */
class UserRepositoryImpl {
    private val apiService = UserApiServiceImpl()
    private val database = SQLiteUserDatabase()
    
    suspend fun getUserById(id: String): User? {
        // Tergantung pada implementasi langsung
        return database.findById(id) ?: apiService.fetchUser(id)
    }
    
    suspend fun saveUser(user: User) {
        // Tergantung pada implementasi langsung
        database.save(user)
        apiService.sendUserUpdate(user)
    }
}

class UserApiServiceImpl {
    suspend fun fetchUser(id: String): User? {
        // Implementasi jaringan
        return null
    }
    
    suspend fun sendUserUpdate(user: User) {
        // Implementasi jaringan
    }
}

class SQLiteUserDatabase {
    fun findById(id: String): User? {
        // Implementasi database
        return null
    }
    
    fun save(user: User) {
        // Implementasi database
    }
}
```

**‚úÖ GOOD: Depend on abstractions**
```kotlin
package com.example.solidprinciples.good

/**
 * Abstraction layer - interface sebagai kontrak
 */
interface UserRepository {
    suspend fun getUserById(id: String): User?
    suspend fun saveUser(user: User): User
    suspend fun deleteUser(id: String): Boolean
}

interface UserApiService {
    suspend fun fetchUser(id: String): User?
    suspend fun saveUser(user: User): User
    suspend fun deleteUser(id: String): Boolean
}

interface UserLocalDataSource {
    suspend fun getUser(id: String): User?
    suspend fun saveUser(user: User): User
    suspend fun deleteUser(id: String): Boolean
}

/**
 * High-level module - sekarang tergantung pada abstraksi
 */
class UserViewModel(
    // Menggunakan abstraksi, bukan implementasi konkrit
    private val repository: UserRepository,
    private val analyticsService: AnalyticsService
) {
    private val _uiState = MutableStateFlow<UserUiState>(UserUiState.Loading)
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()

    suspend fun loadUser(userId: String) {
        _uiState.value = UserUiState.Loading
        analyticsService.logEvent("user_load_started")
        
        try {
            val user = repository.getUserById(userId)
            _uiState.value = if (user != null) {
                UserUiState.Success(user)
            } else {
                UserUiState.Error("User not found")
            }
        } catch (e: Exception) {
            _uiState.value = UserUiState.Error(e.message ?: "Unknown error")
        }
    }
    
    suspend fun saveUser(user: User) {
        try {
            val savedUser = repository.saveUser(user)
            analyticsService.logEvent("user_saved", mapOf("userId" to savedUser.id))
        } catch (e: Exception) {
            analyticsService.logEvent("user_save_failed", mapOf("error" to e.message))
        }
    }
}

/**
 * Low-level modules mengimplementasi abstraksi
 */
class UserRepositoryImpl(
    private val remoteDataSource: UserApiService,
    private val localDataSource: UserLocalDataSource
) : UserRepository {
    
    override suspend fun getUserById(id: String): User? {
        // Mendapatkan dari lokal dulu, jika tidak ada ambil dari remote dan cache
        return localDataSource.getUser(id) ?: run {
            val user = remoteDataSource.fetchUser(id)
            if (user != null) {
                localDataSource.saveUser(user) // Cache ke lokal
            }
            user
        }
    }
    
    override suspend fun saveUser(user: User): User {
        // Simpan ke remote dan lokal
        val savedRemote = remoteDataSource.saveUser(user)
        localDataSource.saveUser(savedRemote)
        return savedRemote
    }
    
    override suspend fun deleteUser(id: String): Boolean {
        // Hapus dari remote dan lokal
        val remoteResult = remoteDataSource.deleteUser(id)
        val localResult = localDataSource.deleteUser(id)
        return remoteResult && localResult
    }
}

class UserApiServiceImpl : UserApiService {
    // Implementasi nyata untuk API
    override suspend fun fetchUser(id: String): User? {
        // Implementasi jaringan
        return null
    }
    
    override suspend fun saveUser(user: User): User {
        // Implementasi jaringan
        return user
    }
    
    override suspend fun deleteUser(id: String): Boolean {
        // Implementasi jaringan
        return true
    }
}

class SQLiteUserDataSource : UserLocalDataSource {
    // Implementasi nyata untuk database lokal
    override suspend fun getUser(id: String): User? {
        // Implementasi database
        return null
    }
    
    override suspend fun saveUser(user: User): User {
        // Implementasi database
        return user
    }
    
    override suspend fun deleteUser(id: String): Boolean {
        // Implementasi database
        return true
    }
}

/**
 * Interface untuk analytics - juga mengikuti DIP
 */
interface AnalyticsService {
    suspend fun logEvent(eventName: String, properties: Map<String, Any> = emptyMap())
}

class FirebaseAnalyticsService : AnalyticsService {
    override suspend fun logEvent(eventName: String, properties: Map<String, Any>) {
        // Implementasi Firebase Analytics
    }
}

// Data classes dan sealed classes
data class User(
    val id: String,
    val name: String,
    val email: String
)

sealed class UserUiState {
    object Loading : UserUiState()
    data class Success(val user: User) : UserUiState()
    data class Error(val message: String) : UserUiState()
}

class MutableStateFlow<T>(private var value: T) {
    fun getValue(): T = value
    fun setValue(newValue: T) { value = newValue }
}

interface StateFlow<T> {
    fun collect(collector: (T) -> Unit)
}
```

### Aplikasi DIP dalam Clean Architecture:

**Domain Layer - Interface sebagai abstraksi utama**
```kotlin
package com.example.solidprinciples.domain

/**
 * Repository interface di domain layer
 * Menjadi titik abstraksi yang digunakan oleh high-level modules (Use Cases)
 */
interface UserRepository {
    suspend fun getUserById(id: String): User?
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
    fun getUsersStream(): Flow<List<User>> // Untuk live updates
}

/**
 * Use Case - high-level module yang tergantung pada abstraksi
 */
class GetUserUseCase(
    // Tergantung pada abstraksi, bukan implementasi konkrit
    private val repository: UserRepository
) {
    suspend operator fun invoke(userId: String): User? {
        return repository.getUserById(userId)
    }
}

class GetUsersUseCase(
    private val repository: UserRepository
) {
    operator fun invoke(): Flow<List<User>> {
        return repository.getUsersStream()
    }
}
```

**Data Layer - Implementasi dari abstraksi**
```kotlin
package com.example.solidprinciples.data

/**
 * Implementasi repository dari abstraksi domain
 * Details (implementasi) tergantung pada abstraksi
 */
class UserRepositoryImpl(
    private val localDataSource: UserLocalDataSource,
    private val remoteDataSource: UserRemoteDataSource
) : UserRepository {
    
    override suspend fun getUserById(id: String): User? {
        return localDataSource.getUserById(id) ?: remoteDataSource.fetchUserById(id).also { user ->
            user?.let { localDataSource.saveUser(it) }
        }
    }
    
    override suspend fun saveUser(user: User) {
        remoteDataSource.saveUser(user)
        localDataSource.saveUser(user)
    }
    
    override suspend fun deleteUser(id: String) {
        remoteDataSource.deleteUser(id)
        localDataSource.deleteUser(id)
    }
    
    override fun getUsersStream(): Flow<List<User>> {
        return localDataSource.getUsersStream()
    }
}

interface UserLocalDataSource {
    suspend fun getUserById(id: String): User?
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
    fun getUsersStream(): Flow<List<User>>
}

interface UserRemoteDataSource {
    suspend fun fetchUserById(id: String): User?
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
}
```

### DIP dalam Dependency Injection:

**Menggunakan Hilt untuk dependency injection**
```kotlin
package com.example.solidprinciples.di

import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {
    
    @Provides
    @Singleton
    fun provideUserRepository(
        localDataSource: UserLocalDataSource,
        remoteDataSource: UserRemoteDataSource
    ): UserRepository {
        // Return implementasi konkret, tapi yang digunakan adalah interface
        return UserRepositoryImpl(localDataSource, remoteDataSource)
    }
}

@Module  
@InstallIn(SingletonComponent::class)
object DataSourceModule {
    
    @Provides
    @Singleton
    fun provideLocalDataSource(): UserLocalDataSource {
        return RoomUserLocalDataSource()
    }
    
    @Provides
    @Singleton
    fun provideRemoteDataSource(): UserRemoteDataSource {
        return RetrofitUserRemoteDataSource()
    }
}

// Implementasi konkret
class RoomUserLocalDataSource : UserLocalDataSource {
    // Implementasi Room database
    override suspend fun getUserById(id: String): User? = TODO()
    override suspend fun saveUser(user: User) = TODO()
    override suspend fun deleteUser(id: String) = TODO()
    override fun getUsersStream(): Flow<List<User>> = TODO()
}

class RetrofitUserRemoteDataSource : UserRemoteDataSource {
    // Implementasi Retrofit API
    override suspend fun fetchUserById(id: String): User? = TODO()
    override suspend fun saveUser(user: User) = TODO()
    override suspend fun deleteUser(id: String) = TODO()
}
```

**ViewModel yang menggunakan dependency injection**
```kotlin
package com.example.solidprinciples.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.solidprinciples.domain.repository.UserRepository
import com.example.solidprinciples.domain.usecase.GetUserUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import javax.inject.Inject

@HiltViewModel
class UserViewModel @Inject constructor(
    // DIP in action: tergantung pada abstraksi, bukan implementasi
    private val getUserUseCase: GetUserUseCase,
    private val repository: UserRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow<UserUiState>(UserUiState.Idle)
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()

    private val _searchQuery = MutableStateFlow("")
    private val usersFlow = repository.getUsersStream()
    
    val filteredUsers: StateFlow<List<User>> = _searchQuery
        .combine(usersFlow) { query, users ->
            if (query.isBlank()) {
                users
            } else {
                users.filter { it.name.contains(query, ignoreCase = true) }
            }
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

    fun searchUsers(query: String) {
        _searchQuery.value = query
    }

    suspend fun loadUser(userId: String) {
        _uiState.value = UserUiState.Loading
        try {
            val user = getUserUseCase(userId)
            _uiState.value = if (user != null) {
                UserUiState.Success(user)
            } else {
                UserUiState.Error("User not found")
            }
        } catch (e: Exception) {
            _uiState.value = UserUiState.Error(e.message ?: "Unknown error")
        }
    }
}
```

### Manfaat DIP dalam Testing:

**‚úÖ Mudah diuji karena dependency bisa dimock**
```kotlin
package com.example.solidprinciples.test

import io.mockk.coEvery
import io.mockk.mockk
import kotlinx.coroutines.test.runTest
import kotlin.test.Test
import kotlin.test.assertEquals

class UserViewModelTest {
    
    @Test
    fun `should load user successfully`() = runTest {
        // Given
        val mockRepository = mockk<UserRepository>()
        val mockUseCase = mockk<GetUserUseCase>()
        val viewModel = UserViewModel(mockUseCase, mockRepository)
        
        val testUser = User("1", "John Doe", "john@example.com")
        
        coEvery { mockUseCase("1") } returns testUser
        
        // When
        viewModel.loadUser("1")
        
        // Then
        // Verifikasi state atau perilaku
    }
    
    @Test
    fun `should handle error when user not found`() = runTest {
        // Given
        val mockUseCase = mockk<GetUserUseCase>()
        val viewModel = UserViewModel(mockUseCase, mockk())
        
        coEvery { mockUseCase("nonexistent") } returns null
        
        // When
        viewModel.loadUser("nonexistent")
        
        // Then
        // Verifikasi error state
    }
}
```

### DIP dalam Plugin Architecture:

**‚úÖ Fleksibel untuk penggantian implementasi**
```kotlin
package com.example.solidprinciples.plugins

/**
 * Interface sebagai kontrak plugin
 */
interface AuthenticationProvider {
    suspend fun authenticate(credentials: Credentials): AuthenticationResult
    suspend fun logout(): Boolean
}

/**
 * Bisa diganti-ganti tanpa mengubah high-level module
 */
class FirebaseAuthenticationProvider : AuthenticationProvider {
    override suspend fun authenticate(credentials: Credentials): AuthenticationResult {
        // Implementasi Firebase Auth
        return AuthenticationResult.Success("firebase_user_id")
    }
    
    override suspend fun logout(): Boolean {
        // Implementasi Firebase logout
        return true
    }
}

class CustomAuthenticationProvider : AuthenticationProvider {
    override suspend fun authenticate(credentials: Credentials): AuthenticationResult {
        // Implementasi custom auth
        return AuthenticationResult.Success("custom_user_id")
    }
    
    override suspend fun logout(): Boolean {
        // Implementasi custom logout
        return true
    }
}

/**
 * High-level module tidak peduli implementasi apa yang digunakan
 */
class AuthManager(
    private val authProvider: AuthenticationProvider
) {
    suspend fun login(username: String, password: String): AuthenticationResult {
        val credentials = Credentials(username, password)
        return authProvider.authenticate(credentials)
    }
    
    suspend fun userLogout(): Boolean {
        return authProvider.logout()
    }
}

data class Credentials(val username: String, val password: String)

sealed class AuthenticationResult {
    data class Success(val userId: String) : AuthenticationResult()
    data class Failure(val error: String) : AuthenticationResult()
}
```

### üéì Penjelasan Konsep:
**DIP seperti Sistem Modul:**
- **Seperti sistem komputer** - CPU tidak tergantung VGA tertentu, keduanya tergantung pada interface PCI-E
- **Seperti sistem listrik** - perangkat tidak tergantung sumber listrik tertentu, semuanya tergantung pada standar socket
- **Seperti kontrak kerja** - tidak tergantung individu, tapi tergantung peran dan tanggung jawab

**Manfaat DIP:**
- **Loose Coupling**: Ketergantungan lemah antar komponen
- **Testability**: Mudah diganti dengan mock untuk testing
- **Flexibility**: Implementasi bisa diganti tanpa merusak high-level modules
- **Maintainability**: Perubahan di low-level tidak mempengaruhi high-level

---

## 7Ô∏è‚É£ SOLID dalam Android Architecture üèóÔ∏è

### Konsep Dasar
SOLID dalam Android Architecture seperti fondasi gedung pencakar langit üè¢ - setiap prinsip bekerja bersama menciptakan struktur yang kuat!

### Overview SOLID dalam Android:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PRESENTATION  ‚îÇ    ‚îÇ    DOMAIN        ‚îÇ    ‚îÇ     DATA        ‚îÇ
‚îÇ   ViewModel     ‚îÇ ‚Üê‚Üí ‚îÇ   Use Cases      ‚îÇ ‚Üê‚Üí ‚îÇ   Repository    ‚îÇ
‚îÇ   UI            ‚îÇ    ‚îÇ   Interfaces     ‚îÇ    ‚îÇ   Implementations‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                       ‚îÇ                        ‚îÇ
       ‚ñº                       ‚ñº                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   COMPOSABLES   ‚îÇ    ‚îÇ     MODEL        ‚îÇ    ‚îÇ Data Sources    ‚îÇ
‚îÇ   Activities    ‚îÇ    ‚îÇ     Entities     ‚îÇ    ‚îÇ API, Database   ‚îÇ
‚îÇ   Fragments     ‚îÇ    ‚îÇ   Validation     ‚îÇ    ‚îÇ SharedPrefs     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 1. SOLID dalam ViewModel Layer:

**SRP - ViewModel hanya mengelola UI State:**
```kotlin
package com.example.solidarchitecture.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.solidarchitecture.domain.usecase.GetUserUseCase
import com.example.solidarchitecture.domain.usecase.GetUsersUseCase
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

/**
 * ‚úÖ SRP: Hanya mengelola state untuk UI
 * - Tidak ada logika bisnis
 * - Tidak ada akses data langsung
 * - Hanya koordinasi antar use cases
 */
class UserListViewModel(
    private val getUsersUseCase: GetUsersUseCase,
    private val getUserUseCase: GetUserUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(UserListUiState())
    val uiState: StateFlow<UserListUiState> = _uiState.asStateFlow()

    private val _searchQuery = MutableStateFlow("")

    init {
        observeUserChanges()
    }

    private fun observeUserChanges() {
        viewModelScope.launch {
            combine(
                getUsersUseCase(),
                _searchQuery
            ) { users, query ->
                if (query.isBlank()) {
                    users
                } else {
                    users.filter { it.name.contains(query, ignoreCase = true) }
                }
            }.collect { users ->
                _uiState.update { currentState ->
                    currentState.copy(
                        users = users,
                        isLoading = false
                    )
                }
            }
        }
    }

    fun searchUsers(query: String) {
        _searchQuery.value = query
    }

    fun loadUser(userId: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            try {
                val user = getUserUseCase(userId)
                _uiState.update { currentState ->
                    currentState.copy(
                        selectedUser = user,
                        isLoading = false
                    )
                }
            } catch (e: Exception) {
                _uiState.update { currentState ->
                    currentState.copy(
                        error = e.message,
                        isLoading = false
                    )
                }
            }
        }
    }
}

data class UserListUiState(
    val users: List<User> = emptyList(),
    val selectedUser: User? = null,
    val isLoading: Boolean = false,
    val error: String? = null
)
```

**OCP - Mudah diperluas tanpa modifikasi:**
```kotlin
/**
 * ViewModel base yang bisa diperluas
 */
abstract class BaseViewModel<T> : ViewModel() {
    
    protected val _uiState = MutableStateFlow(createInitialState())
    val uiState: StateFlow<T> = _uiState.asStateFlow()
    
    protected abstract fun createInitialState(): T
    
    protected fun updateState(newState: (T) -> T) {
        _uiState.update(newState)
    }
}

/**
 * Extensi untuk user-specific logic
 */
class UserProfileViewModel(
    private val getUserProfileUseCase: GetUserProfileUseCase,
    private val updateUserProfileUseCase: UpdateUserProfileUseCase
) : BaseViewModel<UserProfileUiState>() {
    
    override fun createInitialState(): UserProfileUiState {
        return UserProfileUiState.Loading
    }
    
    fun loadUserProfile(userId: String) {
        viewModelScope.launch {
            updateState { UserProfileUiState.Loading }
            try {
                val profile = getUserProfileUseCase(userId)
                updateState { UserProfileUiState.Success(profile) }
            } catch (e: Exception) {
                updateState { UserProfileUiState.Error(e.message ?: "Unknown error") }
            }
        }
    }
}

sealed class UserProfileUiState {
    object Loading : UserProfileUiState()
    data class Success(val profile: UserProfile) : UserProfileUiState()
    data class Error(val message: String) : UserProfileUiState()
}
```

**DIP - Terpisah dari implementasi:**
```kotlin
/**
 * ‚úÖ DIP: Bergantung pada abstraksi, bukan implementasi
 */
class LoginViewModel(
    // Interface, bukan implementasi konkrit
    private val loginUseCase: LoginUseCase,
    private val analyticsService: AnalyticsService
) : ViewModel() {
    
    private val _loginState = MutableStateFlow<LoginState>(LoginState.Idle)
    val loginState: StateFlow<LoginState> = _loginState.asStateFlow()
    
    fun loginUser(credentials: LoginCredentials) {
        viewModelScope.launch {
            _loginState.value = LoginState.Loading
            
            try {
                val result = loginUseCase(credentials)
                if (result.isSuccess) {
                    analyticsService.logEvent("login_success")
                    _loginState.value = LoginState.Success(result.getOrThrow())
                } else {
                    analyticsService.logEvent("login_failed")
                    _loginState.value = LoginState.Error(result.exceptionOrNull()?.message ?: "Login failed")
                }
            } catch (e: Exception) {
                _loginState.value = LoginState.Error(e.message ?: "Unknown error")
            }
        }
    }
}

interface LoginUseCase {
    suspend operator fun invoke(credentials: LoginCredentials): Result<User>
}

interface AnalyticsService {
    suspend fun logEvent(eventName: String, properties: Map<String, Any> = emptyMap())
}

data class LoginCredentials(
    val username: String,
    val password: String
)

sealed class LoginState {
    object Idle : LoginState()
    object Loading : LoginState()
    data class Success(val user: User) : LoginState()
    data class Error(val message: String) : LoginState()
}
```

### 2. SOLID dalam Repository Layer:

**SRP - Repository hanya satu tanggung jawab:**
```kotlin
/**
 * ‚úÖ SRP: UserRepository hanya mengurus user data
 */
interface UserRepository {
    suspend fun getUserById(id: String): User?
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
    fun observeUsers(): Flow<List<User>>
}

/**
 * ‚úÖ SRP: OrderRepository hanya mengurus order data
 */
interface OrderRepository {
    suspend fun getOrdersByUserId(userId: String): List<Order>
    suspend fun saveOrder(order: Order)
    suspend fun getOrderById(id: String): Order?
    fun observeOrdersByUserId(userId: String): Flow<List<Order>>
}

/**
 * ‚úÖ SRP: PreferenceRepository hanya mengurus shared preferences
 */
interface PreferenceRepository {
    suspend fun saveString(key: String, value: String)
    suspend fun getString(key: String, defaultValue: String = ""): String
    suspend fun saveBoolean(key: String, value: Boolean)
    suspend fun getBoolean(key: String, defaultValue: Boolean = false): Boolean
}
```

**ISP - Interface tersegmentasi:**
```kotlin
/**
 * Interface kecil dan fokus - mengikuti ISP
 */
interface ReadRepository<T, ID> {
    suspend fun findById(id: ID): T?
    suspend fun findAll(): List<T>
}

interface WriteRepository<T, ID> {
    suspend fun save(entity: T): T
    suspend fun update(entity: T): T
    suspend fun delete(id: ID): Boolean
}

interface SearchRepository<T> {
    suspend fun search(query: String): List<T>
}

/**
 * Komposisi interface sesuai kebutuhan
 */
interface UserReadRepository : ReadRepository<User, String>, SearchRepository<User>
interface UserWriteRepository : WriteRepository<User, String>

/**
 * Repository lengkap jika dibutuhkan
 */
interface CompleteUserRepository : 
    UserReadRepository, 
    UserWriteRepository,
    FlowRepository<User>
```

**DIP - Repository interface di domain layer:**
```kotlin
/**
 * ‚úÖ DIP: Interface didefinisikan di domain layer
 * Data layer mengimplementasi interface ini
 */
interface UserRepository {
    suspend fun getUserById(id: String): User?
    suspend fun getUsers(): List<User>
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
    fun observeUsers(): Flow<List<User>>
}

/**
 * ‚úÖ DIP: Implementasi mengikuti abstraksi
 */
class UserRepositoryImpl(
    private val remoteDataSource: UserRemoteDataSource,
    private val localDataSource: UserLocalDataSource
) : UserRepository {
    
    override suspend fun getUserById(id: String): User? {
        // Coba lokal dulu, jika tidak ada maka dari remote
        return localDataSource.getUserById(id)
            ?: remoteDataSource.getUserById(id)?.also { user ->
                // Cache ke lokal
                localDataSource.saveUser(user)
            }
    }
    
    override suspend fun getUsers(): List<User> {
        return localDataSource.getUsers()
    }
    
    override suspend fun saveUser(user: User) {
        // Simpan ke remote dan lokal
        remoteDataSource.saveUser(user)
        localDataSource.saveUser(user)
    }
    
    override suspend fun deleteUser(id: String) {
        // Hapus dari remote dan lokal
        remoteDataSource.deleteUser(id)
        localDataSource.deleteUser(id)
    }
    
    override fun observeUsers(): Flow<List<User>> {
        return localDataSource.observeUsers()
    }
}
```

### 3. SOLID dalam Use Case Layer:

**SRP - Setiap Use Case hanya satu tanggung jawab:**
```kotlin
/**
 * ‚úÖ SRP: Hanya satu tanggung jawab
 */
class GetUserByIdUseCase(
    private val repository: UserRepository
) {
    suspend operator fun invoke(userId: String): User? {
        return repository.getUserById(userId)
    }
}

/**
 * ‚úÖ SRP: Hanya satu tanggung jawab
 */
class CreateNewUserUseCase(
    private val repository: UserRepository,
    private val validator: UserValidator
) {
    suspend operator fun invoke(userData: UserData): Result<String> {
        // Validasi
        val validation = validator.validate(userData)
        if (!validation.isValid) {
            return Result.failure(Exception(validation.errors.joinToString(", ")))
        }
        
        // Buat user baru
        val user = User(
            id = generateId(),
            name = userData.name,
            email = userData.email
        )
        
        return try {
            repository.saveUser(user)
            Result.success(user.id)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private fun generateId(): String = "user_${System.currentTimeMillis()}"
}

/**
 * ‚úÖ SRP: Hanya satu tanggung jawab  
 */
class ValidateUserUseCase(
    private val validator: UserValidator
) {
    operator fun invoke(userData: UserData): ValidationResult {
        return validator.validate(userData)
    }
}
```

**OCP - Mudah diperluas:**
```kotlin
/**
 * Base interface untuk semua user use cases
 */
interface UserUseCase<in Input, out Output> {
    suspend operator fun invoke(input: Input): Output
}

/**
 * Specific use case implementations
 */
class GetUserByIdUseCase(
    private val repository: UserRepository
) : UserUseCase<String, User?> {
    override suspend fun invoke(input: String): User? {
        return repository.getUserById(input)
    }
}

class GetUsersWithFilterUseCase(
    private val repository: UserRepository
) : UserUseCase<UserFilter, List<User>> {
    override suspend fun invoke(input: UserFilter): List<User> {
        val allUsers = repository.getUsers()
        return allUsers.filter { user ->
            var match = true
            if (input.isActive != null) match = match && user.isActive == input.isActive
            if (input.minAge != null) match = match && user.age >= input.minAge
            if (input.maxAge != null) match = match && user.age <= input.maxAge
            match
        }
    }
}

data class UserFilter(
    val isActive: Boolean? = null,
    val minAge: Int? = null,
    val maxAge: Int? = null
)
```

**DIP - Bergantung pada abstraksi:**
```kotlin
/**
 * ‚úÖ DIP: Use Case tergantung pada repository interface
 * Bukan pada implementasi konkrit
 */
class ProcessUserRegistrationUseCase(
    // Interface, bukan implementasi
    private val userRepository: UserRepository,
    private val emailService: EmailService,
    private val analyticsService: AnalyticsService
) {
    suspend operator fun invoke(request: RegistrationRequest): RegistrationResult {
        return try {
            // Validasi
            if (!isValidRequest(request)) {
                return RegistrationResult.Error("Invalid registration request")
            }
            
            // Cek apakah user sudah ada
            if (userRepository.getUserById(request.email) != null) {
                return RegistrationResult.Error("User already exists")
            }
            
            // Buat user baru
            val user = User(
                id = request.email, // atau generate ID baru
                name = request.name,
                email = request.email,
                isActive = false,
                isVerified = false
            )
            
            // Simpan user
            userRepository.saveUser(user)
            
            // Kirim email verifikasi
            emailService.sendVerificationEmail(user.email, generateVerificationToken(user.id))
            
            // Log analytics
            analyticsService.logEvent("user_registered", mapOf("userId" to user.id))
            
            RegistrationResult.Success(user.id)
            
        } catch (e: Exception) {
            analyticsService.logEvent("registration_failed", mapOf("error" to e.message))
            RegistrationResult.Error("Registration failed: ${e.message}")
        }
    }
    
    private fun isValidRequest(request: RegistrationRequest): Boolean {
        return request.name.isNotBlank() && 
               request.email.isNotBlank() && 
               request.email.contains("@")
    }
    
    private fun generateVerificationToken(userId: String): String {
        return "token_${userId}_${System.currentTimeMillis()}"
    }
}

interface EmailService {
    suspend fun sendVerificationEmail(to: String, token: String)
}

data class RegistrationRequest(
    val name: String,
    val email: String,
    val password: String
)

sealed class RegistrationResult {
    data class Success(val userId: String) : RegistrationResult()
    data class Error(val message: String) : RegistrationResult()
}
```

### 4. SOLID dalam Data Layer:

**LSP - Implementasi memenuhi kontrak:**
```kotlin
/**
 * ‚úÖ LSP: Semua implementasi memenuhi kontrak yang sama
 */
interface UserRemoteDataSource {
    suspend fun getUserById(id: String): User?
    suspend fun saveUser(user: User): User
    suspend fun deleteUser(id: String): Boolean
}

/**
 * ‚úÖ LSP: Mengikuti semua kontrak tanpa merusak behavior
 */
class ProductionUserRemoteDataSource : UserRemoteDataSource {
    override suspend fun getUserById(id: String): User? {
        // Implementasi production
        return null
    }
    
    override suspend fun saveUser(user: User): User {
        // Implementasi production
        return user
    }
    
    override suspend fun deleteUser(id: String): Boolean {
        // Implementasi production
        return true
    }
}

/**
 * ‚úÖ LSP: Bisa menggantikan implementasi tanpa merusak
 */
class MockUserRemoteDataSource : UserRemoteDataSource {
    private val users = mutableMapOf<String, User>()
    
    override suspend fun getUserById(id: String): User? {
        // Implementasi mock - tetap mengikuti kontrak
        return users[id]
    }
    
    override suspend fun saveUser(user: User): User {
        // Implementasi mock - tetap mengikuti kontrak
        users[user.id] = user
        return user
    }
    
    override suspend fun deleteUser(id: String): Boolean {
        // Implementasi mock - tetap mengikuti kontrak
        return users.remove(id) != null
    }
}
```

**ISP - Interface kecil dan spesifik:**
```kotlin
/**
 * Interface-interface kecil sesuai kebutuhan
 */
interface NetworkDataSource<T> {
    suspend fun fetch(): List<T>
    suspend fun fetchById(id: String): T?
    suspend fun upload(item: T): T
    suspend fun delete(id: String): Boolean
}

interface LocalDataSource<T> {
    suspend fun read(): List<T>
    suspend fun readById(id: String): T?
    suspend fun write(item: T): T
    suspend fun remove(id: String): Boolean
    fun observe(): Flow<List<T>>
}

interface CacheDataSource<T> {
    suspend fun getCached(key: String): T?
    suspend fun cache(key: String, item: T)
    suspend fun clearCache()
}

/**
 * Repository bisa memilih interface yang dibutuhkan
 */
class UserRepositoryImpl(
    private val remoteDataSource: NetworkDataSource<User>,
    private val localDataSource: LocalDataSource<User>,
    private val cacheDataSource: CacheDataSource<User>
) : UserRepository {
    // Implementasi menggunakan berbagai interface kecil
}
```

### üéì Penjelasan Konsep:
**SOLID dalam Android Architecture seperti Rumah Bertingkat:**
- **Setiap lapisan punya tanggung jawab** - tidak saling campur
- **Komunikasi lewat interface** - tidak langsung ke implementasi
- **Bisa diganti-ganti** tanpa merusak struktur keseluruhan
- **Mudah dipelihara dan diperluas**

**Manfaat SOLID dalam Android Architecture:**
- **Maintainability**: Mudah dipelihara karena terstruktur
- **Testability**: Bisa diuji komponen per komponen
- **Flexibility**: Mudah diubah tanpa merusak bagian lain
- **Scalability**: Bisa berkembang tanpa merusak arsitektur

---

## 8Ô∏è‚É£ Code Refactoring dengan SOLID üîß

### Konsep Dasar
Code Refactoring dengan SOLID seperti renovasi rumah üî® - perbaiki struktur tanpa merusak fondasi!

### Identifying SOLID Violations:

**1. Large Classes (SRP Violation):**
```kotlin
// ‚ùå Violation: God Class - terlalu besar dan kompleks
class GodClass {
    // Network operations
    fun makeApiCall() { }
    fun handleResponse() { }
    fun processNetworkError() { }
    
    // Database operations  
    fun saveToDatabase() { }
    fun readFromDatabase() { }
    fun updateDatabase() { }
    
    // UI operations
    fun updateUI() { }
    fun showLoading() { }
    fun showError() { }
    
    // Analytics operations
    fun logEvent() { }
    fun trackUserAction() { }
    
    // File operations
    fun saveToFile() { }
    fun readFromFile() { }
    
    // Validation operations
    fun validateEmail() { }
    fun validatePassword() { }
    
    // Banyak method lain...
}
```

**Refactoring ke SRP-compliant:**
```kotlin
// ‚úÖ Compliant: Pisahkan ke beberapa class dengan tanggung jawab tunggal
interface ApiClient {
    suspend fun makeCall(request: ApiRequest): ApiResponse
}

class NetworkRepository(override val apiClient: ApiClient) : ApiClient by apiClient

interface DatabaseHelper {
    suspend fun save(entity: Any): Long
    suspend fun read(type: String): List<Any>
}

interface UiUpdater<in T> {
    fun update(data: T)
    fun showLoading()
    fun showError(message: String)
}

interface AnalyticsTracker {
    fun logEvent(eventName: String, properties: Map<String, Any> = emptyMap())
}

interface FileStorage {
    suspend fun save(filename: String, data: String): Boolean
    suspend fun read(filename: String): String?
}

interface DataValidator<T> {
    fun validate(data: T): ValidationResult
}
```

**2. Hard to Extend (OCP Violation):**
```kotlin
// ‚ùå Violation: Harus dimodifikasi untuk tambah fitur baru
class PaymentProcessor {
    fun processPayment(type: String, amount: Double): PaymentResult {
        return when (type) {
            "credit" -> processCreditCard(amount)
            "debit" -> processDebitCard(amount) 
            "paypal" -> processPayPal(amount)
            "apple_pay" -> processApplePay(amount)
            // Setiap kali ada metode baru, harus tambah case
            else -> PaymentResult.Error("Unsupported payment type")
        }
    }
    
    private fun processCreditCard(amount: Double): PaymentResult { /* ... */ }
    private fun processDebitCard(amount: Double): PaymentResult { /* ... */ }
    private fun processPayPal(amount: Double): PaymentResult { /* ... */ }
    private fun processApplePay(amount: Double): PaymentResult { /* ... */ }
}
```

**Refactoring ke OCP-compliant:**
```kotlin
// ‚úÖ Compliant: Extend tanpa modification
interface PaymentMethod {
    suspend fun validate(): ValidationResult
    suspend fun process(amount: Double): PaymentResult
    fun getFee(amount: Double): Double
}

class CreditCardPayment(
    private val cardInfo: CardInfo
) : PaymentMethod {
    override suspend fun validate(): ValidationResult {
        // validasi kartu kredit
        return ValidationResult.Success
    }
    
    override suspend fun process(amount: Double): PaymentResult {
        // proses pembayaran kartu kredit
        return PaymentResult.Success("Credit card processed: $$amount")
    }
    
    override fun getFee(amount: Double): Double = amount * 0.029 + 0.30
}

class PayPalPayment(
    private val email: String,
    private val password: String
) : PaymentMethod {
    override suspend fun validate(): ValidationResult {
        // validasi PayPal
        return ValidationResult.Success
    }
    
    override suspend fun process(amount: Double): PaymentResult {
        // proses pembayaran PayPal
        return PaymentResult.Success("PayPal processed: $$amount")
    }
    
    override fun getFee(amount: Double): Double = amount * 0.034 + 0.49
}

class PaymentProcessor {
    suspend fun process(paymentMethod: PaymentMethod, amount: Double): PaymentResult {
        return paymentMethod.process(amount)
    }
}

// Tambah metode pembayaran baru TANPA modification
class CryptoPayment(
    private val walletAddress: String
) : PaymentMethod {
    override suspend fun validate(): ValidationResult {
        // validasi crypto
        return ValidationResult.Success
    }
    
    override suspend fun process(amount: Double): PaymentResult {
        // proses pembayaran crypto
        return PaymentResult.Success("Crypto processed: $$amount")
    }
    
    override fun getFee(amount: Double): Double = 0.001 // biaya sangat rendah
}
```

**3. Fragile Inheritance (LSP Violation):**
```kotlin
// ‚ùå Violation: Subclass merusak behavior parent
open class Bird {
    open fun fly() { println("Bird is flying") }
    open fun eat() { println("Bird is eating") }
}

class Ostrich : Bird() {
    // Melanggar LSP: struktur behavior berbeda
    override fun fly() { 
        throw UnsupportedOperationException("Ostrich cannot fly!") 
    }
    // Ostrich seharusnya tidak punya method fly!
}
```

**Refactoring ke LSP-compliant:**
```kotlin
// ‚úÖ Compliant: Abstraction yang benar
interface Animal {
    fun eat()
    fun move()
}

interface FlyingCreature {
    fun fly()
}

class Bird : Animal, FlyingCreature {
    override fun eat() { println("Bird is eating") }
    override fun move() { println("Bird is moving") }
    override fun fly() { println("Bird is flying") }
}

class Ostrich : Animal { // Ostrich tidak implement FlyingCreature
    override fun eat() { println("Ostrich is eating") }
    override fun move() { println("Ostrich is running") }
    // Tidak ada method fly - tidak melanggar LSP
}
```

### Refactoring Steps:

**Step 1: Identify Violations**
```kotlin
// Kode lama dengan banyak pelanggaran
class UserManager {
    fun getUser(id: String): User? = database.find(id)
    fun saveUser(user: User) = database.save(user)
    fun sendWelcomeEmail(user: User) = emailService.send(email)
    fun logUserAction(action: String) = logger.info(action)
    fun calculateUserScore(user: User): Int {
        return when {
            user.joinDate < System.currentTimeMillis() - 365.days -> 100
            user.joinDate < System.currentTimeMillis() - 30.days -> 50
            else -> 10
        }
    }
    fun validateUser(user: User): Boolean = user.email.contains("@")
    
    // Properties dari berbagai layer
    private val database = Database()
    private val emailService = EmailService()
    private val logger = Logger()
}
```

**Step 2: Extract Responsibilities (SRP)**
```kotlin
// Ekstrak masing-masing tanggung jawab ke class terpisah
class UserProvider(
    private val repository: UserRepository
) {
    suspend fun getUser(id: String): User? = repository.findById(id)
    suspend fun saveUser(user: User) = repository.save(user)
}

class UserNotificationService(
    private val emailService: EmailService
) {
    suspend fun sendWelcomeEmail(user: User) = emailService.sendWelcomeEmail(user)
}

class UserScoreCalculator {
    fun calculateScore(user: User): Int {
        return when {
            user.joinDate < System.currentTimeMillis() - 365.days.toLong() -> 100
            user.joinDate < System.currentTimeMillis() - 30.days.toLong() -> 50
            else -> 10
        }
    }
}

class UserValidator {
    fun validate(user: User): ValidationResult {
        return if (user.email.contains("@")) {
            ValidationResult.Success
        } else {
            ValidationResult.Failure("Invalid email")
        }
    }
}

sealed class ValidationResult {
    object Success : ValidationResult()
    data class Failure(val message: String) : ValidationResult()
}
```

**Step 3: Create Abstractions (DIP)**
```kotlin
// Buat interface sebagai kontrak
interface UserRepository {
    suspend fun findById(id: String): User?
    suspend fun save(user: User)
}

interface EmailService {
    suspend fun sendWelcomeEmail(user: User)
}

interface Logger {
    fun info(message: String)
}

// Implementasi konkrit
class DatabaseUserRepository : UserRepository {
    override suspend fun findById(id: String): User? = TODO()
    override suspend fun save(user: User) = TODO()
}

class SMTPEmailService : EmailService {
    override suspend fun sendWelcomeEmail(user: User) = TODO()
}

class FileLogger : Logger {
    override fun info(message: String) = TODO()
}
```

**Step 4: Implement High-level Module**
```kotlin
// High-level module yang bergantung pada abstraksi
class UserRegistrationService(
    private val userRepository: UserRepository,
    private val emailService: EmailService,
    private val validator: UserValidator,
    private val scoreCalculator: UserScoreCalculator,
    private val logger: Logger
) {
    suspend fun registerUser(userData: UserData): RegistrationResult {
        logger.info("Starting user registration")
        
        val user = User(
            id = generateId(),
            name = userData.name,
            email = userData.email,
            joinDate = System.currentTimeMillis()
        )
        
        val validation = validator.validate(user)
        if (validation is ValidationResult.Failure) {
            logger.info("Registration failed: ${validation.message}")
            return RegistrationResult.Failure(validation.message)
        }
        
        val score = scoreCalculator.calculateScore(user)
        val userWithScore = user.copy(score = score)
        
        userRepository.save(userWithScore)
        emailService.sendWelcomeEmail(userWithScore)
        
        logger.info("User registration completed: ${user.id}")
        return RegistrationResult.Success(userWithScore)
    }
    
    private fun generateId(): String = "user_${System.currentTimeMillis()}"
}

data class UserData(
    val name: String,
    val email: String
)

sealed class RegistrationResult {
    data class Success(val user: User) : RegistrationResult()
    data class Failure(val message: String) : RegistrationResult()
}
```

### Refactoring Tools dan Teknik:

**1. Extract Interface:**
```kotlin
// Sebelum: Konkrit class digunakan langsung
class RealUserRepository {
    suspend fun getUser(id: String): User? = TODO()
    suspend fun saveUser(user: User) = TODO()
}

class ServiceClass(
    private val userRepository: RealUserRepository // Tergantung konkrit
) {
    suspend fun doSomething(userId: String) {
        val user = userRepository.getUser(userId)
        // ...
    }
}

// Sesudah: Extract interface
interface UserRepository {
    suspend fun getUser(id: String): User?
    suspend fun saveUser(user: User)
}

class RealUserRepository : UserRepository {
    override suspend fun getUser(id: String): User? = TODO()
    override suspend fun saveUser(user: User) = TODO()
}

class ServiceClass(
    private val userRepository: UserRepository // Sekarang tergantung abstraksi
) {
    suspend fun doSomething(userId: String) {
        val user = userRepository.getUser(userId)
        // ...
    }
}
```

**2. Composition over Inheritance:**
```kotlin
// Sebelum: Gunakan inheritance
abstract class BaseService {
    protected val logger = Logger()
    protected val timer = Timer()
}

class UserService : BaseService() {
    fun registerUser() {
        timer.start()
        logger.info("Starting user registration")
        // logic
        logger.info("User registration completed")
        timer.stop()
    }
}

// Sesudah: Gunakan composition
interface Service {
    fun execute()
}

class UserService(
    private val logger: Logger,
    private val timer: Timer
) : Service {
    override fun execute() {
        timer.start()
        logger.info("Starting user registration")
        // logic
        logger.info("User registration completed") 
        timer.stop()
    }
}

// Bisa digabung dengan decorator pattern
class TimedService(
    private val service: Service,
    private val timer: Timer
) : Service {
    override fun execute() {
        timer.start()
        service.execute()
        timer.stop()
    }
}
```

**3. Replace Conditional with Polymorphism (OCP):**
```kotlin
// Sebelum: Conditional untuk extend
class NotificationService {
    fun sendNotification(type: String, message: String) {
        when (type) {
            "email" -> sendEmail(message)
            "sms" -> sendSms(message)
            "push" -> sendPush(message)
        }
    }
    
    private fun sendEmail(message: String) { /* ... */ }
    private fun sendSms(message: String) { /* ... */ }
    private fun sendPush(message: String) { /* ... */ }
}

// Sesudah: Polymorphism untuk extension
interface NotificationSender {
    suspend fun send(message: String)
}

class EmailNotificationSender : NotificationSender {
    override suspend fun send(message: String) { /* ... */ }
}

class SmsNotificationSender : NotificationSender {
    override suspend fun send(message: String) { /* ... */ }
}

class PushNotificationSender : NotificationSender {
    override suspend fun send(message: String) { /* ... */ }
}

class NotificationService(
    private val notificationSender: NotificationSender
) {
    suspend fun send(message: String) {
        notificationSender.send(message)
    }
}
```

### üéì Penjelasan Konsep:
**Refactoring dengan SOLID seperti Renovasi:**
- **Identifikasi masalah** seperti inspeksi rumah
- **Rencanakan perbaikan** seperti buat desain baru
- **Eksekusi per tahap** seperti kerja bertahap
- **Pastikan tidak rusak** seperti uji coba

**Manfaat Refactoring SOLID:**
- **Improved Code Quality**: Kode lebih bersih dan terstruktur
- **Better Maintainability**: Mudah dipelihara dan diubah
- **Enhanced Testability**: Mudah diuji
- **Increased Flexibility**: Mudah ditambah fitur baru

---

## 9Ô∏è‚É£ SOLID dan Design Patterns üéØ

### Konsep Dasar
SOLID dan Design Patterns seperti alat dan peta navigasi üß≠ - SOLID memberi prinsip, Design Patterns memberi solusi nyata!

### Hubungan SOLID dengan Design Patterns:

```
SOLID Principles ‚Üí Design Patterns ‚Üí Better Architecture
     ‚Üì                  ‚Üì                  ‚Üì
  Foundation      Implementation     Result
```

### 1. Strategy Pattern (OCP):
```kotlin
/**
 * Strategy Pattern mengimplementasi OCP
 * - Buka untuk ekstensi (bisa tambah strategi baru)
 * - Tutup untuk modifikasi (tidak ubah client code)
 */
interface PaymentStrategy {
    suspend fun pay(amount: Double): PaymentResult
}

class CreditCardPaymentStrategy(
    private val cardNumber: String,
    private val cvv: String
) : PaymentStrategy {
    override suspend fun pay(amount: Double): PaymentResult {
        // Implementasi pembayaran kartu kredit
        return PaymentResult.Success("Paid $$amount via Credit Card")
    }
}

class PayPalPaymentStrategy(
    private val email: String,
    private val password: String
) : PaymentStrategy {
    override suspend fun pay(amount: Double): PaymentResult {
        // Implementasi pembayaran PayPal
        return PaymentResult.Success("Paid $$amount via PayPal")
    }
}

class ShoppingCart(
    private var paymentStrategy: PaymentStrategy
) {
    suspend fun checkout(amount: Double): PaymentResult {
        // Tidak perlu diubah saat tambah metode pembayaran baru
        return paymentStrategy.pay(amount)
    }
    
    fun setPaymentMethod(newStrategy: PaymentStrategy) {
        this.paymentStrategy = newStrategy
    }
}

// Ekstensi tanpa modifikasi - OCP in action!
class CryptoPaymentStrategy(
    private val walletAddress: String
) : PaymentStrategy {
    override suspend fun pay(amount: Double): PaymentResult {
        // Implementasi pembayaran cryptocurrency
        return PaymentResult.Success("Paid $$amount via Crypto")
    }
}
```

### 2. Template Method Pattern (OCP, LSP):
```kotlin
/**
 * Template Method Pattern - OCP: extend behavior, LSP: same contract
 */
abstract class DataProcessor<T> {
    
    // Template method - tidak bisa diubah
    final override fun process(data: T): ProcessResult {
        return try {
            val validated = validate(data)
            val transformed = transform(validated)
            val processed = performProcessing(transformed)
            
            ProcessResult.Success(processed)
        } catch (e: Exception) {
            ProcessResult.Error(e.message ?: "Unknown error")
        }
    }
    
    // Abstract methods - harus diimplementasi
    protected abstract fun validate(data: T): T
    protected abstract fun transform(data: T): T
    protected abstract fun performProcessing(data: T): String
    
    // Hook methods - opsional di-override
    protected open fun beforeProcessing(data: T) { }
    protected open fun afterProcessing(result: String) { }
}

class UserDataProcessor : DataProcessor<UserData>() {
    override fun validate(data: UserData): UserData {
        if (data.name.isBlank()) throw IllegalArgumentException("Name required")
        return data.copy(name = data.name.trim())
    }
    
    override fun transform(data: UserData): UserData {
        return data.copy(
            name = data.name.capitalize(),
            email = data.email.lowercase()
        )
    }
    
    override fun performProcessing(data: UserData): String {
        return "Processed user: ${data.name} <${data.email}>"
    }
}

class OrderDataProcessor : DataProcessor<OrderData>() {
    override fun validate(data: OrderData): OrderData {
        if (data.items.isEmpty()) throw IllegalArgumentException("Order must have items")
        return data
    }
    
    override fun transform(data: OrderData): OrderData {
        return data.copy(
            totalAmount = data.items.sumOf { it.price * it.quantity }
        )
    }
    
    override fun performProcessing(data: OrderData): String {
        return "Processed order with ${data.items.size} items, total: $${data.totalAmount}"
    }
}

data class UserData(val name: String, val email: String)
data class OrderData(val items: List<OrderItem>, val totalAmount: Double = 0.0)
data class OrderItem(val name: String, val price: Double, val quantity: Int)

sealed class ProcessResult {
    data class Success(val data: String) : ProcessResult()
    data class Error(val message: String) : ProcessResult()
}
```

### 3. Factory Pattern (DIP):
```kotlin
/**
 * Factory Pattern - DIP: high-level gets abstraction
 */
interface UserRepository {
    suspend fun getUser(id: String): User?
    suspend fun saveUser(user: User)
}

class NetworkUserRepository : UserRepository {
    override suspend fun getUser(id: String): User? = TODO()
    override suspend fun saveUser(user: User) = TODO()
}

class LocalUserRepository : UserRepository {
    override suspend fun getUser(id: String): User? = TODO()
    override suspend fun saveUser(user: User) = TODO()
}

interface RepositoryFactory {
    fun createUserRepository(): UserRepository
}

class ProductionRepositoryFactory : RepositoryFactory {
    override fun createUserRepository(): UserRepository {
        return NetworkUserRepository() // Production implementation
    }
}

class TestRepositoryFactory : RepositoryFactory {
    override fun createUserRepository(): UserRepository {
        return LocalUserRepository() // Test implementation
    }
}

class UserService(
    factory: RepositoryFactory // Tergantung pada abstraksi factory
) {
    private val repository = factory.createUserRepository()
    
    suspend fun getUser(userId: String): User? {
        return repository.getUser(userId)
    }
}
```

### 4. Repository Pattern (DIP, SRP):
```kotlin
/**
 * Repository Pattern - implementasi DIP dan SRP
 */
interface DataSource<T, ID> {
    suspend fun findById(id: ID): T?
    suspend fun findAll(): List<T>
    suspend fun save(entity: T): T
    suspend fun delete(id: ID): Boolean
}

interface NetworkDataSource<T, ID> : DataSource<T, ID> {
    suspend fun sync(): List<T>
}

interface LocalDataSource<T, ID> : DataSource<T, ID> {
    suspend fun clear(): Boolean
}

interface UserRepository : DataSource<User, String> {
    suspend fun findByEmail(email: String): User?
    suspend fun findActiveUsers(): List<User>
}

class UserRepositoryImpl(
    private val localDataSource: LocalDataSource<User, String>,
    private val networkDataSource: NetworkDataSource<User, String>
) : UserRepository {
    
    override suspend fun findById(id: String): User? {
        return localDataSource.findById(id) ?: networkDataSource.findById(id)
    }
    
    override suspend fun findByEmail(email: String): User? {
        // Cari di lokal, jika tidak ada cari di jaringan
        var user = localDataSource.findAll().find { it.email == email }
        if (user == null) {
            // Sinkronisasi dan coba lagi
            networkDataSource.sync()
            user = localDataSource.findAll().find { it.email == email }
        }
        return user
    }
    
    override suspend fun save(entity: User): User {
        // Simpan ke lokal dan jaringan
        val savedLocal = localDataSource.save(entity)
        networkDataSource.save(savedLocal) // Update jaringan
        return savedLocal
    }
    
    // Implementasi lainnya...
    override suspend fun findAll(): List<User> = localDataSource.findAll()
    override suspend fun delete(id: String): Boolean = localDataSource.delete(id)
    override suspend fun findActiveUsers(): List<User> {
        return localDataSource.findAll().filter { it.isActive }
    }
}
```

### 5. Observer Pattern (ISP):
```kotlin
/**
 * Observer Pattern - ISP: small, focused interfaces
 */
interface Observer<T> {
    fun onChanged(data: T)
}

interface Subject<T> {
    fun subscribe(observer: Observer<T>)
    fun unsubscribe(observer: Observer<T>)
    fun notifyObservers(data: T)
}

interface UserObserver : Observer<User> {
    fun onUserUpdated(user: User) = onChanged(user)
}

interface NotificationObserver : Observer<Notification> {
    fun onNotificationReceived(notification: Notification) = onChanged(notification)
}

class UserManager : Subject<User> {
    private val observers = mutableListOf<Observer<User>>()
    
    override fun subscribe(observer: Observer<User>) {
        observers.add(observer)
    }
    
    override fun unsubscribe(observer: Observer<User>) {
        observers.remove(observer)
    }
    
    override fun notifyObservers(data: User) {
        observers.forEach { it.onChanged(data) }
    }
    
    suspend fun updateUser(userId: String, updates: UserUpdates) {
        val user = getUser(userId) // Ambil user
        val updatedUser = user.copy(
            name = updates.name ?: user.name,
            email = updates.email ?: user.email
        )
        saveUser(updatedUser) // Simpan
        notifyObservers(updatedUser) // Beritahu observers
    }
}

data class Notification(val message: String, val timestamp: Long)
data class UserUpdates(val name: String? = null, val email: String? = null)
```

### 6. Decorator Pattern (OCP):
```kotlin
/**
 * Decorator Pattern - OCP: extend functionality without modification
 */
interface DataSource<T, ID> {
    suspend fun findById(id: ID): T?
    suspend fun save(entity: T): T
}

/**
 * Component interface
 */
interface UserService {
    suspend fun findUser(id: String): User?
    suspend fun saveUser(user: User): User
}

class BaseUserService(
    private val repository: UserRepository
) : UserService {
    override suspend fun findUser(id: String): User? {
        return repository.findById(id)
    }
    
    override suspend fun saveUser(user: User): User {
        return repository.save(user)
    }
}

/**
 * Decorator classes - extend without modifying base
 */
class CachingUserService(
    private val baseService: UserService,
    private val cache: Cache<String, User>
) : UserService {
    override suspend fun findUser(id: String): User? {
        // Coba dari cache dulu
        var user = cache.get(id)
        if (user == null) {
            user = baseService.findUser(id)
            user?.let { cache.put(id, it) } // Cache hasilnya
        }
        return user
    }
    
    override suspend fun saveUser(user: User): User {
        val saved = baseService.saveUser(user)
        cache.put(saved.id, saved) // Update cache
        return saved
    }
}

class LoggingUserService(
    private val baseService: UserService,
    private val logger: Logger
) : UserService {
    override suspend fun findUser(id: String): User? {
        logger.info("Finding user: $id")
        val user = baseService.findUser(id)
        logger.info("Found user: ${user?.id}")
        return user
    }
    
    override suspend fun saveUser(user: User): User {
        logger.info("Saving user: ${user.id}")
        val saved = baseService.saveUser(user)
        logger.info("Saved user: ${saved.id}")
        return saved
    }
}

// Bisa digabungkan!
val decoratedService = LoggingUserService(
    CachingUserService(
        BaseUserService(userRepository),
        userCache
    ),
    appLogger
)
```

### 7. Adapter Pattern (ISP):
```kotlin
/**
 * Adapter Pattern - ISP: convert interface to client's expectation
 */
interface NewPaymentApi {
    suspend fun processPayment(amount: Double, currency: String): PaymentResponse
}

interface OldPaymentSystem {
    fun makePayment(amount: Float): Boolean
}

/**
 * Adapter untuk menghubungkan old system ke new interface
 */
class PaymentAdapter(
    private val oldSystem: OldPaymentSystem
) : NewPaymentApi {
    override suspend fun processPayment(amount: Double, currency: String): PaymentResponse {
        // Konversi dari new interface ke old system
        val result = oldSystem.makePayment(amount.toFloat())
        return if (result) {
            PaymentResponse.Success("Payment of $$amount $currency processed")
        } else {
            PaymentResponse.Failure("Payment failed")
        }
    }
}

/**
 * Client bisa gunakan new interface konsisten
 */
class PaymentProcessor(
    private val paymentApi: NewPaymentApi
) {
    suspend fun makePayment(amount: Double): PaymentResponse {
        return paymentApi.processPayment(amount, "USD")
    }
}

// Bisa gunakan adapter untuk old system
val processor = PaymentProcessor(
    PaymentAdapter(OldPaymentSystemImpl())
)

// Atau gunakan implementasi asli
val processor2 = PaymentProcessor(
    ModernPaymentApiImpl()
)
```

### 8. Command Pattern (SRP, DIP):
```kotlin
/**
 * Command Pattern - SRP: each command has single responsibility
 * DIP: high-levelInvoker depends on Command abstraction
 */
interface Command {
    suspend fun execute()
    suspend fun undo()
}

class SendNotificationCommand(
    private val notificationService: NotificationService,
    private val user: User,
    private val message: String
) : Command {
    override suspend fun execute() {
        notificationService.sendNotification(user.email, message)
    }
    
    override suspend fun undo() {
        notificationService.sendNotification(user.email, "Action reverted: $message")
    }
}

class UpdateUserCommand(
    private val repository: UserRepository,
    private val user: User,
    private val updates: UserUpdates
) : Command {
    private var originalUser: User? = null
    
    override suspend fun execute() {
        originalUser = repository.findById(user.id)
        val updatedUser = user.copy(
            name = updates.name ?: user.name,
            email = updates.email ?: user.email
        )
        repository.save(updatedUser)
    }
    
    override suspend fun undo() {
        originalUser?.let { repository.save(it) }
    }
}

class CommandProcessor {
    private val commandHistory = mutableListOf<Command>()
    
    suspend fun executeCommand(command: Command) {
        command.execute()
        commandHistory.add(command)
    }
    
    suspend fun undoLastCommand() {
        commandHistory.removeLastOrNull()?.undo()
    }
}
```

### 9. Dependency Injection (DIP):
```kotlin
/**
 * DI mengimplementasi DIP dengan cara yang elegan
 */
interface DatabaseService {
    suspend fun save<T>(data: T): Boolean
    suspend fun <T> find(id: String): T?
}

interface NetworkService {
    suspend fun request(url: String): String
}

interface Logger {
    fun log(message: String)
}

// High-level module tidak tergantung implementasi
class DataService(
    private val database: DatabaseService,
    private val network: NetworkService,
    private val logger: Logger
) {
    suspend fun syncData(): SyncResult {
        logger.log("Starting data sync")
        try {
            val data = network.request("https://api.example.com/data")
            val success = database.save(data)
            logger.log("Data sync completed: $success")
            return if (success) SyncResult.Success else SyncResult.Failure("Save failed")
        } catch (e: Exception) {
            logger.log("Data sync failed: ${e.message}")
            return SyncResult.Failure(e.message ?: "Unknown error")
        }
    }
}

// Dengan Hilt
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton
    fun provideDatabaseService(): DatabaseService = RoomDatabaseService()
    
    @Provides  
    @Singleton
    fun provideNetworkService(): NetworkService = RetrofitNetworkService()
    
    @Provides
    @Singleton  
    fun provideLogger(): Logger = TimberLogger()
}

@HiltViewModel
class DataViewModel @Inject constructor(
    private val dataService: DataService
) : ViewModel() {
    // Tidak tahu implementasi apa yang digunakan
}
```

### üéì Penjelasan Konsep:
**SOLID & Design Patterns seperti Resep dan Prinsip Memasak:**
- **SOLID memberi prinsip dasar** (rasa seimbang, bahan segar)
- **Design Patterns memberi resep nyata** (cara memasak spesifik)
- **Keduanya bekerja bersama** untuk hasil terbaik

**Manfaat Kombinasi SOLID + Design Patterns:**
- **Structured Solutions**: Solusi terstruktur dan teruji
- **Best Practices**: Mengikuti praktik terbaik industri
- **Maintainability**: Kode mudah dipelihara dan diubah
- **Testability**: Kode mudah diuji

---

## 1Ô∏è‚É£0Ô∏è‚É£ Testing Benefits üß™

### Konsep Dasar
Testing Benefits dari SOLID Principles seperti sistem keamanan bank üè¶ - membuat seluruh proses pengujian menjadi lebih aman dan efisien!

### 1. SRP Benefits in Testing:

**‚úÖ Easier to Test One Thing:**
```kotlin
// Sebelum: God class sulit diuji
class UserManager {
    fun registerUser() { /* logic jaringan, database, email, logging */ }
    fun validateUser() { /* logic validasi kompleks */ }
    fun sendEmail() { /* logic email */ }
    fun logActivity() { /* logic logging */ }
}

// Setelah: Class dengan tanggung jawab tunggal - mudah diuji
class UserRegistrationService(
    private val userRepository: UserRepository,
    private val emailService: EmailService
) {
    suspend fun registerUser(userData: UserData): RegistrationResult {
        val user = User(
            id = generateId(),
            name = userData.name,
            email = userData.email
        )
        
        userRepository.save(user)
        emailService.sendWelcomeEmail(user)
        
        return RegistrationResult.Success(user)
    }
}

// Test menjadi sangat fokus dan sederhana
@Test
fun `registerUser should save user and send email`() = runTest {
    // Given
    val mockRepository = mockk<UserRepository>()
    val mockEmailService = mockk<EmailService>()
    val service = UserRegistrationService(mockRepository, mockEmailService)
    
    val userData = UserData("John Doe", "john@example.com")
    val expectedUser = User("id", "John Doe", "john@example.com")
    
    coEvery { mockRepository.save(any()) } just runs
    coEvery { mockEmailService.sendWelcomeEmail(any()) } just runs
    
    // When
    val result = service.registerUser(userData)
    
    // Then
    coVerify { mockRepository.save(match { it.name == "John Doe" }) }
    coVerify { mockEmailService.sendWelcomeEmail(expectedUser) }
    assertTrue(result is RegistrationResult.Success)
}
```

### 2. OCP Benefits in Testing:

**‚úÖ Test Extension Without Changing Tests:**
```kotlin
// Interface untuk strategy
interface PaymentMethod {
    suspend fun process(amount: Double): PaymentResult
}

// Implementasi awal
class CreditCardPayment : PaymentMethod {
    override suspend fun process(amount: Double): PaymentResult {
        // logic pembayaran kartu kredit
        return PaymentResult.Success("Credit card payment")
    }
}

// Implementasi baru - tidak perlu ubah test
class CryptoPayment : PaymentMethod {
    override suspend fun process(amount: Double): PaymentResult {
        // logic pembayaran crypto
        return PaymentResult.Success("Crypto payment")
    }
}

// Test untuk interface - bekerja untuk semua implementasi
@Test
fun `payment methods should return success for valid amount`() = runTest {
    val paymentMethods = listOf(
        CreditCardPayment(),
        CryptoPayment(),
        PayPalPayment() // implementasi lain
    )
    
    paymentMethods.forEach { method ->
        val result = method.process(100.0)
        assertTrue(result is PaymentResult.Success)
    }
}
```

### 3. LSP Benefits in Testing:

**‚úÖ Easy Mock Substitution:**
```kotlin
// Interface yang diikuti oleh semua implementasi
interface UserRepository {
    suspend fun findById(id: String): User?
    suspend fun save(user: User)
}

// Implementasi production
class DatabaseUserRepository : UserRepository {
    override suspend fun findById(id: String): User? = TODO()
    override suspend fun save(user: User) = TODO()
}

// Implementasi untuk testing
class InMemoryUserRepository : UserRepository {
    private val users = mutableMapOf<String, User>()
    
    override suspend fun findById(id: String): User? = users[id]
    
    override suspend fun save(user: User) {
        users[user.id] = user
    }
}

// Test bisa ganti implementasi dengan mudah
@Test
fun `service should work with any UserRepository implementation`() = runTest {
    val implementations = listOf(
        InMemoryUserRepository(), // untuk testing
        FakeUserRepository()      // alternatif testing
    )
    
    implementations.forEach { repo ->
        val service = UserService(repo)
        
        // Test behavior - tidak peduli implementasi apa
        val user = User("1", "Test", "test@example.com")
        service.createUser(user)
        
        assertTrue(service.getUser("1") != null)
    }
}
```

### 4. ISP Benefits in Testing:

**‚úÖ Mock Only What's Needed:**
```kotlin
// Interface besar - harus mock semua method
interface FatUserService {
    suspend fun getUser(id: String): User?
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
    suspend fun sendEmail(to: String, subject: String, body: String)
    suspend fun logEvent(event: String)
    suspend fun validateUser(user: User): Boolean
    // ... banyak method lain
}

// Interface kecil - hanya mock yang digunakan
interface ReadUserRepository {
    suspend fun getUser(id: String): User?
}

interface WriteUserRepository {
    suspend fun saveUser(user: User)
}

// Dalam test, hanya perlu mock interface kecil
@Test
fun `user reader should return user when exists`() = runTest {
    val mockReadRepo = mockk<ReadUserRepository>()
    val service = UserReaderService(mockReadRepo)
    
    val expectedUser = User("1", "John", "john@example.com")
    coEvery { mockReadRepo.getUser("1") } returns expectedUser
    
    val result = service.findUser("1")
    
    assertEquals(expectedUser, result)
    coVerify { mockReadRepo.getUser("1") }
}
```

### 5. DIP Benefits in Testing:

**‚úÖ Easy Dependency Injection with Mocks:**
```kotlin
// High-level module tergantung abstraksi
class UserService(
    private val userRepository: UserRepository,      // interface
    private val emailService: EmailService,          // interface  
    private val validator: UserValidator             // interface
) {
    suspend fun registerUser(userData: UserData): RegistrationResult {
        val validation = validator.validate(userData)
        if (!validation.isValid) {
            return RegistrationResult.InvalidData(validation.errors)
        }
        
        val user = User(
            id = generateId(),
            name = userData.name,
            email = userData.email
        )
        
        userRepository.save(user)
        emailService.sendWelcomeEmail(user.email)
        
        return RegistrationResult.Success(user)
    }
}

// Dalam test - inject mock ke constructor
@Test
fun `registerUser should save and email when valid`() = runTest {
    val mockRepository = mockk<UserRepository>()
    val mockEmailService = mockk<EmailService>() 
    val mockValidator = mockk<UserValidator>()
    
    val service = UserService(mockRepository, mockEmailService, mockValidator)
    
    val validData = UserData("John Doe", "john@example.com")
    val user = User("1", "John Doe", "john@example.com")
    
    every { mockValidator.validate(validData) } returns ValidationResult.Valid
    coEvery { mockRepository.save(any()) } just runs
    coEvery { mockEmailService.sendWelcomeEmail(any()) } just runs
    
    val result = service.registerUser(validData)
    
    assertTrue(result is RegistrationResult.Success)
    coVerify { mockRepository.save(any()) }
    coVerify { mockEmailService.sendWelcomeEmail("john@example.com") }
}

// Bisa juga test error scenarios dengan mudah
@Test
fun `registerUser should fail when validation fails`() = runTest {
    val mockRepository = mockk<UserRepository>()
    val mockEmailService = mockk<EmailService>()
    val mockValidator = mockk<UserValidator>()
    
    val service = UserService(mockRepository, mockEmailService, mockValidator)
    
    val invalidData = UserData("", "") // invalid
    every { mockValidator.validate(invalidData) } returns ValidationResult.Invalid(listOf("Name required"))
    
    val result = service.registerUser(invalidData)
    
    assertTrue(result is RegistrationResult.InvalidData)
    coVerify(exactly = 0) { mockRepository.save(any()) }
    coVerify(exactly = 0) { mockEmailService.sendWelcomeEmail(any()) }
}
```

### Comprehensive Testing Example:

**ViewModel Testing dengan SOLID:**
```kotlin
// ViewModel yang mengikuti SOLID
class UserViewModel(
    private val getUsersUseCase: GetUsersUseCase,
    private val analyticsService: AnalyticsService
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UserUiState>(UserUiState.Loading)
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()
    
    fun loadUsers() {
        viewModelScope.launch {
            _uiState.value = UserUiState.Loading
            analyticsService.logEvent("users_load_started")
            
            try {
                val users = getUsersUseCase()
                _uiState.value = UserUiState.Success(users)
                analyticsService.logEvent("users_load_success", mapOf("count" to users.size))
            } catch (e: Exception) {
                _uiState.value = UserUiState.Error(e.message ?: "Unknown error")
                analyticsService.logEvent("users_load_error", mapOf("error" to e.message))
            }
        }
    }
}

// Test yang komprehensif karena SOLID
@OptIn(ExperimentalCoroutinesApi::class)
class UserViewModelTest {
    
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()
    
    private lateinit var viewModel: UserViewModel
    private lateinit var mockGetUsersUseCase: GetUsersUseCase
    private lateinit var mockAnalyticsService: AnalyticsService
    
    @Before
    fun setup() {
        mockGetUsersUseCase = mockk<GetUsersUseCase>()
        mockAnalyticsService = mockk<AnalyticsService>()
        viewModel = UserViewModel(mockGetUsersUseCase, mockAnalyticsService)
    }
    
    @Test
    fun `loadUsers should show loading then success when use case succeeds`() = runTest {
        // Given
        val users = listOf(User("1", "John", "john@example.com"))
        coEvery { mockGetUsersUseCase() } returns users
        coEvery { mockAnalyticsService.logEvent(any(), any()) } just runs
        
        // When
        viewModel.loadUsers()
        
        // Then - test state flow progression
        viewModel.uiState.test {
            assertEquals(UserUiState.Loading, awaitItem())
            val successState = awaitItem()
            assertTrue(successState is UserUiState.Success)
            assertEquals(users, successState.users)
            expectNoMoreItems()
        }
        
        coVerify { mockAnalyticsService.logEvent("users_load_started", any()) }
        coVerify { mockAnalyticsService.logEvent("users_load_success", any()) }
    }
    
    @Test
    fun `loadUsers should show error when use case fails`() = runTest {
        // Given
        val error = Exception("Network error")
        coEvery { mockGetUsersUseCase() } throws error
        coEvery { mockAnalyticsService.logEvent(any(), any()) } just runs
        
        // When
        viewModel.loadUsers()
        
        // Then
        viewModel.uiState.test {
            assertEquals(UserUiState.Loading, awaitItem())
            val errorState = awaitItem()
            assertTrue(errorState is UserUiState.Error)
            assertTrue(errorState.message.contains("Network error"))
        }
        
        coVerify { mockAnalyticsService.logEvent("users_load_error", any()) }
    }
}
```

### Testing Different Scenarios:

**Repository Testing dengan SOLID:**
```kotlin
@Test
fun `repository should get from cache when available`() = runTest {
    // Given
    val mockLocal = mockk<LocalDataSource<User, String>>()
    val mockRemote = mockk<RemoteDataSource<User, String>>()
    val repository = UserRepositoryImpl(mockLocal, mockRemote)
    
    val cachedUser = User("1", "John", "john@example.com")
    coEvery { mockLocal.findById("1") } returns cachedUser
    
    // When
    val result = repository.findById("1")
    
    // Then
    assertEquals(cachedUser, result)
    coVerify { mockLocal.findById("1") }
    coVerify(exactly = 0) { mockRemote.findById("1") } // tidak dipanggil karena ada di cache
}

@Test
fun `repository should fallback to remote when not in cache`() = runTest {
    // Given
    val mockLocal = mockk<LocalDataSource<User, String>>()
    val mockRemote = mockk<RemoteDataSource<User, String>>()
    val repository = UserRepositoryImpl(mockLocal, mockRemote)
    
    val remoteUser = User("1", "John", "john@example.com")
    coEvery { mockLocal.findById("1") } returns null
    coEvery { mockRemote.findById("1") } returns remoteUser
    coEvery { mockLocal.save(any()) } just runs
    
    // When
    val result = repository.findById("1")
    
    // Then
    assertEquals(remoteUser, result)
    coVerify { mockLocal.findById("1") }
    coVerify { mockRemote.findById("1") }
    coVerify { mockLocal.save(remoteUser) } // cache result
}
```

### Integration Testing:

**Testing integration antar components SOLID:**
```kotlin
@Test
fun `full user registration flow should work end to end`() = runTest {
    // Given - setup semua dependency dengan konfigurasi test
    val testRepository = InMemoryUserRepository()
    val testEmailService = TestEmailService()
    val validator = UserValidator()
    
    val registrationService = UserRegistrationService(
        repository = testRepository,
        emailService = testEmailService,
        validator = validator
    )
    
    val userData = UserData("New User", "newuser@example.com")
    
    // When
    val result = registrationService.registerUser(userData)
    
    // Then
    assertTrue(result is RegistrationResult.Success)
    
    val savedUser = testRepository.findById(result.user.id)
    assertNotNull(savedUser)
    assertEquals("New User", savedUser.name)
    assertEquals("newuser@example.com", savedUser.email)
    
    // Verify email was sent
    assertTrue(testEmailService.sentEmails.any { it.to == "newuser@example.com" })
}
```

### üéì Penjelasan Konsep:
**Testing Benefits dari SOLID seperti Sistem Modul:**
- **Seperti mainan LEGO** - setiap bagian bisa diuji sendiri
- **Seperti tim kerja spesialis** - setiap orang bisa diuji kemampuannya sendiri
- **Seperti komponen elektronik** - bisa diuji fungsi per fungsi

**Manfaat Testing dengan SOLID:**
- **Focused Tests**: Test spesifik untuk fungsi tunggal
- **Easy Mocking**: Gampang ganti dependency dengan mock
- **Predictable Behavior**: Implementasi bisa diganti tanpa ubah test
- **Comprehensive Coverage**: Bisa test semua scenario dengan mudah

---

## 1Ô∏è‚É£1Ô∏è‚É£ Common Pitfalls ‚ö†Ô∏è

### Konsep Dasar
Common Pitfalls dalam SOLID seperti jebakan jurang üï≥Ô∏è - harus dikenali dan dihindari agar tidak terperosok!

### 1. Over-engineering (Kebanyakan Abstraksi):

**‚ùå Pitfall: Abstraction untuk semua hal**
```kotlin
// Kebanyakan abstraction - overkill untuk kasus sederhana
interface IReadable<T> {
    suspend fun read(id: String): T?
}

interface IWritable<T> { 
    suspend fun write(entity: T): T
}

interface IDeletable<T> {
    suspend fun delete(id: String): Boolean
}

interface IUpdatable<T> {
    suspend fun update(entity: T): T
}

interface IUserReadable : IReadable<User>
interface IUserWritable : IWritable<User> 
interface IUserDeletable : IDeletable<User>
interface IUserUpdatable : IUpdatable<User>

class ConcreteUserRepository : 
    IUserReadable, IUserWritable, IUserDeletable, IUserUpdatable {
    // Banyak interface - kompleksitas berlebihan
    override suspend fun read(id: String): User? = TODO()
    override suspend fun write(entity: User): User = TODO()
    override suspend fun delete(id: String): Boolean = TODO()
    override suspend fun update(entity: User): User = TODO()
}
```

**‚úÖ Solution: Cukup dengan yang dibutuhkan**
```kotlin
// Simple dan fokus
interface UserRepository {
    suspend fun findById(id: String): User?
    suspend fun save(user: User): User
    suspend fun delete(id: String): Boolean
}
```

### 2. Premature Abstraction:

**‚ùå Pitfall: Bikin abstraction sebelum waktunya**
```kotlin
// Membuat abstraction untuk hal yang belum tentu akan berkembang
interface PaymentProcessorStrategy {
    suspend fun process(amount: Double): PaymentResult
}

class DefaultPaymentProcessor : PaymentProcessorStrategy {
    override suspend fun process(amount: Double): PaymentResult {
        // Saat ini hanya satu implementasi, tidak perlu abstraction
        return PaymentResult.Success("Paid $$amount")
    }
}

// Tidak perlu gunakan
class PaymentService(
    private val strategy: PaymentProcessorStrategy // Hanya satu implementasi
) {
    suspend fun pay(amount: Double) = strategy.process(amount)
}
```

**‚úÖ Solution: Bikin abstraction saat benar-benar dibutuhkan**
```kotlin
// Mulai sederhana
class PaymentService {
    suspend fun pay(amount: Double): PaymentResult {
        return PaymentResult.Success("Paid $$amount")
    }
}

// Baru buat abstraction saat ada kebutuhan nyata
// Jika ternyata ada beberapa metode pembayaran
```

### 3. Too Many Interfaces:

**‚ùå Pitfall: Interface sesedikit mungkin (salah paham ISP)**
```kotlin
// Terlalu banyak interface kecil
interface CanSave<T> { suspend fun save(item: T) }
interface CanLoad<T> { suspend fun load(id: String): T? }
interface CanDelete<T> { suspend fun delete(id: String) }
interface CanUpdate<T> { suspend fun update(item: T) }
interface CanSearch<T> { suspend fun search(query: String): List<T> }
interface CanCount<T> { suspend fun count(): Int }
interface CanClear<T> { suspend fun clear() }

// Banyak interface tapi kompleksitas meningkat
class UserService(
    private val saveService: CanSave<User>,
    private val loadService: CanLoad<User>, 
    private val deleteService: CanDelete<User>,
    private val updateService: CanUpdate<User>,
    private val searchService: CanSearch<User>,
    private val countService: CanCount<User>,
    private val clearService: CanClear<User>
) {
    // Terlalu banyak dependency
}
```

**‚úÖ Solution: Balance antara fokus dan keterbacaan**
```kotlin
// Interface yang fokus tapi tidak terlalu kecil
interface ReadRepository<T, ID> {
    suspend fun findById(id: ID): T?
    suspend fun findAll(): List<T>
}

interface WriteRepository<T, ID> {
    suspend fun save(entity: T): T
    suspend fun update(entity: T): T
    suspend fun delete(id: ID): Boolean
}

interface SearchRepository<T> {
    suspend fun search(query: String): List<T>
    suspend fun count(): Int
}

class UserService(
    private val readRepo: ReadRepository<User, String>,
    private val writeRepo: WriteRepository<User, String>,
    private val searchRepo: SearchRepository<User>
) {
    // Lebih sederhana tapi tetap terpisah fungsinya
}
```

### 4. Analysis Paralysis:

**‚ùå Pitfall: Terlalu lama mikir arsitektur**
```kotlin
// Mikir terlalu jauh, tidak mulai coding
class ComplexArchitectureDecision {
    /*
    Saya harus bikin:
    - Factory untuk setiap jenis repository
    - Strategy untuk setiap business logic
    - Observer untuk setiap perubahan state
    - Decorator untuk setiap service
    - Adapter untuk setiap external service
    - Dan seterusnya...
    
    Sampai akhirnya:
    - Proyek belum jalan
    - Deadline lewat
    - Arsitektur belum selesai
    */
}
```

**‚úÖ Solution: Start simple, refactor when needed**
```kotlin
// Mulai dari yang sederhana
class SimpleUserService {
    suspend fun getUser(id: String): User? {
        // Implementasi langsung
        return database.findUser(id)
    }
}

// Baru refactor saat benar-benar butuh
// Jika muncul kebutuhan yang lebih kompleks
```

### 5. Dogmatic Application:

**‚ùå Pitfall: Mengikuti SOLID secara buta**
```kotlin
// Memaksa SOLID dalam semua kasus, bahkan yang tidak perlu
class Calculator {
    // Ini seharusnya function biasa, tidak perlu kompleks
}

interface ICalculationStrategy {
    fun calculate(a: Double, b: Double): Double
}

class AddStrategy : ICalculationStrategy {
    override fun calculate(a: Double, b: Double): Double = a + b
}

class SubtractStrategy : ICalculationStrategy {
    override fun calculate(a: Double, b: Double): Double = a - b
}

// Terlalu kompleks untuk operasi sederhana
val calculator = Calculator(AddStrategy()) // Tidak efisien!
```

**‚úÖ Solution: Gunakan SOLID secara bijak**
```kotlin
// Untuk kalkulasi sederhana, gunakan function biasa
object SimpleCalculator {
    fun add(a: Double, b: Double): Double = a + b
    fun subtract(a: Double, b: Double): Double = a - b
    fun multiply(a: Double, b: Double): Double = a * b
    fun divide(a: Double, b: Double): Double = a / b
}

// Gunakan pattern kompleks jika memang dibutuhkan
```

### 6. Violating the "Pragmatic" Principle:

**‚ùå Pitfall: Lebih mementingkan arsitektur daripada solusi**
```kotlin
// Kode terlalu arsitektur tapi tidak fokus pada bisnis value
class BusinessLogic {
    /*
    Saya punya:
    - 10 layer abstraction
    - 20 interface
    - 30 class
    - 100 method
    
    Tapi bisnis hanya butuh:
    "Kalau user beli lebih dari 100K, kasih diskon 10%"
    */
    
    fun calculatePrice(input: ComplexInput): ComplexOutput {
        // Kompleksitas yang tidak perlu
    }
}
```

**‚úÖ Solution: Fokus pada business value**
```kotlin
// Solusi yang fokus pada kebutuhan bisnis
class SimpleDiscountCalculator {
    fun calculateFinalPrice(originalPrice: Double, user: User): Double {
        val discount = if (originalPrice > 100_000) 0.1 else 0.0
        return originalPrice * (1 - discount)
    }
}
```

### 7. Interface Explosion:

**‚ùå Pitfall: Bikin interface untuk setiap method**
```kotlin
// Terlalu banyak interface kecil
interface CanLoadUser { suspend fun loadUser(id: String): User? }
interface CanSaveUser { suspend fun saveUser(user: User) }
interface CanDeleteUser { suspend fun deleteUser(id: String) }
interface CanGetUserCount { suspend fun getUserCount(): Int }
interface CanSearchUsers { suspend fun searchUsers(query: String): List<User> }

// Setiap interface hanya punya 1 method
class UserService(
    private val loader: CanLoadUser,
    private val saver: CanSaveUser,
    private val deleter: CanDeleteUser,
    private val counter: CanGetUserCount,
    private val searcher: CanSearchUsers
) {
    // Terlalu banyak dependency
}
```

### 8. Inheritance Overuse:

**‚ùå Pitfall: Terlalu banyak inheritance**
```kotlin
// Rantai inheritance yang terlalu panjang
open class BaseModel {
    var id: String = ""
    var createdAt: Long = 0
    var updatedAt: Long = 0
}

open class EntityModel : BaseModel() {
    var isActive: Boolean = true
}

open class DataModel : EntityModel() {
    var version: Int = 1
}

open class DomainModel : DataModel() {
    var metadata: Map<String, Any> = emptyMap()
}

class UserModel : DomainModel() {
    var name: String = ""
    var email: String = ""
    // Dan masih banyak lagi...
}

// Inheritance yang terlalu panjang susah diikuti
```

**‚úÖ Solution: Gunakan composition**
```kotlin
// Lebih fleksibel dan mudah dipahami
data class BaseModel(
    val id: String = "",
    val createdAt: Long = System.currentTimeMillis(),
    val updatedAt: Long = System.currentTimeMillis()
)

data class EntityModel(
    val base: BaseModel,
    val isActive: Boolean = true
)

// Atau cukup satu data class
data class User(
    override val id: String,
    override val createdAt: Long,
    override val updatedAt: Long,
    override val isActive: Boolean,
    val name: String,
    val email: String
) : BaseDomainEntity
```

### 9. Generic Overuse:

**‚ùå Pitfall: Terlalu banyak generic parameter**
```kotlin
// Generic yang terlalu kompleks
class OverlyGenericRepository<
    T : BaseEntity<ID>,
    ID : Serializable,
    R : BaseRepository<T, ID>,
    S : BaseSpecification<T>,
    E : BaseEvent<T>
> {
    suspend fun <K : T> complexMethod(
        param: Map<String, List<K>>,
        spec: S,
        events: Collection<E>
    ): Result<List<K>, Exception> {
        // Sangat susah dipahami
    }
}
```

**‚úÖ Solution: Gunakan generic saat bermanfaat**
```kotlin
// Cukup jika memang dibutuhkan
interface Repository<T, ID> {
    suspend fun findById(id: ID): T?
    suspend fun save(entity: T): T
}

// Tidak perlu terlalu generic untuk semua kasus
class UserRepository : Repository<User, String> {
    override suspend fun findById(id: String): User? = TODO()
    override suspend fun save(entity: User): User = TODO()
}
```

### 10. Premature Optimization:

**‚ùå Pitfall: Optimasi sebelum dibutuhkan**
```kotlin
// Bikin caching layer kompleks sebelum tahu efektifnya
class PrematurelyOptimizedService {
    private val cache = mutableMapOf<String, Any>()
    private val cacheLock = Mutex()
    private val cacheExpiration = mutableMapOf<String, Long>()
    private val cacheStatistics = CacheStatistics()
    
    // Belum tentu dibutuhkan, tapi langsung bikin kompleks
}
```

**‚úÖ Solution: Optimasi saat benar-benar dibutuhkan**
```kotlin
// Mulai sederhana, optimasi saat ada masalah
class SimpleService {
    suspend fun getData(): Data {
        return api.getData() // Start simple
    }
}

// Jika ada masalah performa, baru tambahkan caching
class OptimizedService {
    private val cache = LruCache<String, Data>(100) // Jika memang dibutuhkan
    
    suspend fun getData(): Data {
        val cached = cache.get("key")
        return cached ?: api.getData().also { cache.put("key", it) }
    }
}
```

### üéì Penjelasan Konsep:
**Common Pitfalls seperti Jebakan:**
- **Seperti jalan tol** - bisa cepat tapi kalau salah pintu masuk bisa sesat
- **Seperti senjata** - bisa ampuh tapi kalau salah gunakan bisa bahaya
- **Seperti obat** - bisa menyembuhkan tapi kalau overdosis bisa fatal

**Prinsip dalam menghindari pitfalls:**
- **Start Simple**: Mulai dari yang sederhana
- **YAGNI**: You Aren't Gonna Need It
- **KISS**: Keep It Simple, Stupid
- **Measure First**: Ukur dulu sebelum mengoptimasi

---

## 1Ô∏è‚É£2Ô∏è‚É£ Practical Guidelines ‚ú®

### Konsep Dasar
Practical Guidelines seperti peta jalan üó∫Ô∏è - petunjuk praktis untuk menerapkan SOLID dalam pengembangan nyata!

### 1. Apply Pragmatically:

**‚úÖ Guideline: Gunakan dengan akal sehat**
```kotlin
// Mulai dari kebutuhan nyata, bukan dari teori
class RealWorldUserCase {
    /*
    1. Mulai simple - buat apa yang dibutuhkan sekarang
    2. Refactor saat muncul kebutuhan nyata  
    3. Jangan bikin untuk "kemungkinan" di masa depan
    4. Fokus pada business value
    5. Gunakan SOLID saat ada masalah nyata yang diselesaikan
    */
}

// Contoh praktis
class PaymentService {
    // Jika hanya ada satu metode pembayaran, cukup sederhana
    suspend fun processPayment(amount: Double): PaymentResult {
        return PaymentResult.Success("Paid $$amount")
    }
}

// Baru komplekskan saat ada kebutuhan nyata
interface PaymentMethod {
    suspend fun process(amount: Double): PaymentResult
}

class PaymentServiceRefactored(
    private val paymentMethod: PaymentMethod
) {
    suspend fun processPayment(amount: Double): PaymentResult {
        return paymentMethod.process(amount)
    }
}
```

### 2. Start Simple, Refactor When Needed:

**‚úÖ Guideline: Evolutionary approach**
```kotlin
// Versi 1: Simple dan langsung
class SimpleUserService {
    suspend fun getUser(id: String): User? {
        // Cukup untuk kebutuhan awal
        return database.findById(id)
    }
}

// Versi 2: Saat muncul kebutuhan logging
class UserServiceWithLogging {
    suspend fun getUser(id: String): User? {
        logger.info("Getting user: $id")
        val user = database.findById(id)
        logger.info("Got user: ${user?.id}")
        return user
    }
}

// Versi 3: Saat muncul kebutuhan caching
class UserServiceWithCache {
    suspend fun getUser(id: String): User? {
        // Coba dari cache dulu
        var user = cache.get(id)
        if (user == null) {
            user = database.findById(id)
            user?.let { cache.put(id, it) }
        }
        return user
    }
}

// Versi 4: Gunakan decorator pattern saat kebutuhan kompleks
interface UserService {
    suspend fun getUser(id: String): User?
}

class BaseUserService : UserService {
    override suspend fun getUser(id: String): User? {
        return database.findById(id)
    }
}

class CachedUserService(
    private val baseService: UserService,
    private val cache: Cache<String, User>
) : UserService {
    override suspend fun getUser(id: String): User? {
        var user = cache.get(id)
        if (user == null) {
            user = baseService.getUser(id)
            user?.let { cache.put(id, it) }
        }
        return user
    }
}
```

### 3. Balance with Deadlines:

**‚úÖ Guideline: Project reality matters**
```kotlin
// Dalam dunia nyata, ada trade-off antara sempurna dan selesai
class ProjectTimelineSolution {
    /*
    Fase 1: MVP - fokus pada fitur utama
    Fase 2: Stabilisasi - perbaiki arsitektur
    Fase 3: Ekspansi - tambah fitur kompleks
    */
}

// Contoh: Payment processing
// Fase 1: Hanya credit card, simple implementation
class SimplePaymentProcessor {
    suspend fun process(amount: Double): PaymentResult {
        return externalPaymentApi.chargeCreditCard(amount)
    }
}

// Fase 2: Tambah beberapa metode, refactor
interface PaymentProcessor {
    suspend fun process(amount: Double, method: PaymentMethodType): PaymentResult
}

class MultiMethodPaymentProcessor : PaymentProcessor {
    override suspend fun process(amount: Double, method: PaymentMethodType): PaymentResult {
        return when (method) {
            PaymentMethodType.CREDIT_CARD -> processCreditCard(amount)
            PaymentMethodType.DEBIT -> processDebit(amount)
            PaymentMethodType.PAYPAL -> processPayPal(amount)
        }
    }
}

// Fase 3: Pattern yang lebih kompleks jika dibutuhkan
class StrategyBasedPaymentProcessor(
    private val paymentStrategies: Map<PaymentMethodType, PaymentStrategy>
) : PaymentProcessor {
    override suspend fun process(amount: Double, method: PaymentMethodType): PaymentResult {
        val strategy = paymentStrategies[method] ?: return PaymentResult.Error("Unsupported method")
        return strategy.process(amount)
    }
}
```

### 4. Team Agreement:

**‚úÖ Guideline: Consistency across team**
```kotlin
// Buat aturan tim yang jelas
object TeamSOLIDGuidelines {
    /*
    1. Code review checklist:
       - Apakah class punya satu tanggung jawab?
       - Apakah gampang diextend tanpa modify?
       - Apakah interface terlalu besar?
       - Apakah high-level module tergantung abstraksi?
    
    2. Pair programming: diskusikan arsitektur bersama
    
    3. Team learning: pelajari SOLID bersama-sama
    
    4. Refactoring session: waktu khusus untuk perbaikan arsitektur
    */
}

// Contoh code review checklist
class SOLIDCodeReview {
    fun reviewClass(clazz: String): List<String> {
        val issues = mutableListOf<String>()
        
        // Cek jumlah method
        if (methodCount > 10) {
            issues.add("Too many methods - might violate SRP")
        }
        
        // Cek inheritance depth
        if (inheritanceDepth > 3) {
            issues.add("Deep inheritance - consider composition")
        }
        
        // Cek parameter count
        if (parameterCount > 5) {
            issues.add("Too many parameters - consider data class or builder")
        }
        
        return issues
    }
}
```

### 5. Code Reviews for Enforcement:

**‚úÖ Guideline: Systematic checking**
```kotlin
// Template code review untuk SOLID
class SOLIDReviewTemplate {
    fun reviewFile(fileName: String, code: String): List<ReviewComment> {
        val comments = mutableListOf<ReviewComment>()
        
        // SRP Check
        if (hasMultipleResponsibilities(code)) {
            comments.add(
                ReviewComment(
                    type = CommentType.SRP_VIOLATION,
                    message = "Class has multiple responsibilities",
                    suggestion = "Split into separate classes"
                )
            )
        }
        
        // OCP Check
        if (hasSwitchForExtension(code)) {
            comments.add(
                ReviewComment(
                    type = CommentType.OCP_VIOLATION,
                    message = "Code requires modification for extension",
                    suggestion = "Use strategy pattern or similar"
                )
            )
        }
        
        // DIP Check
        if (hasDirectDependencyOnConcrete(code)) {
            comments.add(
                ReviewComment(
                    type = CommentType.DIP_VIOLATION,
                    message = "Direct dependency on concrete implementation",
                    suggestion = "Depend on interface instead"
                )
            )
        }
        
        return comments
    }
}

data class ReviewComment(
    val type: CommentType,
    val message: String,
    val suggestion: String,
    val line: Int = 0
)

enum class CommentType {
    SRP_VIOLATION,
    OCP_VIOLATION,
    LSP_VIOLATION,
    ISP_VIOLATION,
    DIP_VIOLATION
}
```

### 6. Incremental SOLID Implementation:

**‚úÖ Guideline: Step by step approach**
```kotlin
// Implementasi SOLID secara bertahap
class IncrementalSOLID {
    /*
    Tahap 1: Identifikasi pelanggaran besar
    Tahap 2: Perbaiki pelanggaran SRP
    Tahap 3: Tambahkan abstraction untuk DIP
    Tahap 4: Implementasi OCP di area kritis
    Tahap 5: Refactor interface untuk ISP
    Tahap 6: Review LSP compliance
    */
}

// Contoh refactor bertahap
// Sebelum: God class
class GodClass {
    fun handleNetwork() { }
    fun handleDatabase() { }
    fun handleUI() { }
    fun handleAnalytics() { }
}

// Tahap 1: Ekstrak berdasarkan tanggung jawab
class NetworkHandler {
    fun handleNetwork() { }
}

class DatabaseHandler { 
    fun handleDatabase() { }
}

class UIHandler {
    fun handleUI() { }
}

class AnalyticsHandler {
    fun handleAnalytics() { }
}

// Tahap 2: Tambahkan interface
interface NetworkService {
    fun handleNetwork(): NetworkResult
}

interface DatabaseService {
    fun handleDatabase(): DatabaseResult
}

// Tahap 3: Gunakan abstraction di high-level
class BusinessLogic(
    private val networkService: NetworkService,
    private val databaseService: DatabaseService
) {
    suspend fun doBusinessWork() {
        val networkResult = networkService.handleNetwork()
        if (networkResult.isSuccess) {
            databaseService.handleDatabase()
        }
    }
}
```

### 7. Measurement and Monitoring:

**‚úÖ Guideline: Track SOLID compliance**
```kotlin
// Alat untuk mengukur SOLID compliance
class SOLIDMetrics {
    fun measureSRP(className: String): SRPMetric {
        val methodCount = countMethods(className)
        val responsibilityCount = estimateResponsibilities(className)
        
        return SRPMetric(
            className = className,
            methodCount = methodCount,
            responsibilityCount = responsibilityCount,
            score = calculateSRPScore(methodCount, responsibilityCount)
        )
    }
    
    fun measureOCP(className: String): OCPMetric {
        val extensionPoints = findExtensionPoints(className)
        val modificationPoints = findModificationPoints(className)
        
        return OCPMetric(
            className = className,
            extensionPoints = extensionPoints,
            modificationPoints = modificationPoints,
            score = calculateOCPScore(extensionPoints, modificationPoints)
        )
    }
}

data class SRPMetric(
    val className: String,
    val methodCount: Int,
    val responsibilityCount: Int,
    val score: Double
)

data class OCPMetric(
    val className: String,
    val extensionPoints: List<String>,
    val modificationPoints: List<String>,
    val score: Double
)

class SOLIDReportGenerator {
    fun generateReport(): SOLIDReport {
        val metrics = collectAllMetrics()
        val violations = findViolations(metrics)
        val recommendations = generateRecommendations(violations)
        
        return SOLIDReport(
            metrics = metrics,
            violations = violations,
            recommendations = recommendations
        )
    }
}
```

### 8. Documentation and Knowledge Sharing:

**‚úÖ Guideline: Keep everyone informed**
```kotlin
// Template dokumentasi SOLID
class SOLIDDokumentasi {
    /*
    Class: UserService
    Responsibilitas: Mengatur lifecycle user (create, read, update, delete)
    Abstraction: UserRepository interface
    Extension: Bisa tambah method tanpa modify existing code
    Dependencies: Bergantung pada UserRepository interface, bukan implementasi
    
    Architecture Decision:
    - Menggunakan Repository pattern untuk DIP
    - Interface kecil untuk ISP
    - Single responsibility untuk SRP
    */
}

// Contoh komentar dokumentasi
/**
 * User registration service
 * 
 * SRP: Only handles user registration logic
 * OCP: Open for adding new validation rules
 * DIP: Depends on abstract UserRepository and EmailService
 * 
 * @param userRepository For user data persistence
 * @param emailService For sending welcome emails  
 * @param validator For user data validation
 */
class UserRegistrationService(
    private val userRepository: UserRepository,
    private val emailService: EmailService,
    private val validator: UserValidator
)
```

### 9. Tooling Support:

**‚úÖ Guideline: Use available tools**
```kotlin
// Gunakan static analysis untuk bantu SOLID
class SOILDAnalysisConfig {
    /*
    Tools yang bisa bantu:
    1. Detekt - deteksi God classes, kompleksitas
    2. Ktlint - formatting untuk maintainability
    3. SonarQube - code quality metrics
    4. Custom rules - untuk aturan tim
    */
}

// Contoh custom rule untuk deteksi SRP violation
fun detectSRPViolation(code: String): Boolean {
    val methodCount = extractMethods(code).size
    val responsibilityKeywords = listOf("database", "network", "file", "ui", "log", "validate")
    val detectedResponsibilities = responsibilityKeywords.count { code.contains(it, ignoreCase = true) }
    
    return methodCount > 10 || detectedResponsibilities > 2
}
```

### 10. Continuous Learning:

**‚úÖ Guideline: Keep improving**
```kotlin
// Implementasi pembelajaran berkelanjutan
class SOLIDLearningPlan {
    val schedule = mapOf(
        "Week 1-2" to "SRP deep dive and practice",
        "Week 3-4" to "OCP and design patterns",
        "Week 5-6" to "LSP and inheritance best practices", 
        "Week 7-8" to "ISP and interface design",
        "Week 9-10" to "DIP and dependency injection",
        "Week 11-12" to "Integration and real project application"
    )
    
    fun practiceProblems(): List<RefactoringExercise> {
        return listOf(
            RefactoringExercise(
                name = "Refactor God Class",
                description = "Take a large class and split into smaller, focused classes"
            ),
            RefactoringExercise(
                name = "Add Extension Without Modification",
                description = "Add new functionality without modifying existing code"
            ),
            RefactoringExercise(
                name = "Apply DIP",
                description = "Replace concrete dependencies with abstractions"
            )
        )
    }
}
```

### üéì Penjelasan Konsep:
**Practical Guidelines seperti Peta dan Kompas:**
- **Bukan aturan keras** tapi pedoman fleksibel
- **Harus disesuaikan** dengan konteks proyek
- **Harus dipahami bersama** oleh tim
- **Harus diaplikasikan secara bertahap**

**Keseimbangan dalam Practical Guidelines:**
- **Antara sempurna dan praktis**
- **Antara teori dan implementasi**
- **Antara waktu dan kualitas**
- **Antara arsitektur dan business value**

---

## 1Ô∏è‚É£3Ô∏è‚É£ Hands-on Exercises üî®

### Konsep Dasar
Hands-on Exercises seperti laboratorium üß™ - tempat mencoba dan mengaplikasikan SOLID Principles secara langsung!

### Exercise 1: Identify SOLID Violations in Code

**Task: Temukan pelanggaran SOLID dalam kode berikut**

```kotlin
// Berikan kode berikut, identifikasi pelanggaran SOLID
class UserManager {
    fun registerUser(userData: UserData): String {
        // Network call
        val response = httpClient.post("/api/users", userData.toJson())
        val userId = response.jsonObject.getString("id")
        
        // Save to database
        database.insert("users", mapOf(
            "id" to userId,
            "name" to userData.name,
            "email" to userData.email
        ))
        
        // Send email
        emailService.send("Welcome!", "Welcome to our app!", userData.email)
        
        // Log activity
        logger.info("User registered: $userId")
        
        // Update cache
        cache.put("user_$userId", userData)
        
        return userId
    }
    
    fun updateUser(userId: String, updates: Map<String, Any>): Boolean {
        // Validation
        validateUserData(updates)
        
        // Database update
        database.update("users", userId, updates)
        
        // Cache invalidation
        cache.remove("user_$userId")
        
        // Analytics
        analytics.track("user_updated", mapOf("user_id" to userId))
        
        return true
    }
    
    fun deleteUser(userId: String): Boolean {
        // Database delete
        database.delete("users", userId)
        
        // Cache cleanup
        cache.remove("user_$userId")
        
        // File cleanup
        fileManager.deleteFile("user_$userId.json")
        
        // Notification
        notificationService.notifyAdmin("User deleted: $userId")
        
        return true
    }
    
    private fun validateUserData(data: Map<String, Any>): Boolean {
        val email = data["email"] as? String ?: return false
        return email.contains("@") && email.contains(".")
    }
    
    // Properties dari berbagai layer
    private val httpClient = HttpClient()
    private val database = Database()
    private val emailService = EmailService()
    private val logger = Logger()
    private val cache = Cache()
    private val analytics = AnalyticsService()
    private val fileManager = FileManager()
    private val notificationService = NotificationService()
}
```

**Solusi:**
```kotlin
// 1. SRP Violation: Class terlalu banyak tanggung jawab
// 2. DIP Violation: Tergantung implementasi konkrit
// 3. OCP Violation: Susah ditambah fitur baru
// 4. Tidak ada interface - ISP tidak berlaku
// 5. God class pattern

// Refactored version:
interface UserRepository {
    suspend fun save(user: User): User
    suspend fun update(id: String, updates: Map<String, Any>): Boolean
    suspend fun delete(id: String): Boolean
}

interface EmailService {
    suspend fun sendWelcomeEmail(user: User)
}

interface Logger {
    fun log(message: String)
}

interface CacheService {
    suspend fun put(key: String, value: Any)
    suspend fun remove(key: String)
}

class UserService(
    private val repository: UserRepository,
    private val emailService: EmailService,
    private val cacheService: CacheService,
    private val logger: Logger
) {
    suspend fun registerUser(userData: UserData): String {
        val user = User(
            id = generateId(),
            name = userData.name,
            email = userData.email
        )
        
        val savedUser = repository.save(user)
        
        emailService.sendWelcomeEmail(savedUser)
        cacheService.put("user_${savedUser.id}", savedUser)
        logger.log("User registered: ${savedUser.id}")
        
        return savedUser.id
    }
}
```

### Exercise 2: Refactor Code to Apply SOLID

**Task: Refactor kode untuk mengikuti semua SOLID principles**

```kotlin
// Kode yang perlu direfactor
class NotificationManager {
    fun sendNotification(userId: String, type: String, message: String) {
        when (type) {
            "email" -> {
                // Send email logic
                val user = database.findUser(userId)
                emailSender.send(user.email, message)
                log("Email sent to ${user.email}")
            }
            "sms" -> {
                // Send SMS logic
                val user = database.findUser(userId)
                smsSender.send(user.phone, message)
                log("SMS sent to ${user.phone}")
            }
            "push" -> {
                // Send push notification logic
                val user = database.findUser(userId)
                pushSender.send(user.deviceToken, message)
                log("Push sent to ${user.deviceToken}")
            }
            else -> throw IllegalArgumentException("Unknown notification type")
        }
    }
    
    private fun log(message: String) {
        // Log to file
        fileWriter.writeToFile("notifications.log", message)
    }
}
```

**Jawaban:**
```kotlin
// Step 1: Buat interface untuk notification strategy (OCP)
interface NotificationStrategy {
    suspend fun sendNotification(user: User, message: String)
}

// Step 2: Implementasi setiap strategy (SRP)
class EmailNotificationStrategy(
    private val emailService: EmailService
) : NotificationStrategy {
    override suspend fun sendNotification(user: User, message: String) {
        emailService.send(user.email, message)
    }
}

class SmsNotificationStrategy(
    private val smsService: SmsService
) : NotificationStrategy {
    override suspend fun sendNotification(user: User, message: String) {
        smsService.send(user.phone, message)
    }
}

class PushNotificationStrategy(
    private val pushService: PushService
) : NotificationStrategy {
    override suspend fun sendNotification(user: User, message: String) {
        pushService.send(user.deviceToken, message)
    }
}

// Step 3: Buat manager yang tergantung abstraksi (DIP)
class NotificationService(
    private val userProvider: UserProvider,
    private val strategies: Map<NotificationType, NotificationStrategy>,
    private val logger: Logger
) {
    suspend fun sendNotification(userId: String, type: NotificationType, message: String) {
        val user = userProvider.findById(userId)
        val strategy = strategies[type] ?: throw IllegalArgumentException("Unknown notification type: $type")
        
        strategy.sendNotification(user, message)
        logger.log("Notification sent: $type to ${user.id}")
    }
}

enum class NotificationType { EMAIL, SMS, PUSH }

// Step 4: ISP - interface kecil dan fokus
interface UserProvider {
    suspend fun findById(id: String): User
}

interface MessageLogger {
    suspend fun log(message: String)
}

// Step 5: Factory untuk manajemen strategy (OCP)
interface NotificationStrategyFactory {
    fun createStrategy(type: NotificationType): NotificationStrategy
}

class DefaultNotificationStrategyFactory(
    private val emailService: EmailService,
    private val smsService: SmsService,
    private val pushService: PushService
) : NotificationStrategyFactory {
    override fun createStrategy(type: NotificationType): NotificationStrategy {
        return when (type) {
            NotificationType.EMAIL -> EmailNotificationStrategy(emailService)
            NotificationType.SMS -> SmsNotificationStrategy(smsService)
            NotificationType.PUSH -> PushNotificationStrategy(pushService)
        }
    }
}
```

### Exercise 3: Design New Features with SOLID

**Task: Desain fitur shopping cart baru dengan SOLID principles**

```kotlin
// Buat desain shopping cart dengan:
// - Bisa berbagai jenis diskon
// - Bisa berbagai jenis biaya tambahan
// - Bisa berbagai metode pembayaran
// - Support berbagai jenis produk

interface ShoppingCart {
    fun addItem(item: CartItem)
    fun removeItem(itemId: String)
    fun applyDiscount(discount: Discount)
    fun addAdditionalCost(cost: AdditionalCost)
    fun calculateTotal(): BigDecimal
    fun checkout(paymentMethod: PaymentMethod): CheckoutResult
}

interface Discount {
    fun calculateDiscount(items: List<CartItem>): BigDecimal
    fun isValid(): Boolean
}

interface AdditionalCost {
    fun calculateCost(items: List<CartItem>): BigDecimal
    fun isValid(): Boolean
}

interface PaymentMethod {
    suspend fun processPayment(amount: BigDecimal): PaymentResult
}

// Contoh implementasi
class PercentageDiscount(private val percentage: BigDecimal) : Discount {
    override fun calculateDiscount(items: List<CartItem>): BigDecimal {
        val subtotal = items.sumOf { it.totalPrice }
        return subtotal * percentage / BigDecimal(100)
    }
    
    override fun isValid(): Boolean = percentage in BigDecimal(0)..BigDecimal(100)
}

class FixedAmountDiscount(private val amount: BigDecimal) : Discount {
    override fun calculateDiscount(items: List<CartItem>): BigDecimal {
        return amount.coerceAtMost(items.sumOf { it.totalPrice })
    }
    
    override fun isValid(): Boolean = amount >= BigDecimal.ZERO
}

class CreditCardPayment(
    private val cardNumber: String,
    private val cvv: String
) : PaymentMethod {
    override suspend fun processPayment(amount: BigDecimal): PaymentResult {
        // Process credit card payment
        return PaymentResult.Success("Paid with credit card: $cardNumber")
    }
}

class ShoppingCartImpl : ShoppingCart {
    private val items = mutableListOf<CartItem>()
    private val discounts = mutableListOf<Discount>()
    private val additionalCosts = mutableListOf<AdditionalCost>()
    
    override fun addItem(item: CartItem) {
        items.add(item)
    }
    
    override fun removeItem(itemId: String) {
        items.removeIf { it.id == itemId }
    }
    
    override fun applyDiscount(discount: Discount) {
        if (discount.isValid()) {
            discounts.add(discount)
        }
    }
    
    override fun addAdditionalCost(cost: AdditionalCost) {
        if (cost.isValid()) {
            additionalCosts.add(cost)
        }
    }
    
    override fun calculateTotal(): BigDecimal {
        var total = items.sumOf { it.totalPrice }
        
        // Apply discounts
        val totalDiscount = discounts.sumOf { it.calculateDiscount(items) }
        total -= totalDiscount
        
        // Add additional costs
        val totalAdditionalCost = additionalCosts.sumOf { it.calculateCost(items) }
        total += totalAdditionalCost
        
        return total.coerceAtLeast(BigDecimal.ZERO)
    }
    
    override fun checkout(paymentMethod: PaymentMethod): CheckoutResult {
        val total = calculateTotal()
        if (total <= BigDecimal.ZERO) {
            return CheckoutResult.Failure("Cart is empty or total is zero")
        }
        
        // In real implementation, would call paymentMethod.processPayment
        return CheckoutResult.Success("Checkout completed, total: $total")
    }
}

data class CartItem(
    val id: String,
    val name: String,
    val price: BigDecimal,
    val quantity: Int
) {
    val totalPrice: BigDecimal get() = price * quantity.toBigDecimal()
}

data class CheckoutResult(
    val isSuccess: Boolean,
    val message: String
) {
    companion object {
        fun Success(message: String) = CheckoutResult(true, message)
        fun Failure(message: String) = CheckoutResult(false, message)
    }
}
```

### Exercise 4: Code Review Checklist

**Task: Buat checklist code review untuk SOLID compliance**

```kotlin
class SOLIDCodeReviewChecklist {
    fun performReview(code: String, className: String): List<ReviewIssue> {
        val issues = mutableListOf<ReviewIssue>()
        
        // SRP Check
        issues.addAll(checkSingleResponsibility(code, className))
        
        // OCP Check
        issues.addAll(checkOpenClosedPrinciple(code))
        
        // LSP Check
        issues.addAll(checkLiskovSubstitution(code))
        
        // ISP Check
        issues.addAll(checkInterfaceSegregation(code))
        
        // DIP Check
        issues.addAll(checkDependencyInversion(code))
        
        return issues
    }
    
    private fun checkSingleResponsibility(code: String, className: String): List<ReviewIssue> {
        val issues = mutableListOf<ReviewIssue>()
        
        // Check method count
        val methodCount = countMethods(code)
        if (methodCount > 10) {
            issues.add(
                ReviewIssue(
                    type = IssueType.TOO_MANY_METHODS,
                    message = "Class has $methodCount methods, consider splitting",
                    severity = Severity.HIGH
                )
            )
        }
        
        // Check responsibility keywords
        val responsibilities = detectResponsibilities(code)
        if (responsibilities.size > 1) {
            issues.add(
                ReviewIssue(
                    type = IssueType.MULTIPLE_RESPONSIBILITIES,
                    message = "Class handles multiple responsibilities: ${responsibilities.joinToString(", ")}",
                    severity = Severity.MEDIUM
                )
            )
        }
        
        return issues
    }
    
    private fun checkOpenClosedPrinciple(code: String): List<ReviewIssue> {
        val issues = mutableListOf<ReviewIssue>()
        
        // Check for switch/if-else that would need modification
        if (hasSwitchForExtension(code)) {
            issues.add(
                ReviewIssue(
                    type = IssueType.OCP_VIOLATION,
                    message = "Code requires modification to add new functionality",
                    severity = Severity.HIGH
                )
            )
        }
        
        return issues
    }
    
    private fun checkDependencyInversion(code: String): List<ReviewIssue> {
        val issues = mutableListOf<ReviewIssue>()
        
        // Check for direct dependencies on concrete classes
        if (hasDirectConcreteDependency(code)) {
            issues.add(
                ReviewIssue(
                    type = IssueType.DIP_VIOLATION,
                    message = "Depends directly on concrete implementation instead of abstraction",
                    severity = Severity.HIGH
                )
            )
        }
        
        return issues
    }
    
    // Implementasi method lain...
}

data class ReviewIssue(
    val type: IssueType,
    val message: String,
    val severity: Severity = Severity.MEDIUM,
    val line: Int = 0
)

enum class IssueType {
    TOO_MANY_METHODS,
    MULTIPLE_RESPONSIBILITIES,
    OCP_VIOLATION,
    LSP_VIOLATION,
    ISP_VIOLATION,
    DIP_VIOLATION
}

enum class Severity {
    LOW, MEDIUM, HIGH, CRITICAL
}
```

### Exercise 5: Real-world Scenario

**Task: Terapkan SOLID dalam skenario e-commerce nyata**

```kotlin
// Skenario: Sistem notifikasi untuk berbagai event dalam e-commerce

// Langkah 1: Identifikasi kebutuhan
interface NotificationEvent {
    val userId: String
    val eventType: EventType
    val eventData: Map<String, Any>
}

enum class EventType {
    ORDER_PLACED, ORDER_SHIPPED, ORDER_DELIVERED, PAYMENT_FAILED, USER_REGISTERED
}

// Langkah 2: Buat strategi notifikasi
interface NotificationStrategy {
    suspend fun shouldSend(event: NotificationEvent): Boolean
    suspend fun send(event: NotificationEvent)
}

// Langkah 3: Implementasi berbagai strategi
class EmailNotificationStrategy(
    private val emailService: EmailService,
    private val templateService: TemplateService
) : NotificationStrategy {
    override suspend fun shouldSend(event: NotificationEvent): Boolean {
        return getUserNotificationPreference(event.userId, "email")
    }
    
    override suspend fun send(event: NotificationEvent) {
        val template = templateService.getTemplate(event.eventType)
        val message = templateService.render(template, event.eventData)
        val user = getUser(event.userId)
        
        emailService.send(user.email, message)
    }
}

class PushNotificationStrategy(
    private val pushService: PushService
) : NotificationStrategy {
    override suspend fun shouldSend(event: NotificationEvent): Boolean {
        // Check if user has app installed and notifications enabled
        return getUserNotificationPreference(event.userId, "push")
    }
    
    override suspend fun send(event: NotificationEvent) {
        val message = formatPushMessage(event)
        val user = getUser(event.userId)
        
        pushService.send(user.deviceToken, message)
    }
}

// Langkah 4: Service utama
class NotificationService(
    private val strategies: Map<EventType, List<NotificationStrategy>>,
    private val eventLogger: EventLogger
) {
    suspend fun handleEvent(event: NotificationEvent) {
        val applicableStrategies = strategies[event.eventType] ?: return
        
        for (strategy in applicableStrategies) {
            if (strategy.shouldSend(event)) {
                try {
                    strategy.send(event)
                    eventLogger.logSuccess(event, strategy::class.simpleName!!)
                } catch (e: Exception) {
                    eventLogger.logFailure(event, strategy::class.simpleName!!, e)
                }
            }
        }
    }
}

// Langkah 5: Factory untuk konfigurasi
class NotificationStrategyFactory {
    fun createStrategiesForEvent(
        eventType: EventType,
        services: ServiceContainer
    ): List<NotificationStrategy> {
        return when (eventType) {
            EventType.ORDER_PLACED -> listOf(
                EmailNotificationStrategy(services.emailService, services.templateService),
                PushNotificationStrategy(services.pushService)
            )
            EventType.PAYMENT_FAILED -> listOf(
                EmailNotificationStrategy(services.emailService, services.templateService)
            )
            else -> emptyList()
        }
    }
}

// Konfigurasi Dependency Injection
@Module
@InstallIn(SingletonComponent::class)
object NotificationModule {
    
    @Provides
    fun provideNotificationService(
        factory: NotificationStrategyFactory,
        services: ServiceContainer
    ): NotificationService {
        val strategies = EventType.values().associateWith { eventType ->
            factory.createStrategiesForEvent(eventType, services)
        }
        
        return NotificationService(strategies, services.eventLogger)
    }
}
```

### üéì Penjelasan Konsep:
**Hands-on Exercises seperti Laboratorium:**
- **Praktik langsung** penerapan teori SOLID
- **Problem-solving** dengan contoh nyata
- **Immediate feedback** dari kode yang dirubah
- **Learning by doing** - pengalaman langsung

**Manfaat Exercises:**
- **Memahami konsep secara mendalam**
- **Mengenali pelanggaran dengan cepat**
- **Melatih refactoring skills**
- **Membangun kebiasaan SOLID dalam coding**

---

## üéØ Kesimpulan

SOLID Principles adalah fondasi penting dalam pengembangan software yang baik, terutama dalam konteks Android Development. Mari kita rangkum:

### 5 Prinsip SOLID:

1. **Single Responsibility Principle (SRP)**:
   - Setiap class hanya punya satu alasan untuk berubah
   - Meningkatkan maintainability dan testability
   - Membuat kode lebih fokus dan mudah dipahami

2. **Open/Closed Principle (OCP)**:
   - Buka untuk ekstensi, tutup untuk modifikasi
   - Gunakan abstraksi dan polimorfisme untuk fleksibilitas
   - Memudahkan penambahan fitur baru

3. **Liskov Substitution Principle (LSP)**:
   - Subtype harus bisa menggantikan supertype
   - Pastikan implementasi memenuhi kontrak interface
   - Hindari perubahan behavior yang tak terduga

4. **Interface Segregation Principle (ISP)**:
   - Lebih baik banyak interface kecil dari satu besar
   - Client hanya tergantung interface yang diperlukan
   - Membuat kode lebih modular dan fleksibel

5. **Dependency Inversion Principle (DIP)**:
   - High-level modules tidak tergantung low-level modules
   - Keduanya tergantung pada abstraksi
   - Abstraksi tidak tergantung detail, detail tergantung abstraksi

### Manfaat SOLID dalam Android Development:

- **Maintainability**: Kode lebih mudah dipelihara dan diubah
- **Testability**: Mudah diuji karena loose coupling dan dependency injection
- **Scalability**: Mudah ditambah fitur baru tanpa merusak yang lama
- **Readability**: Struktur kode lebih jelas dan logis
- **Reusability**: Komponen bisa digunakan di banyak tempat

### Praktik Terbaik:

- Gunakan secara **pragmatis**, tidak dogmatis
- **Start simple**, refactor saat dibutuhkan
- Terapkan **secara bertahap** dalam proyek nyata
- Gunakan **tools dan code review** untuk membantu
- **Pelajari dan praktekkan terus-menerus**

### Peringatan:

- Hindari **over-engineering** untuk kasus sederhana
- Jangan terlalu **premature abstraction**
- Jangan **dogmatic** dalam penerapan
- Seimbangkan dengan **real project constraints**

Dengan memahami dan menerapkan SOLID Principles secara benar, kamu akan bisa membuat aplikasi Android yang lebih baik, lebih mudah dipelihara, dan lebih siap untuk pertumbuhan di masa depan.