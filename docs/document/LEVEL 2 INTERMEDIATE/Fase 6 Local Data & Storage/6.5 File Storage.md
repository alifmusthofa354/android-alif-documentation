## **6.5 File Storage** (3 hari) ⭐⭐

### **Teknologi Modern:**
- Internal/External storage
- Caching strategies

### **Teknologi yang Ditinggalkan:**
- -

### **Sub-topik Detail:**

#### 1. Storage Types Overview

**Internal Storage:**
- Private to app
- Always available
- Deleted when app uninstalled
- No permissions needed

**External Storage:**
- Shared storage (public)
- May not be available (SD card)
- Survives app uninstall
- Requires permissions (Android 10+: scoped storage)

**Cache Storage:**
- Temporary files
- System can delete when low on space
- Internal or external

#### 2. Internal Storage

**Write File:**
```kotlin
class FileManager(private val context: Context) {
    
    fun writeToInternalStorage(filename: String, content: String): Boolean {
        return try {
            context.openFileOutput(filename, Context.MODE_PRIVATE).use { output ->
                output.write(content.toByteArray())
            }
            true
        } catch (e: IOException) {
            Log.e("FileManager", "Error writing file", e)
            false
        }
    }
    
    fun writeToInternalStorageWithDir(directory: String, filename: String, content: String): Boolean {
        return try {
            val dir = File(context.filesDir, directory)
            if (!dir.exists()) {
                dir.mkdirs()
            }
            
            val file = File(dir, filename)
            file.writeText(content)
            true
        } catch (e: IOException) {
            Log.e("FileManager", "Error writing file", e)
            false
        }
    }
}
```

**Read File:**
```kotlin
fun readFromInternalStorage(filename: String): String? {
    return try {
        context.openFileInput(filename).use { input ->
            input.bufferedReader().use { it.readText() }
        }
    } catch (e: IOException) {
        Log.e("FileManager", "Error reading file", e)
        null
    }
}

fun readFromInternalStorageWithDir(directory: String, filename: String): String? {
    return try {
        val file = File(File(context.filesDir, directory), filename)
        if (file.exists()) {
            file.readText()
        } else {
            null
        }
    } catch (e: IOException) {
        Log.e("FileManager", "Error reading file", e)
        null
    }
}
```

**Delete File:**
```kotlin
fun deleteFromInternalStorage(filename: String): Boolean {
    return context.deleteFile(filename)
}

fun deleteDirectory(directory: String): Boolean {
    val dir = File(context.filesDir, directory)
    return dir.deleteRecursively()
}
```

**List Files:**
```kotlin
fun listInternalFiles(): Array<String> {
    return context.fileList()
}

fun listFilesInDirectory(directory: String): List<File> {
    val dir = File(context.filesDir, directory)
    return dir.listFiles()?.toList() ?: emptyList()
}
```

#### 3. Cache Storage

**Write to Cache:**
```kotlin
fun writeToCacheFile(filename: String, content: String): Boolean {
    return try {
        val file = File(context.cacheDir, filename)
        file.writeText(content)
        true
    } catch (e: IOException) {
        Log.e("FileManager", "Error writing cache", e)
        false
    }
}

fun writeToCacheDir(directory: String, filename: String, content: String): Boolean {
    return try {
        val dir = File(context.cacheDir, directory)
        if (!dir.exists()) {
            dir.mkdirs()
        }
        
        val file = File(dir, filename)
        file.writeText(content)
        true
    } catch (e: IOException) {
        Log.e("FileManager", "Error writing cache", e)
        false
    }
}
```

**Read from Cache:**
```kotlin
fun readFromCacheFile(filename: String): String? {
    return try {
        val file = File(context.cacheDir, filename)
        if (file.exists()) {
            file.readText()
        } else {
            null
        }
    } catch (e: IOException) {
        null
    }
}
```

**Clear Cache:**
```kotlin
fun clearCache(): Boolean {
    return try {
        context.cacheDir.deleteRecursively()
        true
    } catch (e: Exception) {
        false
    }
}

fun getCacheSize(): Long {
    return context.cacheDir.walk().filter { it.isFile }.map { it.length() }.sum()
}
```

#### 4. External Storage (Scoped Storage - Android 10+)

**Check External Storage:**
```kotlin
fun isExternalStorageWritable(): Boolean {
    return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED
}

fun isExternalStorageReadable(): Boolean {
    return Environment.getExternalStorageState() in
            setOf(Environment.MEDIA_MOUNTED, Environment.MEDIA_MOUNTED_READ_ONLY)
}
```

**App-Specific External Storage (No Permission Required):**
```kotlin
// Android 10+ (API 29+)
fun writeToExternalAppStorage(filename: String, content: String): Boolean {
    return try {
        val file = File(context.getExternalFilesDir(null), filename)
        file.writeText(content)
        true
    } catch (e: IOException) {
        false
    }
}

fun writeToExternalAppStorageByType(type: String, filename: String, content: String): Boolean {
    // type: Environment.DIRECTORY_PICTURES, DIRECTORY_DOCUMENTS, etc.
    return try {
        val file = File(context.getExternalFilesDir(type), filename)
        file.writeText(content)
        true
    } catch (e: IOException) {
        false
    }
}
```

**Shared Storage (MediaStore - Requires Permissions):**
```kotlin
class MediaStoreManager(private val context: Context) {
    
    // Save image to shared Pictures
    @RequiresPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)
    fun saveImageToMediaStore(bitmap: Bitmap, filename: String): Uri? {
        val contentValues = ContentValues().apply {
            put(MediaStore.Images.Media.DISPLAY_NAME, filename)
            put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
            
            // Android 10+
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)
                put(MediaStore.Images.Media.IS_PENDING, 1)
            }
        }
        
        val resolver = context.contentResolver
        val uri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)
        
        return uri?.let {
            try {
                resolver.openOutputStream(it)?.use { output ->
                    bitmap.compress(Bitmap.CompressFormat.JPEG, 95, output)
                }
                
                // Clear pending flag
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    contentValues.clear()
                    contentValues.put(MediaStore.Images.Media.IS_PENDING, 0)
                    resolver.update(it, contentValues, null, null)
                }
                
                it
            } catch (e: IOException) {
                Log.e("MediaStore", "Error saving image", e)
                resolver.delete(it, null, null)
                null
            }
        }
    }
    
    // Save document to shared Documents
    fun saveDocumentToMediaStore(content: String, filename: String, mimeType: String): Uri? {
        val contentValues = ContentValues().apply {
            put(MediaStore.Files.FileColumns.DISPLAY_NAME, filename)
            put(MediaStore.Files.FileColumns.MIME_TYPE, mimeType)
            
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                put(MediaStore.Files.FileColumns.RELATIVE_PATH, Environment.DIRECTORY_DOCUMENTS)
                put(MediaStore.Files.FileColumns.IS_PENDING, 1)
            }
        }
        
        val resolver = context.contentResolver
        val collection = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)
        } else {
            MediaStore.Files.getContentUri("external")
        }
        
        val uri = resolver.insert(collection, contentValues)
        
        return uri?.let {
            try {
                resolver.openOutputStream(it)?.use { output ->
                    output.write(content.toByteArray())
                }
                
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    contentValues.clear()
                    contentValues.put(MediaStore.Files.FileColumns.IS_PENDING, 0)
                    resolver.update(it, contentValues, null, null)
                }
                
                it
            } catch (e: IOException) {
                resolver.delete(it, null, null)
                null
            }
        }
    }
    
    // Query images from MediaStore
    fun queryImages(): List<MediaItem> {
        val images = mutableListOf<MediaItem>()
        
        val projection = arrayOf(
            MediaStore.Images.Media._ID,
            MediaStore.Images.Media.DISPLAY_NAME,
            MediaStore.Images.Media.SIZE,
            MediaStore.Images.Media.DATE_ADDED
        )
        
        val selection = null
        val selectionArgs = null
        val sortOrder = "${MediaStore.Images.Media.DATE_ADDED} DESC"
        
        context.contentResolver.query(
            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
            projection,
            selection,
            selectionArgs,
            sortOrder
        )?.use { cursor ->
            val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID)
            val nameColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)
            val sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.SIZE)
            val dateColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATE_ADDED)
            
            while (cursor.moveToNext()) {
                val id = cursor.getLong(idColumn)
                val name = cursor.getString(nameColumn)
                val size = cursor.getLong(sizeColumn)
                val date = cursor.getLong(dateColumn)
                
                val contentUri = ContentUris.withAppendedId(
                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                    id
                )
                
                images.add(MediaItem(contentUri, name, size, date))
            }
        }
        
        return images
    }
}

data class MediaItem(
    val uri: Uri,
    val name: String,
    val size: Long,
    val dateAdded: Long
)
```

#### 5. File Download & Caching

**Download File:**
```kotlin
class FileDownloader(
    private val context: Context,
    private val okHttpClient: OkHttpClient
) {
    suspend fun downloadFile(url: String, filename: String): Result<File> {
        return withContext(Dispatchers.IO) {
            try {
                val request = Request.Builder()
                    .url(url)
                    .build()
                
                val response = okHttpClient.newCall(request).execute()
                
                if (!response.isSuccessful) {
                    return@withContext Result.failure(IOException("Failed to download: ${response.code}"))
                }
                
                val file = File(context.cacheDir, filename)
                response.body()?.byteStream()?.use { input ->
                    file.outputStream().use { output ->
                        input.copyTo(output)
                    }
                }
                
                Result.success(file)
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
    
    suspend fun downloadFileWithProgress(
        url: String,
        filename: String,
        onProgress: (Int) -> Unit
    ): Result<File> {
        return withContext(Dispatchers.IO) {
            try {
                val request = Request.Builder()
                    .url(url)
                    .build()
                
                val response = okHttpClient.newCall(request).execute()
                
                if (!response.isSuccessful) {
                    return@withContext Result.failure(IOException("Failed"))
                }
                
                val body = response.body() ?: return@withContext Result.failure(IOException("Empty body"))
                val contentLength = body.contentLength()
                
                val file = File(context.cacheDir, filename)
                var downloaded = 0L
                
                body.byteStream().use { input ->
                    file.outputStream().use { output ->
                        val buffer = ByteArray(8192)
                        var bytes: Int
                        
                        while (input.read(buffer).also { bytes = it } != -1) {
                            output.write(buffer, 0, bytes)
                            downloaded += bytes
                            
                            if (contentLength > 0) {
                                val progress = (downloaded * 100 / contentLength).toInt()
                                withContext(Dispatchers.Main) {
                                    onProgress(progress)
                                }
                            }
                        }
                    }
                }
                
                Result.success(file)
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
}
```

#### 6. Image Caching Strategy

```kotlin
class ImageCacheManager(
    private val context: Context
) {
    private val cacheDir = File(context.cacheDir, "images")
    private val maxCacheSize = 100 * 1024 * 1024L // 100 MB
    
    init {
        if (!cacheDir.exists()) {
            cacheDir.mkdirs()
        }
    }
    
    fun saveImage(url: String, bitmap: Bitmap): File? {
        return try {
            val filename = url.md5() + ".jpg"
            val file = File(cacheDir, filename)
            
            FileOutputStream(file).use { output ->
                bitmap.compress(Bitmap.CompressFormat.JPEG, 85, output)
            }
            
            // Check cache size and cleanup if needed
            if (getCacheSize() > maxCacheSize) {
                cleanupOldestFiles()
            }
            
            file
        } catch (e: IOException) {
            null
        }
    }
    
    fun getImage(url: String): Bitmap? {
        val filename = url.md5() + ".jpg"
        val file = File(cacheDir, filename)
        
        return if (file.exists()) {
            try {
                // Update access time
                file.setLastModified(System.currentTimeMillis())
                BitmapFactory.decodeFile(file.absolutePath)
            } catch (e: Exception) {
                null
            }
        } else {
            null
        }
    }
    
    private fun getCacheSize(): Long {
        return cacheDir.walk().filter { it.isFile }.map { it.length() }.sum()
    }
    
    private fun cleanupOldestFiles() {
        val files = cacheDir.listFiles() ?: return
        
        // Sort by last modified (oldest first)
        files.sortBy { it.lastModified() }
        
        // Delete oldest 30%
        val toDelete = (files.size * 0.3).toInt()
        files.take(toDelete).forEach { it.delete() }
    }
    
    fun clearCache() {
        cacheDir.deleteRecursively()
        cacheDir.mkdirs()
    }
}

// Extension function for MD5 hash
fun String.md5(): String {
    val md = java.security.MessageDigest.getInstance("MD5")
    val digest = md.digest(toByteArray())
    return digest.joinToString("") { "%02x".format(it) }
}
```

#### 7. File Permissions

**Declare Permissions (Manifest):**
```xml
<!-- For Android 9 and below -->
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />

<!-- For Android 13+ (Granular media permissions) -->
<uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
<uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />
<uses-permission android:name="android.permission.READ_MEDIA_AUDIO" />
```

**Request Permissions:**
```kotlin
class PermissionManager(private val activity: Activity) {
    
    fun requestStoragePermission(onGranted: () -> Unit, onDenied: () -> Unit) {
        when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU -> {
                // Android 13+
                requestPermissions(
                    arrayOf(
                        Manifest.permission.READ_MEDIA_IMAGES,
                        Manifest.permission.READ_MEDIA_VIDEO
                    ),
                    onGranted,
                    onDenied
                )
            }
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q -> {
                // Android 10-12 (Scoped Storage)
                requestPermissions(
                    arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE),
                    onGranted,
                    onDenied
                )
            }
            else -> {
                // Android 9 and below
                requestPermissions(
                    arrayOf(
                        Manifest.permission.READ_EXTERNAL_STORAGE,
                        Manifest.permission.WRITE_EXTERNAL_STORAGE
                    ),
                    onGranted,
                    onDenied
                )
            }
        }
    }
    
    private fun requestPermissions(
        permissions: Array<String>,
        onGranted: () -> Unit,
        onDenied: () -> Unit
    ) {
        if (permissions.all { 
            ContextCompat.checkSelfPermission(activity, it) == PackageManager.PERMISSION_GRANTED
        }) {
            onGranted()
        } else {
            val requestCode = 100
            ActivityCompat.requestPermissions(activity, permissions, requestCode)
        }
    }
}
```

**With Jetpack Compose:**
```kotlin
@Composable
fun RequestStoragePermission(
    onGranted: () -> Unit,
    onDenied: () -> Unit
) {
    val permissions = when {
        Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU -> {
            listOf(
                Manifest.permission.READ_MEDIA_IMAGES,
                Manifest.permission.READ_MEDIA_VIDEO
            )
        }
        Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q -> {
            listOf(Manifest.permission.READ_EXTERNAL_STORAGE)
        }
        else -> {
            listOf(
                Manifest.permission.READ_EXTERNAL_STORAGE,
                Manifest.permission.WRITE_EXTERNAL_STORAGE
            )
        }
    }
    
    val launcher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissionsMap ->
        if (permissionsMap.values.all { it }) {
            onGranted()
        } else {
            onDenied()
        }
    }
    
    LaunchedEffect(Unit) {
        launcher.launch(permissions.toTypedArray())
    }
}
```

#### 8. File Picker

```kotlin
class FilePicker(private val activity: Activity) {
    
    private var onFilePicked: ((Uri) -> Unit)? = null
    
    private val pickFileLauncher = activity.registerForActivityResult(
        ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let { onFilePicked?.invoke(it) }
    }
    
    fun pickFile(mimeType: String = "*/*", onPicked: (Uri) -> Unit) {
        onFilePicked = onPicked
        pickFileLauncher.launch(mimeType)
    }
    
    fun pickImage(onPicked: (Uri) -> Unit) {
        pickFile("image/*", onPicked)
    }
    
    fun pickDocument(onPicked: (Uri) -> Unit) {
        pickFile("application/pdf", onPicked)
    }
}

// With Compose
@Composable
fun FilePickerButton() {
    val launcher = rememberLauncherForActivityResult(
        ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let {
            // Handle picked file
        }
    }
    
    Button(onClick = { launcher.launch("image/*") }) {
        Text("Pick Image")
    }
}
```

#### 9. Best Practices
✅ Use internal storage for private data
✅ Use cache for temporary files
✅ Implement cache size limits
✅ Handle storage permissions correctly
✅ Use MediaStore for shared media
✅ Implement proper error handling
✅ Clean up old cache files
✅ Use scoped storage (Android 10+)
✅ Test on devices with limited storage
✅ Provide user feedback during file operations

#### 10. Storage Usage Summary

**When to use what:**

| Storage Type | Use Case | Permissions | Survives Uninstall |
|--------------|----------|-------------|-------------------|
| Internal Storage | Private app data | None | No |
| Cache (Internal) | Temporary files | None | No |
| External App-Specific | Large private files | None (API 29+) | No |
| MediaStore | Shared photos/videos/audio | Yes | Yes |
| SAF (Storage Access Framework) | User-selected files | Runtime | Yes |

#### 11. Hands-on Project
- Implement file management system
- Save/load files to internal storage
- Implement image caching
- Use MediaStore for photos
- File picker integration
- Download manager
- Cache cleanup strategy
- Handle permissions properly

---
