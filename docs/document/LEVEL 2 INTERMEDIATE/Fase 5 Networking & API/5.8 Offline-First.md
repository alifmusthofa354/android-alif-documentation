## **5.8 Offline-First** (3 hari) ⭐⭐

### **Teknologi Modern:**
- Caching strategies
- Network/Cache policy

### **Teknologi yang Ditinggalkan:**
- Online-only apps

### **Sub-topik Detail:**

#### 1. Offline-First Architecture Principles
- Local database sebagai single source of truth
- UI reads from local database
- Network updates local database
- App works offline by default
- Sync ketika online
- Conflict resolution strategy

**Benefits:**
✅ Better user experience
✅ Faster app performance
✅ Works without internet
✅ Reduced server load
✅ Better perceived performance

#### 2. Offline-First Data Flow
```
┌──────────┐
│    UI    │ ← Always reads from local
└────┬─────┘
     │
┌────▼─────────┐
│   Database   │ ← Single source of truth
└────┬─────────┘
     │
┌────▼─────────┐
│  Repository  │ ← Manages sync
└────┬─────────┘
     │
┌────▼─────────┐
│   Network    │ ← Background sync
└──────────────┘
```

#### 3. Network-Bound Resource Pattern

**Basic Implementation:**
```kotlin
inline fun <ResultType, RequestType> networkBoundResource(
    crossinline query: () -> Flow<ResultType>,
    crossinline fetch: suspend () -> RequestType,
    crossinline saveFetchResult: suspend (RequestType) -> Unit,
    crossinline shouldFetch: (ResultType) -> Boolean = { true }
): Flow<Resource<ResultType>> = flow {
    
    // 1. Emit loading state with cached data
    val data = query().first()
    emit(Resource.Loading(data))
    
    // 2. Check if we should fetch from network
    if (shouldFetch(data)) {
        try {
            // 3. Fetch from network
            val apiResponse = fetch()
            
            // 4. Save to database
            saveFetchResult(apiResponse)
            
            // 5. Emit success with new data
            query().collect { newData ->
                emit(Resource.Success(newData))
            }
        } catch (e: Exception) {
            // 6. On error, emit error with cached data
            query().collect { cachedData ->
                emit(Resource.Error(e.message ?: "Unknown error", cachedData))
            }
        }
    } else {
        // 7. No need to fetch, use cached data
        query().collect { cachedData ->
            emit(Resource.Success(cachedData))
        }
    }
}

// Sealed class for resource state
sealed class Resource<T>(
    val data: T? = null,
    val message: String? = null
) {
    class Success<T>(data: T) : Resource<T>(data)
    class Loading<T>(data: T? = null) : Resource<T>(data)
    class Error<T>(message: String, data: T? = null) : Resource<T>(data, message)
}
```

**Usage Example:**
```kotlin
class UserRepository(
    private val userDao: UserDao,
    private val apiService: ApiService
) {
    fun getUsers(): Flow<Resource<List<User>>> = networkBoundResource(
        query = { userDao.getAllUsers() },
        fetch = { apiService.getUsers() },
        saveFetchResult = { users ->
            userDao.deleteAll()
            userDao.insertAll(users)
        },
        shouldFetch = { cachedUsers ->
            // Fetch if cache is empty or stale
            cachedUsers.isEmpty() || isCacheStale()
        }
    )
    
    private fun isCacheStale(): Boolean {
        val lastFetchTime = preferences.getLong("last_fetch_users", 0)
        val now = System.currentTimeMillis()
        val cacheTimeout = 5 * 60 * 1000 // 5 minutes
        return (now - lastFetchTime) > cacheTimeout
    }
}
```

#### 4. Caching Strategies

**Strategy 1: Cache-First**
```kotlin
// Always read from cache first, update in background
suspend fun getCacheFirst(): List<User> {
    // 1. Return cached data immediately
    val cachedUsers = userDao.getAllUsers().first()
    
    // 2. Fetch and update in background
    viewModelScope.launch {
        try {
            val freshUsers = apiService.getUsers()
            userDao.insertAll(freshUsers)
        } catch (e: Exception) {
            // Silent fail, user already has cached data
        }
    }
    
    return cachedUsers
}
```

**Strategy 2: Network-First with Cache Fallback**
```kotlin
suspend fun getNetworkFirst(): Resource<List<User>> {
    return try {
        // 1. Try network first
        val users = apiService.getUsers()
        
        // 2. Update cache
        userDao.insertAll(users)
        
        Resource.Success(users)
    } catch (e: Exception) {
        // 3. Network failed, use cache
        val cachedUsers = userDao.getAllUsers().first()
        if (cachedUsers.isNotEmpty()) {
            Resource.Error("Using cached data", cachedUsers)
        } else {
            Resource.Error(e.message ?: "No data available", null)
        }
    }
}
```

**Strategy 3: Cache-Only (True Offline-First)**
```kotlin
// UI always reads from cache
fun getUsersFlow(): Flow<List<User>> = userDao.getAllUsers()

// Sync happens independently
suspend fun syncUsers() {
    if (isNetworkAvailable()) {
        try {
            val users = apiService.getUsers()
            userDao.insertAll(users)
            updateLastSyncTime()
        } catch (e: Exception) {
            // Log error, retry later
        }
    }
}
```

**Strategy 4: Stale-While-Revalidate**
```kotlin
fun getStaleWhileRevalidate(): Flow<Resource<List<User>>> = flow {
    // 1. Emit cached data immediately (even if stale)
    val cached = userDao.getAllUsers().first()
    if (cached.isNotEmpty()) {
        emit(Resource.Success(cached))
    }
    
    // 2. Fetch fresh data in background
    try {
        val fresh = apiService.getUsers()
        userDao.insertAll(fresh)
        
        // 3. Emit fresh data
        emit(Resource.Success(fresh))
    } catch (e: Exception) {
        // Keep showing cached data
        if (cached.isEmpty()) {
            emit(Resource.Error(e.message, null))
        }
    }
}
```

#### 5. Network State Monitoring
```kotlin
class NetworkMonitor @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val connectivityManager = context.getSystemService(
        Context.CONNECTIVITY_SERVICE
    ) as ConnectivityManager
    
    val isConnected: StateFlow<Boolean> = callbackFlow {
        val callback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                trySend(true)
            }
            
            override fun onLost(network: Network) {
                trySend(false)
            }
        }
        
        connectivityManager.registerDefaultNetworkCallback(callback)
        
        // Emit current state
        val currentState = connectivityManager.activeNetwork != null
        trySend(currentState)
        
        awaitClose {
            connectivityManager.unregisterNetworkCallback(callback)
        }
    }.stateIn(
        scope = CoroutineScope(Dispatchers.Default),
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = false
    )
    
    fun isNetworkAvailable(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network)
        return capabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) == true
    }
}
```

**Usage in Repository:**
```kotlin
class PostRepository(
    private val postDao: PostDao,
    private val apiService: ApiService,
    private val networkMonitor: NetworkMonitor
) {
    suspend fun getPosts(): Flow<Resource<List<Post>>> = flow {
        // Always emit cached data first
        val cached = postDao.getAllPosts().first()
        emit(Resource.Loading(cached))
        
        if (networkMonitor.isNetworkAvailable()) {
            try {
                val fresh = apiService.getPosts()
                postDao.insertAll(fresh)
                emit(Resource.Success(fresh))
            } catch (e: Exception) {
                emit(Resource.Error(e.message, cached))
            }
        } else {
            // Offline, just use cache
            emit(Resource.Success(cached))
        }
    }
}
```

#### 6. Background Sync with WorkManager

**Sync Worker:**
```kotlin
class SyncWorker(
    context: Context,
    params: WorkerParameters,
    private val repository: PostRepository
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        return try {
            repository.syncPosts()
            Result.success()
        } catch (e: Exception) {
            if (runAttemptCount < 3) {
                Result.retry()
            } else {
                Result.failure()
            }
        }
    }
}

// Schedule sync
fun scheduleSyncWork(context: Context) {
    val constraints = Constraints.Builder()
        .setRequiredNetworkType(NetworkType.CONNECTED)
        .build()
    
    val syncRequest = PeriodicWorkRequestBuilder<SyncWorker>(
        repeatInterval = 1,
        repeatIntervalTimeUnit = TimeUnit.HOURS
    )
        .setConstraints(constraints)
        .setBackoffCriteria(
            BackoffPolicy.EXPONENTIAL,
            WorkRequest.MIN_BACKOFF_MILLIS,
            TimeUnit.MILLISECONDS
        )
        .build()
    
    WorkManager.getInstance(context)
        .enqueueUniquePeriodicWork(
            "sync_posts",
            ExistingPeriodicWorkPolicy.KEEP,
            syncRequest
        )
}
```

#### 7. Pending Operations Queue

**For Create/Update/Delete Operations:**
```kotlin
@Entity(tableName = "pending_operations")
data class PendingOperation(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val operationType: OperationType,
    val entityType: String,
    val entityId: String,
    val jsonData: String,
    val timestamp: Long = System.currentTimeMillis(),
    val retryCount: Int = 0
)

enum class OperationType {
    CREATE, UPDATE, DELETE
}

// DAO
@Dao
interface PendingOperationDao {
    @Query("SELECT * FROM pending_operations ORDER BY timestamp ASC")
    fun getAllPending(): Flow<List<PendingOperation>>
    
    @Insert
    suspend fun insert(operation: PendingOperation)
    
    @Delete
    suspend fun delete(operation: PendingOperation)
}

// Repository with pending operations
class PostRepository(
    private val postDao: PostDao,
    private val pendingOpDao: PendingOperationDao,
    private val apiService: ApiService
) {
    suspend fun createPost(post: Post) {
        // 1. Save to local database immediately
        val localId = postDao.insert(post)
        
        // 2. Add to pending operations queue
        val operation = PendingOperation(
            operationType = OperationType.CREATE,
            entityType = "Post",
            entityId = localId.toString(),
            jsonData = Gson().toJson(post)
        )
        pendingOpDao.insert(operation)
        
        // 3. Try to sync immediately if online
        if (networkMonitor.isNetworkAvailable()) {
            syncPendingOperations()
        }
    }
    
    suspend fun syncPendingOperations() {
        val pending = pendingOpDao.getAllPending().first()
        
        pending.forEach { operation ->
            try {
                when (operation.operationType) {
                    OperationType.CREATE -> {
                        val post = Gson().fromJson(operation.jsonData, Post::class.java)
                        val response = apiService.createPost(post)
                        
                        // Update local post with server ID
                        postDao.updateServerId(operation.entityId.toLong(), response.id)
                        
                        // Remove from pending
                        pendingOpDao.delete(operation)
                    }
                    OperationType.UPDATE -> {
                        // Similar logic
                    }
                    OperationType.DELETE -> {
                        // Similar logic
                    }
                }
            } catch (e: Exception) {
                // Handle error, maybe retry later
                Log.e("Sync", "Failed to sync operation: ${e.message}")
            }
        }
    }
}
```

#### 8. Conflict Resolution

**Last-Write-Wins Strategy:**
```kotlin
suspend fun resolveConflict(local: Post, remote: Post): Post {
    return if (local.updatedAt > remote.updatedAt) {
        // Local is newer, upload to server
        apiService.updatePost(local.id, local)
        local
    } else {
        // Remote is newer, save to local
        postDao.update(remote)
        remote
    }
}
```

**Manual Conflict Resolution:**
```kotlin
data class Conflict<T>(
    val local: T,
    val remote: T,
    val resolved: Boolean = false
)

class ConflictManager {
    private val _conflicts = MutableStateFlow<List<Conflict<Post>>>(emptyList())
    val conflicts: StateFlow<List<Conflict<Post>>> = _conflicts.asStateFlow()
    
    fun addConflict(local: Post, remote: Post) {
        val current = _conflicts.value.toMutableList()
        current.add(Conflict(local, remote))
        _conflicts.value = current
    }
    
    suspend fun resolveConflict(conflict: Conflict<Post>, useLocal: Boolean) {
        val resolved = if (useLocal) {
            apiService.updatePost(conflict.local.id, conflict.local)
            conflict.local
        } else {
            postDao.update(conflict.remote)
            conflict.remote
        }
        
        // Remove from conflicts list
        _conflicts.value = _conflicts.value.filter { it != conflict }
    }
}
```

#### 9. Cache Expiration & Invalidation

**Time-Based Expiration:**
```kotlin
@Entity(tableName = "cache_metadata")
data class CacheMetadata(
    @PrimaryKey
    val key: String,
    val lastFetchTime: Long,
    val expirationTime: Long
)

class CacheManager(
    private val cacheMetadataDao: CacheMetadataDao
) {
    suspend fun isCacheValid(key: String, maxAgeMillis: Long): Boolean {
        val metadata = cacheMetadataDao.getMetadata(key) ?: return false
        val now = System.currentTimeMillis()
        return (now - metadata.lastFetchTime) < maxAgeMillis
    }
    
    suspend fun updateCacheTime(key: String) {
        val metadata = CacheMetadata(
            key = key,
            lastFetchTime = System.currentTimeMillis(),
            expirationTime = System.currentTimeMillis() + TimeUnit.HOURS.toMillis(1)
        )
        cacheMetadataDao.insert(metadata)
    }
    
    suspend fun invalidateCache(key: String) {
        cacheMetadataDao.delete(key)
    }
}
```

**Manual Cache Invalidation:**
```kotlin
suspend fun refreshPosts() {
    // Clear cache
    postDao.deleteAll()
    cacheManager.invalidateCache("posts")
    
    // Fetch fresh data
    val fresh = apiService.getPosts()
    postDao.insertAll(fresh)
    cacheManager.updateCacheTime("posts")
}
```

#### 10. Optimistic Updates

**Immediate UI Update:**
```kotlin
suspend fun likePost(postId: String) {
    // 1. Update UI immediately (optimistic)
    postDao.incrementLikes(postId)
    
    // 2. Try to sync with server
    try {
        apiService.likePost(postId)
    } catch (e: Exception) {
        // 3. Rollback on failure
        postDao.decrementLikes(postId)
        
        // Show error to user
        _error.emit("Failed to like post")
    }
}
```

**With Undo:**
```kotlin
class PostViewModel(
    private val repository: PostRepository
) : ViewModel() {
    
    private val undoStack = mutableListOf<suspend () -> Unit>()
    
    fun deletePost(post: Post) {
        viewModelScope.launch {
            // 1. Delete locally
            repository.deletePost(post)
            
            // 2. Add undo action
            undoStack.add {
                repository.insertPost(post)
            }
            
            // 3. Show snackbar with undo option
            _snackbarMessage.emit("Post deleted" to true)
            
            // 4. Actually delete from server after delay
            delay(5000)
            if (undoStack.isNotEmpty()) {
                try {
                    apiService.deletePost(post.id)
                    undoStack.clear()
                } catch (e: Exception) {
                    // Rollback
                    repository.insertPost(post)
                }
            }
        }
    }
    
    fun undo() {
        viewModelScope.launch {
            undoStack.lastOrNull()?.invoke()
            undoStack.removeLastOrNull()
        }
    }
}
```

#### 11. Offline Indicators in UI

**Network Status Banner:**
```kotlin
@Composable
fun OfflineBanner(isOffline: Boolean) {
    AnimatedVisibility(
        visible = isOffline,
        enter = slideInVertically(),
        exit = slideOutVertically()
    ) {
        Surface(
            color = MaterialTheme.colorScheme.errorContainer,
            modifier = Modifier.fillMaxWidth()
        ) {
            Row(
                modifier = Modifier.padding(16.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    imageVector = Icons.Default.CloudOff,
                    contentDescription = null
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text("You're offline. Changes will sync when connected.")
            }
        }
    }
}
```

**Pending Sync Indicator:**
```kotlin
@Composable
fun SyncStatusIndicator(pendingCount: Int) {
    if (pendingCount > 0) {
        Card(
            modifier = Modifier
                .padding(8.dp)
                .fillMaxWidth()
        ) {
            Row(
                modifier = Modifier.padding(16.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                CircularProgressIndicator(
                    modifier = Modifier.size(24.dp)
                )
                Spacer(modifier = Modifier.width(12.dp))
                Text("$pendingCount changes pending sync")
            }
        }
    }
}
```

#### 12. Best Practices
✅ Local database as single source of truth
✅ UI always reads from local database
✅ Sync in background
✅ Show cached data while fetching
✅ Implement conflict resolution
✅ Queue pending operations
✅ Use WorkManager for periodic sync
✅ Indicate offline status to users
✅ Handle sync failures gracefully
✅ Test offline scenarios thoroughly

#### 13. Testing Offline-First
```kotlin
@Test
fun `test offline data access`() = runTest {
    // Given: No network connection
    whenever(networkMonitor.isNetworkAvailable()).thenReturn(false)
    
    // And: Data in cache
    val cachedPosts = listOf(Post(id = "1", title = "Cached"))
    postDao.insertAll(cachedPosts)
    
    // When: Fetching posts
    val result = repository.getPosts().first()
    
    // Then: Returns cached data
    assertTrue(result is Resource.Success)
    assertEquals(cachedPosts, result.data)
}

@Test
fun `test sync when online`() = runTest {
    // Given: Network available
    whenever(networkMonitor.isNetworkAvailable()).thenReturn(true)
    
    // And: Fresh data from API
    val freshPosts = listOf(Post(id = "2", title = "Fresh"))
    whenever(apiService.getPosts()).thenReturn(freshPosts)
    
    // When: Syncing
    repository.syncPosts()
    
    // Then: Database updated
    val cached = postDao.getAllPosts().first()
    assertEquals(freshPosts, cached)
}
```

#### 14. Hands-on Project
- Implement offline-first architecture
- Network-bound resource pattern
- Pending operations queue
- Background sync dengan WorkManager
- Conflict resolution
- Optimistic updates
- Offline UI indicators
- Testing offline scenarios

---
