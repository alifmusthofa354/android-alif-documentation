## **8.5 Testing with Hilt** (3 hari) ⭐⭐

### **Teknologi Modern:**
- @HiltAndroidTest
- @UninstallModules
- @TestInstallIn
- HiltTestApplication

### **Teknologi yang Ditinggalkan:**
- No DI in tests
- Manual mocking
- Hard-to-test code

### **Sub-topik Detail:**

#### **1. Test Setup**

**Dependencies:**
```kotlin
dependencies {
    // Hilt testing
    androidTestImplementation("com.google.dagger:hilt-android-testing:2.48")
    kaptAndroidTest("com.google.dagger:hilt-android-compiler:2.48")
    
    testImplementation("com.google.dagger:hilt-android-testing:2.48")
    kaptTest("com.google.dagger:hilt-android-compiler:2.48")
    
    // Testing libraries
    testImplementation("junit:junit:4.13.2")
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")
    testImplementation("app.cash.turbine:turbine:1.0.0")
    
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
}
```

**Custom Test Runner:**
```kotlin
class HiltTestRunner : AndroidJUnitRunner() {
    override fun newApplication(
        cl: ClassLoader?,
        className: String?,
        context: Context?
    ): Application {
        return super.newApplication(cl, HiltTestApplication::class.java.name, context)
    }
}

// build.gradle
android {
    defaultConfig {
        testInstrumentationRunner = "com.example.HiltTestRunner"
    }
}
```

#### **2. Unit Tests**

**ViewModel Test:**
```kotlin
@HiltAndroidTest
@Config(application = HiltTestApplication::class)
@RunWith(RobolectricTestRunner::class)
class UserViewModelTest {
    
    @get:Rule
    var hiltRule = HiltAndroidRule(this)
    
    @Inject
    lateinit var repository: UserRepository
    
    private lateinit var viewModel: UserViewModel
    
    @Before
    fun setup() {
        hiltRule.inject()
        viewModel = UserViewModel(repository)
    }
    
    @Test
    fun `test load user success`() = runTest {
        // When
        viewModel.loadUser("1")
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertTrue(state is UiState.Success)
    }
}
```

**Repository Test:**
```kotlin
@HiltAndroidTest
class UserRepositoryTest {
    
    @get:Rule
    var hiltRule = HiltAndroidRule(this)
    
    @Inject
    lateinit var repository: UserRepository
    
    @Inject
    lateinit var database: AppDatabase
    
    @Before
    fun setup() {
        hiltRule.inject()
    }
    
    @After
    fun cleanup() {
        database.close()
    }
    
    @Test
    fun `test get user from cache`() = runTest {
        // Given
        val user = User("1", "John")
        database.userDao().insert(user)
        
        // When
        val result = repository.getUser("1")
        
        // Then
        assertEquals(user, result)
    }
}
```

#### **3. Replacing Modules**

**Uninstall Production Module:**
```kotlin
@UninstallModules(NetworkModule::class)
@HiltAndroidTest
class UserRepositoryTest {
    
    @get:Rule
    var hiltRule = HiltAndroidRule(this)
    
    @Inject
    lateinit var repository: UserRepository
    
    @Before
    fun setup() {
        hiltRule.inject()
    }
    
    @Test
    fun testWithFakeApi() = runTest {
        // Uses FakeNetworkModule instead
        val user = repository.getUser("1")
        assertNotNull(user)
    }
}

// Test module
@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [NetworkModule::class]
)
object FakeNetworkModule {
    
    @Provides
    @Singleton
    fun provideApiService(): ApiService {
        return FakeApiService()
    }
}
```

#### **4. Test Doubles**

**Fake Repository:**
```kotlin
class FakeUserRepository : UserRepository {
    private val users = mutableListOf<User>()
    
    override suspend fun getUser(id: String): User {
        return users.find { it.id == id } 
            ?: throw NotFoundException()
    }
    
    override suspend fun saveUser(user: User) {
        users.add(user)
    }
    
    fun clear() {
        users.clear()
    }
}

@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [RepositoryModule::class]
)
abstract class FakeRepositoryModule {
    
    @Binds
    @Singleton
    abstract fun bindUserRepository(
        impl: FakeUserRepository
    ): UserRepository
}
```

#### **5. Instrumented Tests**

**Activity Test:**
```kotlin
@HiltAndroidTest
class MainActivityTest {
    
    @get:Rule(order = 0)
    var hiltRule = HiltAndroidRule(this)
    
    @get:Rule(order = 1)
    var activityRule = ActivityScenarioRule(MainActivity::class.java)
    
    @Inject
    lateinit var repository: UserRepository
    
    @Before
    fun setup() {
        hiltRule.inject()
    }
    
    @Test
    fun testUserListDisplayed() {
        // Given
        runBlocking {
            repository.saveUser(User("1", "John"))
        }
        
        // When
        activityRule.scenario.onActivity { activity ->
            // Interact with activity
        }
        
        // Then
        onView(withText("John")).check(matches(isDisplayed()))
    }
}
```

**Fragment Test:**
```kotlin
@HiltAndroidTest
class UserFragmentTest {
    
    @get:Rule
    var hiltRule = HiltAndroidRule(this)
    
    @Before
    fun setup() {
        hiltRule.inject()
    }
    
    @Test
    fun testFragmentDisplaysUser() {
        // Launch fragment
        launchFragmentInHiltContainer<UserFragment> {
            // Fragment is now launched with Hilt dependencies
        }
        
        // Verify UI
        onView(withId(R.id.userName)).check(matches(isDisplayed()))
    }
}

// Helper function
inline fun <reified T : Fragment> launchFragmentInHiltContainer(
    fragmentArgs: Bundle? = null,
    themeResId: Int = R.style.Theme_App,
    crossinline action: Fragment.() -> Unit = {}
) {
    val mainActivityIntent = Intent.makeMainActivity(
        ComponentName(
            ApplicationProvider.getApplicationContext(),
            HiltTestActivity::class.java
        )
    ).putExtra("androidx.fragment.app.testing.FragmentScenario.EmptyFragmentActivity.THEME_EXTRAS_BUNDLE_KEY", themeResId)
    
    ActivityScenario.launch<HiltTestActivity>(mainActivityIntent).onActivity { activity ->
        val fragment = activity.supportFragmentManager.fragmentFactory.instantiate(
            T::class.java.classLoader!!,
            T::class.java.name
        )
        fragment.arguments = fragmentArgs
        
        activity.supportFragmentManager.beginTransaction()
            .add(android.R.id.content, fragment, "")
            .commitNow()
        
        fragment.action()
    }
}
```

#### **6. Testing ViewModels**

**Complete ViewModel Test:**
```kotlin
@HiltAndroidTest
@Config(application = HiltTestApplication::class)
@RunWith(RobolectricTestRunner::class)
class UserViewModelTest {
    
    @get:Rule
    var hiltRule = HiltAndroidRule(this)
    
    private lateinit var viewModel: UserViewModel
    
    @Inject
    lateinit var repository: FakeUserRepository
    
    private val testDispatcher = StandardTestDispatcher()
    
    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
        hiltRule.inject()
        viewModel = UserViewModel(repository)
    }
    
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
    
    @Test
    fun `initial state is loading`() {
        assertEquals(UiState.Loading, viewModel.uiState.value)
    }
    
    @Test
    fun `load user success updates state`() = runTest {
        // Given
        val user = User("1", "John")
        repository.saveUser(user)
        
        // When
        viewModel.loadUser("1")
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertTrue(state is UiState.Success)
        assertEquals(user, (state as UiState.Success).data)
    }
    
    @Test
    fun `load user error updates state`() = runTest {
        // When
        viewModel.loadUser("999") // Non-existent user
        advanceUntilIdle()
        
        // Then
        val state = viewModel.uiState.value
        assertTrue(state is UiState.Error)
    }
    
    @Test
    fun `ui state flow emits correctly`() = runTest {
        // Given
        val user = User("1", "John")
        repository.saveUser(user)
        
        // When & Then
        viewModel.uiState.test {
            assertEquals(UiState.Loading, awaitItem())
            
            viewModel.loadUser("1")
            assertEquals(UiState.Success(user), awaitItem())
        }
    }
}
```

#### **7. Testing with TestDispatcher**

**Dispatcher Module:**
```kotlin
@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [DispatcherModule::class]
)
object TestDispatcherModule {
    
    @Provides
    @IoDispatcher
    fun provideIODispatcher(): CoroutineDispatcher = 
        StandardTestDispatcher()
    
    @Provides
    @MainDispatcher
    fun provideMainDispatcher(): CoroutineDispatcher = 
        StandardTestDispatcher()
}
```

#### **8. Best Practices**
✅ Use @HiltAndroidTest annotation
✅ Replace production modules with test modules
✅ Use fake implementations over mocks when possible
✅ Test with TestDispatcher
✅ Use HiltTestApplication
✅ Organize test modules separately
✅ Clean up after tests
✅ Test different scenarios (success, error, loading)

---
