# üé® Panduan Lengkap: State Management di Jetpack Compose

## üöÄ Pengantar: Menguasai Data dan State di Compose

Bayangkan kamu adalah seorang tukang kebun digital üå±:
- **State** seperti tanaman yang bisa tumbuh, berubah, dan berkembang
- **Compose** seperti tanah subur yang menanggapi setiap perubahan

Dengan menguasai State Management, kamu bisa membuat aplikasi yang hidup dan responsif!

## üìö Daftar Isi Pembelajaran
1. [üå± Konsep State di Compose](#1Ô∏è‚É£-konsep-state-di-compose-üå±)
2. [üß† remember](#2Ô∏è‚É£-remember-menyimpan-nilai-üß†)
3. [üîÑ mutableStateOf](#3Ô∏è‚É£-mutablestateof-mengelola-state-üîÑ)
4. [üíæ rememberSaveable](#4Ô∏è‚É£-remembersaveable-menjaga-state-üíæ)
5. [üì§ State Hoisting](#5Ô∏è‚É£-state-hoisting-menaikkan-state-üì§)
6. [üåä Unidirectional Data Flow](#6Ô∏è‚É£-unidirectional-data-flow-aliran-data-satu-arah-üåä)
7. [üßÆ derivedStateOf](#7Ô∏è‚É£-derivedstateof-state-turunan-üßÆ)
8. [üìã State in Lists](#8Ô∏è‚É£-state-in-lists-state-di-dalam-list-üìã)
9. [üéØ Kesimpulan](#üéØ-kesimpulan)

---

## 1Ô∏è‚É£ Konsep State di Compose üå±

### Apa itu State?
State seperti air üíß - bisa mengalir, berubah, dan mempengaruhi lingkungan sekitarnya!

**State** adalah data yang bisa berubah dan memicu penataan ulang (recomposition) komponen.

### State Triggers Recomposition
Ketika state berubah, Compose akan secara otomatis menata ulang komponen yang bergantung pada state tersebut.

### Implementation
**ui/screens/StateConceptsScreen.kt**
```kotlin
package com.example.mycomposeapp.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun StateConceptsScreen() {
    // State disimpan dan bisa berubah
    var clickCount by remember { mutableStateOf(0) }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("1Ô∏è‚É£ Konsep State di Compose", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        // 1. Contoh State Basic
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "Jumlah Klik: $clickCount",
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Button(
                    onClick = { clickCount++ }
                ) {
                    Text("Tambah Klik")
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Button(
                    onClick = { clickCount = 0 },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = Color.Red
                    )
                ) {
                    Text("Reset")
                }
            }
        }

        // 2. Stateless vs Stateful Composables
        Text("2Ô∏è‚É£ Stateless vs Stateful Composables", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "Stateful Composable (ada state sendiri):",
                    fontWeight = FontWeight.Bold
                )
                
                StatefulCounter()
                
                Spacer(modifier = Modifier.height(16.dp))
                
                Text(
                    text = "Stateless Composable (menerima state dari luar):",
                    fontWeight = FontWeight.Bold
                )
                
                val (count, setCount) = remember { mutableStateOf(0) }
                StatelessCounter(
                    count = count,
                    onIncrement = { setCount(count + 1) },
                    onDecrement = { setCount(count - 1) },
                    onReset = { setCount(0) }
                )
            }
        }
    }
}

// Stateful Composable - memiliki state sendiri
@Composable
fun StatefulCounter() {
    var count by remember { mutableStateOf(0) }
    
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .background(Color(0xFFE3F2FD))
            .padding(16.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Button(onClick = { count-- }) {
            Text("-")
        }
        
        Text(
            text = "$count",
            fontSize = 24.sp,
            fontWeight = FontWeight.Bold
        )
        
        Button(onClick = { count++ }) {
            Text("+")
        }
    }
}

// Stateless Composable - menerima state dari luar
@Composable
fun StatelessCounter(
    count: Int,
    onIncrement: () -> Unit,
    onDecrement: () -> Unit,
    onReset: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .background(Color(0xFFFFF3E0))
            .padding(16.dp),
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Button(onClick = onDecrement) {
            Text("-")
        }
        
        Text(
            text = "$count",
            fontSize = 24.sp,
            fontWeight = FontWeight.Bold
        )
        
        Button(onClick = onIncrement) {
            Text("+")
        }
        
        Spacer(modifier = Modifier.width(8.dp))
        
        OutlinedButton(
            onClick = onReset,
            colors = ButtonDefaults.outlinedButtonColors(
                contentColor = Color.Red
            )
        ) {
            Text("Reset")
        }
    }
}
```

### üéì Penjelasan Konsep:
**State seperti Air:**
- **State** = Data yang bisa berubah seiring waktu
- **Recomposition** = Proses penataan ulang UI ketika state berubah
- **Stateful** = Komponen yang memiliki state sendiri
- **Stateless** = Komponen yang menerima state dari luar

**Apa itu State:**
- Data yang bisa berubah
- Memicu recomposition saat berubah
- Membuat UI menjadi dinamis dan interaktif

**State Triggers Recomposition:**
- Ketika nilai state berubah
- Compose otomatis menata ulang komponen yang bergantung
- Efisien karena hanya menata ulang yang diperlukan

---

## 2Ô∏è‚É£ remember: Menyimpan Nilai üß†

### Konsep Dasar
`remember` seperti kotak penyimpanan ajaib üéí - menyimpan nilai di antara recomposition!

### Implementation
**ui/screens/RememberExamplesScreen.kt**
```kotlin
package com.example.mycomposeapp.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun RememberExamplesScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("2Ô∏è‚É£ remember: Menyimpan Nilai", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        // 1. Basic remember usage
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "Basic remember:",
                    fontWeight = FontWeight.Bold
                )
                
                val timestamp = remember { System.currentTimeMillis() }
                
                Text("Timestamp saat pertama kali: $timestamp")
                Text("Nilai ini tidak akan berubah saat recomposition")
            }
        }

        // 2. remember with mutableStateOf
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "remember with mutableStateOf:",
                    fontWeight = FontWeight.Bold
                )
                
                var count by remember { mutableStateOf(0) }
                
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Button(onClick = { count++ }) {
                        Text("Tambah")
                    }
                    
                    Text(
                        text = "Count: $count",
                        fontSize = 18.sp,
                        fontWeight = FontWeight.Bold
                    )
                }
            }
        }

        // 3. Tanpa remember - efek negatif
        Text("3Ô∏è‚É£ Tanpa remember (contoh yang salah)", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "Tanpa remember - nilai akan reset setiap recomposition:",
                    fontWeight = FontWeight.Bold
                )
                
                // Ini adalah contoh yang salah - jangan lakukan ini!
                var badCount = 0 // TIDAK DIREKOMENDASIKAN
                
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Button(
                        onClick = { 
                            badCount++ // Nilai akan reset setiap recomposition
                            println("Bad count: $badCount")
                        }
                    ) {
                        Text("Coba Tekan (Salah)")
                    }
                    
                    Text(
                        text = "Count: $badCount (akan selalu 0)",
                        fontSize = 14.sp,
                        color = Color.Red
                    )
                }
            }
        }

        // 4. Contoh perbedaan dengan dan tanpa remember
        Text("4Ô∏è‚É£ Perbedaan dengan dan tanpa remember", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "Dengan remember:",
                    fontWeight = FontWeight.Bold
                )
                
                var goodCount by remember { mutableStateOf(0) }
                
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Button(onClick = { goodCount++ }) {
                        Text("Tambah")
                    }
                    
                    Text(
                        text = "Count: $goodCount",
                        fontSize = 16.sp
                    )
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text(
                    text = "Catatan: nilai tetap saat recomposition",
                    fontSize = 12.sp,
                    color = Color.Gray
                )
            }
        }
    }
}
```

### üéì Penjelasan Konsep:
**remember seperti Kotak Ajaib:**
- Menyimpan nilai di antara recomposition
- Nilai tidak akan hilang setiap kali UI di-render ulang
- Wajib digunakan untuk menyimpan state

**Kapan menggunakan remember:**
- Simpan nilai yang harus bertahan antar recomposition
- Buat mutableStateOf di dalamnya
- Simpan objek yang mahal untuk dibuat

**Perbedaan tanpa dan dengan remember:**
- Tanpa remember: nilai reset setiap recomposition
- Dengan remember: nilai bertahan di antara recomposition

---

## 3Ô∏è‚É£ mutableStateOf: Mengelola State üîÑ

### Konsep Dasar
`mutableStateOf` seperti buku diary üîí - bisa dibaca dan ditulis, dan siapa tahu perubahan!

### Implementation
**ui/screens/MutableStateOfExamplesScreen.kt**
```kotlin
package com.example.mycomposeapp.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Email
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun MutableStateOfExamplesScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("3Ô∏è‚É£ mutableStateOf: Mengelola State", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        // 1. Basic mutableStateOf
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "Basic mutableStateOf:",
                    fontWeight = FontWeight.Bold
                )
                
                var (name, setName) = remember { mutableStateOf("Ahmad") }
                
                OutlinedTextField(
                    value = name,
                    onValueChange = setName,
                    label = { Text("Nama") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text("Halo, $name!")
            }
        }

        // 2. Destructuring: (value, setValue)
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "Destructuring: (value, setValue)",
                    fontWeight = FontWeight.Bold
                )
                
                val (email, setEmail) = remember { mutableStateOf("") }
                
                OutlinedTextField(
                    value = email,
                    onValueChange = setEmail,
                    label = { Text("Email") },
                    leadingIcon = {
                        Icon(
                            imageVector = Icons.Default.Email,
                            contentDescription = null
                        )
                    },
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                if (email.isNotBlank()) {
                    Text("Email yang dimasukkan: $email")
                }
            }
        }

        // 3. Delegation: var value by mutableStateOf("")
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "Delegation: var value by mutableStateOf",
                    fontWeight = FontWeight.Bold
                )
                
                var password by remember { mutableStateOf("") }
                var passwordVisible by remember { mutableStateOf(false) }
                
                OutlinedTextField(
                    value = password,
                    onValueChange = { password = it },
                    label = { Text("Password") },
                    leadingIcon = {
                        Icon(
                            imageVector = Icons.Default.Lock,
                            contentDescription = null
                        )
                    },
                    visualTransformation = if (passwordVisible) {
                        VisualTransformation.None
                    } else {
                        PasswordVisualTransformation()
                    },
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = passwordVisible,
                        onCheckedChange = { passwordVisible = !passwordVisible }
                    )
                    Text("Tampilkan Password")
                }
            }
        }

        // 4. State<T> vs MutableState<T>
        Text("4Ô∏è‚É£ State<T> vs MutableState<T>", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "MutableState<T> (bisa diubah):",
                    fontWeight = FontWeight.Bold
                )
                
                var count by remember { mutableStateOf(0) }
                
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Button(onClick = { count++ }) {
                        Text("Tambah")
                    }
                    
                    Text("Count: $count", fontWeight = FontWeight.Bold)
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text(
                    text = "State<T> (read-only):",
                    fontWeight = FontWeight.Bold
                )
                
                val readOnlyCount = remember { mutableStateOf(0) }
                
                Text("Count (read-only): ${readOnlyCount.value}")
                
                Button(
                    onClick = { readOnlyCount.value++ }, // Masih bisa diubah karena mutableStateOf
                    enabled = true
                ) {
                    Text("Ubah dari read-only (sebenarnya MutableState)")
                }
            }
        }

        // 5. Contoh kompleks: Form pendaftaran
        Text("5Ô∏è‚É£ Contoh Kompleks: Form Pendaftaran", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        RegistrationForm()
    }
}

@Composable
fun RegistrationForm() {
    var name by remember { mutableStateOf("") }
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var isTermsChecked by remember { mutableStateOf(false) }
    var showPassword by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier.fillMaxWidth()
    ) 
    {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) 
        {
            Text(
                text = "Form Pendaftaran",
                fontSize = 18.sp,
                fontWeight = FontWeight.Bold
            )
            
            OutlinedTextField(
                value = name,
                onValueChange = { name = it },
                label = { Text("Nama Lengkap") },
                leadingIcon = {
                    Icon(
                        imageVector = Icons.Default.Person,
                        contentDescription = null
                    )
                },
                modifier = Modifier.fillMaxWidth()
            )
            
            OutlinedTextField(
                value = email,
                onValueChange = { email = it },
                label = { Text("Email") },
                leadingIcon = {
                    Icon(
                        imageVector = Icons.Default.Email,
                        contentDescription = null
                    )
                },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
                modifier = Modifier.fillMaxWidth()
            )
            
            OutlinedTextField(
                value = password,
                onValueChange = { password = it },
                label = { Text("Password") },
                leadingIcon = {
                    Icon(
                        imageVector = Icons.Default.Lock,
                        contentDescription = null
                    )
                },
                visualTransformation = if (showPassword) {
                    VisualTransformation.None
                } else {
                    PasswordVisualTransformation()
                },
                modifier = Modifier.fillMaxWidth()
            )
            
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                Checkbox(
                    checked = showPassword,
                    onCheckedChange = { showPassword = it }
                )
                Text("Tampilkan Password")
            }
            
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                Checkbox(
                    checked = isTermsChecked,
                    onCheckedChange = { isTermsChecked = it }
                )
                Text("Saya setuju dengan syarat dan ketentuan")
            }
            
            Button(
                onClick = { 
                    println("Nama: $name, Email: $email, Password: $password, Terms: $isTermsChecked")
                },
                enabled = name.isNotBlank() && email.isNotBlank() && password.isNotBlank() && isTermsChecked,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Daftar")
            }
        }
    }
}

```

### üéì Penjelasan Konsep

**mutableStateOf seperti Buku Diary:**
- Bisa **read** (dibaca) dan **write** (ditulis)
- Otomatis memicu recomposition saat berubah
- Menggunakan `by` delegation atau destructuring

**State<T> vs MutableState<T>:**
- `State<T>`: hanya bisa baca (read-only)
- `MutableState<T>`: bisa baca dan tulis

**Dua cara menggunakan mutableStateOf:**
1. **Destructuring**: `val (value, setValue) = remember { mutableStateOf("") }`
2. **Delegation**: `var value by remember { mutableStateOf("") }`

---

## 4Ô∏è‚É£ rememberSaveable: Menjaga State üíæ

### Konsep Dasar
`rememberSaveable` seperti brankas yang aman üè¶ - state tetap tersimpan meski activity restart!

### Implementation
**ui/screens/RememberSaveableExamplesScreen.kt**
```kotlin
package com.example.mycomposeapp.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun RememberSaveableExamplesScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("4Ô∏è‚É£ rememberSaveable: Menjaga State", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        // 1. Perbedaan remember vs rememberSaveable
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "Perbedaan remember vs rememberSaveable:",
                    fontWeight = FontWeight.Bold
                )
                
                var normalCount by remember { mutableStateOf(0) }
                var saveableCount by rememberSaveable { mutableStateOf(0) }
                
                Text("remember: $normalCount")
                Text("rememberSaveable: $saveableCount")
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Row(
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Button(onClick = { normalCount++; saveableCount++ }) {
                        Text("Tambah")
                    }
                    
                    Button(
                        onClick = { 
                            normalCount = 0
                            saveableCount = 0
                        },
                        colors = ButtonDefaults.buttonColors(
                            containerColor = Color.Red
                        )
                    ) {
                        Text("Reset")
                    }
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text(
                    text = "Petunjuk: Coba rotasi layar, nilai remember akan reset, tapi rememberSaveable tetap!",
                    fontSize = 12.sp,
                    color = Color.Gray
                )
            }
        }

        // 2. Contoh TextField dengan rememberSaveable
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(
                    text = "TextField dengan rememberSaveable:",
                    fontWeight = FontWeight.Bold
                )
                
                var text by rememberSaveable { mutableStateOf("") }
                
                OutlinedTextField(
                    value = text,
                    onValueChange = { text = it },
                    label = { Text("Masukkan teks (akan tetap saat rotasi)") },
                    modifier = Modifier.fillMaxWidth()
                )
                
                if (text.isNotBlank()) {
                    Text("Anda mengetik: $text")
                }
            }
        }

        // 3. Contoh kompleks: Pengaturan pengguna
        Text("3Ô∏è‚É£ Contoh Kompleks: Pengaturan Pengguna", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        UserSettingsScreen()
    }
}

@Composable
fun UserSettingsScreen() {
    var username by rememberSaveable { mutableStateOf("ahmad_keren") }
    var notificationEnabled by rememberSaveable { mutableStateOf(true) }
    var themeIndex by rememberSaveable { mutableStateOf(0) }
    var fontSize by rememberSaveable { mutableStateOf(16) }
    
    val themes = listOf("Light", "Dark", "System")
    
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Text(
                text = "Pengaturan Pengguna",
                fontSize = 18.sp,
                fontWeight = FontWeight.Bold
            )
            
            OutlinedTextField(
                value = username,
                onValueChange = { username = it },
                label = { Text("Username") },
                leadingIcon = {
                    Icon(
                        imageVector = Icons.Default.Person,
                        contentDescription = null
                    )
                },
                modifier = Modifier.fillMaxWidth()
            )
            
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.Notifications,
                    contentDescription = null
                )
                Text("Notifikasi")
                Spacer(modifier = Modifier.weight(1f))
                Switch(
                    checked = notificationEnabled,
                    onCheckedChange = { notificationEnabled = it }
                )
            }
            
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.DarkMode,
                    contentDescription = null
                )
                Text("Tema")
                Spacer(modifier = Modifier.weight(1f))
                Text(themes[themeIndex])
            }
            
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = Icons.Default.FormatSize,
                    contentDescription = null
                )
                Text("Ukuran Font")
                Spacer(modifier = Modifier.weight(1f))
                Text("$fontSize sp")
            }
            
            Slider(
                value = fontSize.toFloat(),
                onValueChange = { fontSize = it.toInt() },
                valueRange = 12f..24f
            )
        }
    }
}

// 4. Custom Saver untuk objek kompleks
@Composable
fun ComplexObjectSaverExample() {
    // Definisikan class data
    data class UserProfile(
        val name: String,
        val age: Int,
        val isPremium: Boolean
    )
    
    // Buat custom saver
    val userProfileSaver = androidx.compose.runtime.saveable.Saver<UserProfile, String>(
        save = { userProfile ->
            "${userProfile.name},${userProfile.age},${userProfile.isPremium}"
        },
        restore = { savedString ->
            val parts = savedString.split(",")
            UserProfile(
                name = parts[0],
                age = parts[1].toInt(),
                isPremium = parts[2].toBoolean()
            )
        }
    )
    
    var userProfile by rememberSaveable(saver = userProfileSaver) {
        mutableStateOf(UserProfile("Ahmad", 25, false))
    }
    
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text("Custom Saver untuk objek kompleks:", fontWeight = FontWeight.Bold)
            Text("Nama: ${userProfile.name}")
            Text("Umur: ${userProfile.age}")
            Text("Premium: ${userProfile.isPremium}")
            
            Button(
                onClick = {
                    userProfile = userProfile.copy(
                        name = "Ahmad Baru",
                        age = 26,
                        isPremium = true
                    )
                }
            ) {
                Text("Update Profil")
            }
        }
    }
}
```

### üéì Penjelasan Konsep:
**rememberSaveable seperti Brankas Aman:**
- Menyimpan state meski configuration change (rotasi, dll)
- Menggunakan Saved Instance State mechanism
- Cocok untuk data yang harus bertahan

**Kapan menggunakan rememberSaveable:**
- Data yang harus bertahan saat rotasi layar
- Form input dari pengguna
- Pengaturan aplikasi

**Custom Saver:**
- Untuk objek kompleks yang tidak otomatis saveable
- Harus implementasi fungsi save dan restore

---

## 5Ô∏è‚É£ State Hoisting: Menaikkan State üì§

### Konsep Dasar
State Hoisting seperti menaikkan tangga ü™ú - membawa state ke level atas agar bisa digunakan bersama!

### Implementation
**ui/screens/StateHoistingExamplesScreen.kt**
```kotlin
package com.example.mycomposeapp.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun StateHoistingExamplesScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("5Ô∏è‚É£ State Hoisting: Menaikkan State", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        // 1. Sebelum State Hoisting - Stateful Composables
        Text("1Ô∏è‚É£ Sebelum State Hoisting (buruk)", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        BadCounterExample()
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // 2. Sesudah State Hoisting - Stateless Composables
        Text("2Ô∏è‚É£ Setelah State Hoisting (baik)", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var count by remember { mutableStateOf(0) }
        
        GoodCounterExample(
            count = count,
            onIncrement = { count++ },
            onDecrement = { count-- },
            onReset = { count = 0 }
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // 3. Contoh kompleks: Form dengan state hoisting
        Text("3Ô∏è‚É£ Contoh Kompleks: Form dengan State Hoisting", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var formState by remember {
            mutableStateOf(
                FormState(
                    name = "",
                    email = "",
                    phone = "",
                    isSubscribed = false
                )
            )
        }
        
        ContactForm(
            state = formState,
            onStateChanged = { formState = it },
            onSubmit = {
                println("Form submitted: $formState")
            }
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // 4. Contoh: Filter component
        Text("4Ô∏è‚É£ Contoh: Filter Component", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        FilterExample()
    }
}

// 1. Contoh buruk - Stateful
@Composable
fun BadCounterExample() {
    var count by remember { mutableStateOf(0) }
    
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text(
                text = "Stateful Counter (Buruk)",
                fontWeight = FontWeight.Bold
            )
            Text("Count: $count", fontSize = 18.sp)
            
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(onClick = { count++ }) { Text("+") }
                Button(onClick = { count-- }) { Text("-") }
                Button(
                    onClick = { count = 0 },
                    colors = ButtonDefaults.buttonColors(containerColor = Color.Red)
                ) { Text("Reset") }
            }
        }
    }
}

// 2. Contoh baik - Stateless
@Composable
fun GoodCounterExample(
    count: Int,
    onIncrement: () -> Unit,
    onDecrement: () -> Unit,
    onReset: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text(
                text = "Stateless Counter (Baik)",
                fontWeight = FontWeight.Bold
            )
            Text("Count: $count", fontSize = 18.sp)
            
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(onClick = onIncrement) { Text("+") }
                Button(onClick = onDecrement) { Text("-") }
                Button(
                    onClick = onReset,
                    colors = ButtonDefaults.buttonColors(containerColor = Color.Red)
                ) { Text("Reset") }
            }
        }
    }
}

// 3. State untuk form
data class FormState(
    val name: String = "",
    val email: String = "",
    val phone: String = "",
    val isSubscribed: Boolean = false
)

@Composable
fun ContactForm(
    state: FormState,
    onStateChanged: (FormState) -> Unit,
    onSubmit: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Text("Form Kontak", fontSize = 18.sp, fontWeight = FontWeight.Bold)
            
            OutlinedTextField(
                value = state.name,
                onValueChange = { onStateChanged(state.copy(name = it)) },
                label = { Text("Nama") },
                leadingIcon = { Icon(Icons.Default.Person, null) },
                modifier = Modifier.fillMaxWidth()
            )
            
            OutlinedTextField(
                value = state.email,
                onValueChange = { onStateChanged(state.copy(email = it)) },
                label = { Text("Email") },
                leadingIcon = { Icon(Icons.Default.Email, null) },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
                modifier = Modifier.fillMaxWidth()
            )
            
            OutlinedTextField(
                value = state.phone,
                onValueChange = { onStateChanged(state.copy(phone = it)) },
                label = { Text("Telepon") },
                leadingIcon = { Icon(Icons.Default.Phone, null) },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone),
                modifier = Modifier.fillMaxWidth()
            )
            
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                Checkbox(
                    checked = state.isSubscribed,
                    onCheckedChange = { onStateChanged(state.copy(isSubscribed = it)) }
                )
                Text("Berlangganan newsletter")
            }
            
            Button(
                onClick = onSubmit,
                enabled = state.name.isNotBlank() && state.email.isNotBlank(),
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Kirim")
            }
        }
    }
}

// 4. Contoh filter
@Composable
fun FilterExample() {
    var searchQuery by remember { mutableStateOf("") }
    var showFavoritesOnly by remember { mutableStateOf(false) }
    var categoryFilter by remember { mutableStateOf("Semua") }
    
    val categories = listOf("Semua", "Makanan", "Minuman", "Elektronik", "Pakaian")
    
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text("Filter Component", fontWeight = FontWeight.Bold)
            
            OutlinedTextField(
                value = searchQuery,
                onValueChange = { searchQuery = it },
                label = { Text("Cari...") },
                leadingIcon = { Icon(Icons.Default.Search, null) },
                modifier = Modifier.fillMaxWidth()
            )
            
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                Checkbox(
                    checked = showFavoritesOnly,
                    onCheckedChange = { showFavoritesOnly = it }
                )
                Text("Hanya favorit")
            )
            
            ExposedDropdownMenuBox(
                expanded = false,
                onExpandedChange = {}
            ) {
                TextField(
                    value = categoryFilter,
                    onValueChange = { categoryFilter = it },
                    readOnly = true,
                    trailingIcon = { Icon(Icons.Default.ArrowDropDown, null) },
                    modifier = Modifier.fillMaxWidth()
                )
                
                ExposedDropdownMenu(
                    expanded = false,
                    onDismissRequest = {}
                ) {
                    categories.forEach { category ->
                        DropdownMenuItem(
                            text = { Text(category) },
                            onClick = { categoryFilter = category }
                        )
                    }
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text("Current Filter: Query='$searchQuery', Favorites=$showFavoritesOnly, Category='$categoryFilter'")
        }
    }
}
```

### üéì Penjelasan Konsep:
**State Hoisting seperti Menangga:**
- Membawa state ke komponen level atas
- Membuat komponen bawah menjadi stateless
- Meningkatkan reusability dan testability

**Keuntungan State Hoisting:**
- Komponen lebih reusable
- Lebih mudah diuji
- Logika state berada di satu tempat
- Lebih mudah diprediksi

**Pattern State Hoisting:**
- Terima nilai sebagai parameter
- Terima callback sebagai parameter
- Panggil callback saat event terjadi

---

## 6Ô∏è‚É£ Unidirectional Data Flow: Aliran Data Satu Arah üåä

### Konsep Dasar
Unidirectional Data Flow seperti sungai üåä - data mengalir dari hulu ke hilir, event mengalir dari hilir ke hulu!

### Implementation
**ui/screens/UnidirectionalDataFlowExamplesScreen.kt**
```kotlin
package com.example.mycomposeapp.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun UnidirectionalDataFlowExamplesScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("6Ô∏è‚É£ Unidirectional Data Flow: Aliran Data Satu Arah", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        // 1. Konsep dasar
        Text("1Ô∏è‚É£ Konsep Dasar", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var counterState by remember { mutableStateOf(0) }
        
        UnidirectionalCounter(
            count = counterState,
            onIncrement = { counterState++ },
            onDecrement = { counterState-- },
            onReset = { counterState = 0 }
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // 2. Contoh: Todo list
        Text("2Ô∏è‚É£ Contoh: Todo List", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var todoListState by remember {
            mutableStateOf(
                listOf(
                    TodoItem(1, "Baca buku", false),
                    TodoItem(2, "Olahraga", false),
                    TodoItem(3, "Makan", false)
                )
            )
        }
        
        TodoList(
            todos = todoListState,
            onAddTodo = { text ->
                val newTodo = TodoItem(
                    id = System.currentTimeMillis().toInt(),
                    text = text,
                    isCompleted = false
                )
                todoListState = todoListState + newTodo
            },
            onToggleTodo = { id ->
                todoListState = todoListState.map { todo ->
                    if (todo.id == id) {
                        todo.copy(isCompleted = !todo.isCompleted)
                    } else {
                        todo
                    }
                }
            },
            onDeleteTodo = { id ->
                todoListState = todoListState.filter { it.id != id }
            }
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // 3. Contoh: Product catalog
        Text("3Ô∏è‚É£ Contoh: Product Catalog", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var cartState by remember { mutableStateOf<List<Int>>(emptyList()) }
        
        ProductCatalog(
            products = listOf(
                Product(1, "Laptop", 10000000, "Elektronik"),
                Product(2, "Mouse", 150000, "Elektronik"),
                Product(3, "Keyboard", 500000, "Elektronik"),
                Product(4, "Monitor", 3000000, "Elektronik")
            ),
            cart = cartState,
            onAddToCart = { productId ->
                cartState = cartState + productId
            },
            onRemoveFromCart = { productId ->
                cartState = cartState.filter { it != productId }
            }
        )
    }
}

// Counter dengan unidirectional data flow
@Composable
fun UnidirectionalCounter(
    count: Int,
    onIncrement: () -> Unit,
    onDecrement: () -> Unit,
    onReset: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text("Unidirectional Counter", fontWeight = FontWeight.Bold)
            Text("Count: $count", fontSize = 24.sp, fontWeight = FontWeight.Bold)
            
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(onClick = onDecrement) { Text("-") }
                Button(onClick = onIncrement) { Text("+") }
            }
            
            Button(
                onClick = onReset,
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color.Red
                )
            ) {
                Text("Reset")
            }
        }
    }
}

// Data class untuk todo
data class TodoItem(
    val id: Int,
    val text: String,
    val isCompleted: Boolean
)

@Composable
fun TodoList(
    todos: List<TodoItem>,
    onAddTodo: (String) -> Unit,
    onToggleTodo: (Int) -> Unit,
    onDeleteTodo: (Int) -> Unit
) {
    var newTodoText by remember { mutableStateOf("") }
    
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text("Todo List", fontWeight = FontWeight.Bold)
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                TextField(
                    value = newTodoText,
                    onValueChange = { newTodoText = it },
                    label = { Text("Tambah todo...") },
                    modifier = Modifier.weight(1f)
                )
                
                Button(
                    onClick = {
                        if (newTodoText.isNotBlank()) {
                            onAddTodo(newTodoText)
                            newTodoText = ""
                        }
                    },
                    enabled = newTodoText.isNotBlank()
                ) {
                    Text("Tambah")
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Column(
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                todos.forEach { todo ->
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Checkbox(
                            checked = todo.isCompleted,
                            onCheckedChange = { onToggleTodo(todo.id) }
                        )
                        Text(
                            text = todo.text,
                            textDecoration = if (todo.isCompleted) {
                                androidx.compose.ui.text.style.TextDecoration.LineThrough
                            } else {
                                androidx.compose.ui.text.style.TextDecoration.None
                            }
                        )
                        Spacer(modifier = Modifier.weight(1f))
                        IconButton(
                            onClick = { onDeleteTodo(todo.id) }
                        ) {
                            Icon(Icons.Default.Delete, contentDescription = "Hapus")
                        }
                    }
                }
            }
        }
    }
}

// Data class untuk produk
data class Product(
    val id: Int,
    val name: String,
    val price: Int,
    val category: String
)

@Composable
fun ProductCatalog(
    products: List<Product>,
    cart: List<Int>,
    onAddToCart: (Int) -> Unit,
    onRemoveFromCart: (Int) -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text("Product Catalog", fontWeight = FontWeight.Bold)
            Text("Items in cart: ${cart.size}")
            
            Spacer(modifier = Modifier.height(8.dp))
            
            LazyColumn {
                items(products.size) { index ->
                    val product = products[index]
                    val isInCart = cart.contains(product.id)
                    
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(product.name, fontWeight = FontWeight.Bold)
                            Text("Rp ${product.price.toLocaleString()}")
                            Text(product.category, fontSize = 12.sp, color = Color.Gray)
                        }
                        
                        if (isInCart) {
                            Button(
                                onClick = { onRemoveFromCart(product.id) },
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = Color.Red
                                )
                            ) {
                                Text("Keluarkan")
                            }
                        } else {
                            Button(
                                onClick = { onAddToCart(product.id) }
                            ) {
                                Text("Tambahkan")
                            }
                        }
                    }
                    
                    Divider()
                }
            }
        }
    }
}

// Extension function untuk format angka
fun Int.toLocaleString(): String {
    return this.toString().reversed().chunked(3).joinToString(".").reversed()
}
```

### üéì Penjelasan Konsep:
**Unidirectional Data Flow seperti Sungai:**
- **State mengalir ke bawah** (dari parent ke child)
- **Events mengalir ke atas** (dari child ke parent)
- Membuat aplikasi lebih prediktabel

**Prinsip Utama:**
- **Single source of truth**: Satu sumber kebenaran untuk setiap data
- **State flows down**: State dikirim ke komponen anak
- **Events flow up**: Event dikirim ke komponen parent

**Keuntungan Unidirectional Data Flow:**
- Lebih mudah di-debug
- Lebih prediktabel
- Lebih mudah diuji
- Lebih mudah dipahami

---

## 7Ô∏è‚É£ derivedStateOf: State Turunan üßÆ

### Konsep Dasar
`derivedStateOf` seperti kalkulator pintar üßÆ - menghitung nilai dari state lain secara otomatis!

### Implementation
**ui/screens/DerivedStateOfExamplesScreen.kt**
```kotlin
package com.example.mycomposeapp.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun DerivedStateOfExamplesScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("7Ô∏è‚É£ derivedStateOf: State Turunan", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        // 1. Basic derivedStateOf
        Text("1Ô∏è‚É£ Basic derivedStateOf", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var baseNumber by remember { mutableStateOf(10) }
        var multiplier by remember { mutableStateOf(2) }
        
        // derived state - hasil perkalian
        val result by derivedStateOf { baseNumber * multiplier }
        val isResultEven by derivedStateOf { result % 2 == 0 }
        val resultMagnitude by derivedStateOf { 
            when {
                result < 10 -> "Kecil"
                result < 100 -> "Sedang"
                else -> "Besar"
            }
        }
        
        Card(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text("Perkalian: $baseNumber √ó $multiplier = $result", fontWeight = FontWeight.Bold)
                Text("Genap: $isResultEven")
                Text("Ukuran: $resultMagnitude")
                
                Spacer(modifier = Modifier.height(8.dp))
                
                OutlinedTextField(
                    value = baseNumber.toString(),
                    onValueChange = { 
                        baseNumber = it.toIntOrNull() ?: 0 
                    },
                    label = { Text("Angka Dasar") },
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    modifier = Modifier.fillMaxWidth()
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                OutlinedTextField(
                    value = multiplier.toString(),
                    onValueChange = { 
                        multiplier = it.toIntOrNull() ?: 0 
                    },
                    label = { Text("Pengali") },
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }

        // 2. Derived state untuk filter
        Text("2Ô∏è‚É£ Derived State untuk Filter", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var allItems by remember {
            mutableStateOf(
                listOf(
                    Item(1, "Apel", "Buah", 12000),
                    Item(2, "Pisang", "Buah", 8000),
                    Item(3, "Jeruk", "Buah", 15000),
                    Item(4, "Susu", "Minuman", 5000),
                    Item(5, "Nasi", "Makanan", 10000)
                )
            )
        }
        
        var searchQuery by remember { mutableStateOf("") }
        var selectedCategory by remember { mutableStateOf("Semua") }
        
        val categories = remember { 
            allItems.map { it.category }.distinct().toMutableList().apply { add(0, "Semua") }
        }
        
        // derived state untuk filtered items
        val filteredItems by derivedStateOf {
            allItems.filter { item ->
                val matchesSearch = item.name.contains(searchQuery, ignoreCase = true)
                val matchesCategory = selectedCategory == "Semua" || item.category == selectedCategory
                matchesSearch && matchesCategory
            }
        }
        
        ItemFilter(
            items = allItems,
            filteredItems = filteredItems,
            searchQuery = searchQuery,
            onSearchQueryChange = { searchQuery = it },
            selectedCategory = selectedCategory,
            onCategoryChange = { selectedCategory = it },
            categories = categories
        )

        // 3. Derived state untuk validasi form
        Text("3Ô∏è‚É£ Derived State untuk Validasi Form", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var name by remember { mutableStateOf("") }
        var email by remember { mutableStateOf("") }
        var password by remember { mutableStateOf("") }
        var confirmPassword by remember { mutableStateOf("") }
        
        val isNameValid by derivedStateOf { name.length >= 2 }
        val isEmailValid by derivedStateOf { email.contains("@") && email.contains(".") }
        val isPasswordValid by derivedStateOf { password.length >= 6 }
        val isPasswordMatch by derivedStateOf { password == confirmPassword }
        val isFormValid by derivedStateOf {
            isNameValid && isEmailValid && isPasswordValid && isPasswordMatch
        }
        
        RegistrationFormWithValidation(
            name = name,
            onNameChange = { name = it },
            isNameValid = isNameValid,
            
            email = email,
            onEmailChange = { email = it },
            isEmailValid = isEmailValid,
            
            password = password,
            onPasswordChange = { password = it },
            isPasswordValid = isPasswordValid,
            
            confirmPassword = confirmPassword,
            onConfirmPasswordChange = { confirmPassword = it },
            isPasswordMatch = isPasswordMatch,
            
            isFormValid = isFormValid
        )
    }
}

data class Item(
    val id: Int,
    val name: String,
    val category: String,
    val price: Int
)

@Composable
fun ItemFilter(
    items: List<Item>,
    filteredItems: List<Item>,
    searchQuery: String,
    onSearchQueryChange: (String) -> Unit,
    selectedCategory: String,
    onCategoryChange: (String) -> Unit,
    categories: List<String>
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text("Filter Items:", fontWeight = FontWeight.Bold)
            
            OutlinedTextField(
                value = searchQuery,
                onValueChange = onSearchQueryChange,
                label = { Text("Cari...") },
                leadingIcon = { Icon(Icons.Default.Search, null) },
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            ExposedDropdownMenuBox(
                expanded = false,
                onExpandedChange = {}
            ) {
                TextField(
                    value = selectedCategory,
                    onValueChange = onCategoryChange,
                    readOnly = true,
                    trailingIcon = { Icon(Icons.Default.ArrowDropDown, null) },
                    modifier = Modifier.fillMaxWidth()
                )
                
                ExposedDropdownMenu(
                    expanded = false,
                    onDismissRequest = {}
                ) {
                    categories.forEach { category ->
                        DropdownMenuItem(
                            text = { Text(category) },
                            onClick = { onCategoryChange(category) }
                        )
                    }
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text("Total item: ${items.size}, Ditampilkan: ${filteredItems.size}", fontSize = 12.sp)
            
            Spacer(modifier = Modifier.height(8.dp))
            
            LazyColumn {
                items(filteredItems.size) { index ->
                    val item = filteredItems[index]
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 4.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(item.name, fontWeight = FontWeight.Bold)
                            Text("${item.category} - Rp ${item.price.toLocaleString()}", fontSize = 12.sp)
                        }
                    }
                    
                    Divider()
                }
            }
        }
    }
}

@Composable
fun RegistrationFormWithValidation(
    name: String,
    onNameChange: (String) -> Unit,
    isNameValid: Boolean,
    
    email: String,
    onEmailChange: (String) -> Unit,
    isEmailValid: Boolean,
    
    password: String,
    onPasswordChange: (String) -> Unit,
    isPasswordValid: Boolean,
    
    confirmPassword: String,
    onConfirmPasswordChange: (String) -> Unit,
    isPasswordMatch: Boolean,
    
    isFormValid: Boolean
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text("Form Validasi:", fontWeight = FontWeight.Bold)
            
            OutlinedTextField(
                value = name,
                onValueChange = onNameChange,
                label = { Text("Nama") },
                isError = name.isNotBlank() && !isNameValid,
                supportingText = {
                    if (name.isNotBlank() && !isNameValid) {
                        Text("Nama minimal 2 karakter", color = Color.Red)
                    }
                },
                leadingIcon = { Icon(Icons.Default.Person, null) },
                modifier = Modifier.fillMaxWidth()
            )
            
            OutlinedTextField(
                value = email,
                onValueChange = onEmailChange,
                label = { Text("Email") },
                isError = email.isNotBlank() && !isEmailValid,
                supportingText = {
                    if (email.isNotBlank() && !isEmailValid) {
                        Text("Email tidak valid", color = Color.Red)
                    }
                },
                leadingIcon = { Icon(Icons.Default.Email, null) },
                modifier = Modifier.fillMaxWidth()
            )
            
            OutlinedTextField(
                value = password,
                onValueChange = onPasswordChange,
                label = { Text("Password") },
                isError = password.isNotBlank() && !isPasswordValid,
                supportingText = {
                    if (password.isNotBlank() && !isPasswordValid) {
                        Text("Password minimal 6 karakter", color = Color.Red)
                    }
                },
                leadingIcon = { Icon(Icons.Default.Lock, null) },
                modifier = Modifier.fillMaxWidth()
            )
            
            OutlinedTextField(
                value = confirmPassword,
                onValueChange = onConfirmPasswordChange,
                label = { Text("Konfirmasi Password") },
                isError = confirmPassword.isNotBlank() && !isPasswordMatch,
                supportingText = {
                    if (confirmPassword.isNotBlank() && !isPasswordMatch) {
                        Text("Password tidak cocok", color = Color.Red)
                    }
                },
                leadingIcon = { Icon(Icons.Default.Lock, null) },
                modifier = Modifier.fillMaxWidth()
            )
            
            Button(
                onClick = { /* Submit */ },
                enabled = isFormValid,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Daftar")
            }
            
            Text(
                text = "Form Valid: $isFormValid",
                color = if (isFormValid) Color.Green else Color.Red,
                fontWeight = FontWeight.Bold
            )
        }
    }
}
```

### üéì Penjelasan Konsep:
**derivedStateOf seperti Kalkulator Pintar:**
- Menghitung nilai dari state lain
- Hanya merekomposisi saat nilai turunan berubah
- Meningkatkan efisiensi

**Kapan menggunakan derivedStateOf:**
- Menghitung nilai dari state lain
- Filter atau transformasi data
- Validasi kompleks
- Optimasi performa

**Keuntungan derivedStateOf:**
- Menghindari perhitungan berulang
- Hanya bereaksi saat nilai yang digunakan berubah
- Meningkatkan performa

---

## 8Ô∏è‚É£ State in Lists: State di Dalam List üìã

### Konsep Dasar
State in Lists seperti daftar belanja üõí - setiap item bisa memiliki state-nya sendiri!

### Implementation
**ui/screens/StateInListsExamplesScreen.kt**
```kotlin
package com.example.mycomposeapp.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun StateInListsExamplesScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("8Ô∏è‚É£ State in Lists: State di Dalam List", fontSize = 20.sp, fontWeight = FontWeight.Bold)
        
        // 1. State untuk setiap item dalam list
        Text("1Ô∏è‚É£ State untuk Setiap Item", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var items = remember {
            listOf(
                ListItemState(1, "Task 1", false),
                ListItemState(2, "Task 2", true),
                ListItemState(3, "Task 3", false),
                ListItemState(4, "Task 4", false),
                ListItemState(5, "Task 5", true)
            )
        }
        
        ItemListWithIndividualState(items)
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // 2. Contoh: Expandable list items
        Text("2Ô∏è‚É£ Contoh: Item List Expandable", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var expandableItems = remember {
            listOf(
                ExpandableItemState(1, "Judul 1", "Deskripsi panjang untuk item 1...", false),
                ExpandableItemState(2, "Judul 2", "Deskripsi panjang untuk item 2...", false),
                ExpandableItemState(3, "Judul 3", "Deskripsi panjang untuk item 3...", false)
            )
        }
        
        ExpandableItemList(expandableItems)
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // 3. Contoh: Shopping cart dengan state
        Text("3Ô∏è‚É£ Contoh: Shopping Cart", fontSize = 18.sp, fontWeight = FontWeight.Bold)
        
        var cartItems = remember {
            listOf(
                CartItemState(1, "Laptop", 10000000, 1),
                CartItemState(2, "Mouse", 150000, 2),
                CartItemState(3, "Keyboard", 500000, 1)
            )
        }
        
        ShoppingCartList(cartItems)
    }
}

data class ListItemState(
    val id: Int,
    val text: String,
    val isCompleted: Boolean
)

data class ExpandableItemState(
    val id: Int,
    val title: String,
    val description: String,
    val isExpanded: Boolean
)

data class CartItemState(
    val id: Int,
    val name: String,
    val price: Int,
    var quantity: Int
)

@Composable
fun ItemListWithIndividualState(items: List<ListItemState>) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        LazyColumn(
            modifier = Modifier
                .fillMaxWidth()
                .height(300.dp)
                .padding(8.dp)
        ) {
            items(items) { item ->
                var isCompleted by remember(item.id) { mutableStateOf(item.isCompleted) }
                
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Checkbox(
                        checked = isCompleted,
                        onCheckedChange = { isCompleted = it }
                    )
                    
                    Text(
                        text = item.text,
                        textDecoration = if (isCompleted) {
                            androidx.compose.ui.text.style.TextDecoration.LineThrough
                        } else {
                            androidx.compose.ui.text.style.TextDecoration.None
                        }
                    )
                    
                    Spacer(modifier = Modifier.weight(1f))
                    
                    IconButton(
                        onClick = { /* Hapus item */ }
                    ) {
                        Icon(Icons.Default.Delete, contentDescription = "Hapus")
                    }
                }
                
                Divider()
            }
        }
    }
}

@Composable
fun ExpandableItemList(items: List<ExpandableItemState>) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        LazyColumn(
            modifier = Modifier
                .fillMaxWidth()
                .height(300.dp)
                .padding(8.dp)
        ) {
            items(items) { item ->
                var isExpanded by remember(item.id) { mutableStateOf(item.isExpanded) }
                
                Column(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { isExpanded = !isExpanded }
                            .padding(12.dp),
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Icon(
                            imageVector = if (isExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,
                            contentDescription = if (isExpanded) "Kecilkan" else "Perbesar"
                        )
                        Text(item.title, fontWeight = FontWeight.Bold)
                    }
                    
                    if (isExpanded) {
                        Text(
                            text = item.description,
                            modifier = Modifier.padding(start = 32.dp, end = 16.dp, bottom = 8.dp),
                            fontSize = 12.sp,
                            color = Color.Gray
                        )
                    }
                    
                    Divider()
                }
            }
        }
    }
}

@Composable
fun ShoppingCartList(items: List<CartItemState>) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        LazyColumn(
            modifier = Modifier
                .fillMaxWidth()
                .height(400.dp)
                .padding(8.dp)
        ) {
            items(items) { item ->
                var quantity by remember(item.id) { mutableStateOf(item.quantity) }
                
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 12.dp),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Column(
                        modifier = Modifier.weight(1f)
                    ) {
                        Text(item.name, fontWeight = FontWeight.Bold)
                        Text("Rp ${item.price.toLocaleString()}", fontSize = 12.sp, color = Color.Gray)
                    }
                    
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        IconButton(
                            onClick = { 
                                if (quantity > 1) quantity-- 
                            }
                        ) {
                            Icon(Icons.Default.Remove, contentDescription = "Kurangi")
                        }
                        
                        Text("$quantity", fontWeight = FontWeight.Bold)
                        
                        IconButton(
                            onClick = { quantity++ }
                        ) {
                            Icon(Icons.Default.Add, contentDescription = "Tambah")
                        }
                    }
                    
                    Text(
                        text = "Rp ${(item.price * quantity).toLocaleString()}",
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
                
                Divider()
            }
        }
    }
}

// Extension function untuk format angka
fun Int.toLocaleString(): String {
    return this.toString().reversed().chunked(3).joinToString(".").reversed()
}
```

### üéì Penjelasan Konsep:
**State in Lists seperti Daftar Belanja:**
- Setiap item bisa memiliki state-nya sendiri
- Menggunakan `remember(item.id)` untuk key unik
- Setiap item bisa berinteraksi secara independen

**Kapan menggunakan State in Lists:**
- Checkbox dalam list
- Expandable/collapsible items
- Shopping cart dengan jumlah barang
- List dengan interaksi kompleks

**Pentingnya Key Parameter:**
- `remember(item.id)`: Pastikan state tetap dengan item yang benar
- Mencegah kebingungan state saat list berubah
- Meningkatkan efisiensi dan stabilitas

---

## üìÅ Struktur Project Lengkap
```
MyComposeApp/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java/com/example/mycomposeapp/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MainActivity.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StateConceptsScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RememberExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MutableStateOfExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RememberSaveableExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StateHoistingExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UnidirectionalDataFlowExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DerivedStateOfExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StateInListsExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ theme/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Theme.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Type.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Color.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ res/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ drawable/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sample_image.jpg
‚îÇ   ‚îú‚îÄ‚îÄ build.gradle.kts
‚îú‚îÄ‚îÄ build.gradle.kts
```

## üéØ Kesimpulan

Dengan menguasai State Management di Jetpack Compose, kamu sekarang memiliki kemampuan untuk:

- **Memahami Konsep State**: Mengetahui bagaimana state bekerja dan memicu recomposition
- **Menggunakan remember**: Menyimpan nilai di antara recomposition
- **Mengelola State dengan mutableStateOf**: Menggunakan state yang bisa diubah
- **Menggunakan rememberSaveable**: Menyimpan state yang bertahan saat konfigurasi berubah
- **State Hoisting**: Menaikkan state ke komponen level atas untuk membuat komponen reusable
- **Unidirectional Data Flow**: Mengikuti pola aliran data satu arah yang prediktabel
- **derivedStateOf**: Membuat state turunan untuk efisiensi dan optimasi
- **State in Lists**: Mengelola state untuk setiap item dalam list

### üî• Tips Penting:
1. Gunakan `remember` untuk menyimpan nilai antar recomposition
2. Gunakan `rememberSaveable` untuk data penting yang harus bertahan saat konfigurasi berubah
3. Terapkan State Hoisting untuk komponen yang reusable
4. Ikuti pola Unidirectional Data Flow agar aplikasi lebih prediktabel
5. Gunakan `derivedStateOf` untuk menghitung state dari state lain secara efisien
6. Gunakan key unik saat menyimpan state dalam list
7. Hindari state yang tidak perlu dalam komponen kecil

Kamu sekarang siap membuat aplikasi Jetpack Compose yang kompleks dan dinamis dengan manajemen state yang baik!