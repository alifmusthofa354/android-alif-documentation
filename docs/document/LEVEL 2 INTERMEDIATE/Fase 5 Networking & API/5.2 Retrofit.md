# ğŸ“± Panduan Lengkap: Retrofit untuk Android Development

## ğŸš€ Pengantar: Jembatan Digital antara Aplikasi dan Server

Bayangkan kamu adalah seorang diplomat ğŸ•Šï¸:
- **Retrofit** seperti penerjemah profesional yang fasih berbagai bahasa
- **OkHttp** seperti kendaraan diplomatik yang aman dan cepat
- **API Interface** seperti protokol diplomatik yang jelas
- **Interceptors** seperti protokoler yang memeriksa setiap dokumen

Dengan menguasai Retrofit, kamu bisa membuat aplikasi Android yang berkomunikasi dengan server secara efisien, aman, dan terstruktur!

## ğŸ“š Daftar Isi Pembelajaran
1. [ğŸŒŸ Pengenalan Retrofit](#1ï¸âƒ£-pengenalan-retrofit-ğŸŒŸ)
2. [âš™ï¸ Setup & Dependencies](#2ï¸âƒ£-setup--dependencies-âš™ï¸)
3. [ğŸ—ï¸ Building Retrofit Instance](#3ï¸âƒ£-building-retrofit-instance-ğŸ—ï¸)
4. [ğŸ“ API Interface Definition](#4ï¸âƒ£-api-interface-definition-ğŸ“)
5. [ğŸ·ï¸ Annotations Explained](#5ï¸âƒ£-annotations-explained-ğŸ·ï¸)
6. [ğŸ“¦ Data Models (POJOs)](#6ï¸âƒ£-data-models-pojos-ğŸ“¦)
7. [ğŸ“ Making API Calls](#7ï¸âƒ£-making-api-calls-ğŸ“)
8. [ğŸ”„ Coroutines Integration](#8ï¸âƒ£-coroutines-integration-ğŸ”„)
9. [âš ï¸ Error Handling](#9ï¸âƒ£-error-handling-âš ï¸)
10. [ğŸ›¡ï¸ Interceptors](#1ï¸âƒ£0ï¸âƒ£-interceptors-ğŸ›¡ï¸)
11. [ğŸ”„ Gson Converter](#1ï¸âƒ£1ï¸âƒ£-gson-converter-ğŸ”„)
12. [ğŸ“¤ File Upload & Download](#1ï¸âƒ£2ï¸âƒ£-file-upload--download-ğŸ“¤)
13. [ğŸ’¾ Response Caching](#1ï¸âƒ£3ï¸âƒ£-response-caching-ğŸ’¾)
14. [ğŸ”— Retrofit with Hilt](#1ï¸âƒ£4ï¸âƒ£-retrofit-with-hilt-ğŸ”—)
15. [âœ¨ Best Practices](#1ï¸âƒ£5ï¸âƒ£-best-practices-âœ¨)
16. [ğŸ”¨ Hands-on Project](#1ï¸âƒ£6ï¸âƒ£-hands-on-project-ğŸ”¨)
17. [ğŸ¯ Kesimpulan](#ğŸ¯-kesimpulan)

---

## 1ï¸âƒ£ Pengenalan Retrofit ğŸŒŸ

### Konsep Dasar
Retrofit seperti penerjemah profesional ğŸ•Šï¸ - mengubah permintaan dari bahasa Kotlin menjadi bahasa HTTP yang dimengerti server!

### Apa itu Retrofit dan mengapa penting?
**Retrofit** adalah type-safe HTTP client untuk Android dan Java yang dikembangkan oleh Square. Ini memudahkan komunikasi dengan REST API dengan mengubah interface API menjadi objek yang dapat dipanggil. Keunggulannya:

- **Type-safe**: Mengubah HTTP API menjadi interface Kotlin
- **Sintaksis Deklaratif**: Mendefinisikan endpoint dengan anotasi
- **Integrasi Coroutines**: Dukungan native untuk Kotlin coroutines
- **Konverter Fleksibel**: Mendukung JSON, XML, Protocol Buffers
- **Dapat Diperluas**: Dapat dikustomisasi dengan interceptors

### Retrofit vs Alternatif Lain:
| Library | Type-Safe | Coroutines Support | Converter Support | Size |
|---------|-----------|-------------------|-------------------|------|
| **Retrofit** | âœ… | âœ… | âœ… | Sedang |
| **Volley** | âŒ | âŒ | Terbatas | Kecil |
| **Ktor** | âœ… | âœ… | âœ… | Besar |
| **AsyncTask** | âŒ | âŒ | âŒ | Built-in |

### Arsitektur Retrofit:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   APP CODE      â”‚ â†â†’ â”‚   RETROFIT      â”‚ â†â†’ â”‚   SERVER API    â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ Repository/VM   â”‚    â”‚ HTTP Client     â”‚    â”‚ REST Endpoints  â”‚
â”‚ Coroutines      â”‚    â”‚ Converters      â”‚    â”‚ JSON Responses  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Keunggulan Retrofit untuk Android Development:
1. **Type Safety**: Mengubah endpoint menjadi method dengan tipe return yang jelas
2. **Declarative API**: Mendefinisikan endpoint dengan anotasi yang mudah dibaca
3. **Coroutines Integration**: Dukungan native untuk async programming
4. **Converter Support**: Otomatis konversi JSON ke objek Kotlin
5. **Extensible**: Dapat dikustomisasi dengan interceptors
6. **Built on OkHttp**: Memanfaatkan kekuatan OkHttp untuk HTTP

### Contoh Sederhana Retrofit:
**API Interface:**
```kotlin
interface ApiService {
    @GET("users")
    suspend fun getUsers(): List&lt;User&gt;
    
    @GET("users/{id}")
    suspend fun getUserById(@Path("id") userId: Int): User
    
    @POST("users")
    suspend fun createUser(@Body user: User): User
}
```

**Retrofit Client:**
```kotlin
object RetrofitClient {
    private const val BASE_URL = "https://api.example.com/"
    
    val instance: Retrofit by lazy {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    val apiService: ApiService by lazy {
        instance.create(ApiService::class.java)
    }
}
```

**Usage in ViewModel:**
```kotlin
class UserViewModel : ViewModel() {
    private val _users = MutableStateFlow&lt;List&lt;User&gt;&gt;(emptyList())
    val users: StateFlow&lt;List&lt;User&gt;&gt; = _users.asStateFlow()
    
    fun loadUsers() {
        viewModelScope.launch {
            try {
                val userList = RetrofitClient.apiService.getUsers()
                _users.value = userList
            } catch (e: Exception) {
                // Handle error
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Retrofit seperti Penerjemah Profesional:**
- **API Interface**: Kontrak kerja (apa yang akan diterjemahkan)
- **Annotations**: Aturan tata bahasa (cara menerjemahkan)
- **Converters**: Kamus bahasa (JSON â†” Kotlin)
- **OkHttp**: Kendaraan diplomatik (cara mengirim pesan)

**Alur Kerja Retrofit:**
1. Definisikan interface dengan anotasi
2. Buat instance Retrofit
3. Buat implementasi service dari Retrofit
4. Panggil method dari service dalam coroutine
5. Retrofit mengubah panggilan menjadi HTTP request
6. Response dikonversi kembali ke objek Kotlin

**Keunggulan Retrofit:**
- **Sederhana**: Tidak perlu menulis kode boilerplate
- **Efisien**: Otomatisasi konversi dan parsing
- **Aman**: Type safety mengurangi error pada runtime
- **Fleksibel**: Dapat dikustomisasi sesuai kebutuhan

---

## 2ï¸âƒ£ Setup & Dependencies âš™ï¸

### Konsep Dasar
Setup Retrofit seperti merakit alat pertukangan ğŸ”§ - membutuhkan komponen yang tepat untuk bekerja dengan baik!

### Gradle Dependencies:
**app/build.gradle.kts:**
```kotlin
dependencies {
    // Retrofit Core
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    
    // JSON Converter
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
    
    // OkHttp (biasanya sudah termasuk dalam Retrofit)
    implementation("com.squareup.okhttp3:okhttp:4.11.0")
    
    // Logging Interceptor untuk debugging
    implementation("com.squareup.okhttp3:logging-interceptor:4.11.0")
    
    // Coroutines Support
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.1")
}
```

### Permissions di AndroidManifest.xml:
```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.retrofitsample">
    
    <!-- Izin untuk mengakses internet -->
    <uses-permission android:name="android.permission.INTERNET" />
    
    <!-- Izin untuk memeriksa status jaringan (opsional) -->
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    
    <application
        ...>
        ...
    </application>
</manifest>
```

### Network Security Configuration:
**res/xml/network_security_config.xml:**
```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">api.example.com</domain>
    </domain-config>
</network-security-config>
```

**AndroidManifest.xml:**
```xml
<application
    ...
    android:networkSecurityConfig="@xml/network_security_config">
    ...
</application>
```

### Proguard Rules:
**proguard-rules.pro:**
```proguard
# Retrofit
-dontwarn retrofit2.**
-keep class retrofit2.** { *; }
-keepattributes Signature
-keepattributes Exceptions

# OkHttp
-dontwarn okhttp3.**
-dontwarn okio.**
-dontwarn javax.annotation.**
-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase

# Gson
-keepattributes Signature
-keepattributes *Annotation*
-dontwarn sun.misc.**
-keep class com.google.gson.** { *; }
-keep class * implements com.google.gson.TypeAdapterFactory
-keep class * implements com.google.gson.JsonSerializer
-keep class * implements com.google.gson.JsonDeserializer

# Keep data classes
-keep class com.example.retrofitsample.data.model.** { *; }
```

### ğŸ“ Penjelasan Konsep:
**Setup Retrofit seperti Merakit Alat:**
- **Dependencies**: Alat-alat yang dibutuhkan
- **Permissions**: Izin untuk menggunakan alat
- **Security Configuration**: Aturan keamanan
- **Proguard Rules**: Petunjuk untuk optimasi

**Komponen Penting:**
- **Retrofit Core**: Library utama untuk HTTP client
- **Converter**: Untuk mengkonversi data (JSON â†” Kotlin)
- **OkHttp**: Engine HTTP yang mendasari Retrofit
- **Logging Interceptor**: Untuk debugging request/response
- **Coroutines**: Untuk operasi asinkron

**Best Practices:**
- Selalu gunakan versi terbaru dari library
- Tambahkan logging interceptor hanya di debug builds
- Konfigurasikan network security untuk HTTPS
- Tambahkan ProGuard rules untuk menghindari masalah saat release

---

## 3ï¸âƒ£ Building Retrofit Instance ğŸ—ï¸

### Konsep Dasar
Building Retrofit Instance seperti membangun stasiun komunikasi ğŸ—ï¸ - membutuhkan fondasi yang kuat dan konfigurasi yang tepat!

### Basic Retrofit Instance:
**RetrofitClient.kt:**
```kotlin
object RetrofitClient {
    private const val BASE_URL = "https://api.example.com/"
    
    val instance: Retrofit by lazy {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
}
```

### Retrofit dengan OkHttp Client:
**RetrofitClient.kt:**
```kotlin
object RetrofitClient {
    private const val BASE_URL = "https://api.example.com/"
    
    private val okHttpClient = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .build()
    
    val instance: Retrofit by lazy {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
}
```

### Retrofit dengan Logging Interceptor:
**RetrofitClient.kt:**
```kotlin
object RetrofitClient {
    private const val BASE_URL = "https://api.example.com/"
    
    private val loggingInterceptor = HttpLoggingInterceptor().apply {
        level = if (BuildConfig.DEBUG) {
            HttpLoggingInterceptor.Level.BODY
        } else {
            HttpLoggingInterceptor.Level.NONE
        }
    }
    
    private val okHttpClient = OkHttpClient.Builder()
        .addInterceptor(loggingInterceptor)
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .build()
    
    val instance: Retrofit by lazy {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
}
```

### Retrofit dengan Custom Gson:
**RetrofitClient.kt:**
```kotlin
object RetrofitClient {
    private const val BASE_URL = "https://api.example.com/"
    
    private val gson = GsonBuilder()
        .setLenient()
        .setDateFormat("yyyy-MM-dd'T'HH:mm:ss")
        .create()
    
    private val okHttpClient = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .build()
    
    val instance: Retrofit by lazy {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create(gson))
            .build()
    }
}
```

### Retrofit dengan Dynamic Base URL:
**RetrofitClient.kt:**
```kotlin
object RetrofitClient {
    private var baseUrl = "https://api.example.com/"
    
    private val okHttpClient = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .build()
    
    val instance: Retrofit by lazy {
        createRetrofit()
    }
    
    fun updateBaseUrl(newBaseUrl: String) {
        baseUrl = newBaseUrl
    }
    
    private fun createRetrofit(): Retrofit {
        return Retrofit.Builder()
            .baseUrl(baseUrl)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Retrofit Instance seperti Stasiun Komunikasi:**
- **Base URL**: Alamat stasiun utama
- **OkHttp Client**: Infrastruktur komunikasi
- **Converter**: Penerjemah bahasa
- **Timeout**: Batas waktu tunggu
- **Logging Interceptor**: Sistem pemantauan

**Komponen Penting:**
- **BaseUrl**: URL dasar untuk semua endpoint
- **ConverterFactory**: Untuk mengkonversi request/response
- **OkHttpClient**: Untuk konfigurasi HTTP tingkat rendah
- **Timeout**: Untuk mencegah hanging requests
- **Logging**: Untuk debugging dan monitoring

**Best Practices:**
- Gunakan lazy initialization untuk Retrofit instance
- Konfigurasikan timeout yang wajar
- Aktifkan logging hanya di debug builds
- Pertimbangkan untuk menggunakan dependency injection (Hilt)
- Gunakan HTTPS untuk production

---

## 4ï¸âƒ£ API Interface Definition ğŸ“

### Konsep Dasar
API Interface seperti kontrak diplomatik ğŸ“ - mendefinisikan aturan komunikasi yang jelas antara aplikasi dan server!

### Basic API Interface:
**ApiService.kt:**
```kotlin
interface ApiService {
    // GET request untuk mendapatkan semua user
    @GET("users")
    suspend fun getUsers(): List&lt;User&gt;
    
    // GET request dengan path parameter
    @GET("users/{id}")
    suspend fun getUserById(@Path("id") userId: Int): User
    
    // POST request untuk membuat user baru
    @POST("users")
    suspend fun createUser(@Body user: User): User
    
    // PUT request untuk update user
    @PUT("users/{id}")
    suspend fun updateUser(
        @Path("id") userId: Int,
        @Body user: User
    ): User
    
    // DELETE request untuk menghapus user
    @DELETE("users/{id}")
    suspend fun deleteUser(@Path("id") userId: Int): Response&lt;Unit&gt;
}
```

### API Interface dengan Query Parameters:
**ApiService.kt:**
```kotlin
interface ApiService {
    // GET dengan query parameters
    @GET("users")
    suspend fun searchUsers(
        @Query("name") name: String,
        @Query("page") page: Int
    ): List&lt;User&gt;
    
    // GET dengan query map
    @GET("users")
    suspend fun filterUsers(@QueryMap filters: Map&lt;String, String&gt;): List&lt;User&gt;
    
    // GET dengan optional query parameters
    @GET("users")
    suspend fun getUsers(
        @Query("page") page: Int = 1,
        @Query("limit") limit: Int = 20,
        @Query("sort") sort: String? = null
    ): List&lt;User&gt;
}
```

### API Interface dengan Headers:
**ApiService.kt:**
```kotlin
interface ApiService {
    // GET dengan single header
    @GET("users")
    suspend fun getUsers(@Header("Authorization") token: String): List&lt;User&gt;
    
    // GET dengan multiple headers
    @GET("users")
    suspend fun getUsers(@HeaderMap headers: Map&lt;String, String&gt;): List&lt;User&gt;
    
    // GET dengan static headers
    @Headers("Cache-Control: max-age=640000", "User-Agent: MyApp")
    @GET("users")
    suspend fun getCachedUsers(): List&lt;User&gt;
}
```

### API Interface dengan Form Data:
**ApiService.kt:**
```kotlin
interface ApiService {
    // POST dengan form-encoded data
    @FormUrlEncoded
    @POST("login")
    suspend fun login(
        @Field("email") email: String,
        @Field("password") password: String
    ): LoginResponse
    
    // POST dengan field map
    @FormUrlEncoded
    @POST("register")
    suspend fun register(@FieldMap fields: Map&lt;String, String&gt;): RegisterResponse
}
```

### API Interface dengan Multipart Data:
**ApiService.kt:**
```kotlin
interface ApiService {
    // POST dengan multipart data untuk upload file
    @Multipart
    @POST("upload")
    suspend fun uploadImage(
        @Part image: MultipartBody.Part,
        @Part("description") description: RequestBody
    ): UploadResponse
    
    // POST dengan multiple parts
    @Multipart
    @POST("profile")
    suspend fun updateProfile(
        @Part("name") name: RequestBody,
        @Part("email") email: RequestBody,
        @Part image: MultipartBody.Part?
    ): ProfileResponse
}
```

### API Interface dengan Dynamic URL:
**ApiService.kt:**
```kotlin
interface ApiService {
    // GET dengan dynamic URL
    @GET
    suspend fun getDynamicUrl(@Url url: String): ResponseBody
    
    // POST dengan dynamic URL
    @POST
    suspend fun postDynamicUrl(
        @Url url: String,
        @Body body: RequestBody
    ): ResponseBody
}
```

### API Interface dengan Response Wrapper:
**ApiService.kt:**
```kotlin
interface ApiService {
    // GET dengan Response wrapper
    @GET("users/{id}")
    suspend fun getUserResponse(@Path("id") userId: Int): Response&lt;User&gt;
    
    // POST dengan Response wrapper
    @POST("users")
    suspend fun createUserResponse(@Body user: User): Response&lt;User&gt;
    
    // GET dengan custom response wrapper
    @GET("users")
    suspend fun getUsersWithWrapper(): ApiResponse&lt;List&lt;User&gt;&gt;
}
```

### ğŸ“ Penjelasan Konsep:
**API Interface seperti Kontrak Diplomatik:**
- **Method**: Tipe komunikasi (GET, POST, dll)
- **Path**: Lokasi tujuan
- **Parameters**: Informasi tambahan
- **Headers**: Metadata komunikasi
- **Body**: Isi pesan

**Anotasi Penting:**
- **@GET, @POST, @PUT, @DELETE**: Method HTTP
- **@Path**: Parameter di URL path
- **@Query**: Parameter di query string
- **@Body**: Request body
- **@Header**: HTTP header
- **@Field**: Form field
- **@Part**: Multipart part

**Best Practices:**
- Gunakan suspend function untuk coroutines
- Gunakan tipe return yang spesifik (List&lt;User&gt;, bukan Response&lt;List&lt;User&gt;&gt;)
- Kelompokkan endpoint terkait dalam interface yang sama
- Gunakan anotasi yang tepat untuk setiap use case
- Pertimbangkan untuk menggunakan Response wrapper untuk error handling

---

## 5ï¸âƒ£ Annotations Explained ğŸ·ï¸

### Konsep Dasar
Annotations seperti tanda petunjuk jalan ğŸ·ï¸ - memberikan instruksi spesifik tentang bagaimana setiap endpoint harus berperilaku!

### HTTP Method Annotations:
**@GET, @POST, @PUT, @DELETE, @PATCH:**
```kotlin
interface ApiService {
    @GET("users")              // GET request ke /users
    suspend fun getUsers(): List&lt;User&gt;
    
    @POST("users")             // POST request ke /users
    suspend fun createUser(@Body user: User): User
    
    @PUT("users/{id}")         // PUT request ke /users/{id}
    suspend fun updateUser(@Path("id") id: Int, @Body user: User): User
    
    @DELETE("users/{id}")      // DELETE request ke /users/{id}
    suspend fun deleteUser(@Path("id") id: Int): Response&lt;Unit&gt;
    
    @PATCH("users/{id}")       // PATCH request ke /users/{id}
    suspend fun partialUpdateUser(@Path("id") id: Int, @Body user: User): User
}
```

### Path Parameter Annotation:
**@Path:**
```kotlin
interface ApiService {
    // Single path parameter
    @GET("users/{id}")
    suspend fun getUser(@Path("id") userId: Int): User
    
    // Multiple path parameters
    @GET("users/{userId}/posts/{postId}")
    suspend fun getUserPost(
        @Path("userId") userId: Int,
        @Path("postId") postId: Int
    ): Post
    
    // Path parameter dengan encoding
    @GET("search/{query}")
    suspend fun search(@Path(value = "query", encoded = true) query: String): SearchResult
}
```

### Query Parameter Annotations:
**@Query, @QueryMap:**
```kotlin
interface ApiService {
    // Single query parameter
    @GET("users")
    suspend fun getUsersByName(@Query("name") name: String): List&lt;User&gt;
    
    // Multiple query parameters
    @GET("users")
    suspend fun searchUsers(
        @Query("name") name: String,
        @Query("page") page: Int,
        @Query("limit") limit: Int
    ): List&lt;User&gt;
    
    // Query parameter list
    @GET("products")
    suspend fun getProducts(@Query("category") categories: List&lt;String&gt;): List&lt;Product&gt;
    
    // Query map
    @GET("users")
    suspend fun filterUsers(@QueryMap filters: Map&lt;String, String&gt;): List&lt;User&gt;
    
    // Optional query parameter
    @GET("users")
    suspend fun getUsers(@Query("active") active: Boolean? = null): List&lt;User&gt;
}
```

### Request Body Annotations:
**@Body:**
```kotlin
interface ApiService {
    // Object as request body
    @POST("users")
    suspend fun createUser(@Body user: User): User
    
    // Raw request body
    @POST("raw")
    suspend fun postRaw(@Body body: RequestBody): ResponseBody
    
    // String as request body
    @POST("string")
    suspend fun postString(@Body text: String): ResponseBody
}
```

### Header Annotations:
**@Header, @HeaderMap, @Headers:**
```kotlin
interface ApiService {
    // Single header
    @GET("users")
    suspend fun getUsers(@Header("Authorization") token: String): List&lt;User&gt;
    
    // Multiple headers
    @GET("users")
    suspend fun getUsersWithHeaders(@HeaderMap headers: Map&lt;String, String&gt;): List&lt;User&gt;
    
    // Static headers
    @Headers("Cache-Control: max-age=640000", "User-Agent: MyApp")
    @GET("users")
    suspend fun getCachedUsers(): List&lt;User&gt;
    
    // Header dengan value null (menghapus header)
    @GET("users")
    suspend fun getUsersWithoutCache(@Header("Cache-Control") cacheControl: String? = null): List&lt;User&gt;
}
```

### Form Data Annotations:
**@Field, @FieldMap, @FormUrlEncoded:**
```kotlin
interface ApiService {
    // Form-encoded data dengan field
    @FormUrlEncoded
    @POST("login")
    suspend fun login(
        @Field("email") email: String,
        @Field("password") password: String
    ): LoginResponse
    
    // Form-encoded data dengan field map
    @FormUrlEncoded
    @POST("register")
    suspend fun register(@FieldMap fields: Map&lt;String, String&gt;): RegisterResponse
    
    // Field dengan encoding
    @FormUrlEncoded
    @POST("search")
    suspend fun search(@Field(value = "query", encoded = true) query: String): SearchResult
}
```

### Multipart Data Annotations:
**@Part, @PartMap, @Multipart:**
```kotlin
interface ApiService {
    // Multipart dengan part
    @Multipart
    @POST("upload")
    suspend fun uploadFile(
        @Part file: MultipartBody.Part,
        @Part("description") description: RequestBody
    ): UploadResponse
    
    // Multipart dengan part map
    @Multipart
    @POST("profile")
    suspend fun updateProfile(@PartMap parts: Map&lt;String, RequestBody&gt;): ProfileResponse
    
    // Multipart dengan array
    @Multipart
    @POST("photos")
    suspend fun uploadPhotos(@Part photos: List&lt;MultipartBody.Part&gt;): UploadResponse
}
```

### URL Annotations:
**@Url:**
```kotlin
interface ApiService {
    // Dynamic URL
    @GET
    suspend fun getFromUrl(@Url url: String): ResponseBody
    
    // POST ke dynamic URL
    @POST
    suspend fun postToUrl(@Url url: String, @Body body: RequestBody): ResponseBody
    
    // URL dengan parameter
    @GET
    suspend fun getUserProfile(@Url url: String, @Query("fields") fields: String): UserProfile
}
```

### ğŸ“ Penjelasan Konsep:
**Annotations seperti Tanda Petunjuk Jalan:**
- **Method Annotations**: Jenis jalan (jalan tol, jalan biasa)
- **Path Parameter**: Alamat spesifik
- **Query Parameter**: Petunjuk tambahan
- **Headers**: Informasi tambahan tentang kendaraan
- **Body**: Muatan yang dibawa

**Kategori Annotations:**
- **Method**: Menentukan HTTP method
- **Parameter**: Menentukan bagaimana parameter diproses
- **Headers**: Menentukan HTTP headers
- **Body**: Menentukan request body

**Best Practices:**
- Gunakan anotasi yang tepat untuk setiap use case
- Gunakan @Path untuk parameter yang wajib ada di URL
- Gunakan @Query untuk parameter opsional atau filtering
- Gunakan @Body untuk data kompleks
- Gunakan @Headers untuk headers yang statis

---

## 6ï¸âƒ£ Data Models (POJOs) ğŸ“¦

### Konsep Dasar
Data Models seperti paspor digital ğŸ“¦ - dokumen identitas yang mendefinisikan struktur data yang akan dikirim dan diterima!

### Basic Data Model:
**User.kt:**
```kotlin
data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("name")
    val name: String,
    
    @SerializedName("email")
    val email: String,
    
    @SerializedName("active")
    val isActive: Boolean = true,
    
    @SerializedName("created_at")
    val createdAt: String,
    
    @SerializedName("updated_at")
    val updatedAt: String
)
```

### Data Model dengan Nested Objects:
**User.kt:**
```kotlin
data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("name")
    val name: String,
    
    @SerializedName("email")
    val email: String,
    
    @SerializedName("profile")
    val profile: UserProfile,
    
    @SerializedName("posts")
    val posts: List&lt;Post&gt; = emptyList()
)

data class UserProfile(
    @SerializedName("bio")
    val bio: String,
    
    @SerializedName("avatar")
    val avatar: String,
    
    @SerializedName("location")
    val location: String
)

data class Post(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("title")
    val title: String,
    
    @SerializedName("content")
    val content: String,
    
    @SerializedName("published_at")
    val publishedAt: String
)
```

### Data Model dengan Default Values:
**User.kt:**
```kotlin
data class User(
    @SerializedName("id")
    val id: Int = 0,
    
    @SerializedName("name")
    val name: String = "",
    
    @SerializedName("email")
    val email: String = "",
    
    @SerializedName("role")
    val role: UserRole = UserRole.USER,
    
    @SerializedName("active")
    val isActive: Boolean = true,
    
    @SerializedName("created_at")
    val createdAt: String = "",
    
    @SerializedName("updated_at")
    val updatedAt: String = ""
)

enum class UserRole {
    @SerializedName("admin")
    ADMIN,
    
    @SerializedName("user")
    USER,
    
    @SerializedName("guest")
    GUEST
}
```

### Data Model with Nullable Fields:
**User.kt:**
```kotlin
data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("name")
    val name: String,
    
    @SerializedName("email")
    val email: String,
    
    @SerializedName("phone")
    val phone: String? = null,
    
    @SerializedName("avatar")
    val avatar: String? = null,
    
    @SerializedName("last_login")
    val lastLogin: String? = null,
    
    @SerializedName("deactivated_at")
    val deactivatedAt: String? = null
)
```

### Response Wrapper Model:
**ApiResponse.kt:**
```kotlin
data class ApiResponse&lt;T&gt;(
    @SerializedName("success")
    val success: Boolean,
    
    @SerializedName("data")
    val data: T?,
    
    @SerializedName("message")
    val message: String?,
    
    @SerializedName("errors")
    val errors: List&lt;ApiError&gt;? = null
)

data class ApiError(
    @SerializedName("field")
    val field: String,
    
    @SerializedName("message")
    val message: String
)

// Usage
data class UsersResponse(
    @SerializedName("users")
    val users: List&lt;User&gt;
)

// In API interface
@GET("users")
suspend fun getUsers(): ApiResponse&lt;UsersResponse&gt;
```

### Request Model:
**CreateUserRequest.kt:**
```kotlin
data class CreateUserRequest(
    @SerializedName("name")
    val name: String,
    
    @SerializedName("email")
    val email: String,
    
    @SerializedName("password")
    val password: String,
    
    @SerializedName("role")
    val role: UserRole = UserRole.USER
)

data class UpdateUserRequest(
    @SerializedName("name")
    val name: String? = null,
    
    @SerializedName("email")
    val email: String? = null,
    
    @SerializedName("role")
    val role: UserRole? = null,
    
    @SerializedName("active")
    val active: Boolean? = null
)
```

### Data Model with Custom Deserializer:
**DateDeserializer.kt:**
```kotlin
class DateDeserializer : JsonDeserializer&lt;Date&gt; {
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault())
    
    override fun deserialize(
        json: JsonElement,
        typeOfT: Type,
        context: JsonDeserializationContext
    ): Date {
        return try {
            dateFormat.parse(json.asString) ?: Date()
        } catch (e: ParseException) {
            Date()
        }
    }
}

// In data model
data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("name")
    val name: String,
    
    @SerializedName("created_at")
    @JsonAdapter(DateDeserializer::class)
    val createdAt: Date
)
```

### ğŸ“ Penjelasan Konsep:
**Data Models seperti Paspor Digital:**
- **Fields**: Informasi identitas
- **SerializedName**: Nama dalam bahasa berbeda
- **Nested Objects**: Informasi tambahan
- **Default Values**: Informasi default
- **Nullable Fields**: Informasi opsional

**Best Practices:**
- Gunakan data class untuk model yang immutable
- Gunakan @SerializedName untuk mencocokan JSON keys
- Tentukan default values untuk field opsional
- Pisahkan model request dan response jika berbeda
- Gunakan enum untuk field dengan nilai terbatas
- Pertimbangkan untuk menggunakan deserializer kustom untuk format tanggal kompleks

---

## 7ï¸âƒ£ Making API Calls ğŸ“

### Konsep Dasar
Making API Calls seperti menelepon kantor pusat ğŸ“ - menyiapkan nomor yang tepat, menunggu jawaban, dan menangani berbagai kemungkinan hasil!

### Creating Service Instance:
**ApiService.kt:**
```kotlin
object ApiService {
    private const val BASE_URL = "https://api.example.com/"
    
    private val retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build()
    
    val apiService: ApiInterface by lazy {
        retrofit.create(ApiInterface::class.java)
    }
}
```

### Making API Calls with Coroutines:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    suspend fun getUsers(): List&lt;User&gt; {
        return try {
            apiService.getUsers()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    suspend fun getUserById(userId: Int): User? {
        return try {
            apiService.getUserById(userId)
        } catch (e: Exception) {
            null
        }
    }
    
    suspend fun createUser(user: User): User? {
        return try {
            apiService.createUser(user)
        } catch (e: Exception) {
            null
        }
    }
}
```

### API Calls in ViewModel:
**UserViewModel.kt:**
```kotlin
class UserViewModel : ViewModel() {
    private val repository = UserRepository()
    
    private val _users = MutableStateFlow&lt;List&lt;User&gt;&gt;(emptyList())
    val users: StateFlow&lt;List&lt;User&gt;&gt; = _users.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()
    
    private val _error = MutableStateFlow&lt;String?&gt;(null)
    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()
    
    fun loadUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                val userList = repository.getUsers()
                _users.value = userList
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun refreshUsers() {
        loadUsers()
    }
    
    fun createUser(user: User) {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                val newUser = repository.createUser(user)
                if (newUser != null) {
                    loadUsers() // Refresh list
                } else {
                    _error.value = "Failed to create user"
                }
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLoading.value = false
            }
        }
    }
}
```

### Handling Response Wrapper:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    suspend fun getUsers(): Result&lt;List&lt;User&gt;&gt; {
        return try {
            val response = apiService.getUsersResponse()
            if (response.isSuccessful) {
                val usersResponse = response.body()
                if (usersResponse?.success == true) {
                    Result.success(usersResponse.data?.users ?: emptyList())
                } else {
                    Result.failure(Exception(usersResponse?.message ?: "Unknown error"))
                }
            } else {
                Result.failure(Exception("HTTP ${response.code()}: ${response.message()}"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### API Calls with Flow:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    fun getUsersStream(): Flow&lt;List&lt;User&gt;&gt; = flow {
        emit(emptyList()) // Initial value
        
        try {
            val users = apiService.getUsers()
            emit(users)
        } catch (e: Exception) {
            // Handle error
        }
    }.flowOn(Dispatchers.IO)
    
    fun refreshUsers(): Flow&lt;List&lt;User&gt;&gt; = flow {
        try {
            val users = apiService.getUsers()
            emit(users)
        } catch (e: Exception) {
            // Handle error
        }
    }.flowOn(Dispatchers.IO)
}
```

### API Calls with Pagination:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    suspend fun getUsers(page: Int = 1, limit: Int = 20): PaginatedResponse&lt;User&gt; {
        return try {
            apiService.getUsers(page, limit)
        } catch (e: Exception) {
            PaginatedResponse(emptyList(), 0, 0, 0)
        }
    }
}

data class PaginatedResponse&lt;T&gt;(
    @SerializedName("data")
    val data: List&lt;T&gt;,
    
    @SerializedName("page")
    val page: Int,
    
    @SerializedName("limit")
    val limit: Int,
    
    @SerializedName("total")
    val total: Int
) {
    val totalPages: Int
        get() = ceil(total.toDouble() / limit).toInt()
    
    val hasNextPage: Boolean
        get() = page < totalPages
    
    val hasPrevPage: Boolean
        get() = page > 1
}
```

### ğŸ“ Penjelasan Konsep:
**Making API Calls seperti Menelepon Kantor Pusat:**
- **Service Instance**: Nomor telepon yang akan dihubungi
- **Coroutines**: Sambungan telepon yang efisien
- **Try-Catch**: Menangani berbagai kemungkinan hasil
- **ViewModel**: Operator yang mengatur komunikasi
- **Flow**: Aliran informasi yang berkelanjutan

**Alur Panggilan API:**
1. Buat instance service
2. Panggil method dalam coroutine
3. Tangani response
4. Update UI state
5. Tangani error

**Best Practices:**
- Gunakan coroutines untuk operasi asinkron
- Tangani error dengan baik
- Gunakan StateFlow untuk state di ViewModel
- Pisahkan logika API dari UI
- Gunakan Result type untuk error handling
- Pertimbangkan untuk menggunakan caching

---

## 8ï¸âƒ£ Coroutines Integration ğŸ”„

### Konsep Dasar
Coroutines Integration seperti sistem komunikasi real-time ğŸ”„ - memungkinkan aplikasi tetap responsif saat menunggu respons dari server!

### Suspend Functions in Retrofit:
**ApiService.kt:**
```kotlin
interface ApiService {
    // Suspend function untuk GET request
    @GET("users")
    suspend fun getUsers(): List&lt;User&gt;
    
    // Suspend function dengan parameter
    @GET("users/{id}")
    suspend fun getUserById(@Path("id") userId: Int): User
    
    // Suspend function untuk POST request
    @POST("users")
    suspend fun createUser(@Body user: User): User
}
```

### Coroutines in Repository:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    // Simple suspend function
    suspend fun getUsers(): List&lt;User&gt; {
        return apiService.getUsers()
    }
    
    // Suspend function dengan error handling
    suspend fun getUserById(userId: Int): Result&lt;User&gt; {
        return try {
            val user = apiService.getUserById(userId)
            Result.success(user)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // Suspend function dengan Flow
    fun getUsersStream(): Flow&lt;List&lt;User&gt;&gt; = flow {
        emit(emptyList()) // Initial value
        
        try {
            val users = apiService.getUsers()
            emit(users)
        } catch (e: Exception) {
            // Handle error
        }
    }.flowOn(Dispatchers.IO)
}
```

### Coroutines in ViewModel:
**UserViewModel.kt:**
```kotlin
class UserViewModel : ViewModel() {
    private val repository = UserRepository()
    
    private val _users = MutableStateFlow&lt;List&lt;User&gt;&gt;(emptyList())
    val users: StateFlow&lt;List&lt;User&gt;&gt; = _users.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()
    
    private val _error = MutableStateFlow&lt;String?&gt;(null)
    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()
    
    init {
        loadUsers()
    }
    
    fun loadUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                val userList = repository.getUsers()
                _users.value = userList
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun refreshUsers() {
        loadUsers()
    }
}
```

### Coroutines with Flow:
**UserViewModel.kt:**
```kotlin
class UserViewModel : ViewModel() {
    private val repository = UserRepository()
    
    val users: StateFlow&lt;List&lt;User&gt;&gt; = repository.getUsersStream()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()
    
    private val _error = MutableStateFlow&lt;String?&gt;(null)
    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()
    
    fun refreshUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                // Trigger refresh
                repository.refreshUsers().collect { refreshedUsers ->
                    _users.value = refreshedUsers
                }
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLoading.value = false
            }
        }
    }
}
```

### Coroutines with Multiple API Calls:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    // Sequential calls
    suspend fun getUserWithPosts(userId: Int): UserWithPosts? {
        return try {
            val user = apiService.getUserById(userId)
            val posts = apiService.getUserPosts(userId)
            UserWithPosts(user, posts)
        } catch (e: Exception) {
            null
        }
    }
    
    // Parallel calls
    suspend fun getUsersAndPosts(): UsersAndPosts? {
        return try {
            val usersDeferred = async { apiService.getUsers() }
            val postsDeferred = async { apiService.getAllPosts() }
            
            val users = usersDeferred.await()
            val posts = postsDeferred.await()
            
            UsersAndPosts(users, posts)
        } catch (e: Exception) {
            null
        }
    }
    
    // Retry mechanism
    suspend fun getUsersWithRetry(retries: Int = 3): List&lt;User&gt; {
        var lastException: Exception? = null
        
        repeat(retries) { attempt ->
            try {
                return apiService.getUsers()
            } catch (e: Exception) {
                lastException = e
                if (attempt < retries - 1) {
                    delay(1000L * (attempt + 1)) // Exponential backoff
                }
            }
        }
        
        throw lastException ?: Exception("Unknown error")
    }
}

data class UserWithPosts(
    val user: User,
    val posts: List&lt;Post&gt;
)

data class UsersAndPosts(
    val users: List&lt;User&gt;,
    val posts: List&lt;Post&gt;
)
```

### Coroutines with Timeout:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    // With timeout
    suspend fun getUsersWithTimeout(): List&lt;User&gt; {
        return try {
            withTimeout(10_000) {
                apiService.getUsers()
            }
        } catch (e: TimeoutCancellationException) {
            emptyList()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    // With timeoutOrNull
    suspend fun getUsersWithTimeoutOrNull(): List&lt;User&gt;? {
        return withTimeoutOrNull(10_000) {
            apiService.getUsers()
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Coroutines Integration seperti Sistem Komunikasi Real-time:**
- **Suspend Functions**: Pesan yang menunggu jawaban
- **ViewModelScope**: Ruang kerja yang aman
- **Flow**: Aliran informasi berkelanjutan
- **Async Calls**: Panggilan paralel
- **Timeout**: Batas waktu tunggu

**Keunggulan Coroutines dengan Retrofit:**
- **Sederhana**: Tidak perlu callback
- **Efisien**: Tidak memblokir thread utama
- **Fleksibel**: Dapat dikombinasikan dengan operasi lain
- **Aman**: Otomatis menangani lifecycle

**Best Practices:**
- Gunakan suspend functions untuk API calls
- Gunakan viewModelScope untuk operasi di ViewModel
- Gunakan StateFlow untuk state yang observable
- Gunakan Flow untuk data stream
- Tangani timeout untuk operasi yang mungkin lama
- Pertimbangkan untuk menggunakan retry mechanism

---

## 9ï¸âƒ£ Error Handling âš ï¸

### Konsep Dasar
Error Handling seperti asuransi perjalanan âš ï¸ - mempersiapkan rencana cadangan saat terjadi masalah yang tidak diharapkan!

### Basic Error Handling:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    suspend fun getUsers(): List&lt;User&gt; {
        return try {
            apiService.getUsers()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    suspend fun getUserById(userId: Int): User? {
        return try {
            apiService.getUserById(userId)
        } catch (e: Exception) {
            null
        }
    }
}
```

### Error Handling with Result Type:
**Result.kt:**
```kotlin
sealed class Result&lt;out T&gt; {
    data class Success&lt;T&gt;(val data: T) : Result&lt;T&gt;()
    data class Error(val exception: Exception) : Result&lt;Nothing&gt;()
}

inline fun &lt;T&gt; Result&lt;T&gt;.onSuccess(action: (value: T) -> Unit): Result&lt;T&gt; {
    if (this is Result.Success) action(data)
    return this
}

inline fun &lt;T&gt; Result&lt;T&gt;.onError(action: (exception: Exception) -> Unit): Result&lt;T&gt; {
    if (this is Result.Error) action(exception)
    return this
}
```

**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    suspend fun getUsers(): Result&lt;List&lt;User&gt;&gt; {
        return try {
            val users = apiService.getUsers()
            Result.Success(users)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
    
    suspend fun getUserById(userId: Int): Result&lt;User&gt; {
        return try {
            val user = apiService.getUserById(userId)
            Result.Success(user)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
}
```

### Error Handling with Custom Exception:
**ApiException.kt:**
```kotlin
sealed class ApiException(message: String) : Exception(message) {
    class NetworkException(message: String) : ApiException(message)
    class ServerException(val code: Int, message: String) : ApiException(message)
    class ClientException(val code: Int, message: String) : ApiException(message)
    class UnknownException(cause: Throwable) : ApiException(cause.message ?: "Unknown error")
}

object ApiErrorHandler {
    fun handleException(throwable: Throwable): ApiException {
        return when (throwable) {
            is IOException -> ApiException.NetworkException("Network error: ${throwable.message}")
            is HttpException -> {
                when (throwable.code()) {
                    in 400..499 -> ApiException.ClientException(
                        throwable.code(),
                        "Client error: ${throwable.message()}"
                    )
                    in 500..599 -> ApiException.ServerException(
                        throwable.code(),
                        "Server error: ${throwable.message()}"
                    )
                    else -> ApiException.UnknownException(throwable)
                }
            }
            else -> ApiException.UnknownException(throwable)
        }
    }
}
```

**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    suspend fun getUsers(): Result&lt;List&lt;User&gt;&gt; {
        return try {
            val users = apiService.getUsers()
            Result.Success(users)
        } catch (e: Exception) {
            val apiException = ApiErrorHandler.handleException(e)
            Result.Error(apiException)
        }
    }
}
```

### Error Handling in ViewModel:
**UserViewModel.kt:**
```kotlin
class UserViewModel : ViewModel() {
    private val repository = UserRepository()
    
    private val _users = MutableStateFlow&lt;List&lt;User&gt;&gt;(emptyList())
    val users: StateFlow&lt;List&lt;User&gt;&gt; = _users.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()
    
    private val _error = MutableStateFlow&lt;String?&gt;(null)
    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()
    
    fun loadUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            val result = repository.getUsers()
            result.onSuccess { users ->
                _users.value = users
            }.onError { exception ->
                _error.value = when (exception) {
                    is ApiException.NetworkException -> "No internet connection"
                    is ApiException.ServerException -> "Server error: ${exception.code}"
                    is ApiException.ClientException -> "Client error: ${exception.code}"
                    else -> "Unknown error: ${exception.message}"
                }
            }
            
            _isLoading.value = false
        }
    }
}
```

### Error Handling with Response Wrapper:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    suspend fun getUsers(): Result&lt;List&lt;User&gt;&gt; {
        return try {
            val response = apiService.getUsersResponse()
            if (response.isSuccessful) {
                val usersResponse = response.body()
                if (usersResponse?.success == true) {
                    Result.Success(usersResponse.data?.users ?: emptyList())
                } else {
                    Result.Error(Exception(usersResponse?.message ?: "Unknown error"))
                }
            } else {
                Result.Error(Exception("HTTP ${response.code()}: ${response.message()}"))
            }
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
}
```

### Error Handling with Retry:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    suspend fun getUsersWithRetry(retries: Int = 3): Result&lt;List&lt;User&gt;&gt; {
        var lastException: Exception? = null
        
        repeat(retries) { attempt ->
            try {
                val users = apiService.getUsers()
                return Result.Success(users)
            } catch (e: Exception) {
                lastException = e
                if (attempt < retries - 1) {
                    delay(1000L * (attempt + 1)) // Exponential backoff
                }
            }
        }
        
        return Result.Error(lastException ?: Exception("Unknown error"))
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Error Handling seperti Asuransi Perjalanan:**
- **Try-Catch**: Perlindungan dasar
- **Result Type**: Dokumentasi hasil
- **Custom Exception**: Perlindungan spesifik
- **Retry Mechanism**: Rencana cadangan
- **Response Wrapper**: Informasi detail

**Strategi Error Handling:**
1. Tangani exception di repository
2. Konversi exception ke tipe yang spesifik
3. Berikan feedback ke UI
4. Implementasikan retry mechanism jika perlu
5. Log error untuk debugging

**Best Practices:**
- Gunakan Result type untuk error handling yang konsisten
- Buat custom exception untuk error spesifik
- Berikan pesan error yang jelas ke pengguna
- Implementasikan retry mechanism untuk error sementara
- Log error untuk debugging
- Pertimbangkan untuk menggunakan error tracking service

---

## 1ï¸âƒ£0ï¸âƒ£ Interceptors ğŸ›¡ï¸

### Konsep Dasar
Interceptors seperti protokoler diplomatik ğŸ›¡ï¸ - memeriksa dan memodifikasi setiap komunikasi antara aplikasi dan server!

### Logging Interceptor:
**NetworkModule.kt:**
```kotlin
object NetworkModule {
    fun provideOkHttpClient(): OkHttpClient {
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = if (BuildConfig.DEBUG) {
                HttpLoggingInterceptor.Level.BODY
            } else {
                HttpLoggingInterceptor.Level.NONE
            }
        }
        
        return OkHttpClient.Builder()
            .addInterceptor(loggingInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
```

### Authentication Interceptor:
**AuthInterceptor.kt:**
```kotlin
class AuthInterceptor(private val tokenProvider: () -> String?) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val original = chain.request()
        val token = tokenProvider()
        
        val request = if (token != null) {
            original.newBuilder()
                .header("Authorization", "Bearer $token")
                .build()
        } else {
            original
        }
        
        return chain.proceed(request)
    }
}

// Usage
object NetworkModule {
    fun provideOkHttpClient(tokenProvider: () -> String?): OkHttpClient {
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = if (BuildConfig.DEBUG) {
                HttpLoggingInterceptor.Level.BODY
            } else {
                HttpLoggingInterceptor.Level.NONE
            }
        }
        
        val authInterceptor = AuthInterceptor(tokenProvider)
        
        return OkHttpClient.Builder()
            .addInterceptor(authInterceptor)
            .addInterceptor(loggingInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
```

### Network Connection Interceptor:
**NetworkConnectionInterceptor.kt:**
```kotlin
class NetworkConnectionInterceptor(
    private val context: Context
) : Interceptor {
    
    override fun intercept(chain: Interceptor.Chain): Response {
        if (!isNetworkAvailable(context)) {
            throw NoInternetException("No internet connection")
        }
        return chain.proceed(chain.request())
    }
    
    private fun isNetworkAvailable(context: Context): Boolean {
        val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        return cm.activeNetworkInfo?.isConnected == true
    }
}

class NoInternetException(message: String) : IOException(message)

// Usage
object NetworkModule {
    fun provideOkHttpClient(context: Context, tokenProvider: () -> String?): OkHttpClient {
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = if (BuildConfig.DEBUG) {
                HttpLoggingInterceptor.Level.BODY
            } else {
                HttpLoggingInterceptor.Level.NONE
            }
        }
        
        val authInterceptor = AuthInterceptor(tokenProvider)
        val networkInterceptor = NetworkConnectionInterceptor(context)
        
        return OkHttpClient.Builder()
            .addInterceptor(networkInterceptor)
            .addInterceptor(authInterceptor)
            .addInterceptor(loggingInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
```

### Error Handling Interceptor:
**ErrorHandlingInterceptor.kt:**
```kotlin
class ErrorHandlingInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val response = chain.proceed(request)
        
        when (response.code) {
            401 -> throw UnauthorizedException()
            403 -> throw ForbiddenException()
            404 -> throw NotFoundException()
            in 500..599 -> throw ServerException(response.code)
        }
        
        return response
    }
}

class UnauthorizedException : IOException("Unauthorized")
class ForbiddenException : IOException("Forbidden")
class NotFoundException : IOException("Not found")
class ServerException(code: Int) : IOException("Server error: $code")

// Usage
object NetworkModule {
    fun provideOkHttpClient(
        context: Context,
        tokenProvider: () -> String?
    ): OkHttpClient {
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = if (BuildConfig.DEBUG) {
                HttpLoggingInterceptor.Level.BODY
            } else {
                HttpLoggingInterceptor.Level.NONE
            }
        }
        
        val authInterceptor = AuthInterceptor(tokenProvider)
        val networkInterceptor = NetworkConnectionInterceptor(context)
        val errorInterceptor = ErrorHandlingInterceptor()
        
        return OkHttpClient.Builder()
            .addInterceptor(networkInterceptor)
            .addInterceptor(authInterceptor)
            .addInterceptor(errorInterceptor)
            .addInterceptor(loggingInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
```

### Cache Interceptor:
**CacheInterceptor.kt:**
```kotlin
class CacheInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val response = chain.proceed(request)
        
        // Cache response untuk 5 menit
        val cacheControl = CacheControl.Builder()
            .maxAge(5, TimeUnit.MINUTES)
            .build()
        
        return response.newBuilder()
            .header("Cache-Control", cacheControl.toString())
            .build()
    }
}

// Usage
object NetworkModule {
    fun provideOkHttpClient(
        context: Context,
        tokenProvider: () -> String?
    ): OkHttpClient {
        val cacheSize = 10 * 1024 * 1024L // 10 MB
        val cache = Cache(context.cacheDir, cacheSize)
        
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = if (BuildConfig.DEBUG) {
                HttpLoggingInterceptor.Level.BODY
            } else {
                HttpLoggingInterceptor.Level.NONE
            }
        }
        
        val authInterceptor = AuthInterceptor(tokenProvider)
        val networkInterceptor = NetworkConnectionInterceptor(context)
        val errorInterceptor = ErrorHandlingInterceptor()
        val cacheInterceptor = CacheInterceptor()
        
        return OkHttpClient.Builder()
            .cache(cache)
            .addInterceptor(networkInterceptor)
            .addInterceptor(authInterceptor)
            .addInterceptor(errorInterceptor)
            .addNetworkInterceptor(cacheInterceptor)
            .addInterceptor(loggingInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
```

### Retry Interceptor:
**RetryInterceptor.kt:**
```kotlin
class RetryInterceptor(private val maxRetries: Int = 3) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        var response: Response? = null
        var exception: IOException? = null
        
        repeat(maxRetries) { attempt ->
            try {
                response = chain.proceed(request)
                if (response?.isSuccessful == true) {
                    return response!!
                }
            } catch (e: IOException) {
                exception = e
                if (attempt < maxRetries - 1) {
                    Thread.sleep(1000L * (attempt + 1)) // Exponential backoff
                }
            }
        }
        
        return response ?: throw exception ?: IOException("Unknown error")
    }
}

// Usage
object NetworkModule {
    fun provideOkHttpClient(
        context: Context,
        tokenProvider: () -> String?
    ): OkHttpClient {
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = if (BuildConfig.DEBUG) {
                HttpLoggingInterceptor.Level.BODY
            } else {
                HttpLoggingInterceptor.Level.NONE
            }
        }
        
        val authInterceptor = AuthInterceptor(tokenProvider)
        val networkInterceptor = NetworkConnectionInterceptor(context)
        val errorInterceptor = ErrorHandlingInterceptor()
        val retryInterceptor = RetryInterceptor()
        
        return OkHttpClient.Builder()
            .addInterceptor(networkInterceptor)
            .addInterceptor(authInterceptor)
            .addInterceptor(errorInterceptor)
            .addInterceptor(retryInterceptor)
            .addInterceptor(loggingInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Interceptors seperti Protokoler Diplomatik:**
- **Logging Interceptor**: Mencatat semua komunikasi
- **Auth Interceptor**: Memastikan identitas
- **Network Interceptor**: Memeriksa koneksi
- **Error Interceptor**: Menangani masalah
- **Cache Interceptor**: Menyimpan informasi penting
- **Retry Interceptor**: Mencoba kembali jika gagal

**Urutan Eksekusi Interceptor:**
1. Application Interceptors
2. Network Interceptors
3. Server
4. Network Interceptors
5. Application Interceptors

**Best Practices:**
- Gunakan logging interceptor hanya di debug builds
- Pisahkan interceptor untuk tanggung jawab yang berbeda
- Gunakan network interceptor untuk caching
- Implementasikan retry mechanism untuk error sementara
- Pertimbangkan untuk menggunakan dependency injection

---

## 1ï¸âƒ£1ï¸âƒ£ Gson Converter ğŸ”„

### Konsep Dasar
Gson Converter seperti penerjemah multibahasa ğŸ”„ - mengubah bahasa JSON menjadi bahasa Kotlin dan sebaliknya dengan akurat!

### Basic Gson Converter:
**NetworkModule.kt:**
```kotlin
object NetworkModule {
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
}
```

### Custom Gson Configuration:
**NetworkModule.kt:**
```kotlin
object NetworkModule {
    fun provideGson(): Gson {
        return GsonBuilder()
            .setLenient() // Memungkinkan JSON yang tidak strict
            .setDateFormat("yyyy-MM-dd'T'HH:mm:ss") // Format tanggal
            .excludeFieldsWithoutExposeAnnotation() // Hanya include field dengan @Expose
            .create()
    }
    
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create(provideGson()))
            .build()
    }
}
```

### @SerializedName Annotation:
**User.kt:**
```kotlin
data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("user_name")
    val name: String,
    
    @SerializedName("email_address")
    val email: String,
    
    @SerializedName("is_active")
    val isActive: Boolean,
    
    @SerializedName("created_at")
    val createdAt: String,
    
    @SerializedName("updated_at")
    val updatedAt: String
)
```

### @Expose Annotation:
**User.kt:**
```kotlin
data class User(
    @Expose
    @SerializedName("id")
    val id: Int,
    
    @Expose
    @SerializedName("user_name")
    val name: String,
    
    @Expose
    @SerializedName("email_address")
    val email: String,
    
    // Field ini tidak akan diserialisasi/deserialisasi
    @SerializedName("password")
    val password: String,
    
    @Expose
    @SerializedName("is_active")
    val isActive: Boolean,
    
    @Expose
    @SerializedName("created_at")
    val createdAt: String,
    
    @Expose
    @SerializedName("updated_at")
    val updatedAt: String
)
```

### Custom Deserializer:
**DateDeserializer.kt:**
```kotlin
class DateDeserializer : JsonDeserializer&lt;Date&gt; {
    private val dateFormat1 = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault())
    private val dateFormat2 = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
    
    override fun deserialize(
        json: JsonElement,
        typeOfT: Type,
        context: JsonDeserializationContext
    ): Date {
        val dateString = json.asString
        
        return try {
            dateFormat1.parse(dateString) ?: dateFormat2.parse(dateString) ?: Date()
        } catch (e: ParseException) {
            Date()
        }
    }
}

// Usage
data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("name")
    val name: String,
    
    @SerializedName("created_at")
    @JsonAdapter(DateDeserializer::class)
    val createdAt: Date
)
```

### Custom Serializer:
**DateSerializer.kt:**
```kotlin
class DateSerializer : JsonSerializer&lt;Date&gt; {
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault())
    
    override fun serialize(
        src: Date?,
        typeOfSrc: Type,
        context: JsonSerializationContext
    ): JsonElement {
        return JsonPrimitive(dateFormat.format(src))
    }
}

// Usage
data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("name")
    val name: String,
    
    @SerializedName("created_at")
    @JsonAdapter(DateSerializer::class)
    val createdAt: Date
)
```

### Custom Type Adapter:
**UserTypeAdapter.kt:**
```kotlin
class UserTypeAdapter : JsonDeserializer&lt;User&gt;, JsonSerializer&lt;User&gt; {
    override fun deserialize(
        json: JsonElement,
        typeOfT: Type,
        context: JsonDeserializationContext
    ): User {
        val jsonObject = json.asJsonObject
        
        val id = jsonObject.get("id").asInt
        val name = jsonObject.get("name").asString
        val email = jsonObject.get("email").asString
        val isActive = jsonObject.get("is_active").asBoolean
        val createdAt = jsonObject.get("created_at").asString
        val updatedAt = jsonObject.get("updated_at").asString
        
        return User(id, name, email, isActive, createdAt, updatedAt)
    }
    
    override fun serialize(
        src: User,
        typeOfSrc: Type,
        context: JsonSerializationContext
    ): JsonElement {
        val jsonObject = JsonObject()
        
        jsonObject.addProperty("id", src.id)
        jsonObject.addProperty("name", src.name)
        jsonObject.addProperty("email", src.email)
        jsonObject.addProperty("is_active", src.isActive)
        jsonObject.addProperty("created_at", src.createdAt)
        jsonObject.addProperty("updated_at", src.updatedAt)
        
        return jsonObject
    }
}

// Usage
data class User(
    val id: Int,
    val name: String,
    val email: String,
    val isActive: Boolean,
    val createdAt: String,
    val updatedAt: String
)

// In NetworkModule
object NetworkModule {
    fun provideGson(): Gson {
        return GsonBuilder()
            .registerTypeAdapter(User::class.java, UserTypeAdapter())
            .create()
    }
}
```

### Null Handling:
**User.kt:**
```kotlin
data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("name")
    val name: String,
    
    @SerializedName("email")
    val email: String,
    
    @SerializedName("phone")
    val phone: String? = null, // Optional field
    
    @SerializedName("avatar")
    val avatar: String? = null, // Optional field
    
    @SerializedName("is_active")
    val isActive: Boolean = true, // Default value
    
    @SerializedName("created_at")
    val createdAt: String = "", // Default value
    
    @SerializedName("updated_at")
    val updatedAt: String = "" // Default value
)
```

### ğŸ“ Penjelasan Konsep:
**Gson Converter seperti Penerjemah Multibahasa:**
- **@SerializedName**: Kamus istilah
- **@Expose**: Daftar kata penting
- **Custom Deserializer**: Aturan penerjemahan khusus
- **Custom Serializer**: Aturan penulisan khusus
- **Type Adapter**: Penerjemah lengkap

**Proses Konversi:**
1. Retrofit menerima response dari server
2. Gson converter mengubah JSON menjadi objek Kotlin
3. Untuk request, Gson converter mengubah objek Kotlin menjadi JSON
4. Retrofit mengirim request ke server

**Best Practices:**
- Gunakan @SerializedName untuk mencocokan JSON keys
- Tentukan default values untuk field opsional
- Gunakan custom deserializer untuk format yang kompleks
- Pertimbangkan untuk menggunakan @Expose untuk kontrol lebih baik
- Konfigurasikan format tanggal yang konsisten

---

## 1ï¸âƒ£2ï¸âƒ£ File Upload & Download ğŸ“¤

### Konsep Dasar
File Upload & Download seperti layanan pengiriman paket ğŸ“¤ - mengirim dan menerima berkas dengan aman dan efisien!

### File Upload:
**ApiService.kt:**
```kotlin
interface ApiService {
    @Multipart
    @POST("upload")
    suspend fun uploadImage(
        @Part image: MultipartBody.Part,
        @Part("description") description: RequestBody
    ): UploadResponse
    
    @Multipart
    @POST("upload/multiple")
    suspend fun uploadMultipleImages(
        @Part images: List&lt;MultipartBody.Part&gt;
    ): List&lt;UploadResponse&gt;
}

data class UploadResponse(
    @SerializedName("id")
    val id: String,
    
    @SerializedName("url")
    val url: String,
    
    @SerializedName("name")
    val name: String,
    
    @SerializedName("size")
    val size: Long
)
```

**FileUploadRepository.kt:**
```kotlin
class FileUploadRepository {
    private val apiService = ApiService.apiService
    
    suspend fun uploadImage(imageFile: File, description: String): Result&lt;UploadResponse&gt; {
        return try {
            val requestFile = imageFile.asRequestBody("image/*".toMediaTypeOrNull())
            val body = MultipartBody.Part.createFormData("image", imageFile.name, requestFile)
            val descriptionBody = description.toRequestBody("text/plain".toMediaTypeOrNull())
            
            val response = apiService.uploadImage(body, descriptionBody)
            Result.Success(response)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
    
    suspend fun uploadMultipleImages(imageFiles: List&lt;File&gt;): Result&lt;List&lt;UploadResponse&gt;&gt; {
        return try {
            val imageParts = imageFiles.map { file ->
                val requestFile = file.asRequestBody("image/*".toMediaTypeOrNull())
                MultipartBody.Part.createFormData("images", file.name, requestFile)
            }
            
            val responses = apiService.uploadMultipleImages(imageParts)
            Result.Success(responses)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
}
```

### File Upload with Progress:
**FileUploadRepository.kt:**
```kotlin
class FileUploadRepository {
    private val apiService = ApiService.apiService
    
    fun uploadImageWithProgress(imageFile: File, description: String): Flow&lt;UploadProgress&gt; = flow {
        emit(UploadProgress(0))
        
        try {
            val requestFile = imageFile.asRequestBody("image/*".toMediaTypeOrNull())
            val body = MultipartBody.Part.createFormData("image", imageFile.name, requestFile)
            val descriptionBody = description.toRequestBody("text/plain".toMediaTypeOrNull())
            
            val response = apiService.uploadImage(body, descriptionBody)
            emit(UploadProgress(100, response))
        } catch (e: Exception) {
            emit(UploadProgress(error = e))
        }
    }
}

data class UploadProgress(
    val percentage: Int = 0,
    val response: UploadResponse? = null,
    val error: Exception? = null
)
```

### File Download:
**ApiService.kt:**
```kotlin
interface ApiService {
    @GET
    @Streaming
    suspend fun downloadFile(@Url url: String): ResponseBody
    
    @Streaming
    @GET("files/{filename}")
    suspend fun downloadFile(@Path("filename") filename: String): ResponseBody
}
```

**FileDownloadRepository.kt:**
```kotlin
class FileDownloadRepository {
    private val apiService = ApiService.apiService
    
    suspend fun downloadFile(url: String, destinationFile: File): Result&lt;File&gt; {
        return try {
            val responseBody = apiService.downloadFile(url)
            
            responseBody.byteStream().use { input ->
                destinationFile.outputStream().use { output ->
                    input.copyTo(output)
                }
            }
            
            Result.Success(destinationFile)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
    
    fun downloadFileWithProgress(url: String, destinationFile: File): Flow&lt;DownloadProgress&gt; = flow {
        emit(DownloadProgress(0))
        
        try {
            val responseBody = apiService.downloadFile(url)
            val fileSize = responseBody.contentLength()
            var bytesCopied = 0L
            
            responseBody.byteStream().use { input ->
                destinationFile.outputStream().use { output ->
                    val buffer = ByteArray(8 * 1024)
                    var bytes = input.read(buffer)
                    
                    while (bytes >= 0) {
                        output.write(buffer, 0, bytes)
                        bytesCopied += bytes
                        
                        if (fileSize > 0) {
                            val progress = (bytesCopied * 100 / fileSize).toInt()
                            emit(DownloadProgress(progress))
                        }
                        
                        bytes = input.read(buffer)
                    }
                }
            }
            
            emit(DownloadProgress(100, destinationFile))
        } catch (e: Exception) {
            emit(DownloadProgress(error = e))
        }
    }
}

data class DownloadProgress(
    val percentage: Int = 0,
    val file: File? = null,
    val error: Exception? = null
)
```

### File Upload in ViewModel:
**FileViewModel.kt:**
```kotlin
class FileViewModel : ViewModel() {
    private val repository = FileUploadRepository()
    
    private val _uploadProgress = MutableStateFlow&lt;UploadProgress?&gt;(null)
    val uploadProgress: StateFlow&lt;UploadProgress?&gt; = _uploadProgress.asStateFlow()
    
    private val _downloadProgress = MutableStateFlow&lt;DownloadProgress?&gt;(null)
    val downloadProgress: StateFlow&lt;DownloadProgress?&gt; = _downloadProgress.asStateFlow()
    
    fun uploadImage(imageUri: Uri, description: String, context: Context) {
        viewModelScope.launch {
            val imageFile = uriToFile(imageUri, context)
            
            repository.uploadImageWithProgress(imageFile, description).collect { progress ->
                _uploadProgress.value = progress
            }
        }
    }
    
    fun downloadFile(url: String, destinationFile: File) {
        viewModelScope.launch {
            repository.downloadFileWithProgress(url, destinationFile).collect { progress ->
                _downloadProgress.value = progress
            }
        }
    }
    
    private fun uriToFile(uri: Uri, context: Context): File {
        val inputStream = context.contentResolver.openInputStream(uri)
        val file = File(context.cacheDir, "temp_image")
        
        inputStream?.use { input ->
            file.outputStream().use { output ->
                input.copyTo(output)
            }
        }
        
        return file
    }
}
```

### ğŸ“ Penjelasan Konsep:
**File Upload & Download seperti Layanan Pengiriman Paket:**
- **Multipart**: Paket dengan beberapa bagian
- **RequestBody**: Isi paket
- **Streaming**: Pengiriman bertahap
- **Progress**: Pelacakan pengiriman
- **File**: Tujuan akhir

**Proses Upload:**
1. Pilih file
2. Konversi ke RequestBody
3. Buat MultipartBody.Part
4. Kirim ke server
5. Tangani response

**Proses Download:**
1. Dapatkan URL file
2. Buat request download
3. Streaming response ke file
4. Lacak progress
5. Selesaikan download

**Best Practices:**
- Gunakan @Multipart untuk file upload
- Gunakan @Streaming untuk file download
- Lacak progress untuk pengalaman pengguna yang lebih baik
- Tangani error dengan baik
- Bersihkan file sementara setelah selesai
- Pertimbangkan untuk menggunakan background service untuk download besar

---

## 1ï¸âƒ£3ï¸âƒ£ Response Caching ğŸ’¾

### Konsep Dasar
Response Caching seperti memori jangka pendek ğŸ’¾ - menyimpan informasi yang sering diakses untuk mempercepat akses di masa depan!

### Basic Caching:
**NetworkModule.kt:**
```kotlin
object NetworkModule {
    fun provideOkHttpClient(context: Context): OkHttpClient {
        val cacheSize = 10 * 1024 * 1024L // 10 MB
        val cache = Cache(context.cacheDir, cacheSize)
        
        return OkHttpClient.Builder()
            .cache(cache)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
```

### Cache Control Interceptor:
**CacheInterceptor.kt:**
```kotlin
class CacheInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val response = chain.proceed(request)
        
        // Cache response untuk 5 menit
        val cacheControl = CacheControl.Builder()
            .maxAge(5, TimeUnit.MINUTES)
            .build()
        
        return response.newBuilder()
            .header("Cache-Control", cacheControl.toString())
            .build()
    }
}

// Usage
object NetworkModule {
    fun provideOkHttpClient(context: Context): OkHttpClient {
        val cacheSize = 10 * 1024 * 1024L // 10 MB
        val cache = Cache(context.cacheDir, cacheSize)
        
        val cacheInterceptor = CacheInterceptor()
        
        return OkHttpClient.Builder()
            .cache(cache)
            .addNetworkInterceptor(cacheInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
```

### Offline Cache Interceptor:
**OfflineCacheInterceptor.kt:**
```kotlin
class OfflineCacheInterceptor(private val context: Context) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        var request = chain.request()
        
        if (!isNetworkAvailable(context)) {
            val cacheControl = CacheControl.Builder()
                .maxStale(1, TimeUnit.DAYS) // Cache selama 1 hari saat offline
                .build()
            
            request = request.newBuilder()
                .cacheControl(cacheControl)
                .build()
        }
        
        return chain.proceed(request)
    }
    
    private fun isNetworkAvailable(context: Context): Boolean {
        val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        return cm.activeNetworkInfo?.isConnected == true
    }
}

// Usage
object NetworkModule {
    fun provideOkHttpClient(context: Context): OkHttpClient {
        val cacheSize = 10 * 1024 * 1024L // 10 MB
        val cache = Cache(context.cacheDir, cacheSize)
        
        val cacheInterceptor = CacheInterceptor()
        val offlineCacheInterceptor = OfflineCacheInterceptor(context)
        
        return OkHttpClient.Builder()
            .cache(cache)
            .addInterceptor(offlineCacheInterceptor)
            .addNetworkInterceptor(cacheInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
}
```

### Cache with Dynamic Control:
**ApiService.kt:**
```kotlin
interface ApiService {
    @Headers("Cache-Control: max-age=60") // Cache selama 1 menit
    @GET("users")
    suspend fun getCachedUsers(): List&lt;User&gt;
    
    @Headers("Cache-Control: no-cache") // Tidak cache
    @GET("users")
    suspend fun getFreshUsers(): List&lt;User&gt;
    
    @GET("users")
    suspend fun getUsersWithCacheControl(
        @Header("Cache-Control") cacheControl: String
    ): List&lt;User&gt;
}
```

### Cache in Repository:
**UserRepository.kt:**
```kotlin
class UserRepository {
    private val apiService = ApiService.apiService
    
    suspend fun getCachedUsers(): List&lt;User&gt; {
        return try {
            apiService.getCachedUsers()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    suspend fun getFreshUsers(): List&lt;User&gt; {
        return try {
            apiService.getFreshUsers()
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    suspend fun getUsers(forceRefresh: Boolean = false): List&lt;User&gt; {
        return try {
            if (forceRefresh) {
                apiService.getFreshUsers()
            } else {
                apiService.getUsersWithCacheControl("max-age=300") // 5 menit
            }
        } catch (e: Exception) {
            emptyList()
        }
    }
}
```

### Cache with Room Database:
**UserDao.kt:**
```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    suspend fun getAllUsers(): List&lt;UserEntity&gt;
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUsers(users: List&lt;UserEntity&gt;)
    
    @Query("DELETE FROM users")
    suspend fun clearUsers()
}

@Database(entities = [UserEntity::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}

@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey
    val id: Int,
    val name: String,
    val email: String,
    val isActive: Boolean,
    val createdAt: String,
    val updatedAt: String
) {
    fun toUser(): User {
        return User(id, name, email, isActive, createdAt, updatedAt)
    }
}

fun User.toEntity(): UserEntity {
    return UserEntity(id, name, email, isActive, createdAt, updatedAt)
}
```

**UserRepository.kt:**
```kotlin
class UserRepository(
    private val apiService: ApiService,
    private val userDao: UserDao
) {
    suspend fun getUsers(forceRefresh: Boolean = false): List&lt;User&gt; {
        if (forceRefresh) {
            return try {
                val users = apiService.getFreshUsers()
                userDao.clearUsers()
                userDao.insertUsers(users.map { it.toEntity() })
                users
            } catch (e: Exception) {
                // Jika gagal, coba ambil dari cache lokal
                userDao.getAllUsers().map { it.toUser() }
            }
        } else {
            // Coba ambil dari cache lokal dulu
            val cachedUsers = userDao.getAllUsers().map { it.toUser() }
            
            // Lalu refresh di background
            viewModelScope.launch {
                try {
                    val freshUsers = apiService.getFreshUsers()
                    userDao.clearUsers()
                    userDao.insertUsers(freshUsers.map { it.toEntity() })
                } catch (e: Exception) {
                    // Ignore error untuk background refresh
                }
            }
            
            return cachedUsers
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Response Caching seperti Memori Jangka Pendek:**
- **Cache Storage**: Tempat penyimpanan
- **Cache Control**: Aturan penyimpanan
- **Offline Cache**: Memori saat tidak ada koneksi
- **Dynamic Control**: Kontrol sesuai kebutuhan
- **Room Database**: Memori jangka panjang

**Strategi Caching:**
1. **Network First**: Ambil dari network, cache untuk offline
2. **Cache First**: Ambil dari cache, refresh di background
3. **Cache Only**: Hanya gunakan cache
4. **Network Only**: Tidak gunakan cache

**Best Practices:**
- Tentukan kebijakan cache yang sesuai untuk data
- Gunakan cache untuk data yang tidak sering berubah
- Implementasikan cache offline untuk pengalaman pengguna yang lebih baik
- Pertimbangkan untuk menggunakan database lokal untuk cache persisten
- Bersihkan cache secara berkala untuk menghemat ruang penyimpanan

---

## 1ï¸âƒ£4ï¸âƒ£ Retrofit with Hilt ğŸ”—

### Konsep Dasar
Retrofit with Hilt seperti sistem logistik modern ğŸ”— - mengatur distribusi sumber daya dengan efisien dan terstruktur!

### Network Module with Hilt:
**NetworkModule.kt:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideContext(@ApplicationContext context: Context): Context {
        return context
    }
    
    @Provides
    @Singleton
    fun provideCache(context: Context): Cache {
        val cacheSize = 10 * 1024 * 1024L // 10 MB
        return Cache(context.cacheDir, cacheSize)
    }
    
    @Provides
    @Singleton
    fun provideOkHttpClient(
        context: Context,
        cache: Cache,
        @Named("auth_token_provider") tokenProvider: () -> String?
    ): OkHttpClient {
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = if (BuildConfig.DEBUG) {
                HttpLoggingInterceptor.Level.BODY
            } else {
                HttpLoggingInterceptor.Level.NONE
            }
        }
        
        val authInterceptor = AuthInterceptor(tokenProvider)
        val networkInterceptor = NetworkConnectionInterceptor(context)
        val cacheInterceptor = CacheInterceptor()
        
        return OkHttpClient.Builder()
            .cache(cache)
            .addInterceptor(networkInterceptor)
            .addInterceptor(authInterceptor)
            .addNetworkInterceptor(cacheInterceptor)
            .addInterceptor(loggingInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideGson(): Gson {
        return GsonBuilder()
            .setLenient()
            .setDateFormat("yyyy-MM-dd'T'HH:mm:ss")
            .create()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(
        okHttpClient: OkHttpClient,
        gson: Gson
    ): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create(gson))
            .build()
    }
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
    
    @Provides
    @Named("auth_token_provider")
    fun provideAuthTokenProvider(prefManager: PrefManager): () -> String? {
        return { prefManager.getAuthToken() }
    }
}
```

### Database Module with Hilt:
**DatabaseModule.kt:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "app_database"
        ).build()
    }
    
    @Provides
    fun provideUserDao(appDatabase: AppDatabase): UserDao {
        return appDatabase.userDao()
    }
}
```

### Repository with Hilt:
**UserRepository.kt:**
```kotlin
class UserRepository @Inject constructor(
    private val apiService: ApiService,
    private val userDao: UserDao
) {
    suspend fun getUsers(forceRefresh: Boolean = false): List&lt;User&gt; {
        if (forceRefresh) {
            return try {
                val users = apiService.getUsers()
                userDao.clearUsers()
                userDao.insertUsers(users.map { it.toEntity() })
                users
            } catch (e: Exception) {
                userDao.getAllUsers().map { it.toUser() }
            }
        } else {
            val cachedUsers = userDao.getAllUsers().map { it.toUser() }
            
            // Refresh di background
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    val freshUsers = apiService.getUsers()
                    userDao.clearUsers()
                    userDao.insertUsers(freshUsers.map { it.toEntity() })
                } catch (e: Exception) {
                    // Ignore error untuk background refresh
                }
            }
            
            return cachedUsers
        }
    }
    
    suspend fun getUserById(userId: Int): User? {
        return try {
            apiService.getUserById(userId)
        } catch (e: Exception) {
            userDao.getUserById(userId)?.toUser()
        }
    }
    
    suspend fun createUser(user: User): User? {
        return try {
            val newUser = apiService.createUser(user)
            userDao.insertUser(newUser.toEntity())
            newUser
        } catch (e: Exception) {
            null
        }
    }
}
```

### ViewModel with Hilt:
**UserViewModel.kt:**
```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _users = MutableStateFlow&lt;List&lt;User&gt;&gt;(emptyList())
    val users: StateFlow&lt;List&lt;User&gt;&gt; = _users.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()
    
    private val _error = MutableStateFlow&lt;String?&gt;(null)
    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()
    
    init {
        loadUsers()
    }
    
    fun loadUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                val userList = userRepository.getUsers()
                _users.value = userList
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun refreshUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                val userList = userRepository.getUsers(forceRefresh = true)
                _users.value = userList
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun createUser(user: User) {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                val newUser = userRepository.createUser(user)
                if (newUser != null) {
                    loadUsers() // Refresh list
                } else {
                    _error.value = "Failed to create user"
                }
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLoading.value = false
            }
        }
    }
}
```

### Activity/Fragment with Hilt:
**UserListFragment.kt:**
```kotlin
@AndroidEntryPoint
class UserListFragment : Fragment() {
    
    private var _binding: FragmentUserListBinding? = null
    private val binding get() = _binding!!
    
    private val viewModel: UserViewModel by viewModels()
    private lateinit var userAdapter: UserAdapter
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentUserListBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        setupRecyclerView()
        observeViewModel()
        
        binding.refreshLayout.setOnRefreshListener {
            viewModel.refreshUsers()
        }
    }
    
    private fun setupRecyclerView() {
        userAdapter = UserAdapter()
        binding.recyclerView.adapter = userAdapter
        binding.recyclerView.layoutManager = LinearLayoutManager(requireContext())
    }
    
    private fun observeViewModel() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.users.collect { users ->
                userAdapter.submitList(users)
            }
        }
        
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.isLoading.collect { isLoading ->
                binding.refreshLayout.isRefreshing = isLoading
            }
        }
        
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.error.collect { error ->
                if (error != null) {
                    Toast.makeText(requireContext(), error, Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Retrofit with Hilt seperti Sistem Logistik Modern:**
- **Module**: Gudang sumber daya
- **Provides**: Cara mendapatkan sumber daya
- **Inject**: Distribusi sumber daya
- **Singleton**: Sumber daya yang unik
- **Qualifiers**: Label sumber daya

**Alur Kerja Hilt:**
1. Definisikan module untuk menyediakan dependency
2. Gunakan @Inject untuk menginjeksi dependency
3. Hilt akan menyediakan dependency yang dibutuhkan
4. Dependency akan dikelola secara otomatis

**Best Practices:**
- Gunakan @Singleton untuk objek yang mahal untuk dibuat
- Pisahkan module berdasarkan tanggung jawab
- Gunakan @Named atau @Qualifier untuk dependency yang sama dengan tipe yang sama
- Gunakan @HiltViewModel untuk ViewModel
- Gunakan @AndroidEntryPoint untuk Activity/Fragment

---

## 1ï¸âƒ£5ï¸âƒ£ Best Practices âœ¨

### Konsep Dasar
Best Practices seperti buku panduan master âœ¨ - kumpulan aturan dan teknik yang telah terbukti efektif!

### Use Suspend Functions:
**âœ… GOOD:**
```kotlin
interface ApiService {
    @GET("users")
    suspend fun getUsers(): List&lt;User&gt;
}

// Usage
viewModelScope.launch {
    val users = apiService.getUsers()
    _users.value = users
}
```

**âŒ BAD:**
```kotlin
interface ApiService {
    @GET("users")
    fun getUsers(): Call&lt;List&lt;User&gt;&gt;
}

// Usage
apiService.getUsers().enqueue(object : Callback&lt;List&lt;User&gt;&gt; {
    override fun onResponse(call: Call&lt;List&lt;User&gt;&gt;, response: Response&lt;List&lt;User&gt;&gt;) {
        // Handle response
    }
    
    override fun onFailure(call: Call&lt;List&lt;User&gt;&gt;, t: Throwable) {
        // Handle error
    }
})
```

### Implement Proper Error Handling:
**âœ… GOOD:**
```kotlin
sealed class Result&lt;out T&gt; {
    data class Success&lt;T&gt;(val data: T) : Result&lt;T&gt;()
    data class Error(val exception: Exception) : Result&lt;Nothing&gt;()
}

suspend fun &lt;T&gt; safeApiCall(apiCall: suspend () -> T): Result&lt;T&gt; {
    return try {
        Result.Success(apiCall())
    } catch (e: Exception) {
        Result.Error(e)
    }
}

// Usage
val result = safeApiCall { apiService.getUsers() }
when (result) {
    is Result.Success -> // Handle success
    is Result.Error -> // Handle error
}
```

**âŒ BAD:**
```kotlin
// Usage
try {
    val users = apiService.getUsers()
    _users.value = users
} catch (e: Exception) {
    _error.value = e.message
}
```

### Use Interceptors for Common Logic:
**âœ… GOOD:**
```kotlin
class AuthInterceptor(private val tokenProvider: () -> String?) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val original = chain.request()
        val token = tokenProvider()
        
        val request = if (token != null) {
            original.newBuilder()
                .header("Authorization", "Bearer $token")
                .build()
        } else {
            original
        }
        
        return chain.proceed(request)
    }
}

// Usage
val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(AuthInterceptor { getToken() })
    .build()
```

**âŒ BAD:**
```kotlin
// Setiap request harus menambahkan header manual
@GET("users")
suspend fun getUsers(@Header("Authorization") token: String): List&lt;User&gt;

// Usage
val users = apiService.getUsers("Bearer $token")
```

### Enable Logging Only in Debug Builds:
**âœ… GOOD:**
```kotlin
val loggingInterceptor = HttpLoggingInterceptor().apply {
    level = if (BuildConfig.DEBUG) {
        HttpLoggingInterceptor.Level.BODY
    } else {
        HttpLoggingInterceptor.Level.NONE
    }
}

val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(loggingInterceptor)
    .build()
```

**âŒ BAD:**
```kotlin
val loggingInterceptor = HttpLoggingInterceptor().apply {
    level = HttpLoggingInterceptor.Level.BODY // Log di production!
}

val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(loggingInterceptor)
    .build()
```

### Cache Responses When Appropriate:
**âœ… GOOD:**
```kotlin
val cacheSize = 10 * 1024 * 1024L // 10 MB
val cache = Cache(context.cacheDir, cacheSize)

val okHttpClient = OkHttpClient.Builder()
    .cache(cache)
    .addInterceptor { chain ->
        var request = chain.request()
        request = if (hasNetwork())
            request.newBuilder()
                .header("Cache-Control", "public, max-age=60")
                .build()
        else
            request.newBuilder()
                .header("Cache-Control", "public, only-if-cached, max-stale=86400")
                .build()
        chain.proceed(request)
    }
    .build()
```

**âŒ BAD:**
```kotlin
// Tidak ada cache, setiap request selalu ke server
val okHttpClient = OkHttpClient.Builder()
    .build()
```

### Use Timeout Configurations:
**âœ… GOOD:**
```kotlin
val okHttpClient = OkHttpClient.Builder()
    .connectTimeout(30, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .writeTimeout(30, TimeUnit.SECONDS)
    .build()
```

**âŒ BAD:**
```kotlin
// Tidak ada timeout, bisa menyebabkan hanging
val okHttpClient = OkHttpClient.Builder()
    .build()
```

### Implement Retry Logic for Failed Requests:
**âœ… GOOD:**
```kotlin
suspend fun getUsersWithRetry(retries: Int = 3): List&lt;User&gt; {
    var lastException: Exception? = null
    
    repeat(retries) { attempt ->
        try {
            return apiService.getUsers()
        } catch (e: Exception) {
            lastException = e
            if (attempt < retries - 1) {
                delay(1000L * (attempt + 1)) // Exponential backoff
            }
        }
    }
    
    throw lastException ?: Exception("Unknown error")
}
```

**âŒ BAD:**
```kotlin
// Tidak ada retry mechanism
suspend fun getUsers(): List&lt;User&gt; {
    return apiService.getUsers()
}
```

### Separate API Models from Domain Models:
**âœ… GOOD:**
```kotlin
// API Model
data class UserDto(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("user_name")
    val name: String,
    
    @SerializedName("email_address")
    val email: String
)

// Domain Model
data class User(
    val id: Int,
    val name: String,
    val email: String
)

// Mapper
fun UserDto.toDomain(): User {
    return User(id, name, email)
}
```

**âŒ BAD:**
```kotlin
// Menggunakan model yang sama untuk API dan domain
data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("user_name")
    val name: String,
    
    @SerializedName("email_address")
    val email: String
)
```

### Use Sealed Classes for API Responses:
**âœ… GOOD:**
```kotlin
sealed class ApiResponse&lt;out T&gt; {
    data class Success&lt;T&gt;(val data: T) : ApiResponse&lt;T&gt;()
    data class Error(val code: Int, val message: String) : ApiResponse&lt;Nothing&gt;()
    object Loading : ApiResponse&lt;Nothing&gt;()
}

// Usage
when (response) {
    is ApiResponse.Success -> // Handle success
    is ApiResponse.Error -> // Handle error
    is ApiResponse.Loading -> // Show loading
}
```

**âŒ BAD:**
```kotlin
// Tidak ada wrapper untuk response
suspend fun getUsers(): List&lt;User&gt;
```

### Mock API Responses for Testing:
**âœ… GOOD:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object TestNetworkModule {
    
    @Provides
    @Singleton
    fun provideApiService(): ApiService {
        return MockApiService()
    }
}

class MockApiService : ApiService {
    override suspend fun getUsers(): List&lt;User&gt; {
        return listOf(
            User(1, "John Doe", "john@example.com"),
            User(2, "Jane Smith", "jane@example.com")
        )
    }
}
```

**âŒ BAD:**
```kotlin
// Tidak ada mock untuk testing, selalu menggunakan API nyata
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Best Practices seperti Buku Panduan Master:**
- **Suspend Functions**: Cara modern untuk async programming
- **Error Handling**: Strategi untuk menangani masalah
- **Interceptors**: Pemisahan logika umum
- **Logging**: Debugging yang cerdas
- **Caching**: Optimisasi performa dengan menyimpan respons

### Use Dependency Injection (Hilt):
**âœ… GOOD:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}

@HiltViewModel
class UserViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    // ...
}
```

**âŒ BAD:**
```kotlin
// Manual dependency injection, sulit di-maintain
class UserViewModel : ViewModel() {
    private val apiService = RetrofitClient.apiService // Tight coupling
    private val userRepository = UserRepository(apiService)
    // ...
}
```

### Handle Network State Gracefully:
**âœ… GOOD:**
```kotlin
// Tampilkan pesan yang jelas ketika tidak ada koneksi
if (!isNetworkAvailable()) {
    _uiState.value = UiState.Error("No internet connection. Please check your network.")
    return
}
```

**âŒ BAD:**
```kotlin
// Biarkan aplikasi crash tanpa pesan yang jelas
apiService.getUsers() // Akan crash jika tidak ada internet
```

### ğŸ“ Penjelasan Konsep:
**Best Practices seperti Buku Panduan Master:**
- **Suspend Functions**: Cara modern dan efisien untuk async programming
- **Error Handling**: Membuat aplikasi lebih robust dan user-friendly
- **Interceptors**: Pemisahan logika untuk kode yang bersih dan reusable
- **Logging**: Membantu debugging tanpa mengorbankan keamanan di production
- **Caching**: Meningkatkan performa dan menghemat kuota pengguna
- **Timeouts**: Mencegah aplikasi hang/halt
- **Retry Logic**: Meningkatkan keandalan aplikasi
- **Model Separation**: Menciptakan arsitektur yang bersih dan maintainable
- **Sealed Classes**: Memberikan struktur yang aman untuk state management
- **Dependency Injection**: Memudahkan testing dan manajemen dependensi
- **Network State Handling**: Memberikan pengalaman pengguna yang lebih baik

---

## 1ï¸âƒ£6ï¸âƒ£ Hands-on Project ğŸ”¨

### Konsep Dasar
Hands-on Project seperti membangun rumah pertama ğŸ”¨ - menerapkan semua teori menjadi sebuah karya nyata yang fungsional!

### Proyek: Aplikasi Manajemen Pengguna Sederhana
Kita akan membangun aplikasi Android sederhana yang dapat:
1. Menampilkan daftar pengguna dari API publik (JSONPlaceholder)
2. Menambah pengguna baru
3. Menghapus pengguna
4. Menangani loading state dan error

#### Langkah 1: Setup Proyek & Dependencies
**build.gradle.kts (Module: app):**
```kotlin
dependencies {
    // UI
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.6.2")
    implementation("androidx.activity:activity-compose:1.8.1")
    implementation(platform("androidx.compose:compose-bom:2023.08.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    
    // ViewModel
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.6.2")
    
    // Hilt
    implementation("com.google.dagger:hilt-android:2.48")
    implementation("androidx.hilt:hilt-navigation-compose:1.1.0")
    kapt("com.google.dagger:hilt-compiler:2.48")
    
    // Retrofit & OkHttp
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
    implementation("com.squareup.okhttp3:okhttp:4.11.0")
    implementation("com.squareup.okhttp3:logging-interceptor:4.11.0")
    
    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.1")
}
```

**AndroidManifest.xml:**
```xml
<uses-permission android:name="android.permission.INTERNET" />
```

#### Langkah 2: Buat Data Model
**data/model/User.kt:**
```kotlin
package com.example.usermanager.data.model

import com.google.gson.annotations.SerializedName

data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("name")
    val name: String,
    
    @SerializedName("email")
    val email: String,
    
    @SerializedName("phone")
    val phone: String
)

data class CreateUserRequest(
    @SerializedName("name")
    val name: String,
    
    @SerializedName("email")
    val email: String,
    
    @SerializedName("phone")
    val phone: String
)
```

#### Langkah 3: Definisikan API Interface
**network/ApiService.kt:**
```kotlin
package com.example.usermanager.network

import com.example.usermanager.data.model.CreateUserRequest
import com.example.usermanager.data.model.User
import retrofit2.Response
import retrofit2.http.*

interface ApiService {
    @GET("users")
    suspend fun getUsers(): List&lt;User&gt;
    
    @POST("users")
    suspend fun createUser(@Body user: CreateUserRequest): User
    
    @DELETE("users/{id}")
    suspend fun deleteUser(@Path("id") userId: Int): Response&lt;Unit&gt;
}
```

#### Langkah 4: Setup Retrofit dengan Hilt
**di/NetworkModule.kt:**
```kotlin
package com.example.usermanager.di

import com.example.usermanager.network.ApiService
import com.google.gson.GsonBuilder
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.util.concurrent.TimeUnit
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = HttpLoggingInterceptor.Level.BODY
        }
        
        return OkHttpClient.Builder()
            .addInterceptor(loggingInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://jsonplaceholder.typicode.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create(GsonBuilder().create()))
            .build()
    }
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
```

#### Langkah 5: Buat Repository
**data/repository/UserRepository.kt:**
```kotlin
package com.example.usermanager.data.repository

import com.example.usermanager.data.model.CreateUserRequest
import com.example.usermanager.data.model.User
import com.example.usermanager.network.ApiService
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserRepository @Inject constructor(
    private val apiService: ApiService
) {
    suspend fun getUsers(): Result&lt;List&lt;User&gt;&gt; {
        return try {
            val users = apiService.getUsers()
            Result.success(users)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun createUser(request: CreateUserRequest): Result&lt;User&gt; {
        return try {
            val newUser = apiService.createUser(request)
            Result.success(newUser)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun deleteUser(userId: Int): Result&lt;Unit&gt; {
        return try {
            apiService.deleteUser(userId)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

#### Langkah 6: Buat ViewModel
**presentation/viewmodel/UserViewModel.kt:**
```kotlin
package com.example.usermanager.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.usermanager.data.model.CreateUserRequest
import com.example.usermanager.data.model.User
import com.example.usermanager.data.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class UserViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow&lt;UserListUiState&gt;(UserListUiState.Loading)
    val uiState = _uiState.asStateFlow()
    
    init {
        loadUsers()
    }
    
    fun loadUsers() {
        viewModelScope.launch {
            _uiState.value = UserListUiState.Loading
            userRepository.getUsers().collect { result ->
                _uiState.value = when (result) {
                    is Result.Success -> UserListUiState.Success(result.data)
                    is Result.Error -> UserListUiState.Error(result.exception.message ?: "Unknown error")
                }
            }
        }
    }
    
    fun addUser(name: String, email: String, phone: String) {
        viewModelScope.launch {
            _uiState.value = UserListUiState.Loading
            val request = CreateUserRequest(name, email, phone)
            userRepository.createUser(request).collect { result ->
                if (result is Result.Success) {
                    loadUsers() // Refresh list
                } else {
                    _uiState.value = UserListUiState.Error(result.exception.message ?: "Failed to create user")
                }
            }
        }
    }
    
    fun deleteUser(userId: Int) {
        viewModelScope.launch {
            userRepository.deleteUser(userId).collect { result ->
                if (result is Result.Success) {
                    loadUsers() // Refresh list
                } else {
                    // Bisa menampilkan snackbar error
                }
            }
        }
    }
}

sealed class UserListUiState {
    object Loading : UserListUiState()
    data class Success(val users: List&lt;User&gt;) : UserListUiState()
    data class Error(val message: String) : UserListUiState()
}
```

#### Langkah 7: Buat UI dengan Jetpack Compose
**presentation/screen/UserListScreen.kt:**
```kotlin
package com.example.usermanager.presentation.screen

// ... imports ...

@Composable
fun UserListScreen(
    viewModel: UserViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    when (val state = uiState) {
        is UserListUiState.Loading -> {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
        }
        is UserListUiState.Success -> {
            LazyColumn(modifier = Modifier.fillMaxSize()) {
                items(state.users) { user ->
                    UserItem(user = user, onDelete = { viewModel.deleteUser(it.id) })
                }
            }
        }
        is UserListUiState.Error -> {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                Text(text = "Error: ${state.message}", color = MaterialTheme.colorScheme.error)
            }
        }
    }
}

@Composable
fun UserItem(user: User, onDelete: () -> Unit) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(text = user.name, style = MaterialTheme.typography.titleMedium)
                Text(text = user.email, style = MaterialTheme.typography.bodyMedium)
            }
            IconButton(onClick = onDelete) {
                Icon(Icons.Default.Delete, contentDescription = "Delete User")
            }
        }
    }
}
```

#### Langkah 8: Integrasi dengan Activity
**MainActivity.kt:**
```kotlin
package com.example.usermanager

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.ui.Modifier
import com.example.usermanager.presentation.screen.UserListScreen
import com.example.usermanager.ui.theme.UserManagerTheme
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            UserManagerTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    UserListScreen()
                }
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Hands-on Project seperti Membangun Rumah:**
- **Setup**: Mempersiapkan fondasi dan alat
- **Model**: Membuat cetakan untuk struktur
- **API Interface**: Merancang jalan akses
- **DI Module**: Memasang instalasi listrik dan air
- **Repository**: Mengatur logika perumahan
- **ViewModel**: Mengatur kontrol pintu dan lampu
- **UI**: Mendesain interior dan eksterior
- **Activity**: Menempatkan rumah di lokasi

**Hasil Akhir:**
Anda telah berhasil membuat aplikasi Android yang fungsional dengan arsitektur modern (MVVM), menggunakan Retrofit untuk komunikasi network, Hilt untuk dependency injection, dan Jetpack Compose untuk UI. Aplikasi ini dapatampilkan, menambah, dan menghapus data pengguna dari server!

---

## ğŸ¯ Kesimpulan

### ğŸŒŸ Apa yang Telah Kita Pelajari:
Kita telah menempuh perjalanan lengkap dari nol hingga mahir dalam menggunakan Retrofit di Android:

1.  **Pengenalan Retrofit**: Memahami apa itu Retrofit dan mengapa ia menjadi pilihan utama.
2.  **Setup & Dependencies**: Menyiapkan proyek dengan semua alat yang dibutuhkan.
3.  **Building Retrofit Instance**: Membangun klien HTTP yang kuat dan fleksibel.
4.  **API Interface Definition**: Mendefinisikan kontrak komunikasi dengan server.
5.  **Annotations Explained**: Menguasai anotasi untuk setiap skenario request.
6.  **Data Models**: Menciptakan struktur data yang efisien.
7.  **Making API Calls**: Melakukan panggilan API dengan coroutines.
8.  **Coroutines Integration**: Mengintegrasikan pemrograman asinkron dengan mulus.
9.  **Error Handling**: Membangun aplikasi yang tangguh terhadap kesalahan.
10. **Interceptors**: Menambahkan logika umum seperti autentikasi dan logging.
11. **Gson Converter**: Mengkonversi data JSON dengan mudah.
12. **File Upload & Download**: Menangani transfer file.
13. **Response Caching**: Mengoptimalkan performa dengan caching.
14. **Retrofit with Hilt**: Mengelola dependensi secara profesional.
15. **Best Practices**: Menerapkan standar industri untuk kode yang bersih.
16. **Hands-on Project**: Menerapkan semua teori dalam proyek nyata.

### ğŸš€ Langkah Selanjutnya:
Dengan fondasi yang kuat ini, Anda siap untuk:

1.  **Mendalami Autentikasi**: Menerapkan JWT, OAuth2, dan mekanisme keamanan lainnya.
2.  **Mengeksplorasi GraphQL**: Alternatif modern untuk REST API.
3.  **Mempelajari Testing**: Unit test, integration test untuk layer network.
4.  **Optimasi Performa**: Menerapkan strategi caching dan request batching yang lebih advanced.
5.  **Membangun Aplikasi Kompleks**: Menerapkan semua ini dalam proyek skala besar.

### ğŸ¯ Tips untuk Menjadi Ahli Retrofit:
1.  **Praktik adalah Kunci**: Teruslah membuat proyek dan bereksperimen dengan API.
2.  **Baca Dokumentasi**: Dokumentasi resmi Retrofit dan OkHttp adalah sumber terbaik.
3.  **Ikuti Komunitas**: Bergabunglah dengan forum dan komunitas Android developer.
4.  **Analisis Kode Sumber**: Pelajari bagaimana library populer mengimplementasikan Retrofit.
5.  **Jangan Takut untuk Bertanya**: Komunitas developer selalu siap membantu.

Dengan dedikasi dan latihan, Retrofit akan menjadi alat yang sangat powerful dalam arsenal pengembangan Android Anda. Selamat berkoding!