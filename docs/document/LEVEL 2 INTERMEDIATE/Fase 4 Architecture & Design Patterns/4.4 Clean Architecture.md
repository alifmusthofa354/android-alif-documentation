## **4.4 Clean Architecture** (1 minggu) ⭐⭐⭐

### **Teknologi Modern:**
- Layers: Presentation, Domain, Data
- Domain layer
- Data layer

### **Teknologi yang Ditinggalkan:**
- Monolithic architecture

### **Sub-topik Detail:**

#### 1. Clean Architecture Principles
- Konsep dari Uncle Bob (Robert C. Martin)
- Tujuan Clean Architecture
- Independence of frameworks
- Testability
- Independence of UI
- Independence of database
- SOLID principles integration

#### 2. The Dependency Rule
- Dependencies point inward
- Inner layers tidak tahu outer layers
- Domain layer sebagai center
- Dependency Inversion Principle
- Abstraction dan interfaces
- Plugin architecture

#### 3. Architecture Layers Overview
**Presentation Layer (Outer)**
- UI components
- ViewModels
- UI State
- Navigation

**Domain Layer (Middle/Core)**
- Use Cases
- Business logic
- Domain models
- Repository interfaces

**Data Layer (Outer)**
- Repository implementations
- Data sources (API, Database)
- DTOs dan Entities
- Mappers

#### 4. Domain Layer (Core)
- **Use Cases/Interactors**
  - Business logic
  - Use case classes
  - Single responsibility
  
- **Domain Models**
  - Pure Kotlin classes
  - Business entities
  - No Android dependencies
  
- **Repository Interfaces**
  - Abstraction untuk data
  - Defined by domain needs
  - Implemented di data layer

#### 5. Data Layer
- **Repository Implementations**
  - Implement domain interfaces
  - Coordinate data sources
  - Caching logic
  
- **Data Sources**
  - Remote (API calls)
  - Local (Database, Preferences)
  - Mock/Fake for testing
  
- **DTOs & Entities**
  - Network response models
  - Database entities
  - Different from domain models
  
- **Mappers**
  - DTO → Domain Model
  - Entity → Domain Model
  - Extension functions untuk mapping

#### 6. Presentation Layer
- **UI (Compose/Views)**
  - Display data
  - User interactions
  - Navigation
  
- **ViewModels**
  - Call Use Cases
  - Hold UI State
  - Handle events
  
- **UI Models**
  - Screen-specific models
  - Different from domain models
  - Presentation concerns

#### 7. Package Structure

**Option 1: Layer-based**
```
app/
├── presentation/
│   ├── home/
│   ├── profile/
│   └── common/
├── domain/
│   ├── usecase/
│   ├── model/
│   └── repository/
└── data/
    ├── repository/
    ├── source/
    └── mapper/
```

**Option 2: Feature-based**
```
app/
├── feature/
│   └── user/
│       ├── presentation/
│       ├── domain/
│       └── data/
```

#### 8. Data Flow
```
UI → ViewModel → Use Case → Repository Interface
                               ↓
                    Repository Implementation
                               ↓
                         Data Sources
```

#### 9. Model Mapping
- **API DTO** → Data Entity
- **Data Entity** → Domain Model  
- **Domain Model** → UI Model
- Mapping functions
- Extension functions
- Mapper classes

#### 10. Dependency Injection
- Module organization per layer
- Domain module (Use Cases)
- Data module (Repositories, Data Sources)
- App module (ViewModels)
- Interface bindings
- Singleton vs Factory

#### 11. Testing Strategy
**Domain Layer Testing:**
- Unit test Use Cases
- Pure business logic tests
- No Android dependencies
- Fast execution

**Data Layer Testing:**
- Repository tests
- Data source tests
- Mapper tests
- Integration tests

**Presentation Layer Testing:**
- ViewModel tests
- UI tests
- Navigation tests

#### 12. Benefits & Trade-offs
**Benefits:**
- Separation of concerns
- Testability
- Maintainability
- Scalability
- Team collaboration
- Independent development

**Trade-offs:**
- More boilerplate
- Steeper learning curve
- More files dan classes
- Initial setup time
- Overkill untuk simple apps

#### 13. Modularization (Optional)
- Multi-module project
- Feature modules
- Core modules
- Shared modules
- Build time optimization
- Dynamic feature modules

#### 14. Hands-on Project
- Build app dengan Clean Architecture
- Implement all 3 layers
- Proper separation of concerns
- Dependency injection
- Complete testing
- Real-world feature implementation

---
