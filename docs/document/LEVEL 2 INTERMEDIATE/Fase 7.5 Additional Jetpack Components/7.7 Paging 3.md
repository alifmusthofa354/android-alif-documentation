## **7.7 Paging 3** (1 minggu) ⭐⭐⭐

### **Teknologi Modern:**
- Paging 3 dengan Compose
- RemoteMediator
- PagingSource
- PagingData

### **Teknologi yang Ditinggalkan:**
- Manual pagination
- PagedList (Paging 2)
- Custom endless scroll implementations

### **Sub-topik Detail:**

#### **1. Pengenalan Paging 3**
- Apa itu Paging 3
- Efficient list loading
- Architecture components integration
- Memory efficient pagination
- Network + Database caching
- Loading states management

**Mengapa Paging 3:**
✅ Efficient memory usage
✅ Built-in loading states
✅ Automatic retry mechanism
✅ Seamless Compose integration
✅ Room database support
✅ RemoteMediator untuk offline-first
✅ Flow-based reactive streams

#### **2. Setup Paging 3**

**Dependencies:**
```kotlin
dependencies {
    // Paging 3
    implementation("androidx.paging:paging-runtime:3.2.1")
    implementation("androidx.paging:paging-compose:3.2.1")
    
    // Room integration
    implementation("androidx.room:room-paging:2.6.1")
    
    // Testing
    testImplementation("androidx.paging:paging-common:3.2.1")
}
```

#### **3. PagingSource - Basic Pagination**

**Network-Only Pagination:**
```kotlin
class UserPagingSource(
    private val apiService: ApiService,
    private val query: String
) : PagingSource<Int, User>() {
    
    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, User> {
        return try {
            val page = params.key ?: 1
            val pageSize = params.loadSize
            
            val response = apiService.getUsers(
                query = query,
                page = page,
                pageSize = pageSize
            )
            
            LoadResult.Page(
                data = response.users,
                prevKey = if (page == 1) null else page - 1,
                nextKey = if (response.users.isEmpty()) null else page + 1
            )
        } catch (e: Exception) {
            LoadResult.Error(e)
        }
    }
    
    override fun getRefreshKey(state: PagingState<Int, User>): Int? {
        // Return the page number closest to anchor position
        return state.anchorPosition?.let { anchorPosition ->
            state.closestPageToPosition(anchorPosition)?.prevKey?.plus(1)
                ?: state.closestPageToPosition(anchorPosition)?.nextKey?.minus(1)
        }
    }
}
```

**Repository with Paging:**
```kotlin
class UserRepository(private val apiService: ApiService) {
    
    fun getUsersPaged(query: String): Flow<PagingData<User>> {
        return Pager(
            config = PagingConfig(
                pageSize = 20,
                enablePlaceholders = false,
                prefetchDistance = 5,
                initialLoadSize = 40
            ),
            pagingSourceFactory = { UserPagingSource(apiService, query) }
        ).flow
    }
}
```

**ViewModel:**
```kotlin
class UserViewModel(
    private val repository: UserRepository
) : ViewModel() {
    
    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()
    
    val users: Flow<PagingData<User>> = searchQuery
        .debounce(300)
        .flatMapLatest { query ->
            repository.getUsersPaged(query)
        }
        .cachedIn(viewModelScope)
    
    fun onSearchQueryChanged(query: String) {
        _searchQuery.value = query
    }
}
```

**Compose UI:**
```kotlin
@Composable
fun UserListScreen(viewModel: UserViewModel = viewModel()) {
    val users = viewModel.users.collectAsLazyPagingItems()
    
    Column {
        SearchBar(
            query = viewModel.searchQuery.collectAsState().value,
            onQueryChange = { viewModel.onSearchQueryChanged(it) }
        )
        
        LazyColumn {
            items(users.itemCount) { index ->
                users[index]?.let { user ->
                    UserItem(user = user)
                }
            }
            
            // Loading state
            when (users.loadState.refresh) {
                is LoadState.Loading -> {
                    item {
                        Box(
                            modifier = Modifier.fillMaxSize(),
                            contentAlignment = Alignment.Center
                        ) {
                            CircularProgressIndicator()
                        }
                    }
                }
                is LoadState.Error -> {
                    val error = (users.loadState.refresh as LoadState.Error).error
                    item {
                        ErrorItem(
                            message = error.message ?: "Unknown error",
                            onRetry = { users.retry() }
                        )
                    }
                }
                else -> {}
            }
            
            // Append loading state
            when (users.loadState.append) {
                is LoadState.Loading -> {
                    item {
                        Box(
                            modifier = Modifier.fillMaxWidth(),
                            contentAlignment = Alignment.Center
                        ) {
                            CircularProgressIndicator()
                        }
                    }
                }
                is LoadState.Error -> {
                    val error = (users.loadState.append as LoadState.Error).error
                    item {
                        RetryItem(onRetry = { users.retry() })
                    }
                }
                else -> {}
            }
        }
    }
}
```

#### **4. Room Database Integration**

**Entity:**
```kotlin
@Entity(tableName = "users")
data class User(
    @PrimaryKey val id: String,
    val name: String,
    val email: String,
    val avatarUrl: String,
    val createdAt: Long = System.currentTimeMillis()
)

@Entity(tableName = "remote_keys")
data class RemoteKeys(
    @PrimaryKey val userId: String,
    val prevKey: Int?,
    val nextKey: Int?
)
```

**DAO:**
```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users ORDER BY createdAt DESC")
    fun getAllUsersPaged(): PagingSource<Int, User>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(users: List<User>)
    
    @Query("DELETE FROM users")
    suspend fun clearAll()
}

@Dao
interface RemoteKeysDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(remoteKeys: List<RemoteKeys>)
    
    @Query("SELECT * FROM remote_keys WHERE userId = :userId")
    suspend fun remoteKeysUserId(userId: String): RemoteKeys?
    
    @Query("DELETE FROM remote_keys")
    suspend fun clearRemoteKeys()
}
```

#### **5. RemoteMediator - Offline First**

**RemoteMediator Implementation:**
```kotlin
@OptIn(ExperimentalPagingApi::class)
class UserRemoteMediator(
    private val database: AppDatabase,
    private val apiService: ApiService,
    private val query: String
) : RemoteMediator<Int, User>() {
    
    private val userDao = database.userDao()
    private val remoteKeysDao = database.remoteKeysDao()
    
    override suspend fun initialize(): InitializeAction {
        // Check if we need to refresh
        val cacheTimeout = TimeUnit.HOURS.convert(1, TimeUnit.MILLISECONDS)
        
        return if (System.currentTimeMillis() - getLastRefreshTime() >= cacheTimeout) {
            InitializeAction.LAUNCH_INITIAL_REFRESH
        } else {
            InitializeAction.SKIP_INITIAL_REFRESH
        }
    }
    
    override suspend fun load(
        loadType: LoadType,
        state: PagingState<Int, User>
    ): MediatorResult {
        return try {
            val page = when (loadType) {
                LoadType.REFRESH -> {
                    val remoteKeys = getRemoteKeyClosestToCurrentPosition(state)
                    remoteKeys?.nextKey?.minus(1) ?: 1
                }
                LoadType.PREPEND -> {
                    val remoteKeys = getRemoteKeyForFirstItem(state)
                    val prevKey = remoteKeys?.prevKey
                        ?: return MediatorResult.Success(endOfPaginationReached = remoteKeys != null)
                    prevKey
                }
                LoadType.APPEND -> {
                    val remoteKeys = getRemoteKeyForLastItem(state)
                    val nextKey = remoteKeys?.nextKey
                        ?: return MediatorResult.Success(endOfPaginationReached = remoteKeys != null)
                    nextKey
                }
            }
            
            val response = apiService.getUsers(
                query = query,
                page = page,
                pageSize = state.config.pageSize
            )
            
            val users = response.users
            val endOfPaginationReached = users.isEmpty()
            
            database.withTransaction {
                // Clear all tables on refresh
                if (loadType == LoadType.REFRESH) {
                    remoteKeysDao.clearRemoteKeys()
                    userDao.clearAll()
                }
                
                // Create remote keys
                val prevKey = if (page == 1) null else page - 1
                val nextKey = if (endOfPaginationReached) null else page + 1
                val keys = users.map {
                    RemoteKeys(userId = it.id, prevKey = prevKey, nextKey = nextKey)
                }
                
                remoteKeysDao.insertAll(keys)
                userDao.insertAll(users)
            }
            
            MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)
        } catch (e: Exception) {
            MediatorResult.Error(e)
        }
    }
    
    private suspend fun getRemoteKeyForLastItem(state: PagingState<Int, User>): RemoteKeys? {
        return state.pages.lastOrNull { it.data.isNotEmpty() }?.data?.lastOrNull()
            ?.let { user ->
                remoteKeysDao.remoteKeysUserId(user.id)
            }
    }
    
    private suspend fun getRemoteKeyForFirstItem(state: PagingState<Int, User>): RemoteKeys? {
        return state.pages.firstOrNull { it.data.isNotEmpty() }?.data?.firstOrNull()
            ?.let { user ->
                remoteKeysDao.remoteKeysUserId(user.id)
            }
    }
    
    private suspend fun getRemoteKeyClosestToCurrentPosition(
        state: PagingState<Int, User>
    ): RemoteKeys? {
        return state.anchorPosition?.let { position ->
            state.closestItemToPosition(position)?.id?.let { userId ->
                remoteKeysDao.remoteKeysUserId(userId)
            }
        }
    }
    
    private suspend fun getLastRefreshTime(): Long {
        // Implement your cache timestamp logic
        return 0L
    }
}
```

**Repository with RemoteMediator:**
```kotlin
class UserRepository(
    private val database: AppDatabase,
    private val apiService: ApiService
) {
    @OptIn(ExperimentalPagingApi::class)
    fun getUsersPaged(query: String): Flow<PagingData<User>> {
        return Pager(
            config = PagingConfig(
                pageSize = 20,
                enablePlaceholders = false,
                prefetchDistance = 5
            ),
            remoteMediator = UserRemoteMediator(database, apiService, query),
            pagingSourceFactory = { database.userDao().getAllUsersPaged() }
        ).flow
    }
}
```

#### **6. Load States**

**Handling All Load States:**
```kotlin
@Composable
fun UserListWithStates(viewModel: UserViewModel = viewModel()) {
    val users = viewModel.users.collectAsLazyPagingItems()
    
    LazyColumn {
        // Refresh state (initial load or pull-to-refresh)
        when (users.loadState.refresh) {
            is LoadState.Loading -> {
                item {
                    LoadingItem()
                }
            }
            is LoadState.Error -> {
                val error = (users.loadState.refresh as LoadState.Error).error
                item {
                    ErrorItem(
                        message = error.localizedMessage ?: "Error loading data",
                        onRetry = { users.retry() }
                    )
                }
            }
            is LoadState.NotLoading -> {
                // Show items
                items(users.itemCount) { index ->
                    users[index]?.let { user ->
                        UserItem(user = user)
                    }
                }
                
                // Empty state
                if (users.itemCount == 0) {
                    item {
                        EmptyStateItem()
                    }
                }
            }
        }
        
        // Prepend state (loading previous page)
        when (users.loadState.prepend) {
            is LoadState.Loading -> {
                item {
                    LoadingItem()
                }
            }
            is LoadState.Error -> {
                val error = (users.loadState.prepend as LoadState.Error).error
                item {
                    RetryItem(onRetry = { users.retry() })
                }
            }
            else -> {}
        }
        
        // Append state (loading next page)
        when (users.loadState.append) {
            is LoadState.Loading -> {
                item {
                    LoadingItem()
                }
            }
            is LoadState.Error -> {
                val error = (users.loadState.append as LoadState.Error).error
                item {
                    RetryItem(
                        message = "Failed to load more",
                        onRetry = { users.retry() }
                    )
                }
            }
            else -> {}
        }
    }
}

@Composable
fun LoadingItem() {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        contentAlignment = Alignment.Center
    ) {
        CircularProgressIndicator()
    }
}

@Composable
fun ErrorItem(message: String, onRetry: () -> Unit) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = message, color = Color.Red)
        Spacer(modifier = Modifier.height(8.dp))
        Button(onClick = onRetry) {
            Text("Retry")
        }
    }
}

@Composable
fun EmptyStateItem() {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        contentAlignment = Alignment.Center
    ) {
        Text("No items found")
    }
}
```

#### **7. Transformations**

**Map Transformation:**
```kotlin
val usersUi: Flow<PagingData<UserUi>> = repository.getUsersPaged()
    .map { pagingData ->
        pagingData.map { user ->
            UserUi(
                id = user.id,
                displayName = "${user.firstName} ${user.lastName}",
                avatarUrl = user.avatarUrl ?: DEFAULT_AVATAR
            )
        }
    }
```

**Filter Transformation:**
```kotlin
val activeUsers: Flow<PagingData<User>> = repository.getUsersPaged()
    .map { pagingData ->
        pagingData.filter { user ->
            user.isActive
        }
    }
```

**Insert Separators:**
```kotlin
val usersWithHeaders: Flow<PagingData<UiModel>> = repository.getUsersPaged()
    .map { pagingData ->
        pagingData.map { UiModel.UserItem(it) }
    }
    .map { pagingData ->
        pagingData.insertSeparators { before, after ->
            if (before == null) {
                return@insertSeparators UiModel.HeaderItem("Recent Users")
            }
            
            val beforeDate = (before as UiModel.UserItem).user.createdAt.toDate()
            val afterDate = (after as? UiModel.UserItem)?.user?.createdAt?.toDate()
            
            if (afterDate != null && beforeDate != afterDate) {
                UiModel.SeparatorItem(afterDate)
            } else {
                null
            }
        }
    }

sealed class UiModel {
    data class UserItem(val user: User) : UiModel()
    data class HeaderItem(val title: String) : UiModel()
    data class SeparatorItem(val date: String) : UiModel()
}
```

#### **8. Pull to Refresh**

**With Accompanist:**
```kotlin
@OptIn(ExperimentalMaterialApi::class)
@Composable
fun UserListWithRefresh(viewModel: UserViewModel = viewModel()) {
    val users = viewModel.users.collectAsLazyPagingItems()
    val refreshing = users.loadState.refresh is LoadState.Loading
    
    val pullRefreshState = rememberPullRefreshState(
        refreshing = refreshing,
        onRefresh = { users.refresh() }
    )
    
    Box(modifier = Modifier.pullRefresh(pullRefreshState)) {
        LazyColumn {
            items(users.itemCount) { index ->
                users[index]?.let { user ->
                    UserItem(user = user)
                }
            }
        }
        
        PullRefreshIndicator(
            refreshing = refreshing,
            state = pullRefreshState,
            modifier = Modifier.align(Alignment.TopCenter)
        )
    }
}
```

#### **9. Testing Paging**

**Test PagingSource:**
```kotlin
@Test
fun `test paging source load success`() = runTest {
    val mockApi = mockk<ApiService>()
    coEvery { mockApi.getUsers(any(), any(), any()) } returns UsersResponse(
        users = listOf(
            User("1", "John Doe", "john@example.com", "avatar1.jpg"),
            User("2", "Jane Doe", "jane@example.com", "avatar2.jpg")
        )
    )
    
    val pagingSource = UserPagingSource(mockApi, "test")
    
    val result = pagingSource.load(
        PagingSource.LoadParams.Refresh(
            key = null,
            loadSize = 2,
            placeholdersEnabled = false
        )
    )
    
    assertTrue(result is PagingSource.LoadResult.Page)
    val page = result as PagingSource.LoadResult.Page
    assertEquals(2, page.data.size)
    assertEquals(null, page.prevKey)
    assertEquals(2, page.nextKey)
}

@Test
fun `test paging source load error`() = runTest {
    val mockApi = mockk<ApiService>()
    coEvery { mockApi.getUsers(any(), any(), any()) } throws IOException("Network error")
    
    val pagingSource = UserPagingSource(mockApi, "test")
    
    val result = pagingSource.load(
        PagingSource.LoadParams.Refresh(
            key = null,
            loadSize = 2,
            placeholdersEnabled = false
        )
    )
    
    assertTrue(result is PagingSource.LoadResult.Error)
}
```

#### **10. Best Practices**
✅ Use RemoteMediator untuk offline-first
✅ Handle all load states properly
✅ Implement proper error handling
✅ Use cachedIn(viewModelScope) untuk share paging data
✅ Test paging logic
✅ Implement pull-to-refresh
✅ Use appropriate page sizes
✅ Handle empty states
✅ Implement retry mechanism
✅ Cache data dalam Room untuk offline support

#### **11. Advanced Patterns**

**Multi-Type Items:**
```kotlin
sealed class FeedItem {
    data class Post(val post: PostModel) : FeedItem()
    data class Ad(val ad: AdModel) : FeedItem()
    data class Recommendation(val items: List<ItemModel>) : FeedItem()
}

@Composable
fun FeedList(pagingItems: LazyPagingItems<FeedItem>) {
    LazyColumn {
        items(
            count = pagingItems.itemCount,
            key = { index ->
                when (val item = pagingItems[index]) {
                    is FeedItem.Post -> "post_${item.post.id}"
                    is FeedItem.Ad -> "ad_${item.ad.id}"
                    is FeedItem.Recommendation -> "rec_${item.items.first().id}"
                    null -> "loading_$index"
                }
            }
        ) { index ->
            when (val item = pagingItems[index]) {
                is FeedItem.Post -> PostItem(item.post)
                is FeedItem.Ad -> AdItem(item.ad)
                is FeedItem.Recommendation -> RecommendationItem(item.items)
                null -> LoadingPlaceholder()
            }
        }
    }
}
```

#### **12. Hands-on Exercises**
- Implement basic pagination dengan network-only
- Create offline-first pagination dengan RemoteMediator
- Handle all load states dengan proper UI
- Implement pull-to-refresh
- Add search functionality dengan debounce
- Create multi-type list dengan separators
- Test paging source dan remote mediator
- Implement infinite scroll dengan proper error handling

---
