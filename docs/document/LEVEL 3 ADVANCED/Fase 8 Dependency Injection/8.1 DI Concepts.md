## **8.1 DI Concepts** (2 hari) ⭐⭐⭐

### **Teknologi Modern:**
- Dependency Injection principles
- Constructor injection
- Inversion of Control (IoC)
- SOLID principles

### **Teknologi yang Ditinggalkan:**
- Manual instantiation
- Singleton pattern everywhere
- Static dependencies
- Service locator pattern

### **Sub-topik Detail:**

#### **1. Apa itu Dependency Injection?**

**Masalah Tanpa DI:**
```kotlin
// ❌ BAD: Tight coupling
class UserRepository {
    private val api = RetrofitClient.create() // Hard-coded dependency
    private val database = AppDatabase.getInstance() // Singleton
    
    suspend fun getUser(id: String): User {
        return api.getUser(id)
    }
}

class UserViewModel : ViewModel() {
    private val repository = UserRepository() // Creates its own dependencies
    
    fun loadUser(id: String) {
        viewModelScope.launch {
            val user = repository.getUser(id)
        }
    }
}

// Problems:
// - Hard to test (can't mock dependencies)
// - Tight coupling
// - Hard to change implementation
// - No control over object creation
```

**Dengan DI:**
```kotlin
// ✅ GOOD: Loose coupling
class UserRepository(
    private val api: ApiService, // Injected
    private val database: UserDao // Injected
) {
    suspend fun getUser(id: String): User {
        return api.getUser(id)
    }
}

class UserViewModel(
    private val repository: UserRepository // Injected
) : ViewModel() {
    fun loadUser(id: String) {
        viewModelScope.launch {
            val user = repository.getUser(id)
        }
    }
}

// Benefits:
// - Easy to test (can inject mocks)
// - Loose coupling
// - Easy to change implementation
// - Centralized object creation
```

#### **2. Types of Dependency Injection**

**Constructor Injection (Recommended):**
```kotlin
class UserRepository(
    private val apiService: ApiService,
    private val userDao: UserDao,
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO
) {
    suspend fun getUser(id: String): User = withContext(dispatcher) {
        try {
            val user = apiService.getUser(id)
            userDao.insert(user)
            user
        } catch (e: Exception) {
            userDao.getUser(id) ?: throw e
        }
    }
}

// All dependencies are visible and required
// Immutable after construction
// Easy to test
```

**Field Injection (Not Recommended):**
```kotlin
class UserRepository {
    @Inject lateinit var apiService: ApiService
    @Inject lateinit var userDao: UserDao
    
    // Problems:
    // - Mutable
    // - Can be null
    // - Dependencies not visible
    // - Hard to test without DI framework
}
```

**Method Injection (Rare):**
```kotlin
class UserRepository(private val apiService: ApiService) {
    private lateinit var userDao: UserDao
    
    fun setUserDao(dao: UserDao) {
        this.userDao = dao
    }
}
```

#### **3. Dependency Inversion Principle**

**Interface-based Dependencies:**
```kotlin
// Define interface
interface UserDataSource {
    suspend fun getUser(id: String): User
    suspend fun saveUser(user: User)
}

// Remote implementation
class RemoteUserDataSource(
    private val apiService: ApiService
) : UserDataSource {
    override suspend fun getUser(id: String): User {
        return apiService.getUser(id)
    }
    
    override suspend fun saveUser(user: User) {
        apiService.updateUser(user)
    }
}

// Local implementation
class LocalUserDataSource(
    private val userDao: UserDao
) : UserDataSource {
    override suspend fun getUser(id: String): User {
        return userDao.getUser(id) ?: throw NotFoundException()
    }
    
    override suspend fun saveUser(user: User) {
        userDao.insert(user)
    }
}

// Repository depends on interface, not implementation
class UserRepository(
    private val remoteDataSource: UserDataSource,
    private val localDataSource: UserDataSource
) {
    suspend fun getUser(id: String): User {
        return try {
            remoteDataSource.getUser(id).also {
                localDataSource.saveUser(it)
            }
        } catch (e: Exception) {
            localDataSource.getUser(id)
        }
    }
}
```

#### **4. Inversion of Control (IoC)**

**Without IoC:**
```kotlin
// Object creates its own dependencies
class MainActivity : AppCompatActivity() {
    private val viewModel = UserViewModel(
        UserRepository(
            RetrofitClient.create(),
            AppDatabase.getInstance(this).userDao()
        )
    )
}
```

**With IoC:**
```kotlin
// Container manages object creation
class MainActivity : AppCompatActivity() {
    private val viewModel: UserViewModel by viewModels()
    // Dependencies provided by DI container
}
```

#### **5. Manual Dependency Injection**

**Simple Container:**
```kotlin
object AppContainer {
    private val retrofit = Retrofit.Builder()
        .baseUrl("https://api.example.com/")
        .addConverterFactory(GsonConverterFactory.create())
        .build()
    
    val apiService: ApiService = retrofit.create(ApiService::class.java)
    
    fun provideUserRepository(context: Context): UserRepository {
        val database = Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "app_db"
        ).build()
        
        return UserRepository(apiService, database.userDao())
    }
}

// Usage
class MainActivity : AppCompatActivity() {
    private val repository by lazy {
        AppContainer.provideUserRepository(this)
    }
}
```

**Factory Pattern:**
```kotlin
interface ViewModelFactory<T : ViewModel> {
    fun create(): T
}

class UserViewModelFactory(
    private val repository: UserRepository
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(UserViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return UserViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

// Usage
val viewModel: UserViewModel by viewModels {
    UserViewModelFactory(repository)
}
```

#### **6. DI Benefits**

**Testability:**
```kotlin
// Easy to test with mocks
@Test
fun `test load user success`() = runTest {
    // Given
    val mockApi = mockk<ApiService>()
    val mockDao = mockk<UserDao>()
    coEvery { mockApi.getUser("1") } returns User("1", "John")
    
    val repository = UserRepository(mockApi, mockDao)
    
    // When
    val user = repository.getUser("1")
    
    // Then
    assertEquals("John", user.name)
}
```

**Flexibility:**
```kotlin
// Easy to swap implementations
class TestAppContainer : AppContainer {
    override val apiService = FakeApiService()
    override fun provideUserRepository(context: Context) = 
        UserRepository(apiService, FakeUserDao())
}
```

#### **7. SOLID Principles dalam DI**

**Single Responsibility:**
```kotlin
// Each class has one responsibility
class NetworkClient // Only handles network
class DatabaseClient // Only handles database
class UserRepository // Only handles user data logic
```

**Open/Closed:**
```kotlin
// Open for extension, closed for modification
interface DataSource {
    suspend fun getData(): Data
}

class RemoteDataSource : DataSource
class CachedDataSource : DataSource
class MockDataSource : DataSource
```

**Liskov Substitution:**
```kotlin
// Subtypes can replace base types
fun processData(dataSource: DataSource) {
    // Works with any DataSource implementation
}
```

**Interface Segregation:**
```kotlin
// Split large interfaces
interface Readable {
    fun read(): Data
}

interface Writable {
    fun write(data: Data)
}

// Client only depends on what it needs
class ReadOnlyRepository(private val readable: Readable)
```

**Dependency Inversion:**
```kotlin
// Depend on abstractions, not concretions
class Repository(
    private val dataSource: DataSource // Interface
) {
    // Not:
    // private val dataSource: RemoteDataSource // Concrete
}
```

#### **8. Best Practices**
✅ Prefer constructor injection
✅ Use interfaces untuk abstraction
✅ Keep dependencies minimal
✅ Avoid circular dependencies
✅ Make dependencies explicit
✅ Use factory pattern when needed
✅ Follow SOLID principles
✅ Keep classes focused (Single Responsibility)

---
