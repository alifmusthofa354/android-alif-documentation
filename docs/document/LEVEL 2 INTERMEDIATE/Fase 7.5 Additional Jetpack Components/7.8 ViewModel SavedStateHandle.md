## **7.8 ViewModel SavedStateHandle** (2 hari) ⭐⭐

### **Teknologi Modern:**
- SavedStateHandle
- State restoration
- Process death handling
- Navigation arguments

### **Teknologi yang Ditinggalkan:**
- Manual state saving
- onSaveInstanceState boilerplate
- Static variables untuk state

### **Sub-topik Detail:**

#### **1. Pengenalan SavedStateHandle**
- Apa itu SavedStateHandle
- Process death scenarios
- Automatic state restoration
- Integration dengan ViewModel
- Navigation arguments access
- Survives configuration changes dan process death

**Mengapa SavedStateHandle:**
✅ Survives process death
✅ No boilerplate code
✅ Type-safe state access
✅ Automatic restoration
✅ Works with Navigation component
✅ Testable
✅ Supports StateFlow integration

#### **2. Basic Usage**

**Simple State Saving:**
```kotlin
class CounterViewModel(
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    // Simple get/set
    var counter: Int
        get() = savedStateHandle.get<Int>("counter") ?: 0
        set(value) {
            savedStateHandle.set("counter", value)
        }
    
    fun increment() {
        counter++
    }
    
    fun decrement() {
        counter--
    }
}
```

**With StateFlow:**
```kotlin
class UserViewModel(
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    // Automatic state restoration
    val userName: StateFlow<String> = savedStateHandle.getStateFlow(
        key = "user_name",
        initialValue = ""
    )
    
    val userAge: StateFlow<Int> = savedStateHandle.getStateFlow(
        key = "user_age",
        initialValue = 0
    )
    
    fun updateUserName(name: String) {
        savedStateHandle["user_name"] = name
    }
    
    fun updateUserAge(age: Int) {
        savedStateHandle["user_age"] = age
    }
}
```

**With LiveData:**
```kotlin
class ProductViewModel(
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    val productId: LiveData<String> = savedStateHandle.getLiveData(
        key = "product_id",
        initialValue = ""
    )
    
    val quantity: LiveData<Int> = savedStateHandle.getLiveData(
        key = "quantity",
        initialValue = 1
    )
    
    fun setProductId(id: String) {
        savedStateHandle["product_id"] = id
    }
    
    fun updateQuantity(qty: Int) {
        savedStateHandle["quantity"] = qty
    }
}
```

#### **3. Navigation Arguments**

**Receiving Navigation Arguments:**
```kotlin
// Navigation route: "user/{userId}"
class UserDetailViewModel(
    private val savedStateHandle: SavedStateHandle,
    private val repository: UserRepository
) : ViewModel() {
    
    // Get userId from navigation arguments
    private val userId: String = checkNotNull(savedStateHandle["userId"]) {
        "userId is required"
    }
    
    private val _uiState = MutableStateFlow<UiState<User>>(UiState.Loading)
    val uiState: StateFlow<UiState<User>> = _uiState.asStateFlow()
    
    init {
        loadUser()
    }
    
    private fun loadUser() {
        viewModelScope.launch {
            try {
                val user = repository.getUser(userId)
                _uiState.value = UiState.Success(user)
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message ?: "Unknown error")
            }
        }
    }
}
```

**Optional Arguments:**
```kotlin
class SearchViewModel(
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    // Optional argument with default
    private val initialQuery: String = savedStateHandle["query"] ?: ""
    
    private val _searchQuery = MutableStateFlow(initialQuery)
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()
    
    init {
        // Use initial query if provided
        if (initialQuery.isNotEmpty()) {
            performSearch(initialQuery)
        }
    }
    
    fun onSearchQueryChanged(query: String) {
        _searchQuery.value = query
        savedStateHandle["query"] = query
        performSearch(query)
    }
}
```

#### **4. Complex State Management**

**Form State:**
```kotlin
data class UserFormState(
    val firstName: String = "",
    val lastName: String = "",
    val email: String = "",
    val phone: String = "",
    val address: String = ""
)

class UserFormViewModel(
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    private val _formState = MutableStateFlow(
        savedStateHandle.get<UserFormState>("form_state") ?: UserFormState()
    )
    val formState: StateFlow<UserFormState> = _formState.asStateFlow()
    
    fun updateFirstName(value: String) {
        updateFormState { it.copy(firstName = value) }
    }
    
    fun updateLastName(value: String) {
        updateFormState { it.copy(lastName = value) }
    }
    
    fun updateEmail(value: String) {
        updateFormState { it.copy(email = value) }
    }
    
    private fun updateFormState(update: (UserFormState) -> UserFormState) {
        _formState.update { currentState ->
            val newState = update(currentState)
            savedStateHandle["form_state"] = newState
            newState
        }
    }
    
    fun submitForm() {
        viewModelScope.launch {
            try {
                val state = formState.value
                // Submit form
                repository.createUser(state)
                // Clear saved state after successful submission
                savedStateHandle.remove<UserFormState>("form_state")
            } catch (e: Exception) {
                // Handle error
            }
        }
    }
}
```

**List State:**
```kotlin
class ShoppingCartViewModel(
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    private val _cartItems = MutableStateFlow(
        savedStateHandle.get<List<CartItem>>("cart_items") ?: emptyList()
    )
    val cartItems: StateFlow<List<CartItem>> = _cartItems.asStateFlow()
    
    val totalPrice: StateFlow<Double> = cartItems.map { items ->
        items.sumOf { it.price * it.quantity }
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = 0.0
    )
    
    fun addItem(item: CartItem) {
        updateCartItems { currentItems ->
            val existingItem = currentItems.find { it.id == item.id }
            if (existingItem != null) {
                currentItems.map {
                    if (it.id == item.id) {
                        it.copy(quantity = it.quantity + 1)
                    } else {
                        it
                    }
                }
            } else {
                currentItems + item
            }
        }
    }
    
    fun removeItem(itemId: String) {
        updateCartItems { currentItems ->
            currentItems.filterNot { it.id == itemId }
        }
    }
    
    fun updateQuantity(itemId: String, quantity: Int) {
        updateCartItems { currentItems ->
            currentItems.map {
                if (it.id == itemId) {
                    it.copy(quantity = quantity)
                } else {
                    it
                }
            }
        }
    }
    
    private fun updateCartItems(update: (List<CartItem>) -> List<CartItem>) {
        _cartItems.update { currentItems ->
            val newItems = update(currentItems)
            savedStateHandle["cart_items"] = newItems
            newItems
        }
    }
    
    fun clearCart() {
        _cartItems.value = emptyList()
        savedStateHandle.remove<List<CartItem>>("cart_items")
    }
}
```

#### **5. Custom Type Handling**

**Parcelable Data Class:**
```kotlin
@Parcelize
data class UserFilter(
    val minAge: Int = 0,
    val maxAge: Int = 100,
    val country: String = "",
    val isActive: Boolean = true
) : Parcelable

class UserListViewModel(
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    private val _filter = MutableStateFlow(
        savedStateHandle.get<UserFilter>("filter") ?: UserFilter()
    )
    val filter: StateFlow<UserFilter> = _filter.asStateFlow()
    
    fun updateFilter(newFilter: UserFilter) {
        _filter.value = newFilter
        savedStateHandle["filter"] = newFilter
        applyFilter(newFilter)
    }
}
```

**Serializable with JSON:**
```kotlin
class PreferencesViewModel(
    private val savedStateHandle: SavedStateHandle,
    private val gson: Gson
) : ViewModel() {
    
    private val _preferences = MutableStateFlow(
        loadPreferences()
    )
    val preferences: StateFlow<UserPreferences> = _preferences.asStateFlow()
    
    private fun loadPreferences(): UserPreferences {
        val json = savedStateHandle.get<String>("preferences_json")
        return if (json != null) {
            gson.fromJson(json, UserPreferences::class.java)
        } else {
            UserPreferences.default()
        }
    }
    
    fun updatePreferences(prefs: UserPreferences) {
        _preferences.value = prefs
        val json = gson.toJson(prefs)
        savedStateHandle["preferences_json"] = json
    }
}
```

#### **6. Testing SavedStateHandle**

**ViewModel Test:**
```kotlin
class CounterViewModelTest {
    
    private lateinit var savedStateHandle: SavedStateHandle
    private lateinit var viewModel: CounterViewModel
    
    @Before
    fun setup() {
        savedStateHandle = SavedStateHandle()
        viewModel = CounterViewModel(savedStateHandle)
    }
    
    @Test
    fun `increment increases counter`() {
        // Given
        assertEquals(0, viewModel.counter)
        
        // When
        viewModel.increment()
        
        // Then
        assertEquals(1, viewModel.counter)
        assertEquals(1, savedStateHandle.get<Int>("counter"))
    }
    
    @Test
    fun `state is restored from SavedStateHandle`() {
        // Given - Simulate process death
        savedStateHandle.set("counter", 5)
        
        // When - Create new ViewModel with saved state
        val restoredViewModel = CounterViewModel(savedStateHandle)
        
        // Then
        assertEquals(5, restoredViewModel.counter)
    }
}
```

**Test with Initial State:**
```kotlin
@Test
fun `test form restoration`() = runTest {
    // Given - Previous form state
    val previousState = UserFormState(
        firstName = "John",
        lastName = "Doe",
        email = "john@example.com"
    )
    savedStateHandle.set("form_state", previousState)
    
    // When - Create ViewModel
    val viewModel = UserFormViewModel(savedStateHandle)
    
    // Then - State is restored
    assertEquals(previousState, viewModel.formState.value)
}
```

#### **7. Best Practices**

**DO:**
```kotlin
// ✅ Use SavedStateHandle for UI state
class MyViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {
    val searchQuery: StateFlow<String> = savedStateHandle.getStateFlow("query", "")
}

// ✅ Save small, UI-related data
data class UiState(
    val selectedTab: Int = 0,
    val scrollPosition: Int = 0,
    val isExpanded: Boolean = false
)

// ✅ Use Parcelable for custom types
@Parcelize
data class Filter(val category: String, val minPrice: Double) : Parcelable
```

**DON'T:**
```kotlin
// ❌ Don't save large objects
class BadViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {
    // Don't save bitmaps, large lists, etc.
    savedStateHandle["huge_image"] = largeBitmap  // BAD!
}

// ❌ Don't save repository or use case instances
class BadViewModel(
    savedStateHandle: SavedStateHandle,
    repository: Repository  // Don't save this
) : ViewModel() {
    init {
        savedStateHandle["repository"] = repository  // BAD!
    }
}

// ❌ Don't save complex business logic state
// Save only UI-related state in SavedStateHandle
```

#### **8. Integration Patterns**

**With Hilt:**
```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val savedStateHandle: SavedStateHandle,
    private val repository: UserRepository
) : ViewModel() {
    
    private val userId: String = checkNotNull(savedStateHandle["userId"])
    
    val user: StateFlow<User?> = flow {
        emit(repository.getUser(userId))
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = null
    )
}
```

**With Navigation Compose:**
```kotlin
// Navigation graph
@Composable
fun AppNavGraph(navController: NavHostController) {
    NavHost(navController, startDestination = "home") {
        composable("home") {
            HomeScreen(
                onNavigateToDetail = { userId ->
                    navController.navigate("user/$userId")
                }
            )
        }
        
        composable(
            route = "user/{userId}",
            arguments = listOf(
                navArgument("userId") { type = NavType.StringType }
            )
        ) {
            // SavedStateHandle automatically receives userId
            UserDetailScreen()
        }
    }
}

@Composable
fun UserDetailScreen(viewModel: UserViewModel = hiltViewModel()) {
    // userId from navigation is available in SavedStateHandle
    val user by viewModel.user.collectAsState()
    
    // UI code
}
```

#### **9. Hands-on Exercises**
- Implement form dengan state restoration
- Create shopping cart dengan SavedStateHandle
- Build search screen dengan query persistence
- Handle navigation arguments
- Test state restoration
- Implement complex filter state
- Create multi-step wizard dengan state saving
- Build draft saving functionality

---
