## **8.2 Hilt Setup** (4 hari) ⭐⭐⭐

### **Teknologi Modern:**
- Hilt (Built on Dagger)
- @HiltAndroidApp
- @AndroidEntryPoint
- Automatic dependency injection

### **Teknologi yang Ditinggalkan:**
- Dagger 2 (kompleks untuk pemula)
- Koin (reflection-based)
- Manual DI containers

### **Sub-topik Detail:**

#### **1. Hilt Setup**

**Dependencies:**
```kotlin
// Project build.gradle
plugins {
    id("com.google.dagger.hilt.android") version "2.48" apply false
}

// App build.gradle
plugins {
    id("kotlin-kapt")
    id("com.google.dagger.hilt.android")
}

dependencies {
    implementation("com.google.dagger:hilt-android:2.48")
    kapt("com.google.dagger:hilt-android-compiler:2.48")
    
    // ViewModel integration
    implementation("androidx.hilt:hilt-navigation-compose:1.1.0")
    
    // WorkManager integration
    implementation("androidx.hilt:hilt-work:1.1.0")
    kapt("androidx.hilt:hilt-compiler:1.1.0")
    
    // Testing
    androidTestImplementation("com.google.dagger:hilt-android-testing:2.48")
    kaptAndroidTest("com.google.dagger:hilt-android-compiler:2.48")
    testImplementation("com.google.dagger:hilt-android-testing:2.48")
    kaptTest("com.google.dagger:hilt-android-compiler:2.48")
}

// Enable Hilt Gradle plugin
kapt {
    correctErrorTypes = true
}
```

**Proguard Rules:**
```proguard
# Hilt
-keep class dagger.** { *; }
-keep class javax.inject.** { *; }
-keep class * extends dagger.hilt.android.internal.managers.ViewComponentManager$FragmentContextWrapper { *; }
```

#### **2. Application Setup**

**Hilt Application:**
```kotlin
@HiltAndroidApp
class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()
        // Hilt initializes automatically
        Timber.plant(Timber.DebugTree())
    }
}
```

**AndroidManifest:**
```xml
<application
    android:name=".MyApp"
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name">
    
    <activity android:name=".MainActivity">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>
</application>
```

#### **3. Android Components**

**Activity:**
```kotlin
@AndroidEntryPoint
class MainActivity : AppCompatActivity() {
    
    @Inject
    lateinit var analytics: AnalyticsHelper
    
    private val viewModel: UserViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        analytics.logScreenView("MainActivity")
    }
}
```

**Fragment:**
```kotlin
@AndroidEntryPoint
class UserFragment : Fragment() {
    
    @Inject
    lateinit var analytics: AnalyticsHelper
    
    private val viewModel: UserViewModel by viewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        viewModel.loadUser("123")
    }
}
```

**ViewModel:**
```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    private val userId = savedStateHandle.get<String>("userId") ?: ""
    
    private val _uiState = MutableStateFlow<UiState<User>>(UiState.Loading)
    val uiState = _uiState.asStateFlow()
    
    fun loadUser(id: String) {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            try {
                val user = repository.getUser(id)
                _uiState.value = UiState.Success(user)
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message ?: "Unknown error")
            }
        }
    }
}
```

**Compose:**
```kotlin
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        setContent {
            MyAppTheme {
                UserScreen()
            }
        }
    }
}

@Composable
fun UserScreen(
    viewModel: UserViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    when (val state = uiState) {
        is UiState.Loading -> LoadingScreen()
        is UiState.Success -> UserContent(state.data)
        is UiState.Error -> ErrorScreen(state.message)
    }
}
```

#### **4. Providing Dependencies**

**Module:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .addInterceptor(HttpLoggingInterceptor().apply {
                level = HttpLoggingInterceptor.Level.BODY
            })
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
```

**Database Module:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "app_database"
        )
            .fallbackToDestructiveMigration()
            .build()
    }
    
    @Provides
    fun provideUserDao(database: AppDatabase): UserDao {
        return database.userDao()
    }
    
    @Provides
    fun provideArticleDao(database: AppDatabase): ArticleDao {
        return database.articleDao()
    }
}
```

#### **5. Binds vs Provides**

**@Binds (Preferred):**
```kotlin
// Use @Binds for interface to implementation binding
@Module
@InstallIn(SingletonComponent::class)
abstract class DataModule {
    
    @Binds
    @Singleton
    abstract fun bindUserRepository(
        impl: UserRepositoryImpl
    ): UserRepository
    
    @Binds
    abstract fun bindAnalytics(
        impl: FirebaseAnalytics
    ): Analytics
}

// Implementation
class UserRepositoryImpl @Inject constructor(
    private val apiService: ApiService,
    private val userDao: UserDao
) : UserRepository {
    override suspend fun getUser(id: String): User {
        return apiService.getUser(id)
    }
}
```

**@Provides:**
```kotlin
// Use @Provides when you need logic or third-party classes
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton
    fun provideGson(): Gson {
        return GsonBuilder()
            .setDateFormat("yyyy-MM-dd'T'HH:mm:ss")
            .create()
    }
    
    @Provides
    fun provideCoroutineDispatcher(): CoroutineDispatcher {
        return Dispatchers.IO
    }
}
```

#### **6. Component Scopes**

**Singleton (App-level):**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton // Lives for entire app lifecycle
    fun provideSharedPreferences(
        @ApplicationContext context: Context
    ): SharedPreferences {
        return context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE)
    }
}
```

**Activity Scoped:**
```kotlin
@Module
@InstallIn(ActivityComponent::class)
object ActivityModule {
    
    @Provides
    @ActivityScoped // Lives for activity lifecycle
    fun provideActivityHelper(): ActivityHelper {
        return ActivityHelper()
    }
}
```

**Fragment Scoped:**
```kotlin
@Module
@InstallIn(FragmentComponent::class)
object FragmentModule {
    
    @Provides
    fun provideFragmentHelper(): FragmentHelper {
        return FragmentHelper()
    }
}
```

**ViewModel Scoped:**
```kotlin
// ViewModels are automatically scoped by Hilt
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository
) : ViewModel()
```

#### **7. Qualifiers**

**Named Qualifier:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DispatcherModule {
    
    @Provides
    @Named("IO")
    fun provideIODispatcher(): CoroutineDispatcher = Dispatchers.IO
    
    @Provides
    @Named("Main")
    fun provideMainDispatcher(): CoroutineDispatcher = Dispatchers.Main
    
    @Provides
    @Named("Default")
    fun provideDefaultDispatcher(): CoroutineDispatcher = Dispatchers.Default
}

// Usage
class UserRepository @Inject constructor(
    @Named("IO") private val ioDispatcher: CoroutineDispatcher,
    @Named("Default") private val defaultDispatcher: CoroutineDispatcher
)
```

**Custom Qualifier:**
```kotlin
@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class IoDispatcher

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class MainDispatcher

@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class DefaultDispatcher

@Module
@InstallIn(SingletonComponent::class)
object DispatcherModule {
    
    @Provides
    @IoDispatcher
    fun provideIODispatcher(): CoroutineDispatcher = Dispatchers.IO
    
    @Provides
    @MainDispatcher
    fun provideMainDispatcher(): CoroutineDispatcher = Dispatchers.Main
    
    @Provides
    @DefaultDispatcher
    fun provideDefaultDispatcher(): CoroutineDispatcher = Dispatchers.Default
}

// Usage
class UserRepository @Inject constructor(
    @IoDispatcher private val ioDispatcher: CoroutineDispatcher
) {
    suspend fun getUser(id: String) = withContext(ioDispatcher) {
        // Network call
    }
}
```

#### **8. Entry Points**

**Custom Entry Point:**
```kotlin
// For classes Hilt doesn't own
@EntryPoint
@InstallIn(SingletonComponent::class)
interface AnalyticsEntryPoint {
    fun analytics(): Analytics
}

// Usage in non-Hilt class
class CustomClass(context: Context) {
    private val analytics = EntryPointAccessors
        .fromApplication(context, AnalyticsEntryPoint::class.java)
        .analytics()
}
```

#### **9. Best Practices**
✅ Use @Binds over @Provides when possible
✅ Keep modules focused (network, database, etc.)
✅ Use appropriate scopes
✅ Prefer constructor injection
✅ Use qualifiers untuk multiple instances
✅ Organize modules by feature
✅ Don't over-use @Singleton
✅ Test with Hilt testing utilities

---
