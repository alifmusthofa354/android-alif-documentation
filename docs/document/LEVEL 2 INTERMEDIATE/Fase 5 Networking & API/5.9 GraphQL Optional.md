

# üé® Panduan Lengkap: GraphQL di Android dengan Apollo Client

## üöÄ Pengantar: Revolusi Query Data di Aplikasi Modern

Bayangkan kamu adalah seorang kepala perpustakaan digital üìö:
- **GraphQL** seperti sistem permintaan buku yang canggih
- **Apollo Client** seperti asisten pribadi yang menangani semua permintaan
- **Queries** seperti formulir permintaan buku yang detail
- **Mutations** seperti formulir untuk menambah atau mengubah buku

Dengan menguasai GraphQL, kamu bisa membangun aplikasi yang lebih efisien, responsif, dan mudah di-maintain!

## üìö Daftar Isi Pembelajaran
1. [üåü GraphQL vs REST](#1Ô∏è‚É£-graphql-vs-rest-üåü)
2. [üìñ GraphQL Basics](#2Ô∏è‚É£-graphql-basics-üìñ)
3. [‚öôÔ∏è Setup Apollo Client](#3Ô∏è‚É£-setup-apollo-client-‚öôÔ∏è)
4. [üìù Writing GraphQL Queries](#4Ô∏è‚É£-writing-graphql-queries-üìù)
5. [üîÑ GraphQL Mutations](#5Ô∏è‚É£-graphql-mutations-üîÑ)
6. [üß© Fragments for Reusability](#6Ô∏è‚É£-fragments-for-reusability-üß©)
7. [üî¢ Query Variables & Arguments](#7Ô∏è‚É£-query-variables--arguments-üî¢)
8. [‚ö†Ô∏è Error Handling](#8Ô∏è‚É£-error-handling-‚ö†Ô∏è)
9. [üíæ Caching with Apollo](#9Ô∏è‚É£-caching-with-apollo-üíæ)
10. [üëÄ Watching Queries (Reactive)](#1Ô∏è‚É£0Ô∏è‚É£-watching-queries-reactive-üëÄ)
11. [üì° GraphQL Subscriptions (Real-Time)](#1Ô∏è‚É£1Ô∏è‚É£-graphql-subscriptions-real-time-üì°)
12. [üìÑ Pagination](#1Ô∏è‚É£2Ô∏è‚É£-pagination-üìÑ)
13. [üé≠ Optimistic Updates](#1Ô∏è‚É£3Ô∏è‚É£-optimistic-updates-üé≠)
14. [‚úÖ Best Practices](#1Ô∏è‚É£4Ô∏è‚É£-best-practices-‚úÖ)
15. [üî® Hands-on Project](#1Ô∏è‚É£5Ô∏è‚É£-hands-on-project-üî®)

---

## 1Ô∏è‚É£ GraphQL vs REST üåü

### Konsep Dasar
GraphQL vs REST seperti supermarket vs pasar tradisional üõí - di supermarket kamu bisa mendapatkan semua yang kamu butuhkan dalam satu kunjungan!

### REST Challenges:
- **Over-fetching**: Mendapatkan terlalu banyak data yang tidak dibutuhkan
- **Under-fetching**: Membutuhkan multiple request untuk mendapatkan data lengkap
- **Multiple endpoints**: Memerlukan banyak URL berbeda untuk berbagai sumber daya
- **Versioning issues**: Kesulitan dalam mengelola versi API

### GraphQL Advantages:
‚úÖ **Single endpoint**: Hanya satu endpoint untuk semua permintaan
‚úÖ **Request exactly what you need**: Mendapatkan hanya data yang diperlukan
‚úÖ **No over/under-fetching**: Menghindari permintaan berlebih atau kurang
‚úÖ **Strong typing**: Sistem tipe yang kuat untuk validasi
‚úÖ **Self-documenting**: Schema berfungsi sebagai dokumentasi
‚úÖ **Real-time with subscriptions**: Mendukung update data real-time

### Example Comparison:
**REST:**
```
GET /users/123
GET /users/123/posts
GET /users/123/followers
```

**GraphQL:**
```
POST /graphql
{
  user(id: "123") {
    name
    posts { title }
    followers { name }
  }
}
```

### Implementasi REST:
**network/api/UserApiService.kt**
```kotlin
package com.example.restapp.network.api

import retrofit2.http.*
import com.example.restapp.model.User
import com.example.restapp.model.Post
import com.example.restapp.model.Follower

interface UserApiService {
    @GET("users/{id}")
    suspend fun getUser(@Path("id") userId: String): User
    
    @GET("users/{id}/posts")
    suspend fun getUserPosts(@Path("id") userId: String): List<Post>
    
    @GET("users/{id}/followers")
    suspend fun getUserFollowers(@Path("id") userId: String): List<Follower>
}
```

**network/repository/UserRepository.kt**
```kotlin
package com.example.restapp.network.repository

import com.example.restapp.network.api.UserApiService
import com.example.restapp.model.UserDetail

class UserRepository(
    private val apiService: UserApiService
) {
    suspend fun getUserDetail(userId: String): UserDetail {
        // Multiple network calls
        val user = apiService.getUser(userId)
        val posts = apiService.getUserPosts(userId)
        val followers = apiService.getUserFollowers(userId)
        
        return UserDetail(
            user = user,
            posts = posts,
            followers = followers
        )
    }
}
```

### Implementasi GraphQL:
**graphql/UserQuery.graphql**
```graphql
query GetUserDetail($id: ID!) {
  user(id: $id) {
    id
    name
    email
    posts {
      id
      title
      content
    }
    followers {
      id
      name
    }
  }
}
```

**graphql/repository/UserRepository.kt**
```kotlin
package com.example.graphqlapp.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.GetUserDetailQuery

class UserRepository(
    private val apolloClient: ApolloClient
) {
    suspend fun getUserDetail(userId: String): UserDetail? {
        val response = apolloClient
            .query(GetUserDetailQuery(id = userId))
            .execute()
        
        return response.data?.user?.let { user ->
            UserDetail(
                id = user.id,
                name = user.name,
                email = user.email,
                posts = user.posts.map { post ->
                    Post(
                        id = post.id,
                        title = post.title,
                        content = post.content
                    )
                },
                followers = user.followers.map { follower ->
                    Follower(
                        id = follower.id,
                        name = follower.name
                    )
                }
            )
        }
    }
}
```

### üéì Penjelasan Konsep:
**GraphQL vs REST seperti Supermarket vs Pasar Tradisional:**
- **REST**: Pasar tradisional (harus ke beberapa kios berbeda)
- **GraphQL**: Supermarket (semua dalam satu tempat)
- **Over-fetching**: Membeli terlalu banyak barang yang tidak dibutuhkan
- **Under-fetching**: Harus kembali ke pasar untuk barang yang terlupa
- **Single endpoint**: Satu kasir untuk semua transaksi

**Keunggulan GraphQL:**
- **Efisiensi**: Satu request untuk semua data yang dibutuhkan
- **Fleksibilitas**: Klien dapat memilih data yang diperlukan
- **Pengembangan**: Tidak perlu multiple endpoint untuk berbagai kebutuhan
- **Evolusi**: Mudah menambahkan field tanpa breaking changes

---

## 2Ô∏è‚É£ GraphQL Basics üìñ

### Konsep Dasar
GraphQL Basics seperti bahasa universal untuk komunikasi data üó£Ô∏è - memungkinkan klien dan server berbicara dengan bahasa yang sama!

### Schema Definition:
**graphql/schema.graphqls**
```graphql
# User type definition
type User {
  id: ID!
  name: String!
  email: String!
  avatar: String
  posts: [Post!]!
  followers: [User!]!
  following: [User!]!
  createdAt: String!
  updatedAt: String!
}

# Post type definition
type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  likes: Int!
  comments: [Comment!]!
  createdAt: String!
  updatedAt: String!
}

# Comment type definition
type Comment {
  id: ID!
  content: String!
  author: User!
  post: Post!
  createdAt: String!
}

# Query type definition (read operations)
type Query {
  user(id: ID!): User
  users(limit: Int, offset: Int): [User!]!
  post(id: ID!): Post
  posts(limit: Int, offset: Int): [Post!]!
  searchPosts(keyword: String!, limit: Int): [Post!]!
  me: User
}

# Mutation type definition (write operations)
type Mutation {
  createUser(name: String!, email: String!): User!
  updateUser(id: ID!, name: String, email: String): User!
  deleteUser(id: ID!): Boolean!
  createPost(title: String!, content: String!): Post!
  updatePost(id: ID!, title: String, content: String): Post!
  deletePost(id: ID!): Boolean!
  likePost(id: ID!): Post!
  unlikePost(id: ID!): Post!
  createComment(postId: ID!, content: String!): Comment!
}

# Subscription type definition (real-time operations)
type Subscription {
  postAdded: Post!
  postUpdated(id: ID!): Post!
  postDeleted(id: ID!): ID!
  userUpdated(id: ID!): User!
  commentAdded(postId: ID!): Comment!
}
```

### Query Example:
**graphql/queries/GetUser.graphql**
```graphql
query GetUser($id: ID!) {
  user(id: $id) {
    id
    name
    email
    avatar
    createdAt
  }
}
```

**graphql/queries/GetUserWithPosts.graphql**
```graphql
query GetUserWithPosts($id: ID!) {
  user(id: $id) {
    id
    name
    email
    avatar
    posts {
      id
      title
      likes
      createdAt
    }
  }
}
```

### Mutation Example:
**graphql/mutations/CreateUser.graphql**
```graphql
mutation CreateUser($name: String!, $email: String!) {
  createUser(name: $name, email: $email) {
    id
    name
    email
    createdAt
  }
}
```

**graphql/mutations/LikePost.graphql**
```graphql
mutation LikePost($id: ID!) {
  likePost(id: $id) {
    id
    title
    likes
  }
}
```

### Subscription Example:
**graphql/subscriptions/OnPostAdded.graphql**
```graphql
subscription OnPostAdded {
  postAdded {
    id
    title
    content
    author {
      id
      name
    }
    createdAt
  }
}
```

### üéì Penjelasan Konsep:
**GraphQL Basics seperti Bahasa Universal:**
- **Schema**: Kamus atau tata bahasa yang disepakati
- **Types**: Kata benda (User, Post)
- **Fields**: Sifat atau karakteristik kata benda (name, title)
- **Queries**: Kalimat tanya (Siapa pengguna ini?)
- **Mutations**: Kalimat perintah (Buat pengguna baru)
- **Subscriptions**: Langganan untuk update real-time

**Komponen Inti GraphQL:**
- **Schema**: Kontrak antara klien dan server, mendefinisikan semua kemungkinan data.
- **Types**: Struktur data yang bisa diminta (misalnya `User`, `Post`).
- **Fields**: Properti dari sebuah tipe (misalnya `name` pada tipe `User`).
- **Queries**: Operasi untuk membaca data.
- **Mutations**: Operasi untuk menulis atau mengubah data.
- **Subscriptions**: Operasi untuk menerima update data real-time.

**Keunggulan Schema:**
- **Self-Documenting**: Schema itu sendiri adalah dokumentasi API.
- **Strong Typing**: Mencegah error karena tipe data yang tidak sesuai.
- **Introspection**: Klien bisa menanyakan struktur schema kepada server.

---

## 3Ô∏è‚É£ Setup Apollo Client ‚öôÔ∏è

### Konsep Dasar
Setup Apollo Client seperti menyewa asisten pribadi yang sangat efisien ü§ñ - dia tahu ke mana harus pergi, apa yang harus diminta, dan bagaimana mengingatnya!

### Pengertian Apollo Client:
Apollo Client adalah library GraphQL yang komprehensif untuk:
- Mengirim query dan mutation ke server
- Mengelola cache data
- Mendukung real-time dengan subscriptions
- Integrasi yang mudah dengan UI framework

### Dependencies:
**build.gradle.kts (Module: app)**
```kotlin
dependencies {
    // Apollo GraphQL
    implementation("com.apollographql.apollo3:apollo-runtime:4.0.0")
    
    // Coroutines support
    implementation("com.apollographql.apollo3:apollo-coroutines-support:4.0.0")
    
    // Normalized cache untuk caching canggih
    implementation("com.apollographql.apollo3:apollo-normalized-cache:4.0.0")
    
    // SQLite cache untuk persisten cache
    implementation("com.apollographql.apollo3:apollo-normalized-cache-sqlite:4.0.0")
    
    // Logging interceptor untuk debugging
    implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")
}

// Plugin untuk menggenerate kode dari file .graphql
plugins {
    id("com.apollographql.apollo3") version "4.0.0"
}
```

### Konfigurasi Apollo:
**build.gradle.kts (Module: app)**
```kotlin
apollo {
    service("service") {
        // Nama package untuk kode yang di-generate
        packageName.set("com.example.graphql")
        
        // Lokasi file schema.graphqls (biasanya diunduh dari server)
        schemaFile.set(file("src/main/graphql/schema.graphqls"))
        
        // Generate model Kotlin dari schema
        generateKotlinModels.set(true)
    }
}
```

### Membuat Apollo Client:
**di/ApolloClientModule.kt**
```kotlin
package com.example.graphql.di

import android.content.Context
import com.apollographql.apollo3.ApolloClient
import com.apollographql.apollo3.cache.normalized.api.MemoryCacheFactory
import com.apollographql.apollo3.cache.normalized.sqlite.SqlNormalizedCacheFactory
import com.apollographql.apollo3.network.okHttpClient.OkHttpClient
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object ApolloClientModule {
    
    @Provides
    @Singleton
    fun provideApolloClient(@ApplicationContext context: Context): ApolloClient {
        // Logging interceptor untuk debugging
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = HttpLoggingInterceptor.Level.BODY
        }
        
        // Interceptor untuk menambahkan header auth
        val authInterceptor = Interceptor { chain ->
            val request = chain.request().newBuilder()
                .addHeader("Authorization", "Bearer YOUR_TOKEN_HERE")
                .build()
            chain.proceed(request)
        }
        
        // OkHttp Client
        val okHttpClient = OkHttpClient.Builder()
            .addInterceptor(loggingInterceptor)
            .addInterceptor(authInterceptor)
            .build()
        
        // SQLite cache untuk persisten cache
        val sqliteCacheFactory = SqlNormalizedCacheFactory(context, "apollo.db")
        
        return ApolloClient.Builder()
            .serverUrl("https://api.example.com/graphql")
            .okHttpClient(okHttpClient)
            .normalizedCache(sqliteCacheFactory) // Aktifkan cache
            .build()
    }
}
```

### Menggunakan Apollo Client:
**repository/UserRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.GetUserQuery
import com.example.graphql.type.buildUser
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    // Contoh penggunaan akan ada di bagian berikutnya
}
```

### üéì Penjelasan Konsep:
**Apollo Client seperti Asisten Pribadi:**
- **Server URL**: Alamat kantor tempat asisten bekerja.
- **OkHttp**: Kendaraan yang digunakan asisten untuk bepergian.
- **Interceptors**: Aturan yang harus diikuti asisten (misalnya, membawa ID card).
- **Cache**: Memori asisten untuk mengingat informasi yang sering diminta.
- **Apollo Client**: Asisten itu sendiri yang mengelola semua permintaan.

**Komponen Setup Apollo:**
- **Dependencies**: Peralatan yang dibutuhkan asisten.
- **Apollo Plugin**: Mesin penerjemah yang mengubah bahasa GraphQL menjadi kode Kotlin.
- **ApolloClient Instance**: Asisten yang siap bekerja.
- **Cache**: Memori jangka pendek (In-Memory) dan jangka panjang (SQLite).

**Best Practices:**
- Gunakan Dependency Injection (Hilt) untuk menyediakan `ApolloClient`.
- Pisahkan token autentikasi dan konfigurasi sensitif lainnya.
- Selalu gunakan cache untuk meningkatkan performa dan pengalaman offline.
- Aktifkan logging di development mode untuk memudahkan debugging.

---

## 4Ô∏è‚É£ Writing GraphQL Queries üìù

### Konsep Dasar
Writing GraphQL Queries seperti mengisi formulir permintaan yang sangat detail üìÑ - kamu bisa menentukan persis data apa yang kamu butuhkan!

### Pengertian GraphQL Queries:
Query adalah operasi GraphQL untuk membaca data dari server. Dengan query, kamu bisa:
- Mendapatkan data yang spesifik yang dibutuhkan
- Menggabungkan data dari berbagai sumber dalam satu permintaan
- Menghindari over-fetching dan under-fetching

### Membuat File Query:
Buat file dengan ekstensi `.graphql` di dalam direktori `src/main/graphql/com/example/graphql/`.

**graphql/GetUsers.graphql**
```graphql
query GetUsers {
  users {
    id
    name
    email
    avatar
  }
}
```

**graphql/GetUserById.graphql**
```graphql
query GetUserById($id: ID!) {
  user(id: $id) {
    id
    name
    email
    avatar
    posts {
      id
      title
      likes
      createdAt
    }
  }
}
```

**graphql/GetPosts.graphql**
```graphql
query GetPosts($limit: Int = 10, $offset: Int = 0) {
  posts(limit: $limit, offset: $offset) {
    id
    title
    content
    author {
      id
      name
      avatar
    }
    likes
    comments {
      id
      content
      author {
        name
      }
    }
    createdAt
  }
}
```

### Eksekusi Query di Repository:
**repository/UserRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.GetUsersQuery
import com.example.graphql.GetUserByIdQuery
import com.example.graphql.GetPostsQuery
import com.example.graphql.domain.model.User
import com.example.graphql.domain.model.Post
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Mendapatkan daftar semua user
     */
    suspend fun getUsers(): Result<List<User>> {
        return try {
            val response = apolloClient.query(GetUsersQuery()).execute()
            
            if (response.hasErrors()) {
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                val users = response.data?.users?.map { user ->
                    User(
                        id = user.id,
                        name = user.name,
                        email = user.email,
                        avatar = user.avatar
                    )
                } ?: emptyList()
                Result.success(users)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Mendapatkan user berdasarkan ID beserta post-nya
     */
    suspend fun getUserById(userId: String): Result<User?> {
        return try {
            val response = apolloClient.query(GetUserByIdQuery(id = userId)).execute()
            
            if (response.hasErrors()) {
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                val user = response.data?.user?.let { user ->
                    User(
                        id = user.id,
                        name = user.name,
                        email = user.email,
                        avatar = user.avatar,
                        posts = user.posts.map { post ->
                            Post(
                                id = post.id,
                                title = post.title,
                                likes = post.likes,
                                createdAt = post.createdAt
                            )
                        }
                    )
                }
                Result.success(user)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

/**
 * Repository untuk Post
 */
@Singleton
class PostRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Mendapatkan daftar post dengan pagination
     */
    suspend fun getPosts(limit: Int = 10, offset: Int = 0): Result<List<Post>> {
        return try {
            val response = apolloClient.query(GetPostsQuery(limit = limit, offset = offset)).execute()
            
            if (response.hasErrors()) {
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                val posts = response.data?.posts?.map { post ->
                    Post(
                        id = post.id,
                        title = post.title,
                        content = post.content,
                        authorName = post.author.name,
                        authorAvatar = post.author.avatar,
                        likes = post.likes,
                        commentsCount = post.comments.size,
                        createdAt = post.createdAt
                    )
                } ?: emptyList()
                Result.success(posts)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### Domain Model:
**domain/model/User.kt**
```kotlin
package com.example.graphql.domain.model

data class User(
    val id: String,
    val name: String,
    val email: String,
    val avatar: String? = null,
    val posts: List<Post> = emptyList()
)
```

**domain/model/Post.kt**
```kotlin
package com.example.graphql.domain.model

data class Post(
    val id: String,
    val title: String,
    val content: String,
    val authorName: String,
    val authorAvatar: String? = null,
    val likes: Int,
    val commentsCount: Int,
    val createdAt: String
)
```

### üéì Penjelasan Konsep:
**Writing Queries seperti Mengisi Formulir:**
- **Query**: Formulir permintaan data.
- **Fields**: Kotak isian yang harus diisi (data yang diminta).
- **Variables**: Bagian yang bisa diisi dinamis (misalnya ID user).
- **Generated Code**: Formulir yang sudah diproses menjadi objek yang bisa digunakan.
- **Repository**: Petugas yang mengirimkan formulir dan menerima hasilnya.

**Alur Kerja Query:**
1.  **Definisi**: Tulis query di file `.graphql`.
2.  **Generasi**: Apollo plugin meng-generate kode Kotlin dari query tersebut.
3.  **Eksekusi**: Panggil method yang di-generate dari `ApolloClient`.
4.  **Parsing**: Terima response dan parsing data ke dalam model domain.
5.  **Error Handling**: Tangani error yang mungkin terjadi.

**Best Practices:**
- Beri nama query yang deskriptif (misalnya `GetUserById`).
- Gunakan variabel (`$id`) untuk query yang dinamis.
- Selalu tangani `response.hasErrors()` untuk menangkap error dari server.
- Mapping response GraphQL ke model domain untuk memisahkan lapisan data dengan UI.

---

## 5Ô∏è‚É£ GraphQL Mutations üîÑ

### Konsep Dasar
GraphQL Mutations seperti formulir untuk mengajukan permohonan üìù - mengubah data di server dengan instruksi yang jelas!

### Pengertian GraphQL Mutations:
Mutation adalah operasi GraphQL untuk menulis atau mengubah data di server. Dengan mutation, kamu bisa:
- Membuat data baru (Create)
- Memperbarui data yang ada (Update)
- Menghapus data (Delete)

### Membuat File Mutation:
**graphql/mutations/CreateUser.graphql**
```graphql
mutation CreateUser($name: String!, $email: String!) {
  createUser(name: $name, email: $email) {
    id
    name
    email
    avatar
    createdAt
  }
}
```

**graphql/mutations/LikePost.graphql**
```graphql
mutation LikePost($id: ID!) {
  likePost(id: $id) {
    id
    title
    likes
  }
}
```

**graphql/mutations/CreatePost.graphql**
```graphql
mutation CreatePost($title: String!, $content: String!) {
  createPost(title: $title, content: $content) {
    id
    title
    content
    author {
      id
      name
    }
    likes
    createdAt
  }
}
```

### Eksekusi Mutation di Repository:
**repository/UserRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.CreateUserMutation
import com.example.graphql.domain.model.User
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Membuat user baru
     */
    suspend fun createUser(name: String, email: String): Result<User> {
        return try {
            val response = apolloClient.mutation(CreateUserMutation(name = name, email = email)).execute()
            
            if (response.hasErrors()) {
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                val user = response.data?.createUser?.let { user ->
                    User(
                        id = user.id,
                        name = user.name,
                        email = user.email,
                        avatar = user.avatar
                    )
                }
                if (user != null) {
                    Result.success(user)
                } else {
                    Result.failure(Exception("Failed to create user"))
                }
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

**repository/PostRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.LikePostMutation
import com.example.graphql.CreatePostMutation
import com.example.graphql.domain.model.Post
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PostRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Menyukai sebuah post
     */
    suspend fun likePost(postId: String): Result<Post> {
        return try {
            val response = apolloClient.mutation(LikePostMutation(id = postId)).execute()
            
            if (response.hasErrors()) {
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                val post = response.data?.likePost?.let { post ->
                    Post(
                        id = post.id,
                        title = post.title,
                        likes = post.likes
                        // ... field lainnya
                    )
                }
                if (post != null) {
                    Result.success(post)
                } else {
                    Result.failure(Exception("Failed to like post"))
                }
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Membuat post baru
     */
    suspend fun createPost(title: String, content: String): Result<Post> {
        return try {
            val response = apolloClient.mutation(CreatePostMutation(title = title, content = content)).execute()
            
            if (response.hasErrors()) {
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                val post = response.data?.createPost?.let { post ->
                    Post(
                        id = post.id,
                        title = post.title,
                        content = post.content,
                        authorName = post.author.name,
                        likes = post.likes,
                        createdAt = post.createdAt
                    )
                }
                if (post != null) {
                    Result.success(post)
                } else {
                    Result.failure(Exception("Failed to create post"))
                }
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### Optimistic Updates dengan Mutations:
**repository/PostRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.apollographql.apollo3.api.Optional
import com.example.graphql.LikePostMutation
import com.example.graphql.GetPostByIdQuery
import com.example.graphql.domain.model.Post
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PostRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Menyukai post dengan optimistic update
     */
    suspend fun likePostOptimistic(postId: String, currentPost: Post): Result<Post> {
        return try {
            // 1. Definisikan data optimis (UI akan langsung update dengan ini)
            val optimisticData = GetPostByIdQuery.Data {
                post = GetPostByIdQuery.Post {
                    id = postId
                    title = currentPost.title
                    likes = currentPost.likes + 1
                    // ... field lainnya
                }
            }
            
            // 2. Jalankan mutation dengan update optimis
            val response = apolloClient.mutation(LikePostMutation(id = postId))
                .optimisticUpdates(optimisticData)
                .execute()
            
            if (response.hasErrors()) {
                // Jika gagal, kembalikan ke state semula (Apollo melakukan ini otomatis)
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                // Jika berhasil, update dengan data dari server
                val updatedPost = response.data?.likePost?.let { post ->
                    currentPost.copy(
                        id = post.id,
                        title = post.title,
                        likes = post.likes
                    )
                }
                if (updatedPost != null) {
                    Result.success(updatedPost)
                } else {
                    Result.failure(Exception("Failed to like post"))
                }
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### üéì Penjelasan Konsep:
**Mutations seperti Formulir Permohonan:**
- **Mutation**: Formulir untuk mengubah data.
- **Arguments**: Data yang harus diisi di formulir (misalnya `name`, `email`).
- **Generated Code**: Formulir yang siap digunakan.
- **Repository**: Petugas yang mengajukan formulir.
- **Optimistic Update**: Mengasumsikan permohonan akan disetujui dan langsung menampilkannya.

**Alur Kerja Mutation:**
1.  **Definisi**: Tulis mutation di file `.graphql`.
2.  **Generasi**: Apollo plugin meng-generate kode.
3.  **Eksekusi**: Panggil method mutation dengan data yang diperlukan.
4.  **Optimistic Update (Opsional)**: Update UI terlebih dahulu untuk responsivitas.
5.  **Response**: Terima konfirmasi (data baru) atau error dari server.

**Best Practices:**
- Gunakan `Result` wrapper untuk error handling yang konsisten.
- Implementasikan optimistic update untuk operasi yang sering berhasil (misalnya, like).
- Selalu minta field yang diperlukan pada response mutation untuk memperbarui UI.
- Tangani error dengan baik dan berikan feedback kepada pengguna.

---

## 6Ô∏è‚É£ Fragments for Reusability üß©

### Konsep Dasar
GraphQL Fragments seperti balok LEGO üß© - kamu bisa membuat blok-blok kecil yang bisa digunakan kembali di berbagai query yang lebih besar!

### Pengertian GraphQL Fragments:
Fragment adalah unit kode GraphQL yang dapat digunakan kembali yang memungkinkan kamu:
- Mendefinisikan sekumpulan field yang bisa digunakan di beberapa query
- Memastikan konsistensi data di seluruh aplikasi
- Mempermudah pemeliharaan kode
- Menghindari pengulangan penulisan field yang sama

### Membuat Fragment:
**graphql/fragments/UserDetails.graphql**
```graphql
fragment UserDetails on User {
  id
  name
  email
  avatar
  createdAt
}
```

**graphql/fragments/PostSummary.graphql**
```graphql
fragment PostSummary on Post {
  id
  title
  likes
  createdAt
}
```

**graphql/fragments/AuthorDetails.graphql**
```graphql
fragment AuthorDetails on User {
  id
  name
  avatar
}
```

### Menggunakan Fragment dalam Query:
**graphql/queries/GetUserWithPosts.graphql**
```graphql
# Import fragment yang akan digunakan
query GetUserWithPosts($id: ID!) {
  user(id: $id) {
    ...UserDetails  # Menggunakan fragment UserDetails
    posts {
      ...PostSummary # Menggunakan fragment PostSummary
    }
  }
}
```

**graphql/queries/GetPosts.graphql**
```graphql
query GetPosts($limit: Int, $offset: Int) {
  posts(limit: $limit, offset: $offset) {
    ...PostSummary # Menggunakan fragment yang sama
    content
    author {
      ...AuthorDetails # Menggunakan fragment AuthorDetails
    }
  }
}
```

### Eksekusi Query dengan Fragment:
**repository/PostRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.GetPostsQuery
import com.example.graphql.fragment.AuthorDetails
import com.example.graphql.fragment.PostSummary
import com.example.graphql.domain.model.Post
import com.example.graphql.domain.model.Author
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PostRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Mendapatkan daftar post dengan informasi author
     */
    suspend fun getPosts(limit: Int = 10, offset: Int = 0): Result<List<Post>> {
        return try {
            val response = apolloClient.query(GetPostsQuery(limit = limit, offset = offset)).execute()
            
            if (response.hasErrors()) {
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                val posts = response.data?.posts?.map { post ->
                    // Mapping dari fragment PostSummary
                    val postSummary = post.postSummary
                    // Mapping dari fragment AuthorDetails
                    val authorDetails = post.author.onAuthorDetails
                    
                    Post(
                        id = postSummary.id,
                        title = postSummary.title,
                        likes = postSummary.likes,
                        createdAt = postSummary.createdAt,
                        author = Author(
                            id = authorDetails.id,
                            name = authorDetails.name,
                            avatar = authorDetails.avatar
                        )
                    )
                } ?: emptyList()
                Result.success(posts)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### Domain Model:
**domain/model/Author.kt**
```kotlin
package com.example.graphql.domain.model

data class Author(
    val id: String,
    val name: String,
    val avatar: String? = null
)
```

**domain/model/Post.kt**
```kotlin
package com.example.graphql.domain.model

data class Post(
    val id: String,
    val title: String,
    val likes: Int,
    val createdAt: String,
    val author: Author
)
```

### üéì Penjelasan Konsep:
**Fragments seperti Balok LEGO:**
- **Fragment**: Balok LEGO dengan bentuk tertentu (misalnya, balok roda, balok jendela).
- **Query**: Model lengkap yang kamu bangun (misalnya, mobil).
- **Reusability**: Balok roda bisa digunakan untuk mobil, truk, atau pesawat.
- **Consistency**: Semua mobil yang menggunakan balok roda yang sama akan memiliki roda yang konsisten.

**Manfaat Fragments:**
- **DRY (Don't Repeat Yourself)**: Tidak perlu menulis ulang field yang sama.
- **Konsistensi**: Memastikan semua bagian aplikasi meminta data yang sama dengan cara yang sama.
- **Pemeliharaan**: Jika perlu mengubah field, cukup ubah di satu tempat (di definisi fragment).
- **Organisasi**: Membantu mengorganisir query yang kompleks menjadi bagian-bagian yang lebih kecil.

**Best Practices:**
- Beri nama fragment yang deskriptif (misalnya, `UserDetails`, bukan `UserFrag`).
- Kelompokkan fragment berdasarkan tipe data atau fitur.
- Gunakan fragment untuk field yang sering diminta bersama-sama.
- Simpan fragment di direktori terpisah (`fragments/`) untuk organisasi yang lebih baik.

---

## 7Ô∏è‚É£ Query Variables & Arguments üî¢

### Konsep Dasar
Query Variables & Arguments seperti template surat üíå - kamu membuat satu template, tapi bisa mengisinya dengan informasi berbeda setiap kali!

### Pengertian Query Variables & Arguments:
- **Arguments**: Parameter yang bisa diterima oleh field dalam query (misalnya, `id: ID!`).
- **Variables**: Nilai dinamis yang dilewatkan ke query saat eksekusi, menggantikan hardcoded value.

### Query dengan Arguments:
**graphql/queries/GetUser.graphql**
```graphql
query GetUser($id: ID!) { # $id adalah variabel
  user(id: $id) { # id: $id adalah argument
    id
    name
    email
  }
}
```

**graphql/queries/SearchPosts.graphql**
```graphql
query SearchPosts($keyword: String!, $limit: Int = 10) { # $limit memiliki nilai default
  searchPosts(keyword: $keyword, limit: $limit) {
    id
    title
    content
  }
}
```

### Eksekusi Query dengan Variables:
**repository/UserRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.GetUserQuery
import com.example.graphql.SearchPostsQuery
import com.example.graphql.domain.model.User
import com.example.graphql.domain.model.Post
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Mendapatkan user berdasarkan ID
     */
    suspend fun getUserById(userId: String): Result<User?> {
        return try {
            // Melewatkan variabel 'id' ke query
            val response = apolloClient.query(GetUserQuery(id = userId)).execute()
            
            if (response.hasErrors()) {
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                val user = response.data?.user?.let { user ->
                    User(
                        id = user.id,
                        name = user.name,
                        email = user.email
                    )
                }
                Result.success(user)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

@Singleton
class PostRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Mencari post berdasarkan keyword
     */
    suspend fun searchPosts(keyword: String, limit: Int = 10): Result<List<Post>> {
        return try {
            // Melewatkan variabel 'keyword' dan 'limit'
            val response = apolloClient.query(SearchPostsQuery(keyword = keyword, limit = limit)).execute()
            
            if (response.hasErrors()) {
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                val posts = response.data?.searchPosts?.map { post ->
                    Post(
                        id = post.id,
                        title = post.title,
                        content = post.content
                    )
                } ?: emptyList()
                Result.success(posts)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### Penggunaan di ViewModel:
**presentation/viewmodel/SearchViewModel.kt**
```kotlin
package com.example.graphql.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.graphql.domain.model.Post
import com.example.graphql.repository.PostRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class SearchViewModel @Inject constructor(
    private val postRepository: PostRepository
) : ViewModel() {
    
    private val _searchResults = MutableStateFlow<List<Post>>(emptyList())
    val searchResults: StateFlow<List<Post>> = _searchResults.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()
    
    fun searchPosts(keyword: String) {
        if (keyword.isBlank()) {
            _searchResults.value = emptyList()
            return
        }
        
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            val result = postRepository.searchPosts(keyword)
            
            result.fold(
                onSuccess = { posts ->
                    _searchResults.value = posts
                },
                onFailure = { throwable ->
                    _error.value = throwable.message
                }
            )
            
            _isLoading.value = false
        }
    }
}
```

### üéì Penjelasan Konsep:
**Variables & Arguments seperti Template Surat:**
- **Query**: Template surat yang sudah dibuat.
- **Variables**: Isian surat yang bisa berubah (nama penerima, alamat).
- **Arguments**: Kotak pos di template surat (misalnya, "Kepada Yth. [Nama]").
- **Eksekusi**: Mengisi template dengan data spesifik dan mengirimkannya.

**Alur Kerja:**
1.  **Definisi**: Buat query dengan placeholder untuk variabel (`$id`).
2.  **Eksekusi**: Saat memanggil query, lewatkan nilai untuk variabel tersebut (`id = "123"`).
3.  **Substitusi**: Apollo mengganti placeholder dengan nilai yang diberikan.
4.  **Response**: Server menerima query yang sudah lengkap dan mengembalikan data.

**Best Practices:**
- Gunakan variabel untuk semua nilai yang dinamis.
- Beri nama variabel yang deskriptif (`$userId`, `$postLimit`).
- Gunakan nilai default untuk variabel yang sering memiliki nilai yang sama (`$limit: Int = 10`).
- Hindari *hardcoding* nilai langsung di dalam string query.

---

## 8Ô∏è‚É£ Error Handling ‚ö†Ô∏è

### Konsep Dasar
Error Handling seperti sistem navigasi GPS üõ∞Ô∏è - jika ada jalan tertutup, sistem akan memberi tahu dan mencari jalan alternatif!

### Jenis-Jenis Error di GraphQL:
1.  **GraphQL Errors**: Error yang dikembalikan server di dalam `errors` field (misalnya, validasi gagal, user tidak ditemukan).
2.  **Network Errors**: Error yang terjadi karena masalah jaringan (tidak ada koneksi, timeout).
3.  **Parsing Errors**: Error yang terjadi saat response tidak bisa di-parsing.

### Implementasi Error Handling:
**repository/BaseRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloException
import com.apollographql.apollo3.api.ApolloResponse
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

/**
 * Wrapper untuk menangani hasil operasi GraphQL
 */
sealed class GraphqlResult<out T> {
    data class Success<T>(val data: T) : GraphqlResult<T>()
    data class Error(val exception: Throwable) : GraphqlResult<Nothing>()
}

/**
 * Fungsi ekstensi untuk memetakan ApolloResponse ke GraphqlResult
 */
fun <T> ApolloResponse<T>.toResult(): GraphqlResult<T> {
    return if (hasErrors()) {
        val errorMessage = errors?.joinToString { it.message } ?: "Unknown GraphQL error"
        GraphqlResult.Error(Exception(errorMessage))
    } else if (data == null) {
        GraphqlResult.Error(Exception("No data received"))
    } else {
        GraphqlResult.Success(data)
    }
}

/**
 * Fungsi ekstensi untuk menangani exception jaringan
 */
suspend fun <T> safeGraphqlCall(apiCall: suspend () -> ApolloResponse<T>): GraphqlResult<T> {
    return try {
        apiCall().toResult()
    } catch (e: ApolloException) {
        GraphqlResult.Error(e)
    } catch (e: Exception) {
        GraphqlResult.Error(e)
    }
}
```

### Menggunakan Error Handling di Repository:
**repository/UserRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.GetUserQuery
import com.example.graphql.domain.model.User
import com.example.graphql.repository.BaseRepository.GraphqlResult
import com.example.graphql.repository.BaseRepository.safeGraphqlCall
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Mendapatkan user dengan error handling yang komprehensif
     */
    suspend fun getUserById(userId: String): GraphqlResult<User?> {
        return safeGraphqlCall {
            apolloClient.query(GetUserQuery(id = userId)).execute()
        }.map { response ->
            response.user?.let { user ->
                User(
                    id = user.id,
                    name = user.name,
                    email = user.email
                )
            }
        }
    }
}
```

### Menampilkan Error di UI:
**presentation/viewmodel/UserViewModel.kt**
```kotlin
package com.example.graphql.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.graphql.domain.model.User
import com.example.graphql.repository.BaseRepository
import com.example.graphql.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class UserViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UserUiState>(UserUiState.Idle)
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()
    
    fun loadUser(userId: String) {
        viewModelScope.launch {
            _uiState.value = UserUiState.Loading
            
            when (val result = userRepository.getUserById(userId)) {
                is BaseRepository.GraphqlResult.Success -> {
                    if (result.data != null) {
                        _uiState.value = UserUiState.Success(result.data)
                    } else {
                        _uiState.value = UserUiState.Error("User not found")
                    }
                }
                is BaseRepository.GraphqlResult.Error -> {
                    _uiState.value = UserUiState.Error(
                        result.exception.message ?: "An unknown error occurred"
                    )
                }
            }
        }
    }
}

sealed class UserUiState {
    object Idle : UserUiState()
    object Loading : UserUiState()
    data class Success(val user: User) : UserUiState()
    data class Error(val message: String) : UserUiState()
}
```

### üéì Penjelasan Konsep:
**Error Handling seperti Sistem Navigasi GPS:**
- **API Call**: Memulai perjalanan.
- **GraphQL Error**: GPS memberi tahu "Jalan ditutup 2 km lagi".
- **Network Error**: GPS kehilangan sinyal.
- **Error Handling**: Sistem memberi tahu pengguna dan mencoba rute alternatif atau meminta bantuan.
- **UI Update**: Menampilkan pesan "Mencari rute alternatif..." atau "Tidak dapat terhubung ke server".

**Strategi Error Handling:**
- **Wrapper**: Bungkus semua pemanggilan API dalam `try-catch` atau fungsi pembantu (`safeGraphqlCall`).
- **Pemetaan**: Ubah `ApolloResponse` menjadi tipe hasil yang lebih sederhana (misalnya, `Result` atau `GraphqlResult`).
- **Validasi**: Periksa `response.hasErrors()` untuk menangkap error spesifik dari GraphQL.
- **Feedback**: Berikan feedback yang jelas kepada pengguna melalui UI.

**Best Practices:**
- Jangan biarkan exception tidak tertangani (crash).
- Berikan pesan error yang informatif tetapi ramah pengguna.
- Pisahkan antara error jaringan dan error bisnis.
- Log error untuk debugging di development.

---

## 9Ô∏è‚É£ Caching with Apollo üíæ

### Konsep Dasar
Caching with Apollo seperti memori jenius üß† - mengingat semua yang pernah diminta, sehingga tidak perlu bertanya lagi!

### Pengertian Caching di Apollo:
Caching adalah mekanisme untuk menyimpan hasil query secara lokal. Dengan cache, aplikasi bisa:
- Menampilkan data lebih cepat (tanpa menunggu network)
- Bekerja offline (dengan data yang sudah di-cache)
- Mengurangi jumlah permintaan ke server
- Memberikan pengalaman pengguna yang lebih smooth

### Jenis-Jenis Cache di Apollo:
1.  **In-Memory Cache**: Menyimpan data di RAM. Cepat, tetapi hilang saat aplikasi ditutup.
2.  **Normalized Cache**: Menyimpan data dengan struktur yang terorganisir. Sangat efisien untuk update parsial.
3.  **SQLite Cache**: Menyimpan data di database SQLite. Persisten, data tidak hilang saat aplikasi ditutup.

### Setup Normalized Cache dengan SQLite:
**di/ApolloClientModule.kt**
```kotlin
package com.example.graphql.di

import android.content.Context
import com.apollographql.apollo3.ApolloClient
import com.apollographql.apollo3.cache.normalized.api.MemoryCacheFactory
import com.apollographql.apollo3.cache.normalized.sqlite.SqlNormalizedCacheFactory
import com.apollographql.apollo3.network.okHttpClient.OkHttpClient
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import okhttp3.OkHttpClient
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object ApolloClientModule {
    
    @Provides
    @Singleton
    fun provideApolloClient(@ApplicationContext context: Context): ApolloClient {
        // SQLite cache untuk persisten cache
        val sqliteCacheFactory = SqlNormalizedCacheFactory(context, "apollo.db")
        
        // Memory cache sebagai lapisan pertama
        val memoryCacheFactory = MemoryCacheFactory(maxSizeBytes = 10 * 1024 * 1024) // 10MB
        
        return ApolloClient.Builder()
            .serverUrl("https://api.example.com/graphql")
            .normalizedCache(memoryCacheFactory.chain(sqliteCacheFactory))
            .build()
    }
}
```

### Cache Policies:
**repository/PostRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.apollographql.apollo3.api.ApolloResponse
import com.apollographql.apollo3.api.Optional
import com.apollographql.apollo3.fetchPolicy
import com.example.graphql.GetPostsQuery
import com.example.graphql.domain.model.Post
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PostRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Mendapatkan post dengan kebijakan Cache-First
     * Prioritaskan data dari cache, jika tidak ada baru ambil dari network
     */
    suspend fun getPostsCacheFirst(): Result<List<Post>> {
        return try {
            val response = apolloClient.query(GetPostsQuery())
                .fetchPolicy(com.apollographql.apollo3.api.FetchPolicy.CacheFirst)
                .execute()
            
            // ... mapping response ke model domain
            Result.success(emptyList()) // Placeholder
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Mendapatkan post dengan kebijakan Network-Only
     * Selalu ambil data dari network, abaikan cache
     */
    suspend fun getPostsNetworkOnly(): Result<List<Post>> {
        return try {
            val response = apolloClient.query(GetPostsQuery())
                .fetchPolicy(com.apollographql.apollo3.api.FetchPolicy.NetworkOnly)
                .execute()
            
            // ... mapping response ke model domain
            Result.success(emptyList()) // Placeholder
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * Mendapatkan post dengan kebijakan Cache-and-Network
     * Tampilkan data dari cache, lalu ambil data dari network di background
     */
    suspend fun getPostsCacheAndNetwork(): Result<List<Post>> {
        return try {
            val response = apolloClient.query(GetPostsQuery())
                .fetchPolicy(com.apollographql.apollo3.api.FetchPolicy.CacheAndNetwork)
                .execute()
            
            // ... mapping response ke model domain
            Result.success(emptyList()) // Placeholder
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### Cache Invalidation:
**repository/UserRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.UpdateUserMutation
import com.example.graphql.domain.model.User
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Memperbarui user dan meng-cache hasilnya
     * Apollo akan secara otomatis memperbarui cache untuk entitas User yang sama
     */
    suspend fun updateUser(userId: String, name: String): Result<User> {
        return try {
            val response = apolloClient.mutation(UpdateUserMutation(id = userId, name = Optional.present(name)))
                // Optimistic response akan di-cache
                // Response sukses dari server akan mengupdate cache
                .execute()
            
            // ... mapping response ke model domain
            Result.success(User(userId, name, "")) // Placeholder
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### üéì Penjelasan Konsep:
**Caching seperti Memori Jenius:**
- **Cache**: Memori jenius yang menyimpan semua percakapan.
- **Query**: Pertanyaan yang diajukan kepada jenius.
- **Cache Hit**: Jenius langsung menjawab karena sudah tahu.
- **Cache Miss**: Jenius harus mencari tahu dulu (melalui network).
- **Cache Invalidation**: Jenius memperbarui ingatannya jika ada informasi baru.

**Strategi Cache:**
- **Cache-First**: Tanya ke memori dulu, lebih cepat. Cocok untuk data yang jarang berubah.
- **Network-Only**: Selalu tanya ke sumber asli. Cocok untuk data yang harus selalu segar.
- **Cache-and-Network**: Tampilkan yang di memori dulu, lalu perbarui di belakang layar. Memberikan pengalaman tercepat.

**Best Practices:**
- Gunakan `Cache-and-Network` untuk UI yang membutuhkan responsivitas tinggi.
- Gunakan `Network-Only` untuk data yang sangat kritis (misalnya, data pembayaran).
- Pahami cara kerja *normalized cache* untuk memaksimalkan manfaatnya.
- Gunakan `SQLite cache` agar data tetap ada saat aplikasi dibuka kembali.

---

## 1Ô∏è‚É£0Ô∏è‚É£ Watching Queries (Reactive) üëÄ

### Konsep Dasar
Watching Queries seperti berlangganan koran üì∞ - setiap ada berita baru, koran langsung dikirim ke rumahmu tanpa perlu meminta lagi!

### Pengertian Watching Queries:
Watching Queries adalah kemampuan Apollo untuk:
- Mengamati perubahan pada cache untuk query tertentu
- Memberikan update otomatis ke subscriber jika data di cache berubah
- Membuat UI menjadi reaktif dan selalu up-to-date
- Menggantikan polling (menanyakan data secara berkala)

### Implementasi Watching Queries:
**repository/PostRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.GetPostsQuery
import com.example.graphql.domain.model.Post
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PostRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Mengamati perubahan pada daftar post
     * Fungsi ini mengembalikan Flow yang akan emit nilai baru setiap kali cache berubah
     */
    fun watchPosts(): Flow<List<Post>> {
        return apolloClient
            .query(GetPostsQuery())
            .watch() // Fungsi kunci untuk watching query
            .map { response ->
                // Mapping data dari response ke model domain
                response.data?.posts?.map { post ->
                    Post(
                        id = post.id,
                        title = post.title,
                        likes = post.likes
                    )
                } ?: emptyList()
            }
    }
}
```

### Menggunakan di ViewModel:
**presentation/viewmodel/PostListViewModel.kt**
```kotlin
package com.example.graphql.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.graphql.domain.model.Post
import com.example.graphql.repository.PostRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import javax.inject.Inject

@HiltViewModel
class PostListViewModel @Inject constructor(
    private val postRepository: PostRepository
) : ViewModel() {
    
    /**
     * StateFlow yang akan otomatis ter-update setiap kali data post berubah di cache
     * `stateIn` mengubah Flow menjadi StateFlow yang bisa diamati oleh UI
     */
    val posts: StateFlow<List<Post>> = postRepository
        .watchPosts()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000), // Berhenti berlangganan jika tidak ada subscriber selama 5 detik
            initialValue = emptyList() // Nilai awal
        )
}
```

### Mengamati Perubahan Data Spesifik:
**repository/UserRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.GetUserQuery
import com.example.graphql.domain.model.User
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Mengamati perubahan pada user tertentu
     * Cache akan ter-update jika ada mutation yang mempengaruhi user ini
     */
    fun watchUserById(userId: String): Flow<User?> {
        return apolloClient
            .query(GetUserQuery(id = userId))
            .watch()
            .map { response ->
                response.data?.user?.let { user ->
                    User(
                        id = user.id,
                        name = user.name,
                        email = user.email
                    )
                }
            }
    }
}
```

### üéì Penjelasan Konsep:
**Watching Queries seperti Berlangganan Koran:**
- **Query**: Berlangganan ke koran tentang topik tertentu (misalnya, "Daftar Post").
- **Cache**: Kantor redaksi koran.
- **Watch**: Mendaftar sebagai pelanggan.
- **Update**: Setiap ada berita baru (post ditambah/diubah), koran langsung dikirim.
- **Flow**: Tumpukan koran yang datang setiap hari.

**Alur Kerja Watching Queries:**
1.  **Berlangganan**: UI memanggil `repository.watchPosts()`.
2.  **Eksekusi Awal**: Apollo menjalankan query pertama kali dan menyimpan hasilnya di cache.
3.  **Emit Data**: Flow meng-emit data awal ini ke UI.
4.  **Cache Update**: Jika ada mutation (misalnya, `createPost`) yang mempengaruhi data ini, Apollo akan memperbarui cache.
5.  **Emit Update**: Flow secara otomatis meng-emit data baru dari cache ke UI.
6.  **UI Update**: UI yang mengamati Flow akan otomatis diperbarui.

**Best Practices:**
- Gunakan `watch()` untuk data yang sering berubah dan perlu ditampilkan secara real-time.
- Gunakan `stateIn` di ViewModel untuk mengelola lifecycle Flow dengan baik.
- Kombinasikan dengan `Cache-and-Network` untuk pengalaman terbaik (data lama ditampilkan, data baru diambil di background).
- Ingat bahwa `watch()` hanya bereaksi terhadap perubahan di *cache*, bukan perubahan real-time dari server (untuk itu, gunakan *Subscriptions*).

---

## 1Ô∏è‚É£1Ô∏è‚É£ GraphQL Subscriptions (Real-Time) üì°

### Konsep Dasar
GraphQL Subscriptions seperti saluran berita TV langsung üì∫ - kamu akan mendapatkan update secara real-time tepat saat kejadian terjadi!

### Pengertian GraphQL Subscriptions:
Subscription adalah operasi GraphQL yang memungkinkan server untuk *mendorong* data ke klien secara real-time melalui koneksi persisten (biasanya WebSocket). Ini digunakan untuk:
- Notifikasi real-time (like, komentar, pesan baru)
- Update data langsung (tracking pengiriman, skor pertandingan)
- Kolaborasi multi-pengguna (editing dokumen bersama)

### Setup WebSocket Transport:
**di/ApolloClientModule.kt**
```kotlin
package com.example.graphql.di

import android.content.Context
import com.apollographql.apollo3.ApolloClient
import com.apollographql.apollo3.network.ws.WebSocketNetworkTransport
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object ApolloClientModule {
    
    @Provides
    @Singleton
    fun provideApolloClient(@ApplicationContext context: Context): ApolloClient {
        // WebSocket transport untuk subscriptions
        val webSocketTransport = WebSocketNetworkTransport.Builder()
            .serverUrl("wss://api.example.com/graphql") // URL WebSocket
            .build()
        
        return ApolloClient.Builder()
            .serverUrl("https://api.example.com/graphql") // URL HTTP untuk queries/mutations
            .subscriptionNetworkTransport(webSocketTransport) // Tambahkan transport untuk subscription
            .build()
    }
}
```

### Membuat File Subscription:
**graphql/subscriptions/OnPostAdded.graphql**
```graphql
subscription OnPostAdded {
  postAdded {
    id
    title
    content
    author {
      id
      name
    }
    createdAt
  }
}
```

**graphql/subscriptions/OnPostLiked.graphql**
```graphql
subscription OnPostLiked($postId: ID!) {
  postLiked(postId: $postId) {
    id
    likes
  }
}
```

### Eksekusi Subscription di Repository:
**repository/PostRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.example.graphql.OnPostAddedSubscription
import com.example.graphql.OnPostLikedSubscription
import com.example.graphql.domain.model.Post
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.filterNotNull
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PostRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Berlangganan untuk notifikasi post baru
     * Mengembalikan Flow yang akan emit setiap kali post baru ditambahkan
     */
    fun subscribeToNewPosts(): Flow<Post> {
        return apolloClient
            .subscription(OnPostAddedSubscription())
            .toFlow() // Mengubah subscription menjadi Flow
            .map { response ->
                // Mapping data dari response ke model domain
                response.data?.postAdded?.let { post ->
                    Post(
                        id = post.id,
                        title = post.title,
                        content = post.content,
                        authorName = post.author.name,
                        likes = 0 // Post baru belum ada like
                    )
                }
            }
            .filterNotNull() // Hanya emit nilai yang tidak null
    }
    
    /**
     * Berlangganan untuk update like pada post tertentu
     */
    fun subscribeToPostLikes(postId: String): Flow<Int> {
        return apolloClient
            .subscription(OnPostLikedSubscription(postId = postId))
            .toFlow()
            .map { response ->
                response.data?.postLiked?.likes
            }
            .filterNotNull()
    }
}
```

### Menggunakan di ViewModel:
**presentation/viewmodel/RealTimePostViewModel.kt**
```kotlin
package com.example.graphql.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.graphql.domain.model.Post
import com.example.graphql.repository.PostRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class RealTimePostViewModel @Inject constructor(
    private val postRepository: PostRepository
) : ViewModel() {
    
    private val _posts = MutableStateFlow<List<Post>>(emptyList())
    val posts: StateFlow<List<Post>> = _posts.asStateFlow()
    
    init {
        // Memuat data awal
        loadInitialPosts()
        
        // Memulai berlangganan untuk post baru
        subscribeToNewPosts()
    }
    
    private fun loadInitialPosts() {
        viewModelScope.launch {
            // Logika untuk memuat post awal, misalnya dengan query biasa
            // val initialPosts = postRepository.getPosts()
            // _posts.value = initialPosts
        }
    }
    
    private fun subscribeToNewPosts() {
        viewModelScope.launch {
            postRepository.subscribeToNewPosts().collect { newPost ->
                // Tambahkan post baru ke daftar yang ada
                val currentPosts = _posts.value.toMutableList()
                currentPosts.add(0, newPost) // Tambahkan di awal daftar
                _posts.value = currentPosts
            }
        }
    }
}
```

### üéì Penjelasan Konsep:
**Subscriptions seperti Saluran Berita TV Langsung:**
- **Subscription**: Berlangganan ke saluran berita (misalnya, "Breaking News").
- **WebSocket**: Sinyal TV kabel yang selalu terhubung.
- **Server**: Stasiun TV yang menyiarkan berita.
- **Event**: Berita baru yang terjadi (kecelakaan, konferensi pers).
- **Client**: TV di rumah yang langsung menampilkan berita tersebut.

**Alur Kerja Subscriptions:**
1.  **Koneksi**: Klien membuka koneksi WebSocket ke server.
2.  **Berlangganan**: Klien mengirimkan dokumen subscription.
3.  **Server Konfirmasi**: Server menerima dan memulai berlangganan.
4.  **Event Terjadi**: Terjadi sesuatu di server (misalnya, data diubah).
5.  **Server Dorong Data**: Server mendorong data yang relevan ke klien melalui WebSocket.
6.  **Klien Terima Data**: Klien menerima data dan memperbarui UI.

**Best Practices:**
- Gunakan subscriptions untuk fitur yang benar-benar membutuhkan real-time.
- Kelola lifecycle subscription dengan baik (berhenti berlangganan saat UI tidak terlihat untuk menghemat baterai dan sumber daya).
- Tangani koneksi yang terputus dan coba untuk menghubungkan kembali.
- Pastikan server memiliki dukungan WebSocket dan GraphQL Subscriptions.

---

## 1Ô∏è‚É£2Ô∏è‚É£ Pagination üìÑ

### Konsep Dasar
Pagination seperti membaca buku yang tebal üìñ - kamu tidak membacanya sekaligus, tapi halaman per halaman agar lebih mudah dicerna!

### Pengertian Pagination di GraphQL:
Pagination adalah teknik untuk memuat data dalam "potongan" atau "halaman" yang lebih kecil. Ini penting untuk:
- Meningkatkan performa aplikasi (memuat lebih sedikit data)
- Menghemat kuota internet pengguna
- Mengurangi beban di server
- Memberikan pengalaman scrolling yang smooth

### Strategi Pagination: Cursor-Based
Strategi ini menggunakan `cursor` (penanda unik untuk item terakhir) dan `hasNextPage` untuk menentukan apakah ada halaman berikutnya. Ini adalah metode yang paling robust dan direkomendasikan oleh GraphQL.

### Schema untuk Pagination:
**graphql/schema.graphqls**
```graphql
type Post {
  id: ID!
  title: String!
  content: String!
  # ... field lainnya
}

type PageInfo {
  hasNextPage: Boolean!
  endCursor: String
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

type PostEdge {
  node: Post!
  cursor: String!
}

type Query {
  posts(after: String, limit: Int!): PostConnection!
}
```

### Query untuk Pagination:
**graphql/queries/GetPostsPaginated.graphql**
```graphql
query GetPostsPaginated($after: String, $limit: Int!) {
  posts(after: $after, limit: $limit) {
    edges {
      node {
        id
        title
        content
        author {
          name
        }
        likes
      }
      cursor
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
```

### Implementasi dengan Paging 3 Library:
**repository/PostPagingSource.kt**
```kotlin
package com.example.graphql.repository

import androidx.paging.PagingSource
import androidx.paging.PagingState
import com.apollographql.apollo3.ApolloClient
import com.example.graphql.GetPostsPaginatedQuery
import com.example.graphql.domain.model.Post
import javax.inject.Inject

class PostPagingSource @Inject constructor(
    private val apolloClient: ApolloClient
) : PagingSource<String, Post>() {
    
    override suspend fun load(params: LoadParams<String>): LoadResult<String, Post> {
        return try {
            val response = apolloClient.query(
                GetPostsPaginatedQuery(
                    after = params.key, // Cursor untuk halaman berikutnya, null untuk halaman pertama
                    limit = params.loadSize // Jumlah item per halaman
                )
            ).execute()
            
            val posts = response.data?.posts
            val items = posts?.edges?.map { edge ->
                Post(
                    id = edge.node.id,
                    title = edge.node.title,
                    content = edge.node.content,
                    authorName = edge.node.author.name,
                    likes = edge.node.likes
                )
            } ?: emptyList()
            
            LoadResult.Page(
                data = items,
                prevKey = null, // Tidak mendukung navigasi ke halaman sebelumnya
                nextKey = if (posts?.pageInfo?.hasNextPage == true) {
                    posts.pageInfo.endCursor
                } else {
                    null // Tidak ada halaman berikutnya
                }
            )
        } catch (e: Exception) {
            LoadResult.Error(e)
        }
    }
    
    override fun getRefreshKey(state: PagingState<String, Post>): String? {
        // Kunci untuk refresh data, biasanya null
        return null
    }
}
```

### Menggunakan PagingSource di Repository:
**repository/PostRepository.kt**
```kotlin
package com.example.graphql.repository

import androidx.paging.Pager
import androidx.paging.PagingConfig
import androidx.paging.PagingData
import com.apollographql.apollo3.ApolloClient
import com.example.graphql.domain.model.Post
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PostRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Mengembalikan Flow dari PagingData untuk daftar post
     */
    fun getPostsPaged(): Flow<PagingData<Post>> {
        return Pager(
            config = PagingConfig(
                pageSize = 20, // Jumlah item per halaman
                enablePlaceholders = false,
                initialLoadSize = 40 // Jumlah item untuk load awal
            ),
            pagingSourceFactory = { PostPagingSource(apolloClient) }
        ).flow
    }
}
```

### Menampilkan di ViewModel:
**presentation/viewmodel/PagedPostViewModel.kt**
```kotlin
package com.example.graphql.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.paging.PagingData
import com.example.graphql.domain.model.Post
import com.example.graphql.repository.PostRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class PagedPostViewModel @Inject constructor(
    private val postRepository: PostRepository
) : ViewModel() {
    
    val posts: Flow<PagingData<Post>> = postRepository.getPostsPaged()
    
    fun refresh() {
        viewModelScope.launch {
            // Paging library akan otomatis me-refresh data
            // Biasanya dengan memanggil pagingSource.invalidate()
            // Implementasi bisa bervariasi tergantung cara menangani PagingData di UI
        }
    }
}
```

### üéì Penjelasan Konsep:
**Pagination seperti Membaca Buku:**
- **Data**: Buku yang sangat tebal.
- **Page**: Satu halaman dari buku tersebut.
- **Cursor**: Penanda jari kamu di halaman terakhir yang kamu baca.
- **Load Next Page**: Membalik halaman berikutnya.
- **Paging Library**: Asisten yang secara otomatis membalik halaman untukmu saat kamu mencapai akhir halaman.

**Alur Kerja Pagination:**
1.  **Load Awal**: Aplikasi meminta halaman pertama (tanpa `cursor`).
2.  **Tampilkan Data**: Halaman pertama ditampilkan.
3.  **User Scroll**: Pengguna scroll ke akhir daftar.
4.  **Load Berikutnya**: Aplikasi meminta halaman berikutnya dengan `endCursor` dari halaman sebelumnya.
5.  **Gabung Data**: Data baru ditambahkan ke daftar yang ada.
6.  **Ulangi**: Proses berlanjut hingga `hasNextPage` adalah `false`.

**Best Practices:**
- Gunakan **Paging 3 Library** dari Jetpack untuk implementasi yang mudah dan robust di Android.
- Gunakan strategi **cursor-based** untuk stabilitas terbaik.
- Tentukan `pageSize` yang wajar (misalnya, 20-50 item).
- Tampilkan *loading indicator* saat memuat halaman berikutnya.

---

## 1Ô∏è‚É£3Ô∏è‚É£ Optimistic Updates üé≠

### Konsep Dasar
Optimistic Updates seperti sulap üé© - aplikasi langsung menunjukkan hasilnya, padahal si pesulit (server) masih melakukan triknya di belakang layar!

### Pengertian Optimistic Updates:
Optimistic update adalah teknik di mana UI memperbarui dirinya sendiri *sebelum* menerima konfirmasi dari server. Ini memberikan pengalaman pengguna yang sangat responsif.

### Pengertian Optimistic Updates:
Optimistic update adalah teknik di mana UI:
- Memperbarui tampilan *sebelum* mutation selesai
- Mengasumsikan operasi akan berhasil
- Secara otomatis membatalkan perubahan (rollback) jika terjadi error
- Memberikan feedback instan kepada pengguna

### Implementasi Optimistic Updates:
**graphql/mutations/LikePost.graphql**
```graphql
mutation LikePost($id: ID!) {
  likePost(id: $id) {
    id
    title
    likes
  }
}
```

**repository/PostRepository.kt**
```kotlin
package com.example.graphql.repository

import com.apollographql.apollo3.ApolloClient
import com.apollographql.apollo3.api.Optional
import com.example.graphql.LikePostMutation
import com.example.graphql.GetPostByIdQuery
import com.example.graphql.domain.model.Post
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PostRepository @Inject constructor(
    private val apolloClient: ApolloClient
) {
    
    /**
     * Menyukai post dengan optimistic update
     */
    suspend fun likePostOptimistically(post: Post): Result<Post> {
        return try {
            // 1. Buat data optimis (data yang akan ditampilkan di UI sambil menunggu response)
            val optimisticPost = GetPostByIdQuery.Data {
                post = GetPostByIdQuery.Post {
                    id = post.id
                    title = post.title
                    likes = post.likes + 1 // Asumsikan like akan bertambah
                }
            }
            
            // 2. Jalankan mutation dengan update optimis
            val response = apolloClient.mutation(LikePostMutation(id = post.id))
                .optimisticUpdates(optimisticPost) // Fungsi kunci untuk optimistic update
                .execute()
            
            if (response.hasErrors()) {
                // Jika ada error, Apollo akan otomatis rollback cache ke state sebelumnya
                val errorMessage = response.errors?.joinToString { it.message } ?: "Unknown error"
                Result.failure(Exception(errorMessage))
            } else {
                // Jika berhasil, update UI dengan data dari server
                val updatedPost = response.data?.likePost?.let { serverPost ->
                    post.copy(
                        id = serverPost.id,
                        title = serverPost.title,
                        likes = serverPost.likes
                    )
                }
                if (updatedPost != null) {
                    Result.success(updatedPost)
                } else {
                    Result.failure(Exception("Failed to parse server response"))
                }
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### Penggunaan di ViewModel:
**presentation/viewmodel/PostDetailViewModel.kt**
```kotlin
package com.example.graphql.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.graphql.domain.model.Post
import com.example.graphql.repository.PostRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class PostDetailViewModel @Inject constructor(
    private val postRepository: PostRepository
) : ViewModel() {
    
    private val _post = MutableStateFlow<Post?>(null)
    val post: StateFlow<Post?> = _post.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()
    
    fun likePost() {
        val currentPost = _post.value ?: return
        
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            val result = postRepository.likePostOptimistically(currentPost)
            
            result.fold(
                onSuccess = { updatedPost ->
                    // UI sudah diperbarui secara optimis, tinggal update state di ViewModel
                    _post.value = updatedPost
                },
                onFailure = { throwable ->
                    // UI sudah di-rollback oleh Apollo, tinggal tampilkan error
                    _error.value = throwable.message
                }
            )
            
            _isLoading.value = false
        }
    }
}
```

### üéì Penjelasan Konsep:
**Optimistic Updates seperti Sulap:**
- **UI**: Panggung pertunjukan.
- **Mutation**: Trik yang akan dilakukan (misalnya, mengubah kartu As menjadi King).
- **Optimistic Update**: Sulapnya langsung berhasil! Kartu berubah di mata penonton.
- **Server Response**: Asisten membisikkan ke telinga pesulap apakah triknya benar-benar berhasil.
- **Success**: Trik berhasil! Perubahan tetap ada.
- **Failure**: Trik gagal! Pesulap dengan cepat mengembalikan kartu ke keadaan semula (rollback).

**Alur Kerja Optimistic Update:**
1.  **User Action**: Pengguna menekan tombol "Like".
2.  **UI Update (Optimistic)**: UI langsung menampilkan angka like bertambah.
3.  **Cache Update**: Apollo menyimpan state "seolah-olah sudah berhasil" di cache.
4.  **Mutation**: Permintaan mutation dikirim ke server.
5.  **Server Response**: Server merespons dengan data sebenarnya (sukses atau error).
6.  **Cache Resolution**:
    -   **Jika Sukses**: Apollo mengganti data optimis di cache dengan data dari server.
    -   **Jika Gagal**: Apollo menghapus data optimis dan mengembalikan cache ke state sebelum mutation.
7.  **UI Update**: Karena UI mengamati cache, UI akan otomatis diperbarui sesuai resolusi cache.

**Best Practices:**
- Gunakan untuk operasi yang kemungkinan besar berhasil (misalnya, like, follow).
- Jangan gunakan untuk operasi kritis yang sering gagal (misalnya, pembayaran).
- Pastikan UI memberikan indikator loading saat operasi berlangsung.
- Berikan pesan error yang jelas jika operasi gagal.

---

## 1Ô∏è‚É£4Ô∏è‚É£ Best Practices ‚úÖ

### Konsep Dasar
Best Practices seperti aturan main yang sudah disepakati ‚öΩ - memastikan semua pengembang bermain dengan cara yang efektif, efisien, dan adil!

### Daftar Best Practices untuk GraphQL:

#### ‚úÖ Use Fragments untuk Reusability
Gunakan fragment untuk menghindari pengulangan field yang sama di berbagai query. Ini membuat kode lebih bersih, konsisten, dan mudah dikelola.
- **Contoh**: Daripada menulis `{ id, name, avatar }` di setiap query yang membutuhkan data user, buatlah `fragment UserDetails on User { id, name, avatar }` dan gunakan `...UserDetails`.

#### ‚úÖ Request Only Needed Fields
Salah satu keunggulan utama GraphQL adalah mendapatkan hanya data yang dibutuhkan. Manfaatkan ini dengan baik untuk membuat aplikasi lebih ringan dan cepat.
- **Contoh**: Di layar daftar post, mungkin kamu hanya perlu `{ id, title, author { name } }`. Jangan minta field `content` yang panjang jika tidak ditampilkan.

#### ‚úÖ Implement Proper Error Handling
Jangan abaikan error. Tangani error dari GraphQL (`response.hasErrors()`) dan error jaringan (`ApolloException`) dengan baik untuk memberikan pengalaman pengguna yang stabil.
- **Contoh**: Gunakan `Result` wrapper atau `sealed class` untuk mengelola state (Success, Error, Loading) secara konsisten di seluruh aplikasi.

#### ‚úÖ Use Caching Appropriately
Pilih kebijakan cache (`FetchPolicy`) yang sesuai dengan kebutuhan data. Jangan selalu menggunakan `NetworkOnly` jika data tidak berubah sering.
- **Contoh**: Gunakan `CacheFirst` untuk data master (misalnya, daftar kategori). Gunakan `CacheAndNetwork` untuk timeline feed agar responsif.

#### ‚úÖ Leverage Subscriptions untuk Real-Time
Untuk fitur yang membutuhkan update real-time (notifikasi, kolaborasi), gunakan GraphQL Subscriptions daripada polling yang tidak efisien.
- **Contoh**: Untuk fitur chat, gunakan subscription untuk menerima pesan baru tanpa perlu refresh berkala.

#### ‚úÖ Implement Pagination
Jangan muat semua data sekaligus. Gunakan pagination (disarankan cursor-based dengan Paging 3 Library) untuk daftar data yang panjang.
- **Contoh**: Daftar post, komentar, atau hasil pencarian harus menggunakan pagination untuk performa dan penghematan kuota.

#### ‚úÖ Use Variables for Dynamic Queries
Jangan pernah menggabungkan string untuk membuat query dinamis. Gunakan variabel GraphQL yang aman dan tipe-nya terjamin.
- **Contoh**: Gunakan `query GetUser($id: ID!) { user(id: $id) { ... } }` dan lewatkan `id` saat eksekusi, jangan gunakan string interpolation.

#### ‚úÖ Type-Safe with Generated Code
Manfaatkan kode yang di-generate oleh Apollo Plugin. Kode ini type-safe dan akan mencegah banyak error saat kompilasi.
- **Contoh**: Jangan membuat panggilan API secara manual. Selalu gunakan class `GetUserQuery` dan `LikePostMutation` yang sudah di-generate.

#### ‚úÖ Monitor Query Performance
Pantau kompleksitas dan waktu eksekusi query di sisi server. Query yang terlalu kompleks dapat memperlambat aplikasi dan membebani server.
- **Contoh**: Gunakan tools seperti Apollo Studio untuk menganalisis performa query dan mengidentifikasi yang lambat.

#### ‚úÖ Handle Network Errors Gracefully
Aplikasi bisa offline. Tangani kondisi ini dengan menampilkan data dari cache dan memberi tahu pengguna bahwa mereka sedang offline.
- **Contoh**: Tampilkan banner "Anda sedang offline" dan antrikan mutation untuk dijalankan saat koneksi kembali.

### üéì Penjelasan Konsep:
**Best Practices seperti Aturan Main:**
- **Fragments**: "Formasi standar tim" yang bisa digunakan di berbagai strategi.
- **Needed Fields**: "Hanya operasi yang diperlukan" untuk mencetak gol, tidak perlu yang berlebihan.
- **Error Handling**: "Wasit cadangan" yang siap mengambil alih jika wasit utama cedera.
- **Caching**: "Strategi menjaga stamina" dengan tidak berlari terus-menerus.
- **Subscriptions**: "Komunikasi rahasia" antar pemain untuk koordinasi real-time.

---

## 1Ô∏è‚É£5Ô∏è‚É£ Hands-on Project üî®

### Konsep Dasar
Hands-on Project seperti membangun roket üöÄ - menerapkan semua teori untuk menciptakan sesuatu yang luar biasa dan siap meluncur!

### Tujuan Proyek:
Membangun aplikasi sosial media sederhana bernama **"Chit-Chat"** dengan fitur:
- Menampilkan timeline post dengan pagination
- Melihat detail post dan profil user
- Membuat post baru
- Menyukai post (dengan optimistic update)
- Notifikasi real-time untuk post baru (dengan subscription)

### Langkah-Langkah Implementasi:

#### Langkah 1: Setup Proyek
1.  Buat proyek baru di Android Studio dengan template "Empty Activity".
2.  Tambahkan dependensi berikut di `build.gradle.kts` (Module: app):
    ```kotlin
    // Hilt
    implementation("com.google.dagger:hilt-android:2.48")
    kapt("com.google.dagger:hilt-compiler:2.48")
    
    // Apollo GraphQL
    implementation("com.apollographql.apollo3:apollo-runtime:4.0.0")
    implementation("com.apollographql.apollo3:apollo-normalized-cache-sqlite:4.0.0")
    
    // Jetpack Compose
    implementation("androidx.activity:activity-compose:1.8.2")
    implementation(platform("androidx.compose:compose-bom:2023.08.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.material3:material3")
    
    // ViewModel & Coroutines
    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0")
    
    // Paging 3
    implementation("androidx.paging:paging-runtime:3.2.1")
    implementation("androidx.paging:paging-compose:3.2.1")
    ```
3.  Tambahkan plugin Apollo dan konfigurasinya di `build.gradle.kts` (seperti di bagian Setup).
4.  Buat class Application dan anotasi dengan `@HiltAndroidApp`.

#### Langkah 2: Schema & GraphQL Operations
1.  Dapatkan file `schema.graphqls` dari server GraphQL kamu.
2.  Buat file `.graphql` yang diperlukan di `src/main/graphql`:
    -   `GetPostsPaginated.graphql` (untuk timeline)
    -   `CreatePost.graphql`
    -   `LikePost.graphql`
    -   `OnPostAdded.graphql` (untuk subscription)
    -   `GetUserById.graphql`

#### Langkah 3: Setup Apollo Client & DI
1.  Buat `ApolloClientModule` (seperti di bagian Setup) untuk menyediakan `ApolloClient` dengan Hilt.
2.  Konfigurasikan `ApolloClient` dengan `SQLiteNormalizedCacheFactory` dan `WebSocketNetworkTransport`.

#### Langkah 4: Repository Layer
1.  **`PostRepository.kt`**:
    -   Buat `PostPagingSource` untuk pagination timeline.
    -   Buat fungsi `createPost()` untuk menjalankan mutation.
    -   Buat fungsi `likePostOptimistically()` untuk optimistic update.
    -   Buat fungsi `subscribeToNewPosts()` yang mengembalikan `Flow<Post>`.
2.  **`UserRepository.kt`**:
    -   Buat fungsi `getUserById()` untuk query data user.

#### Langkah 5: ViewModel Layer
1.  **`TimelineViewModel.kt`**:
    -   Gunakan `Pager` untuk membuat `Flow<PagingData<Post>>` dari `PostPagingSource`.
    -   Di `init`, mulai `viewModelScope.launch` untuk mengumpulkan aliran dari `subscribeToNewPosts()` dan perbarui `PagingData` saat post baru masuk.
2.  **`PostDetailViewModel.kt`**:
    -   Simpan state `Post` saat ini.
    -   Implementasikan fungsi `likePost()` yang memanggil repository.
    -   Implementasikan fungsi `createPost()`.

#### Langkah 6: UI Layer (Jetpack Compose)
1.  **`TimelineScreen.kt`**:
    -   Gunakan `LazyPagingItems()` untuk menampilkan daftar post dari `PagingData`.
    -   Tampilkan loading indicator di footer saat memuat halaman berikutnya.
2.  **`PostItem.kt`**:
    -   Tampilkan judul, konten, author, dan jumlah like.
    -   Tombol "Like" akan memanggil `viewModel.likePost()`. Karena menggunakan optimistic update, UI akan langsung berubah tanpa menunggu.
3.  **`CreatePostDialog.kt`**:
    -   Tampilkan field untuk memasukkan judul dan konten.
    -   Tombol "Post" akan memanggil `viewModel.createPost()`.

#### Langkah 7: Integrasi dan Testing
1.  Hubungkan semua layar dengan Navigation Compose.
2.  Uji aplikasi:
    -   Scrolling timeline untuk memastikan pagination bekerja.
    -   Membuat post baru dan melihatnya muncul di timeline.
    -   Menekan "Like" dan melihat angka berubah secara instan.
    -   (Jika memiliki server real-time) Buka aplikasi di dua perangkat, buat post di satu perangkat, dan lihat post itu muncul di perangkat lainnya secara otomatis.

### üéì Penjelasan Konsep:
**Hands-on Project seperti Membangun Roket:**
- **Teori**: Buku panduan fisika dan teknik kedirgantaraan.
- **Dependencies**: Bahan-bahan bakar dan logam.
- **Setup**: Merancang blueprint di komputer.
- **Repository**: Mesin dan sistem propulsi.
- **ViewModel**: Kokpit dengan semua tombol kontrol.
- **UI**: Badan roket dan jendela pandang.
- **Testing**: Simulasi penerbangan sebelum peluncuran sesungguhnya.

---

## üéØ Kesimpulan

Selamat! üéâ Anda telah menyelesaikan perjalanan intensif mempelajari **GraphQL di Android dengan Apollo Client**. Anda kini dibekali dengan keterampilan untuk:

- **Memahami Paradigma Baru**: Anda tahu persis perbedaan antara REST dan GraphQL, dan kapan harus menggunakan masing-masing.
- **Menulis Query & Mutation yang Efisien**: Anda bisa meminta data yang tepat yang dibutuhkan, tidak lebih dan tidak kurang.
- **Membangun Aplikasi yang Responsif**: Dengan optimistic updates dan caching, aplikasi Anda akan terasa sangat cepat.
- **Mengimplementasikan Fitur Real-Time**: Anda bisa menambahkan fitur canggih seperti notifikasi langsung dengan subscriptions.
- **Mengelola Data dengan Mudah**: Pagination dan error handling yang baik membuat aplikasi Anda stabil dan dapat diandalkan.

Dengan kekuatan GraphQL dan Apollo Client, Anda siap untuk membangun aplikasi Android modern yang lebih efisien, kuat, dan memberikan pengalaman pengguna yang luar biasa. Teruslah bereksperimen, bangun proyek-proyek menakjubkan, dan nikmati kemudahan yang ditawarkan oleh ekosistem GraphQL