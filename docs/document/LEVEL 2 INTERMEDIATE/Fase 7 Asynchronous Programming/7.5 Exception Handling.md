## **7.5 Exception Handling** (3 hari) ⭐⭐⭐

### **Teknologi Modern:**
- CoroutineExceptionHandler
- supervisorScope
- try-catch dalam coroutines
- Flow error handling

### **Teknologi yang Ditinggalkan:**
- Unhandled crashes
- Thread.UncaughtExceptionHandler

### **Sub-topik Detail:**

#### **1. Basic Exception Handling**

**try-catch dalam Coroutines:**
```kotlin
class UserViewModel : ViewModel() {
    fun loadUser(userId: String) {
        viewModelScope.launch {
            try {
                _uiState.value = UiState.Loading
                val user = repository.getUser(userId)
                _uiState.value = UiState.Success(user)
            } catch (e: IOException) {
                _uiState.value = UiState.Error("Network error: ${e.message}")
            } catch (e: HttpException) {
                _uiState.value = UiState.Error("Server error: ${e.code()}")
            } catch (e: Exception) {
                _uiState.value = UiState.Error("Unknown error: ${e.message}")
            }
        }
    }
}
```

**Multiple Calls dengan Error Handling:**
```kotlin
suspend fun loadCompleteProfile(userId: String): Result<UserProfile> {
    return try {
        val user = api.getUser(userId)
        val posts = api.getUserPosts(userId)
        val followers = api.getFollowers(userId)
        
        Result.success(UserProfile(user, posts, followers))
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

**Finally Block:**
```kotlin
fun loadData() {
    viewModelScope.launch {
        try {
            showLoading()
            val data = repository.getData()
            displayData(data)
        } catch (e: Exception) {
            showError(e.message)
        } finally {
            hideLoading() // Always executes
        }
    }
}
```

#### **2. CoroutineExceptionHandler**

**Basic Usage:**
```kotlin
val exceptionHandler = CoroutineExceptionHandler { context, exception ->
    Log.e("Coroutine", "Caught exception: $exception")
    // Send to crash reporting
    FirebaseCrashlytics.getInstance().recordException(exception)
}

val scope = CoroutineScope(Dispatchers.Main + exceptionHandler)

scope.launch {
    // Uncaught exceptions handled by exceptionHandler
    throw RuntimeException("Something went wrong")
}
```

**With ViewModel:**
```kotlin
class MyViewModel : ViewModel() {
    private val exceptionHandler = CoroutineExceptionHandler { _, exception ->
        _uiState.value = UiState.Error(exception.message ?: "Unknown error")
        Log.e("MyViewModel", "Error occurred", exception)
    }
    
    private val viewModelScope = CoroutineScope(
        viewModelScope.coroutineContext + exceptionHandler
    )
    
    fun loadData() {
        viewModelScope.launch {
            val data = repository.getData() // Exceptions caught by handler
            _uiState.value = UiState.Success(data)
        }
    }
}
```

**Multiple Handlers:**
```kotlin
class AppCoroutineScope {
    private val networkHandler = CoroutineExceptionHandler { _, exception ->
        when (exception) {
            is IOException -> Log.e("Network", "Network error", exception)
            is HttpException -> Log.e("Network", "HTTP ${exception.code()}", exception)
        }
    }
    
    private val databaseHandler = CoroutineExceptionHandler { _, exception ->
        Log.e("Database", "Database error", exception)
    }
    
    val networkScope = CoroutineScope(Dispatchers.IO + networkHandler)
    val dbScope = CoroutineScope(Dispatchers.IO + databaseHandler)
}
```

#### **3. SupervisorJob & supervisorScope**

**SupervisorJob:**
```kotlin
// Child failures don't affect siblings
val supervisor = SupervisorJob()
val scope = CoroutineScope(Dispatchers.Main + supervisor)

scope.launch {
    throw Exception("Child 1 failed")
}

scope.launch {
    delay(1000)
    println("Child 2 still running") // This will run
}
```

**supervisorScope:**
```kotlin
suspend fun loadMultipleResources() {
    supervisorScope {
        // Independent child coroutines
        val user = async {
            try {
                api.getUser()
            } catch (e: Exception) {
                User.default()
            }
        }
        
        val posts = async {
            try {
                api.getPosts()
            } catch (e: Exception) {
                emptyList()
            }
        }
        
        val settings = async {
            try {
                api.getSettings()
            } catch (e: Exception) {
                Settings.default()
            }
        }
        
        // One failure doesn't cancel others
        UserProfile(user.await(), posts.await(), settings.await())
    }
}
```

**ViewModel with SupervisorScope:**
```kotlin
class DashboardViewModel : ViewModel() {
    private val supervisor = SupervisorJob()
    private val scope = CoroutineScope(viewModelScope.coroutineContext + supervisor)
    
    fun loadDashboard() {
        scope.launch {
            supervisorScope {
                // Load multiple sections independently
                launch { loadUserSection() }
                launch { loadPostsSection() }
                launch { loadStatsSection() }
            }
        }
    }
    
    private suspend fun loadUserSection() {
        try {
            val user = repository.getUser()
            _userState.value = UiState.Success(user)
        } catch (e: Exception) {
            _userState.value = UiState.Error(e.message)
        }
    }
}
```

#### **4. Cancellation Exception**

**Handling Cancellation:**
```kotlin
suspend fun doWork() {
    try {
        repeat(1000) { i ->
            delay(100)
            println("Working: $i")
        }
    } catch (e: CancellationException) {
        println("Work was cancelled")
        // Don't catch and suppress - re-throw it
        throw e
    } catch (e: Exception) {
        println("Other error: $e")
    }
}
```

**Cleanup on Cancellation:**
```kotlin
suspend fun downloadFile(url: String): File {
    val tempFile = createTempFile()
    
    try {
        val bytes = api.downloadFile(url)
        tempFile.writeBytes(bytes)
        return tempFile
    } catch (e: CancellationException) {
        // Cleanup before cancellation
        withContext(NonCancellable) {
            tempFile.delete()
        }
        throw e
    }
}
```

**NonCancellable Context:**
```kotlin
val job = launch {
    try {
        performWork()
    } finally {
        // This cleanup will run even if cancelled
        withContext(NonCancellable) {
            saveState()
            cleanup()
        }
    }
}

job.cancel()
```

#### **5. Flow Error Handling**

**catch Operator:**
```kotlin
fun getUserData(userId: String): Flow<UserData> = flow {
    val user = api.getUser(userId)
    val posts = api.getUserPosts(userId)
    emit(UserData(user, posts))
}.catch { exception ->
    // Handle exception
    Log.e("Flow", "Error loading user data", exception)
    
    // Emit fallback value
    emit(UserData.empty())
    
    // Or emit error state
    // emit(UserData.error(exception.message))
}
```

**Catch Specific Exceptions:**
```kotlin
dataFlow
    .catch { e ->
        when (e) {
            is IOException -> {
                Log.e("Flow", "Network error", e)
                emit(cachedData)
            }
            is HttpException -> {
                Log.e("Flow", "HTTP ${e.code()}", e)
                emit(Data.error(e.code()))
            }
            else -> {
                // Re-throw unknown exceptions
                throw e
            }
        }
    }
    .collect { data ->
        updateUI(data)
    }
```

**Multiple catch Blocks:**
```kotlin
fun loadData(): Flow<Data> = flow {
    emit(database.getData())
}
    .map { processData(it) }
    .catch { e ->
        Log.e("Process", "Processing failed", e)
        throw e // Re-throw to next catch
    }
    .catch { e ->
        Log.e("Flow", "Overall failure", e)
        emit(Data.error())
    }
```

**retry & retryWhen:**
```kotlin
// Simple retry
fun fetchData(): Flow<Data> = flow {
    emit(api.getData())
}.retry(3) // Retry up to 3 times

// Conditional retry
fun fetchDataWithCondition(): Flow<Data> = flow {
    emit(api.getData())
}.retry(3) { cause ->
    // Only retry on network errors
    cause is IOException
}

// Retry with exponential backoff
fun fetchDataWithBackoff(): Flow<Data> = flow {
    emit(api.getData())
}.retryWhen { cause, attempt ->
    if (cause is IOException && attempt < 3) {
        delay(1000 * (attempt + 1))
        true
    } else {
        false
    }
}
```

#### **6. Error States & Sealed Classes**

**Result Wrapper:**
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()
    object Loading : Result<Nothing>()
}

class UserRepository {
    suspend fun getUser(id: String): Result<User> {
        return try {
            val user = api.getUser(id)
            Result.Success(user)
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
}

// Usage in ViewModel
class UserViewModel : ViewModel() {
    private val _uiState = MutableStateFlow<Result<User>>(Result.Loading)
    val uiState: StateFlow<Result<User>> = _uiState.asStateFlow()
    
    fun loadUser(id: String) {
        viewModelScope.launch {
            _uiState.value = Result.Loading
            _uiState.value = repository.getUser(id)
        }
    }
}
```

**UiState with Error:**
```kotlin
sealed class UiState<out T> {
    object Idle : UiState<Nothing>()
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(
        val message: String,
        val throwable: Throwable? = null,
        val retry: (() -> Unit)? = null
    ) : UiState<Nothing>()
}

class ProductViewModel : ViewModel() {
    private val _uiState = MutableStateFlow<UiState<List<Product>>>(UiState.Idle)
    val uiState: StateFlow<UiState<List<Product>>> = _uiState.asStateFlow()
    
    fun loadProducts() {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            try {
                val products = repository.getProducts()
                _uiState.value = UiState.Success(products)
            } catch (e: Exception) {
                _uiState.value = UiState.Error(
                    message = e.message ?: "Unknown error",
                    throwable = e,
                    retry = { loadProducts() }
                )
            }
        }
    }
}
```

#### **7. Network Error Handling**

**HTTP Error Codes:**
```kotlin
sealed class NetworkError : Exception() {
    object NoInternet : NetworkError()
    data class ServerError(val code: Int, val message: String) : NetworkError()
    data class ClientError(val code: Int, val message: String) : NetworkError()
    object Timeout : NetworkError()
    object Unknown : NetworkError()
}

suspend fun safeApiCall(apiCall: suspend () -> Response): Result<Response> {
    return try {
        val response = withTimeout(30.seconds) {
            apiCall()
        }
        
        when (response.code()) {
            in 200..299 -> Result.Success(response)
            in 400..499 -> Result.Error(NetworkError.ClientError(response.code(), response.message()))
            in 500..599 -> Result.Error(NetworkError.ServerError(response.code(), response.message()))
            else -> Result.Error(NetworkError.Unknown)
        }
    } catch (e: IOException) {
        Result.Error(NetworkError.NoInternet)
    } catch (e: TimeoutCancellationException) {
        Result.Error(NetworkError.Timeout)
    } catch (e: Exception) {
        Result.Error(NetworkError.Unknown)
    }
}
```

**Retry Strategy:**
```kotlin
class RetryStrategy {
    suspend fun <T> retryWithExponentialBackoff(
        times: Int = 3,
        initialDelay: Long = 1000,
        maxDelay: Long = 10000,
        factor: Double = 2.0,
        block: suspend () -> T
    ): T {
        var currentDelay = initialDelay
        repeat(times - 1) { attempt ->
            try {
                return block()
            } catch (e: Exception) {
                if (e is CancellationException) throw e
                
                Log.w("Retry", "Attempt ${attempt + 1} failed", e)
                delay(currentDelay)
                currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)
            }
        }
        return block() // Last attempt
    }
}

// Usage
suspend fun fetchData(): Data {
    return retryStrategy.retryWithExponentialBackoff {
        api.getData()
    }
}
```

#### **8. Database Error Handling**

**Safe Database Operations:**
```kotlin
class UserRepository(private val userDao: UserDao) {
    
    suspend fun insertUser(user: User): Result<Unit> {
        return try {
            withContext(Dispatchers.IO) {
                userDao.insert(user)
            }
            Result.Success(Unit)
        } catch (e: SQLiteConstraintException) {
            Result.Error(DatabaseError.DuplicateEntry)
        } catch (e: SQLiteException) {
            Result.Error(DatabaseError.DatabaseCorrupted)
        } catch (e: Exception) {
            Result.Error(DatabaseError.Unknown(e))
        }
    }
    
    suspend fun getUser(id: String): Result<User> {
        return try {
            withContext(Dispatchers.IO) {
                val user = userDao.getUserById(id)
                if (user != null) {
                    Result.Success(user)
                } else {
                    Result.Error(DatabaseError.NotFound)
                }
            }
        } catch (e: Exception) {
            Result.Error(DatabaseError.Unknown(e))
        }
    }
}

sealed class DatabaseError : Exception() {
    object DuplicateEntry : DatabaseError()
    object NotFound : DatabaseError()
    object DatabaseCorrupted : DatabaseError()
    data class Unknown(val cause: Throwable) : DatabaseError()
}
```

#### **9. Logging & Analytics**

**Comprehensive Error Logging:**
```kotlin
class ErrorLogger {
    fun log Error(
        tag: String,
        message: String,
        throwable: Throwable,
        context: Map<String, Any> = emptyMap()
    ) {
        // Log to Logcat
        Log.e(tag, message, throwable)
        
        // Send to Crash Reporting
        FirebaseCrashlytics.getInstance().apply {
            setCustomKey("error_context", context.toString())
            recordException(throwable)
        }
        
        // Send to Analytics
        FirebaseAnalytics.getInstance().logEvent("error_occurred") {
            param("error_type", throwable::class.simpleName ?: "Unknown")
            param("error_message", message)
        }
    }
}

// Usage in ViewModel
class MyViewModel(private val errorLogger: ErrorLogger) : ViewModel() {
    fun loadData() {
        viewModelScope.launch {
            try {
                val data = repository.getData()
                _uiState.value = UiState.Success(data)
            } catch (e: Exception) {
                errorLogger.logError(
                    tag = "MyViewModel",
                    message = "Failed to load data",
                    throwable = e,
                    context = mapOf(
                        "user_id" to currentUserId,
                        "timestamp" to System.currentTimeMillis()
                    )
                )
                _uiState.value = UiState.Error(e.message)
            }
        }
    }
}
```

#### **10. Testing Error Scenarios**

**Test Error Handling:**
```kotlin
@Test
fun `loadUser handles network error correctly`() = runTest {
    // Given
    val exception = IOException("Network error")
    val repository = mockRepository(throwsException = exception)
    val viewModel = UserViewModel(repository)
    
    // When
    viewModel.loadUser("123")
    advanceUntilIdle()
    
    // Then
    val state = viewModel.uiState.value
    assertTrue(state is UiState.Error)
    assertEquals("Network error", (state as UiState.Error).message)
}

@Test
fun `retry mechanism works correctly`() = runTest {
    var attempts = 0
    val data = retryWithExponentialBackoff(times = 3) {
        attempts++
        if (attempts < 3) {
            throw IOException("Temporary error")
        }
        "Success"
    }
    
    assertEquals(3, attempts)
    assertEquals("Success", data)
}
```

#### **11. Best Practices**
✅ Always handle exceptions in coroutines
✅ Use try-catch untuk expected errors
✅ Use CoroutineExceptionHandler untuk unexpected errors
✅ Use supervisorScope untuk independent operations
✅ Never catch CancellationException without re-throwing
✅ Log errors dengan proper context
✅ Provide user-friendly error messages
✅ Implement retry logic untuk transient errors
✅ Test error scenarios
✅ Use sealed classes untuk error states

#### **12. Hands-on Exercises**
- Implement comprehensive error handling dalam ViewModel
- Create retry mechanism dengan exponential backoff
- Build error logging system
- Handle network errors dengan user feedback
- Implement supervisorScope untuk parallel operations
- Create error recovery strategies
- Write tests untuk error scenarios
- Build error tracking dengan Firebase Crashlytics

---
