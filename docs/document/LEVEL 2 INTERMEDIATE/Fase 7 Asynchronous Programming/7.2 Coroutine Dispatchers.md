## **7.2 Coroutine Dispatchers** (3 hari) ⭐⭐⭐

### **Teknologi Modern:**
- Dispatchers.Main
- Dispatchers.IO
- Dispatchers.Default
- Custom Dispatchers

### **Teknologi yang Ditinggalkan:**
- Thread pools manual
- HandlerThread
- AsyncTask thread management

### **Sub-topik Detail:**

#### **1. Pengenalan Dispatchers**
- Apa itu Dispatchers
- Thread pools di balik dispatchers
- Kapan menggunakan dispatcher yang tepat
- Performance implications
- Default dispatcher selection

**Dispatcher Types:**
- **Main**: UI operations
- **IO**: Network, database, file operations
- **Default**: CPU-intensive work
- **Unconfined**: Advanced use cases

#### **2. Dispatchers.Main**

**UI Thread Operations:**
```kotlin
class MainActivity : AppCompatActivity() {
    
    fun loadData() {
        lifecycleScope.launch(Dispatchers.Main) {
            // Update UI
            progressBar.visibility = View.VISIBLE
            
            // Fetch data on IO thread
            val data = withContext(Dispatchers.IO) {
                repository.fetchData()
            }
            
            // Back to Main thread automatically
            textView.text = data
            progressBar.visibility = View.GONE
        }
    }
}
```

**Main.immediate:**
```kotlin
lifecycleScope.launch {
    // Already on Main thread
    
    withContext(Dispatchers.Main.immediate) {
        // Doesn't switch if already on Main
        // More efficient
        updateUI()
    }
}
```

#### **3. Dispatchers.IO**

**Network Operations:**
```kotlin
suspend fun fetchUserData(userId: String): User {
    return withContext(Dispatchers.IO) {
        // Network call
        apiService.getUser(userId)
    }
}
```

**Database Operations:**
```kotlin
class UserRepository(private val userDao: UserDao) {
    
    suspend fun insertUser(user: User) {
        withContext(Dispatchers.IO) {
            userDao.insert(user)
        }
    }
    
    suspend fun getAllUsers(): List<User> {
        return withContext(Dispatchers.IO) {
            userDao.getAllUsers()
        }
    }
}
```

**File Operations:**
```kotlin
suspend fun saveToFile(data: String, file: File) {
    withContext(Dispatchers.IO) {
        file.writeText(data)
    }
}

suspend fun readFromFile(file: File): String {
    return withContext(Dispatchers.IO) {
        file.readText()
    }
}
```

**Parallel IO Operations:**
```kotlin
suspend fun loadUserProfile(userId: String): UserProfile {
    return withContext(Dispatchers.IO) {
        coroutineScope {
            val user = async { userDao.getUser(userId) }
            val posts = async { postDao.getUserPosts(userId) }
            val followers = async { followDao.getFollowers(userId) }
            
            UserProfile(
                user = user.await(),
                posts = posts.await(),
                followers = followers.await()
            )
        }
    }
}
```

#### **4. Dispatchers.Default**

**CPU-Intensive Work:**
```kotlin
suspend fun processImage(bitmap: Bitmap): Bitmap {
    return withContext(Dispatchers.Default) {
        // Heavy image processing
        val matrix = ColorMatrix()
        matrix.setSaturation(0f)
        
        val paint = Paint()
        paint.colorFilter = ColorMatrixColorFilter(matrix)
        
        val result = Bitmap.createBitmap(
            bitmap.width,
            bitmap.height,
            bitmap.config
        )
        
        val canvas = Canvas(result)
        canvas.drawBitmap(bitmap, 0f, 0f, paint)
        
        result
    }
}
```

**Sorting Large Data:**
```kotlin
suspend fun sortLargeList(items: List<Item>): List<Item> {
    return withContext(Dispatchers.Default) {
        items.sortedWith(
            compareBy<Item> { it.priority }
                .thenBy { it.name }
        )
    }
}
```

**Complex Calculations:**
```kotlin
suspend fun calculateStatistics(data: List<Double>): Statistics {
    return withContext(Dispatchers.Default) {
        val mean = data.average()
        val variance = data.map { (it - mean).pow(2) }.average()
        val stdDev = sqrt(variance)
        
        Statistics(mean, variance, stdDev)
    }
}
```

**Parsing Large JSON:**
```kotlin
suspend fun parseJsonData(jsonString: String): List<Item> {
    return withContext(Dispatchers.Default) {
        Gson().fromJson(
            jsonString,
            object : TypeToken<List<Item>>() {}.type
        )
    }
}
```

#### **5. Switching Between Dispatchers**

**withContext Pattern:**
```kotlin
class DataProcessor {
    
    suspend fun processAndSave(rawData: String) {
        // Start on Main thread
        showLoading()
        
        // Switch to Default for CPU work
        val processed = withContext(Dispatchers.Default) {
            processData(rawData)
        }
        
        // Switch to IO for database
        withContext(Dispatchers.IO) {
            database.save(processed)
        }
        
        // Back to Main for UI
        hideLoading()
        showSuccess()
    }
}
```

**Multiple Context Switches:**
```kotlin
suspend fun complexOperation() {
    // Main thread
    updateUI("Starting...")
    
    // IO for network
    val apiData = withContext(Dispatchers.IO) {
        apiService.getData()
    }
    
    // Default for processing
    val processed = withContext(Dispatchers.Default) {
        processData(apiData)
    }
    
    // IO for database
    withContext(Dispatchers.IO) {
        database.insert(processed)
    }
    
    // IO for file
    withContext(Dispatchers.IO) {
        saveToFile(processed)
    }
    
    // Back to Main
    updateUI("Complete!")
}
```

#### **6. Custom Dispatchers**

**Limited Thread Pool:**
```kotlin
class ImageProcessor {
    // Only 2 threads for image processing
    private val imageDispatcher = Dispatchers.IO.limitedParallelism(2)
    
    suspend fun processImages(images: List<Bitmap>): List<Bitmap> {
        return images.map { bitmap ->
            withContext(imageDispatcher) {
                processImage(bitmap)
            }
        }
    }
}
```

**Single Thread Dispatcher:**
```kotlin
class DatabaseManager {
    // Serialize all database operations
    private val dbDispatcher = Dispatchers.IO.limitedParallelism(1)
    
    suspend fun performTransaction() {
        withContext(dbDispatcher) {
            database.transaction {
                // All operations on single thread
            }
        }
    }
}
```

**Custom Thread Pool:**
```kotlin
val customDispatcher = Executors.newFixedThreadPool(4).asCoroutineDispatcher()

lifecycleScope.launch {
    withContext(customDispatcher) {
        // Work on custom thread pool
    }
}

// Don't forget to close
customDispatcher.close()
```

#### **7. Dispatcher Best Practices**

**DO:**
```kotlin
// ✅ Use appropriate dispatcher
suspend fun fetchAndProcess() {
    val data = withContext(Dispatchers.IO) {
        apiService.getData()
    }
    
    val processed = withContext(Dispatchers.Default) {
        processData(data)
    }
}

// ✅ Let caller decide context
suspend fun getData(): Data {
    // No dispatcher specified
    return apiService.getData()
}

// ✅ Use limitedParallelism for controlled concurrency
private val limitedDispatcher = Dispatchers.IO.limitedParallelism(3)
```

**DON'T:**
```kotlin
// ❌ Don't use Dispatchers.Main for heavy work
withContext(Dispatchers.Main) {
    heavyComputation() // Blocks UI!
}

// ❌ Don't hardcode dispatcher if not necessary
suspend fun getData() {
    withContext(Dispatchers.IO) {
        // Let caller control context
    }
}

// ❌ Don't use Default for IO operations
withContext(Dispatchers.Default) {
    database.query() // Use IO instead
}
```

#### **8. Performance Considerations**

**Thread Pool Sizes:**
```kotlin
// IO Dispatcher: 64 threads or number of cores (whichever is larger)
// Default Dispatcher: Number of CPU cores (minimum 2)

fun checkDispatcherInfo() {
    println("CPU cores: ${Runtime.getRuntime().availableProcessors()}")
    // Use this info to decide custom dispatchers
}
```

**Measuring Performance:**
```kotlin
suspend fun measureOperation() {
    val time = measureTimeMillis {
        withContext(Dispatchers.Default) {
            heavyOperation()
        }
    }
    println("Operation took: $time ms")
}
```

#### **9. Testing with Dispatchers**

**Test Dispatcher:**
```kotlin
@ExperimentalCoroutinesApi
class RepositoryTest {
    
    private val testDispatcher = UnconfinedTestDispatcher()
    
    @Before
    fun setup() {
        Dispatchers.setMain(testDispatcher)
    }
    
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
    
    @Test
    fun `test fetch data`() = runTest {
        val repository = UserRepository(api, testDispatcher)
        val result = repository.fetchUser("123")
        assertEquals(expectedUser, result)
    }
}
```

**Inject Dispatchers for Testing:**
```kotlin
class UserRepository(
    private val api: ApiService,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) {
    suspend fun getUser(id: String): User {
        return withContext(ioDispatcher) {
            api.getUser(id)
        }
    }
}

// In test
val testRepository = UserRepository(mockApi, UnconfinedTestDispatcher())
```

#### **10. Common Patterns**

**Repository Pattern with Dispatchers:**
```kotlin
class ProductRepository(
    private val api: ApiService,
    private val dao: ProductDao,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) {
    suspend fun getProduct(id: String): Product {
        return withContext(ioDispatcher) {
            // Try cache first
            val cached = dao.getProduct(id)
            if (cached != null && !cached.isStale()) {
                return@withContext cached
            }
            
            // Fetch from network
            val product = api.getProduct(id)
            dao.insert(product)
            product
        }
    }
    
    suspend fun searchProducts(query: String): List<Product> {
        return withContext(ioDispatcher) {
            api.searchProducts(query)
        }
    }
}
```

**ViewModel with Dispatchers:**
```kotlin
class ProductViewModel(
    private val repository: ProductRepository,
    private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default
) : ViewModel() {
    
    fun searchProducts(query: String) {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            
            try {
                // Network call on IO (handled by repository)
                val products = repository.searchProducts(query)
                
                // Heavy filtering on Default
                val filtered = withContext(defaultDispatcher) {
                    products.filter { it.matchesAdvancedCriteria(query) }
                        .sortedBy { it.relevanceScore(query) }
                }
                
                _uiState.value = UiState.Success(filtered)
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message)
            }
        }
    }
}
```

#### **11. Hands-on Exercises**
- Implement repository dengan proper dispatchers
- Buat image processing dengan Dispatchers.Default
- Optimize database operations dengan IO dispatcher
- Create custom limited dispatcher
- Measure performance dengan different dispatchers
- Write tests dengan TestDispatcher
- Implement complex multi-dispatcher flow
- Benchmark IO vs Default untuk different operations

---
