## **7.12 Logging Strategy** (2 hari) ⭐⭐

### **Teknologi Modern:**
- Timber
- Kermit
- Structured logging
- Remote logging (Firebase Crashlytics)

### **Teknologi yang Ditinggalkan:**
- println() everywhere
- Log.d/e/i tanpa tag
- No logging strategy

### **Sub-topik Detail:**

#### **1. Timber Setup**

**Dependencies:**
```kotlin
dependencies {
    implementation("com.jakewharton.timber:timber:5.0.1")
}
```

**Application Class:**
```kotlin
class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()
        
        if (BuildConfig.DEBUG) {
            Timber.plant(Timber.DebugTree())
        } else {
            Timber.plant(ReleaseTree())
        }
    }
}

class ReleaseTree : Timber.Tree() {
    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {
        if (priority == Log.ERROR || priority == Log.WARN) {
            // Send to crash reporting
            FirebaseCrashlytics.getInstance().log(message)
            t?.let { FirebaseCrashlytics.getInstance().recordException(it) }
        }
    }
}
```

#### **2. Timber Usage**

**Basic Logging:**
```kotlin
// Debug
Timber.d("User clicked button")

// Info
Timber.i("API call completed successfully")

// Warning
Timber.w("Cache miss, fetching from network")

// Error
Timber.e("Failed to load data")

// With exception
try {
    performOperation()
} catch (e: Exception) {
    Timber.e(e, "Operation failed")
}

// With formatting
Timber.d("User %s logged in at %d", userName, timestamp)
```

**Tagging:**
```kotlin
// Automatic tag from class name
class UserRepository {
    init {
        Timber.tag("UserRepo").d("Repository initialized")
    }
}

// Manual tag
Timber.tag("Network").d("Request: $url")
```

#### **3. Custom Trees**

**File Logging Tree:**
```kotlin
class FileLoggingTree(private val context: Context) : Timber.Tree() {
    private val logFile = File(context.filesDir, "app_logs.txt")
    
    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {
        val priorityString = when (priority) {
            Log.VERBOSE -> "V"
            Log.DEBUG -> "D"
            Log.INFO -> "I"
            Log.WARN -> "W"
            Log.ERROR -> "E"
            else -> "?"
        }
        
        val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US)
            .format(Date())
        
        val logMessage = "$timestamp $priorityString/$tag: $message\n"
        
        try {
            logFile.appendText(logMessage)
        } catch (e: IOException) {
            Log.e("FileLoggingTree", "Failed to write log", e)
        }
    }
}
```

**Network Logging Tree:**
```kotlin
class NetworkLoggingTree(private val apiService: LoggingApiService) : Timber.Tree() {
    private val logs = mutableListOf<LogEntry>()
    
    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {
        if (priority >= Log.WARN) {
            logs.add(LogEntry(priority, tag, message, t))
            
            if (logs.size >= 10) {
                sendLogs()
            }
        }
    }
    
    private fun sendLogs() {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                apiService.sendLogs(logs)
                logs.clear()
            } catch (e: Exception) {
                // Handle error
            }
        }
    }
}
```

#### **4. Structured Logging**

**Log Data Classes:**
```kotlin
data class NetworkLog(
    val url: String,
    val method: String,
    val statusCode: Int,
    val duration: Long,
    val error: String? = null
)

fun logNetworkRequest(log: NetworkLog) {
    Timber.tag("Network").i(
        "Request: ${log.method} ${log.url} - ${log.statusCode} (${log.duration}ms)"
    )
    log.error?.let { Timber.tag("Network").e(it) }
}
```

**Event Logging:**
```kotlin
sealed class AppEvent {
    data class UserLogin(val userId: String) : AppEvent()
    data class ScreenView(val screenName: String) : AppEvent()
    data class ButtonClick(val buttonId: String) : AppEvent()
    data class ApiError(val endpoint: String, val error: String) : AppEvent()
}

object EventLogger {
    fun log(event: AppEvent) {
        when (event) {
            is AppEvent.UserLogin -> 
                Timber.i("User logged in: ${event.userId}")
            is AppEvent.ScreenView -> 
                Timber.d("Screen viewed: ${event.screenName}")
            is AppEvent.ButtonClick -> 
                Timber.d("Button clicked: ${event.buttonId}")
            is AppEvent.ApiError -> 
                Timber.e("API error at ${event.endpoint}: ${event.error}")
        }
    }
}
```

#### **5. OkHttp Logging Interceptor**

**Setup:**
```kotlin
val loggingInterceptor = HttpLoggingInterceptor().apply {
    level = if (BuildConfig.DEBUG) {
        HttpLoggingInterceptor.Level.BODY
    } else {
        HttpLoggingInterceptor.Level.NONE
    }
}

val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(loggingInterceptor)
    .build()
```

**Custom Network Logger:**
```kotlin
class TimberHttpLoggingInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val startTime = System.currentTimeMillis()
        
        Timber.tag("OkHttp").d("→ ${request.method} ${request.url}")
        
        val response = try {
            chain.proceed(request)
        } catch (e: Exception) {
            Timber.tag("OkHttp").e(e, "← HTTP FAILED")
            throw e
        }
        
        val duration = System.currentTimeMillis() - startTime
        Timber.tag("OkHttp").d(
            "← ${response.code} ${request.url} (${duration}ms)"
        )
        
        return response
    }
}
```

#### **6. Firebase Crashlytics Integration**

**Setup:**
```kotlin
dependencies {
    implementation(platform("com.google.firebase:firebase-bom:32.7.0"))
    implementation("com.google.firebase:firebase-crashlytics-ktx")
    implementation("com.google.firebase:firebase-analytics-ktx")
}
```

**Usage:**
```kotlin
class CrashlyticsTree : Timber.Tree() {
    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {
        if (priority == Log.ERROR || priority == Log.WARN) {
            val crashlytics = FirebaseCrashlytics.getInstance()
            
            crashlytics.log("$priority/$tag: $message")
            
            t?.let { crashlytics.recordException(it) }
        }
    }
}

// Set user info
FirebaseCrashlytics.getInstance().setUserId(userId)
FirebaseCrashlytics.getInstance().setCustomKey("user_type", userType)

// Log custom events
FirebaseCrashlytics.getInstance().log("User completed onboarding")
```

#### **7. Production Logging**

**Release Configuration:**
```kotlin
class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()
        
        if (BuildConfig.DEBUG) {
            // Full logging
            Timber.plant(Timber.DebugTree())
        } else {
            // Production logging
            Timber.plant(CrashlyticsTree())
            Timber.plant(ErrorOnlyTree())
        }
    }
}

class ErrorOnlyTree : Timber.Tree() {
    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {
        if (priority >= Log.ERROR) {
            // Log to file or remote service
            logToFile(priority, tag, message, t)
        }
    }
}
```

#### **8. Best Practices**
✅ Use Timber instead of Log
✅ Remove logs di production (atau send ke analytics)
✅ Never log sensitive data (passwords, tokens)
✅ Use appropriate log levels
✅ Add context to error logs
✅ Log network requests
✅ Use structured logging
✅ Implement remote logging untuk production

---
