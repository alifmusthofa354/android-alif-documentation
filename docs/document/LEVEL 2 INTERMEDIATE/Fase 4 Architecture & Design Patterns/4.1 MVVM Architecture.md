# ğŸ¨ Panduan Lengkap: MVVM Architecture di Android dengan Jetpack Compose

## ğŸš€ Pengantar: Arsitektur Modern untuk Aplikasi Android

Bayangkan kamu adalah seorang arsitek digital ğŸ›ï¸:
- **MVVM** seperti rencana desain gedung (Model-View-ViewModel)
- **Compose** seperti sistem konstruksi modern (UI yang deklaratif)
- **Coroutines + Flow** seperti pipa dan mekanisme dalam gedung

Dengan menguasai MVVM Architecture, kamu bisa membangun aplikasi yang modular, testable, dan scalable!

## ğŸ“š Daftar Isi Pembelajaran
1. [ğŸŒŸ Pengenalan MVVM Pattern](#1ï¸âƒ£-pengenalan-mvvm-pattern-ğŸŒŸ)
2. [ğŸ§® Model Layer](#2ï¸âƒ£-model-layer-ğŸ§®)
3. [ğŸ‘ï¸ View Layer](#3ï¸âƒ£-view-layer-ğŸ‘ï¸)
4. [ğŸ§  ViewModel Layer](#4ï¸âƒ£-viewmodel-layer-ğŸ§ )
5. [ğŸ”— Data Binding & Observables](#5ï¸âƒ£-data-binding--observables-ğŸ”—)
6. [ğŸ”„ State Management](#6ï¸âƒ£-state-management-ğŸ”„)
7. [ğŸ’¬ Communication Patterns](#7ï¸âƒ£-communication-patterns-ğŸ’¬)
8. [ğŸ§ª Testing MVVM](#8ï¸âƒ£-testing-mvvm-ğŸ§ª)
9. [âœ¨ Best Practices](#9ï¸âƒ£-best-practices-âœ¨)
10. [ğŸ”¨ Hands-on Project](#1ï¸âƒ£0ï¸âƒ£-hands-on-project-ğŸ”¨)
11. [ğŸ¯ Kesimpulan](#ğŸ¯-kesimpulan)

---

## 1ï¸âƒ£ Pengenalan MVVM Pattern ğŸŒŸ

### Konsep Dasar
MVVM (Model-View-ViewModel) seperti trio musik ğŸµ yang berperan penting dalam pengembangan aplikasi Android modern!

### Apa itu MVVM dan mengapa penting?
**MVVM (Model-View-ViewModel)** adalah pola arsitektur perangkat lunak yang memisahkan pengembangan antarmuka pengguna (View) dari logika bisnis (Model). Tujuannya adalah untuk menciptakan aplikasi yang:

- **Modular**: Setiap bagian memiliki tanggung jawab sendiri
- **Testable**: Mudah diuji unit testing
- **Maintainable**: Mudah dipelihara dan dikembangkan
- **Scalable**: Dapat dikembangkan tanpa merusak struktur

### Evolusi MVVM di Android:
```
1. MVC (Model-View-Controller) â†’ Terlalu banyak logic di View
2. MVP (Model-View-Presenter) â†’ Lebih baik, tapi memory leaks
3. MVVM (Model-View-ViewModel) â†’ Terbaik untuk Android + Compose
```

### Struktur MVVM:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MODEL     â”‚ â†â†’ â”‚ VIEWMODEL    â”‚ â†â†’ â”‚    VIEW     â”‚
â”‚             â”‚    â”‚              â”‚    â”‚             â”‚
â”‚ Data & Logicâ”‚    â”‚ State & Sync â”‚    â”‚ UI & Events â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Perbedaan MVVM vs MVC vs MVP:

| Pattern | View | Controller/Presenter/ViewModel | Model |
|---------|------|-------------------------------|-------|
| **MVC** | â€¢ Tahu Model<br/>â€¢ Re-render sendiri | â€¢ Tidak ada atau minimal | â€¢ Tahu View |
| **MVP** | â€¢ Tahu Presenter<br/>â€¢ Passive View | â€¢ Tahu View<br/>â€¢ Sync data | â€¢ Tidak tahu View |
| **MVVM** | â€¢ Observes ViewModel<br/>â€¢ Reactive | â€¢ Tahu Model<br/>â€¢ Data binding | â€¢ Tidak tahu View |

### Keunggulan MVVM untuk Android Development:
1. **Separation of Concerns**: Setiap komponen punya tanggung jawab sendiri
2. **Testability**: ViewModel mudah di-test karena tidak terikat dengan View
3. **Memory Efficient**: ViewModels bertahan saat config changes
4. **LiveData/Flow Integration**: Reactive programming
5. **Lifecycle Awareness**: Tidak ada memory leaks karena lifecycle aware

### Implementation Contoh Sederhana:
**domain/model/User.kt**
```kotlin
package com.example.mvvmsample.domain.model

/**
 * Model Layer - Representasi data dalam domain
 */
data class User(
    val id: Int,
    val name: String,
    val email: String,
    val isActive: Boolean = true
)
```

**domain/repository/UserRepository.kt**
```kotlin
package com.example.mvvmsample.domain.repository

import com.example.mvvmsample.domain.model.User

/**
 * Repository dalam Model Layer
 */
interface UserRepository {
    suspend fun getUsers(): List<User>
    suspend fun getUserById(id: Int): User?
    suspend fun updateUser(user: User)
    suspend fun deleteUser(id: Int)
}
```

**presentation/viewmodel/UserListViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mvvmsample.domain.model.User
import com.example.mvvmsample.domain.repository.UserRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

/**
 * ViewModel Layer - Business logic dan state management
 */
class UserListViewModel(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _users = MutableStateFlow<List<User>>(emptyList())
    val users: StateFlow<List<User>> = _users.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()
    
    init {
        loadUsers()
    }
    
    fun loadUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                val userList = userRepository.getUsers()
                _users.value = userList
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun updateUser(user: User) {
        viewModelScope.launch {
            try {
                userRepository.updateUser(user)
                loadUsers() // Refresh list
            } catch (e: Exception) {
                _error.value = e.message
            }
        }
    }
}
```

**presentation/ui/UserListView.kt** (Compose)
```kotlin
package com.example.mvvmsample.presentation.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.example.mvvmsample.domain.model.User

/**
 * View Layer - UI rendering dan event handling
 */
@Composable
fun UserListView(
    users: List<User>,
    isLoading: Boolean,
    error: String?,
    onRefresh: () -> Unit
) {
    Column(
        modifier = Modifier.fillMaxSize()
    ) {
        // Header
        TopAppBar(
            title = { Text("Daftar Pengguna") },
            actions = {
                IconButton(onClick = onRefresh) {
                    Icon(Icons.Default.Refresh, contentDescription = "Refresh")
                }
            }
        )
        
        // Content
        if (isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .wrapContentSize(Alignment.Center)
            ) {
                CircularProgressIndicator()
            }
        } else if (!error.isNullOrEmpty()) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .wrapContentSize(Alignment.Center)
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Icon(
                        imageVector = Icons.Default.Error,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.error
                    )
                    Text(
                        text = "Error: $error",
                        color = MaterialTheme.colorScheme.error
                    )
                }
            }
        } else {
            UserListContent(users)
        }
    }
}

@Composable
fun UserListContent(users: List<User>) {
    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(users) { user ->
            UserItem(user = user)
        }
    }
}

@Composable
fun UserItem(user: User) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .background(
                        color = if (user.isActive) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline,
                        shape = androidx.compose.foundation.shape.CircleShape
                    ),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = user.name.take(1).uppercase(),
                    color = MaterialTheme.colorScheme.onPrimary
                )
            }
            
            Spacer(modifier = Modifier.width(16.dp))
            
            Column {
                Text(
                    text = user.name,
                    style = MaterialTheme.typography.titleMedium
                )
                Text(
                    text = user.email,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**MVVM seperti Trio Musik:**
- **Model**: Instrument (menyediakan data)
- **View**: Penonton (melihat tampilan)
- **ViewModel**: Dirigen (mengatur alur lagu dan sinkronisasi)

**Separation of Concerns (SoC):**
- Model: Menangani data dan logika bisnis
- View: Hanya untuk tampilan dan event
- ViewModel: Menghubungkan Model dan View

**Keunggulan MVVM:**
- **Tangguh**: Tidak rusak saat perubahan UI
- **Testable**: Bisa test tanpa UI
- **Maintainable**: Mudah dipelihara
- **Scalable**: Bisa dikembangkan dengan mudah

---

## 2ï¸âƒ£ Model Layer ğŸ§®

### Konsep Dasar
Model Layer seperti perpustakaan ğŸ“š - menyimpan dan mengelola data serta logika bisnis!

### Pengertian Model dalam MVVM:
Model adalah lapisan paling bawah dalam arsitektur MVVM. Ini berisi:
- **Domain Models**: Representasi entitas bisnis
- **Repositories**: Pengelola data dari berbagai sumber
- **Use Cases**: Logika bisnis spesifik
- **Data Models**: Representasi data dari API/database

### Data Classes dan Business Objects:
**domain/model/User.kt**
```kotlin
package com.example.mvvmsample.domain.model

import kotlinx.datetime.LocalDateTime

/**
 * Domain model - representasi entitas bisnis
 */
data class User(
    val id: Int,
    val name: String,
    val email: String,
    val isActive: Boolean = true,
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime
)

/**
 * Entity untuk user preferences
 */
data class UserPreferences(
    val userId: Int,
    val theme: ThemePreference = ThemePreference.SYSTEM,
    val notificationsEnabled: Boolean = true,
    val language: String = "en"
)

enum class ThemePreference {
    LIGHT, DARK, SYSTEM
}

/**
 * Transfer data object (DTO) untuk API
 */
data class UserDto(
    val id: Int,
    val name: String,
    val email: String,
    val isActive: Boolean,
    val created_at: String,
    val updated_at: String
)

/**
 * Extension function untuk konversi DTO ke Model
 */
fun UserDto.toDomain(): User {
    return User(
        id = this.id,
        name = this.name,
        email = this.email,
        isActive = this.isActive,
        createdAt = LocalDateTime.parse(created_at), // Gunakan library parsing yang sesuai
        updatedAt = LocalDateTime.parse(updated_at)
    )
}
```

### Repository sebagai Model:
**domain/repository/UserRepository.kt**
```kotlin
package com.example.mvvmsample.domain.repository

import com.example.mvvmsample.domain.model.User
import kotlinx.coroutines.flow.Flow

/**
 * Interface repository - kontrak untuk pengelolaan data
 */
interface UserRepository {
    /**
     * Mendapatkan semua pengguna sebagai Flow
     */
    suspend fun getUsers(): List<User>
    
    /**
     * Mendapatkan stream pengguna (untuk live updates)
     */
    fun getUsersStream(): Flow<List<User>>
    
    /**
     * Mendapatkan pengguna berdasarkan ID
     */
    suspend fun getUserById(id: Int): User?
    
    /**
     * Mendapatkan stream pengguna berdasarkan ID
     */
    fun getUserByIdStream(id: Int): Flow<User?>
    
    /**
     * Menyimpan pengguna baru
     */
    suspend fun saveUser(user: User)
    
    /**
     * Memperbarui pengguna
     */
    suspend fun updateUser(user: User)
    
    /**
     * Menghapus pengguna
     */
    suspend fun deleteUser(id: Int)
    
    /**
     * Mencari pengguna berdasarkan nama
     */
    suspend fun searchUsers(query: String): List<User>
}

/**
 * Implementasi repository
 */
class UserRepositoryImpl(
    private val localDataSource: UserLocalDataSource,
    private val remoteDataSource: UserRemoteDataSource
) : UserRepository {
    
    override suspend fun getUsers(): List<User> {
        // Coba ambil dari remote terlebih dahulu, lalu cache ke local
        return try {
            val remoteUsers = remoteDataSource.fetchUsers()
            // Cache ke local storage
            remoteUsers.forEach { user ->
                localDataSource.saveUser(user)
            }
            remoteUsers
        } catch (e: Exception) {
            // Jika gagal, ambil dari cache
            localDataSource.getAllUsers()
        }
    }
    
    override fun getUsersStream(): Flow<List<User>> {
        return localDataSource.getAllUsersStream()
    }
    
    override suspend fun getUserById(id: Int): User? {
        return try {
            val remoteUser = remoteDataSource.fetchUserById(id)
            // Cache ke local storage
            localDataSource.saveUser(remoteUser)
            remoteUser
        } catch (e: Exception) {
            // Jika gagal, ambil dari cache
            localDataSource.getUserById(id)
        }
    }
    
    override fun getUserByIdStream(id: Int): Flow<User?> {
        return localDataSource.getUserByIdStream(id)
    }
    
    override suspend fun saveUser(user: User) {
        // Simpan ke remote dan local
        remoteDataSource.createUser(user)
        localDataSource.saveUser(user)
    }
    
    override suspend fun updateUser(user: User) {
        // Update di remote dan local
        remoteDataSource.updateUser(user)
        localDataSource.saveUser(user)
    }
    
    override suspend fun deleteUser(id: Int) {
        // Hapus dari remote dan local
        remoteDataSource.deleteUser(id)
        localDataSource.deleteUser(id)
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return localDataSource.searchUsers(query)
    }
}
```

### Domain Models vs Data Models:
**domain/model/Product.kt**
```kotlin
package com.example.mvvmsample.domain.model

/**
 * Domain Model - representasi entitas bisnis
 * Tidak terikat dengan sumber data tertentu
 */
data class Product(
    val id: String,
    val name: String,
    val description: String,
    val price: Double,
    val category: ProductCategory,
    val imageUrl: String,
    val rating: Double,
    val inStock: Boolean
)

enum class ProductCategory {
    ELECTRONICS,
    CLOTHING,
    BOOKS,
    HOME,
    TOYS
}

/**
 * Data Model - representasi untuk database/API
 */
data class ProductEntity(
    val id: String,
    val name: String,
    val description: String,
    val price: Double,
    val categoryId: Int,
    val imageUrl: String,
    val rating: Double,
    val inStock: Boolean,
    val createdAt: Long,
    val updatedAt: Long
)

/**
 * DTO (Data Transfer Object) - untuk komunikasi API
 */
data class ProductDto(
    val id: String,
    val name: String,
    val description: String,
    val price: Double,
    val category_id: Int,
    val image_url: String,
    val rating: Double,
    val in_stock: Boolean
)

/**
 * Mapper extensions
 */
fun Product.toEntity(): ProductEntity {
    return ProductEntity(
        id = this.id,
        name = this.name,
        description = this.description,
        price = this.price,
        categoryId = this.category.ordinal,
        imageUrl = this.imageUrl,
        rating = this.rating,
        inStock = this.inStock,
        createdAt = System.currentTimeMillis(),
        updatedAt = System.currentTimeMillis()
    )
}

fun ProductDto.toDomain(): Product {
    return Product(
        id = this.id,
        name = this.name,
        description = this.description,
        price = this.price,
        category = ProductCategory.values()[this.category_id],
        imageUrl = this.image_url,
        rating = this.rating,
        inStock = this.in_stock
    )
}

fun ProductEntity.toDomain(): Product {
    return Product(
        id = this.id,
        name = this.name,
        description = this.description,
        price = this.price,
        category = ProductCategory.values()[this.categoryId],
        imageUrl = this.imageUrl,
        rating = this.rating,
        inStock = this.inStock
    )
}
```

### Model Immutability:
**domain/model/immutable/ImmutableModels.kt**
```kotlin
package com.example.mvvmsample.domain.model.immutable

/**
 * Immutable models - tidak bisa diubah setelah dibuat
 * Lebih aman dalam concurrent environment
 */
data class ImmutableUser(
    val id: Int,
    val name: String,
    val email: String,
    val profile: UserProfile
) {
    /**
     * Method untuk membuat salinan dengan perubahan
     */
    fun copyWithUpdatedProfile(updatedProfile: UserProfile): ImmutableUser {
        return this.copy(profile = updatedProfile)
    }
    
    fun copyWithName(newName: String): ImmutableUser {
        return this.copy(name = newName)
    }
}

/**
 * Data class dengan immutable collections
 */
data class ImmutableUserList(
    private val users: Map<Int, ImmutableUser> = emptyMap()
) {
    val allUsers: List<ImmutableUser> get() = users.values.toList()
    
    fun getUser(id: Int): ImmutableUser? = users[id]
    
    fun addUser(user: ImmutableUser): ImmutableUserList {
        return ImmutableUserList(
            users = users + (user.id to user)
        )
    }
    
    fun removeUser(id: Int): ImmutableUserList {
        return ImmutableUserList(
            users = users - id
        )
    }
    
    fun updateUser(user: ImmutableUser): ImmutableUserList {
        return if (users.containsKey(user.id)) {
            ImmutableUserList(
                users = users + (user.id to user)
            )
        } else {
            this // Tidak diubah jika user tidak ditemukan
        }
    }
}

data class UserProfile(
    val age: Int,
    val location: String,
    val preferences: Map<String, Boolean> = emptyMap()
)
```

### Data Validation di Model Layer:
**domain/validation/DataValidator.kt**
```kotlin
package com.example.mvvmsample.domain.validation

import java.util.regex.Pattern

/**
 * Validator untuk data di model layer
 */
object DataValidator {
    
    /**
     * Result type untuk validation
     */
    sealed class ValidationResult {
        object Valid : ValidationResult()
        data class Invalid(val message: String) : ValidationResult()
    }
    
    /**
     * Validasi email
     */
    fun validateEmail(email: String): ValidationResult {
        val emailPattern = Pattern.compile(
            "[a-zA-Z0-9\\+\\.\\_\\%\\-\\+]{1,256}" +
            "\\@" +
            "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
            "(" +
            "\\." +
            "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
            ")+"
        )
        
        return if (email.isBlank()) {
            ValidationResult.Invalid("Email tidak boleh kosong")
        } else if (!emailPattern.matcher(email).matches()) {
            ValidationResult.Invalid("Format email tidak valid")
        } else {
            ValidationResult.Valid
        }
    }
    
    /**
     * Validasi password
     */
    fun validatePassword(password: String): ValidationResult {
        return when {
            password.length < 8 -> 
                ValidationResult.Invalid("Password minimal 8 karakter")
            !password.any { it.isDigit() } ->
                ValidationResult.Invalid("Password harus mengandung setidaknya satu angka")
            !password.any { it.isUpperCase() } ->
                ValidationResult.Invalid("Password harus mengandung setidaknya satu huruf besar")
            !password.any { it.isLowerCase() } ->
                ValidationResult.Invalid("Password harus mengandung setidaknya satu huruf kecil")
            else -> ValidationResult.Valid
        }
    }
    
    /**
     * Validasi nama
     */
    fun validateName(name: String): ValidationResult {
        return if (name.length < 2) {
            ValidationResult.Invalid("Nama harus minimal 2 karakter")
        } else if (!name.all { it.isLetter() || it.isWhitespace() }) {
            ValidationResult.Invalid("Nama hanya boleh mengandung huruf dan spasi")
        } else {
            ValidationResult.Valid
        }
    }
    
    /**
     * Validasi harga
     */
    fun validatePrice(price: Double): ValidationResult {
        return if (price <= 0) {
            ValidationResult.Invalid("Harga harus lebih dari 0")
        } else {
            ValidationResult.Valid
        }
    }
}

/**
 * Extension functions untuk validasi langsung
 */
fun String.validateEmail(): DataValidator.ValidationResult = DataValidator.validateEmail(this)
fun String.validatePassword(): DataValidator.ValidationResult = DataValidator.validatePassword(this)
fun String.validateName(): DataValidator.ValidationResult = DataValidator.validateName(this)
fun Double.validatePrice(): DataValidator.ValidationResult = DataValidator.validatePrice(this)
```

### Penggunaan Contoh:
**domain/model/UserWithValidation.kt**
```kotlin
package com.example.mvvmsample.domain.model

import com.example.mvvmsample.domain.validation.DataValidator

/**
 * User model dengan validasi built-in
 */
data class ValidatedUser(
    val id: String,
    val name: String,
    val email: String
) {
    companion object {
        /**
         * Membuat user dengan validasi
         */
        fun create(id: String, name: String, email: String): Result<ValidatedUser> {
            val nameValidation = DataValidator.validateName(name)
            val emailValidation = DataValidator.validateEmail(email)
            
            val errors = mutableListOf<String>().apply {
                if (nameValidation is DataValidator.ValidationResult.Invalid) {
                    add("Name: ${nameValidation.message}")
                }
                if (emailValidation is DataValidator.ValidationResult.Invalid) {
                    add("Email: ${emailValidation.message}")
                }
            }
            
            return if (errors.isEmpty()) {
                Result.success(ValidatedUser(id, name, email))
            } else {
                Result.failure(Exception(errors.joinToString("\n")))
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Model Layer seperti Perpustakaan:**
- **Data Classes**: Rak buku (tempat menyimpan data)
- **Repository**: Sistem manajemen perpustakaan (atur data dari berbagai sumber)
- **Validation**: Petugas perpustakaan (pastikan data valid)
- **Immutability**: Buku yang tidak bisa diedit (aman untukå¹¶å‘)

**Domain Models vs Data Models:**
- **Domain Models**: Fokus pada bisnis logic dan entitas bisnis
- **Data Models**: Fokus pada struktur data untuk storage/API
- **DTO**: Untuk transfer data antara layanan

**Best Practices:**
- Gunakan data class untuk representasi data
- Pisahkan domain model dari data model
- Terapkan validasi di model layer
- Gunakan immutable objects untuk thread safety
- Gunakan Result type untuk error handling

---

## 3ï¸âƒ£ View Layer ğŸ‘ï¸

### Konsep Dasar
View Layer seperti layar bioskop ğŸ¬ - hanya menampilkan apa yang seharusnya ditampilkan dan menangani input pengguna!

### Pengertian View dalam MVVM:
View dalam MVVM adalah lapisan presentasi yang:
- Bertanggung jawab hanya untuk **menampilkan UI**
- **Tidak mengandung logika bisnis**
- **Mengikuti state dari ViewModel**
- **Mengirim event ke ViewModel**
- Tidak menyimpan state aplikasi

### Activity dan Fragment sebagai View:
**presentation/ui/activity/MainActivity.kt**
```kotlin
package com.example.mvvmsample.presentation.ui.activity

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import com.example.mvvmsample.presentation.ui.screen.user_list.UserListScreen
import com.example.mvvmsample.presentation.ui.screen.user_detail.UserDetailScreen
import com.example.mvvmsample.presentation.ui.theme.MvvmSampleTheme
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MvvmSampleTheme {
                // A theme in Material 3
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    MyAppNavigation()
                }
            }
        }
    }
}

@Composable
fun MyAppNavigation() {
    val navController = rememberNavController()
    
    NavHost(
        navController = navController,
        startDestination = "user_list"
    ) {
        composable("user_list") {
            UserListScreen(
                onUserClick = { userId ->
                    navController.navigate("user_detail/$userId")
                }
            )
        }
        
        composable(
            "user_detail/{userId}",
            arguments = listOf(navArgument("userId") { type = NavType.IntType })
        ) { backStackEntry ->
            val userId = backStackEntry.arguments?.getInt("userId") ?: 0
            UserDetailScreen(
                userId = userId,
                onBack = { navController.popBackStack() }
            )
        }
    }
}
```

### Composable Functions sebagai View:
**presentation/ui/screen/user_list/UserListScreen.kt**
```kotlin
package com.example.mvvmsample.presentation.ui.screen.user_list

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.mvvmsample.domain.model.User
import com.example.mvvmsample.presentation.ui.component.UserListItem
import com.example.mvvmsample.presentation.viewmodel.UserListViewModel

@Composable
fun UserListScreen(
    onUserClick: (Int) -> Unit,
    viewModel: UserListViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    when (val state = uiState) {
        is UserListViewModel.UiState.Loading -> {
            LoadingScreen()
        }
        is UserListViewModel.UiState.Error -> {
            ErrorScreen(
                message = state.message,
                onRetry = { viewModel.loadUsers() }
            )
        }
        is UserListViewModel.UiState.Success -> {
            UserListContent(
                users = state.users,
                onRefresh = { viewModel.loadUsers() },
                onUserClick = onUserClick
            )
        }
    }
}

@Composable
private fun UserListContent(
    users: List<User>,
    onRefresh: () -> Unit,
    onUserClick: (Int) -> Unit
) {
    Column(
        modifier = Modifier.fillMaxSize()
    ) {
        TopBar(
            title = "Daftar Pengguna",
            onRefresh = onRefresh
        )
        
        LazyColumn(
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(users) { user ->
                UserListItem(
                    user = user,
                    onClick = { onUserClick(user.id) }
                )
            }
        }
    }
}

@Composable
private fun TopBar(
    title: String,
    onRefresh: () -> Unit
) {
    TopAppBar(
        title = { Text(title) },
        actions = {
            IconButton(onClick = onRefresh) {
                Icon(Icons.Default.Refresh, contentDescription = "Segarkan")
            }
        }
    )
}

@Composable
private fun LoadingScreen() {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .wrapContentSize(Alignment.Center)
    ) {
        CircularProgressIndicator()
    }
}

@Composable
private fun ErrorScreen(
    message: String,
    onRetry: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .wrapContentSize(Alignment.Center),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Icon(
            imageVector = Icons.Default.Error,
            contentDescription = "Error",
            tint = MaterialTheme.colorScheme.error
        )
        Text(
            text = "Terjadi kesalahan",
            color = MaterialTheme.colorScheme.error,
            style = MaterialTheme.typography.headlineSmall
        )
        Text(
            text = message,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            style = MaterialTheme.typography.bodyMedium
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = onRetry) {
            Text("Coba Lagi")
        }
    }
}
```

### Composable Components:
**presentation/ui/component/UserListItem.kt**
```kotlin
package com.example.mvvmsample.presentation.ui.component

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.example.mvvmsample.domain.model.User

@Composable
fun UserListItem(
    user: User,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Box(
                modifier = Modifier
                    .size(40.dp)
                    .background(
                        color = if (user.isActive) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline,
                        shape = androidx.compose.foundation.shape.CircleShape
                    ),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = Icons.Default.Person,
                    contentDescription = null,
                    tint = if (user.isActive) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            
            Spacer(modifier = Modifier.width(16.dp))
            
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = user.name,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium
                )
                Text(
                    text = user.email,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            
            if (!user.isActive) {
                Icon(
                    imageVector = Icons.Default.Block,
                    contentDescription = "Nonaktif",
                    tint = MaterialTheme.colorScheme.error
                )
            }
        }
    }
}
```

### View hanya untuk UI Rendering:
**presentation/ui/common/UiState.kt**
```kotlin
package com.example.mvvmsample.presentation.ui.common

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector

/**
 * Loading state component
 */
@Composable
fun LoadingIndicator() {
    CircularProgressIndicator()
}

/**
 * Empty state component
 */
@Composable
fun EmptyState(
    message: String,
    icon: ImageVector = Icons.Default.Inbox,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = icon,
                contentDescription = null,
                modifier = Modifier.size(64.dp)
            )
            androidx.compose.ui.text.Text(
                text = message,
                style = MaterialTheme.typography.bodyLarge
            )
        }
    }
}

/**
 * Error state component
 */
@Composable
fun ErrorState(
    errorMessage: String,
    onRetry: (() -> Unit)? = null
) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = Icons.Default.ErrorOutline,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.error
            )
            Text(
                text = errorMessage,
                color = MaterialTheme.colorScheme.error,
                style = MaterialTheme.typography.bodyLarge
            )
            if (onRetry != null) {
                Spacer(modifier = Modifier.height(16.dp))
                Button(onClick = onRetry) {
                    Text("Coba Lagi")
                }
            }
        }
    }
}
```

### Event Handling dari View ke ViewModel:
**presentation/ui/screen/user_form/UserFormScreen.kt**
```kotlin
package com.example.mvvmsample.presentation.ui.screen.user_form

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.mvvmsample.domain.model.User
import com.example.mvvmsample.presentation.viewmodel.UserFormViewModel

@Composable
fun UserFormScreen(
    userId: Int? = null,
    onBack: () -> Unit,
    viewModel: UserFormViewModel = hiltViewModel()
) {
    var nameInput by remember { mutableStateOf(TextFieldValue("")) }
    var emailInput by remember { mutableStateOf(TextFieldValue("")) }
    var isActive by remember { mutableStateOf(true) }
    
    // Jika edit, muat data awal
    LaunchedEffect(userId) {
        if (userId != null) {
            viewModel.loadUserData(userId)
        }
    }
    
    // Observasi data dari ViewModel
    val userData by viewModel.userData.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    
    // Muat data ke input fields ketika tersedia
    LaunchedEffect(userData) {
        userData?.let { user ->
            nameInput = TextFieldValue(user.name)
            emailInput = TextFieldValue(user.email)
            isActive = user.isActive
        }
    }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Header
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = onBack) {
                Icon(Icons.Default.ArrowBack, contentDescription = "Kembali")
            }
            Text(
                text = if (userId != null) "Edit Pengguna" else "Tambah Pengguna",
                style = MaterialTheme.typography.headlineMedium
            )
            // Spacer untuk balance
            Spacer(modifier = Modifier.width(48.dp)) // Ukuran IconButton
        }
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // Form fields
        OutlinedTextField(
            value = nameInput,
            onValueChange = { nameInput = it },
            label = { Text("Nama") },
            modifier = Modifier.fillMaxWidth(),
            leadingIcon = {
                Icon(Icons.Default.Person, contentDescription = null)
            }
        )
        
        OutlinedTextField(
            value = emailInput,
            onValueChange = { emailInput = it },
            label = { Text("Email") },
            modifier = Modifier.fillMaxWidth(),
            leadingIcon = {
                Icon(Icons.Default.Email, contentDescription = null)
            }
        )
        
        Row(
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Checkbox(
                checked = isActive,
                onCheckedChange = { isActive = it }
            )
            Text("Aktif")
        }
        
        Spacer(modifier = Modifier.weight(1f))
        
        // Action buttons
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Button(
                onClick = onBack,
                modifier = Modifier.weight(1f),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.errorContainer,
                    contentColor = MaterialTheme.colorScheme.onErrorContainer
                )
            ) {
                Text("Batal")
            }
            
            Button(
                onClick = {
                    // Kirim event ke ViewModel
                    val userInput = User(
                        id = userId ?: 0,
                        name = nameInput.text,
                        email = emailInput.text,
                        isActive = isActive
                    )
                    viewModel.saveUser(userInput)
                },
                enabled = !isLoading,
                modifier = Modifier.weight(1f)
            ) {
                if (isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(24.dp),
                        strokeWidth = 2.dp
                    )
                } else {
                    Text(if (userId != null) "Simpan" else "Tambah")
                }
            }
        }
    }
}
```

### View tidak boleh mengandung business logic:
**âŒ Salah - View dengan business logic:**
```kotlin
// JANGAN LAKUKAN INI
@Composable
fun WrongUserListScreen() {
    var users by remember { mutableStateOf<List<User>>(emptyList()) }
    var isLoading by remember { mutableStateOf(false) }
    
    // JANGAN MELAKUKAN NETWORK CALL DI DALAM VIEW
    LaunchedEffect(Unit) {
        isLoading = true
        try {
            val response = apiService.getUsers() // JANGAN!
            users = response.map { it.toDomain() } // JANGAN!
        } catch (e: Exception) {
            // Error handling di View - JANGAN!
        } finally {
            isLoading = false
        }
    }
    
    // Tampilkan data
    // ...
}
```

**âœ… Benar - View hanya untuk rendering:**
```kotlin
// INI YANG BENAR
@Composable
fun CorrectUserListScreen(
    viewModel: UserListViewModel = hiltViewModel()
) {
    // Observasi state dari ViewModel
    val uiState by viewModel.uiState.collectAsState()
    
    // Hanya render UI berdasarkan state
    when (val state = uiState) {
        is UserListViewModel.UiState.Loading -> {
            LoadingScreen()
        }
        is UserListViewModel.UiState.Error -> {
            ErrorScreen(
                message = state.message,
                onRetry = { viewModel.loadUsers() } // Kirim event ke ViewModel
            )
        }
        is UserListViewModel.UiState.Success -> {
            UserListContent(state.users) { user ->
                // Kirim event ke ViewModel
                viewModel.onUserClicked(user)
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**View Layer seperti Layar Bioskop:**
- **Hanya menampilkan**: Tidak membuat keputusan bisnis
- **Mengikuti instruksi**: Mengikuti state dari ViewModel
- **Mengirim feedback**: Mengirim event ke ViewModel
- **Fokus pada UI**: Tidak menyentuh data atau logika bisnis

**Tanggung Jawab View:**
- Menampilkan data dari ViewModel
- Menangani event pengguna (klik, input, dll)
- Menerjemahkan data ke bentuk UI
- Menampilkan loading/error states

**Tanggung Jawab BUKAN View:**
- Mengambil data langsung dari sumber data
- Mengandung logika bisnis
- Menyimpan state aplikasi
- Melakukan validasi kompleks

**Best Practices:**
- Gunakan Composable functions untuk UI
- Gunakan Hilt untuk dependency injection
- Observasi state dari ViewModel
- Kirim event ke ViewModel
- Gunakan StateFlow untuk reactive UI
- Pisahkan komponen menjadi reusable chunks

---

## 4ï¸âƒ£ ViewModel Layer ğŸ§ 

### Konsep Dasar
ViewModel Layer seperti otak ğŸ§  - mengatur logika, state, dan komunikasi antara Model dan View!

### Pengertian dan Peran ViewModel:
ViewModel adalah lapisan yang menyediakan data untuk UI dan bertahan saat perubahan konfigurasi (seperti rotasi layar). Fungsinya:

- **Menyimpan dan mengatur UI-related data**
- **Bertahan saat configuration changes**
- **Menyediakan data untuk View dalam format siap tampil**
- **Mediasi antara Model dan View**
- **Menyediakan scope untuk coroutines**

### Lifecycle-aware Components:
ViewModel dibuat menggunakan `viewModel { ... }` atau dengan constructor injection dan memiliki lifecycle khusus:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Created        â”‚ â† ViewModel created
â”‚  (onCreate)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Active         â”‚ â† ViewModel siap digunakan
â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Inactive       â”‚ â† Activity/Fragment tidak aktif
â”‚                 â”‚   tetapi masih ada
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Destroyed      â”‚ â† ViewModel dihancurkan
â”‚  (onCleared)    â”‚   dan sumber daya dibersihkan
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Membuat ViewModel Class:
**presentation/viewmodel/UserListViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mvvmsample.domain.model.User
import com.example.mvvmsample.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class UserListViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    // Private mutable state
    private val _uiState = MutableStateFlow<UserListUiState>(UserListUiState.Loading)
    val uiState: StateFlow<UserListUiState> = _uiState.asStateFlow()
    
    private val _users = MutableStateFlow<List<User>>(emptyList())
    val users: StateFlow<List<User>> = _users.asStateFlow()
    
    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    init {
        loadUsers()
    }
    
    fun loadUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                userRepository.getUsersStream()
                    .catch { exception ->
                        _error.value = exception.message
                        _isLoading.value = false
                    }
                    .collect { users ->
                        _users.value = users
                        _uiState.value = UserListUiState.Success(users)
                        _isLoading.value = false
                    }
            } catch (e: Exception) {
                _error.value = e.message
                _uiState.value = UserListUiState.Error(e.message ?: "Unknown error")
                _isLoading.value = false
            }
        }
    }
    
    fun onUserClicked(user: User) {
        // Handle user click event
        // Bisa mengirimkan event ke view melalui shared flow
        // atau update internal state
    }
    
    fun searchUsers(query: String) {
        viewModelScope.launch {
            _isLoading.value = true
            try {
                val filteredUsers = userRepository.searchUsers(query)
                _users.value = filteredUsers
                _uiState.value = UserListUiState.Success(filteredUsers)
            } catch (e: Exception) {
                _error.value = e.message
                _uiState.value = UserListUiState.Error(e.message ?: "Error searching users")
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun deleteUser(userId: Int) {
        viewModelScope.launch {
            try {
                userRepository.deleteUser(userId)
                // Refresh the list after deletion
                loadUsers()
            } catch (e: Exception) {
                _error.value = e.message
            }
        }
    }
}

/**
 * UI State untuk UserList
 */
sealed class UserListUiState {
    object Loading : UserListUiState()
    data class Success(val users: List<User>) : UserListUiState()
    data class Error(val message: String) : UserListUiState()
}
```

### ViewModel Scope dan Lifecycle:
**presentation/viewmodel/ExampleViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import timber.log.Timber

class ExampleViewModel : ViewModel() {
    
    // StateFlow: untuk menyimpan state yang bisa diobservasi
    private val _counter = MutableStateFlow(0)
    val counter: StateFlow<Int> = _counter.asStateFlow()
    
    // SharedFlow: untuk event yang bisa dilewatkan ke banyak subscriber
    private val _events = Channel<String>()
    val events: Flow<String> = _events.receiveAsFlow()
    
    // SharedFlow untuk efek samping (one-shot events)
    private val _effect = Channel<String>()
    val effect: Flow<String> = _effect.receiveAsFlow()
    
    init {
        // Di sini kita bisa memulai pengamatan atau inisialisasi
        initializeViewModel()
    }
    
    private fun initializeViewModel() {
        // Contoh pengamatan terhadap counter
        viewModelScope.launch {
            counter.collect { newValue ->
                Timber.d("Counter value changed to: $newValue")
                
                // Kirim event jika counter genap
                if (newValue % 2 == 0 && newValue > 0) {
                    _events.trySend("Counter is even: $newValue")
                }
            }
        }
    }
    
    fun incrementCounter() {
        _counter.value++
    }
    
    fun decrementCounter() {
        _counter.value--
    }
    
    fun resetCounter() {
        _counter.value = 0
    }
    
    fun triggerEffect(message: String) {
        // Kirim efek samping yang hanya akan diterima sekali
        _effect.trySend(message)
    }
    
    // Override onCleared untuk membersihkan sumber daya
    override fun onCleared() {
        super.onCleared()
        // Bersihkan sumber daya di sini
        Timber.d("ExampleViewModel cleared")
        // Channel otomatis akan tertutup oleh Android Framework
    }
}

/**
 * ViewModel dengan beberapa jenis state
 */
@HiltViewModel
class ComplexViewModel @Inject constructor(
    private val repository: SomeRepository
) : ViewModel() {
    
    // UI State object untuk mengelola semua state dalam satu place
    private val _uiState = MutableStateFlow(ComplexUiState.initial())
    val uiState: StateFlow<ComplexUiState> = _uiState.asStateFlow()
    
    // Private scope untuk operasi tertentu
    private val _loadingJobs = mutableListOf<Job>()
    
    fun loadData() {
        // Hentikan job sebelumnya jika ada
        _loadingJobs.forEach { it.cancel() }
        _loadingJobs.clear()
        
        val job = viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }
            
            try {
                val data = repository.getData()
                _uiState.update { currentState ->
                    currentState.copy(
                        data = data,
                        isLoading = false,
                        error = null
                    )
                }
            } catch (e: Exception) {
                _uiState.update { currentState ->
                    currentState.copy(
                        isLoading = false,
                        error = e.message
                    )
                }
            }
        }
        
        _loadingJobs.add(job)
    }
    
    fun updateSearchQuery(query: String) {
        _uiState.update { currentState ->
            currentState.copy(searchQuery = query)
        }
        
        // Filter data berdasarkan query
        viewModelScope.launch {
            delay(500) // Debounce
            val filteredData = _uiState.value.originalData.filter { 
                it.contains(query, ignoreCase = true) 
            }
            _uiState.update { currentState ->
                currentState.copy(displayedData = filteredData)
            }
        }
    }
    
    override fun onCleared() {
        super.onCleared()
        _loadingJobs.forEach { it.cancel() }
    }
}

data class ComplexUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val data: List<String> = emptyList(),
    val originalData: List<String> = emptyList(),
    val displayedData: List<String> = emptyList(),
    val searchQuery: String = ""
) {
    companion object {
        fun initial() = ComplexUiState()
    }
}
```

### ViewModelProvider dan Injection:
**di/ViewModelModule.kt**
```kotlin
package com.example.mvvmsample.di

import com.example.mvvmsample.presentation.viewmodel.UserListViewModel
import com.example.mvvmsample.presentation.viewmodel.UserDetailViewModel
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.components.ViewModelComponent
import dagger.hilt.android.scopes.ViewModelScoped

@Module
@InstallIn(ViewModelComponent::class)
object ViewModelModule {
    
    @Provides
    @ViewModelScoped
    fun provideUserListViewModel(
        userRepository: UserRepository
    ): UserListViewModel {
        return UserListViewModel(userRepository)
    }
    
    @Provides
    @ViewModelScoped
    fun provideUserDetailViewModel(
        userRepository: UserRepository
    ): UserDetailViewModel {
        return UserDetailViewModel(userRepository)
    }
}
```

**presentation/viewmodel/UserDetailViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mvvmsample.domain.model.User
import com.example.mvvmsample.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class UserDetailViewModel @Inject constructor(
    private val userRepository: UserRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    private val userId: Int = savedStateHandle.get<Int>("userId") ?: 0
    
    private val _uiState = MutableStateFlow<UserDetailUiState>(UserDetailUiState.Loading)
    val uiState: StateFlow<UserDetailUiState> = _uiState.asStateFlow()
    
    private val _userData = MutableStateFlow<User?>(null)
    val userData: StateFlow<User?> = _userData.asStateFlow()
    
    init {
        loadUser()
    }
    
    private fun loadUser() {
        viewModelScope.launch {
            try {
                userRepository.getUserByIdStream(userId)
                    .catch { exception ->
                        _uiState.value = UserDetailUiState.Error(exception.message ?: "Unknown error")
                    }
                    .collect { user ->
                        _userData.value = user
                        _uiState.value = if (user != null) {
                            UserDetailUiState.Success(user)
                        } else {
                            UserDetailUiState.Error("User not found")
                        }
                    }
            } catch (e: Exception) {
                _uiState.value = UserDetailUiState.Error(e.message ?: "Unknown error")
            }
        }
    }
    
    fun updateUser(user: User) {
        viewModelScope.launch {
            try {
                userRepository.updateUser(user)
                _userData.value = user
                _uiState.value = UserDetailUiState.Success(user)
            } catch (e: Exception) {
                _uiState.value = UserDetailUiState.Error(e.message ?: "Failed to update user")
            }
        }
    }
    
    fun deleteUser() {
        viewModelScope.launch {
            try {
                userRepository.deleteUser(userId)
                // Tidak ada state untuk user yang dihapus
            } catch (e: Exception) {
                _uiState.value = UserDetailUiState.Error(e.message ?: "Failed to delete user")
            }
        }
    }
    
    fun toggleUserStatus() {
        val currentUser = _userData.value
        if (currentUser != null) {
            val updatedUser = currentUser.copy(isActive = !currentUser.isActive)
            updateUser(updatedUser)
        }
    }
}

sealed class UserDetailUiState {
    object Loading : UserDetailUiState()
    data class Success(val user: User) : UserDetailUiState()
    data class Error(val message: String) : UserDetailUiState()
}
```

### Surviving Configuration Changes:
ViewModel secara otomatis bertahan saat perubahan konfigurasi seperti rotasi layar:

**presentation/viewmodel/ConfigurationChangeViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class ConfigurationChangeViewModel : ViewModel() {
    
    // State ini akan bertahan saat rotation
    private val _timer = MutableStateFlow(0)
    val timer: StateFlow<Int> = _timer.asStateFlow()
    
    private val _textValue = MutableStateFlow("")
    val textValue: StateFlow<String> = _textValue.asStateFlow()
    
    private var timerJob: kotlinx.coroutines.Job? = null
    
    fun startTimer() {
        timerJob?.cancel() // Stop timer sebelumnya jika ada
        
        timerJob = viewModelScope.launch {
            while (true) {
                delay(1000)
                _timer.value++
            }
        }
    }
    
    fun stopTimer() {
        timerJob?.cancel()
        timerJob = null
    }
    
    fun updateText(newValue: String) {
        _textValue.value = newValue
    }
    
    fun clearText() {
        _textValue.value = ""
    }
    
    override fun onCleared() {
        super.onCleared()
        // Hentikan job saat ViewModel dihancurkan
        timerJob?.cancel()
    }
}
```

### Clearing ViewModel Resources (onCleared):
```kotlin
override fun onCleared() {
    super.onCleared()
    
    // Hentikan semua job
    _loadingJobs.forEach { it.cancel() }
    _loadingJobs.clear()
    
    // Hentikan pengamatan
    // Tutup channels jika perlu
    // Bersihkan referensi yang mungkin menyebabkan memory leaks
}
```

### ğŸ“ Penjelasan Konsep:
**ViewModel Layer seperti Otak:**
- **Menyimpan state UI**: Data yang perlu bertahan
- **Menyediakan data ke View**: Dalam format siap tampil
- **Bertahan saat config changes**: Rotasi layar, dll
- **Scope untuk coroutines**: Menjaga operasi async tetap aman

**Keunggulan ViewModel:**
- **Lifecycle awareness**: Otomatis cleanup
- **Configuration change survival**: Tidak kehilangan data
- **Separation of concerns**: UI logic dipisahkan
- **Testability**: Mudah diuji secara terpisah

**Best Practices:**
- Gunakan `viewModelScope` untuk coroutines
- Gunakan StateFlow untuk reactive state
- Gunakan SharedFlow untuk event
- Implementasi `onCleared()` untuk cleanup
- Jangan simpan Context/Activity/Fragment reference
- Gunakan Hilt untuk dependency injection

---

## 5ï¸âƒ£ Data Binding & Observables ğŸ”—

### Konsep Dasar
Data Binding & Observables seperti sistem irigasi ğŸŒŠ - mengalirkan data dari sumber ke tujuan secara otomatis dan responsif!

### Konsep Data Binding di MVVM:
Data binding dalam konteks MVVM adalah mekanisme untuk menghubungkan data dari ViewModel ke View secara deklaratif. Di Jetpack Compose, ini diwujudkan melalui:

- **StateFlow**: Untuk state yang bisa diobservasi
- **SharedFlow**: Untuk event dan komunikasi
- **@Composable functions**: Yang bisa mengobservasi perubahan state
- **collectAsState()**: Untuk mengikat Flow ke state Composable

### Observable Patterns:
Dalam MVVM, observables adalah objek yang bisa memberi tahu observer saat nilainya berubah. Di Kotlin, ini diimplementasikan melalui:

**Domain/ObservableExample.kt**
```kotlin
package com.example.mvvmsample.domain.observable

import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

/**
 * Contoh sederhana observable pattern dengan Flow
 */
class ObservableCounter {
    private val _count = MutableStateFlow(0)
    val count: StateFlow<Int> = _count.asStateFlow()
    
    private val _events = MutableSharedFlow<String>()
    val events: Flow<String> = _events.asSharedFlow()
    
    fun increment() {
        _count.value++
        _events.tryEmit("Count incremented to ${_count.value}")
    }
    
    fun decrement() {
        _count.value--
        _events.tryEmit("Count decremented to ${_count.value}")
    }
}

/**
 * Contoh penggunaan dengan repository observables
 */
class ObservableUserRepository(
    private val apiService: ApiService,
    private val database: UserDao
) {
    fun getUsers(): Flow<List<User>> {
        return database.getAllUsers()
            .flatMapLatest { dbUsers ->
                if (dbUsers.isNotEmpty()) {
                    // Jika sudah ada data di database, kembalikan dulu
                    flowOf(dbUsers)
                        .onStart {
                            // Lalu coba refresh dari API
                            try {
                                val apiUsers = apiService.getUsers()
                                database.insertAll(apiUsers.map { it.toEntity() })
                            } catch (e: Exception) {
                                // Log error, tapi jangan hentikan flow
                            }
                        }
                } else {
                    // Jika tidak ada data, ambil dari API
                    flow {
                        val users = apiService.getUsers()
                        database.insertAll(users.map { it.toEntity() })
                        emit(users)
                    }
                }
            }
            .catch { e ->
                // Tangani error dan kembalikan error
                throw e
            }
    }
}
```

### StateFlow dan LiveData:
**StateFlow** adalah implementasi reactive streams dari Kotlin Coroutines, sedangkan **LiveData** adalah dari Architecture Components.

```kotlin
// StateFlow (modern & direkomendasikan)
private val _state = MutableStateFlow(0)
val state: StateFlow<Int> = _state.asStateFlow()

// SharedFlow (untuk events)
private val _events = MutableSharedFlow<Event>()
val events: Flow<Event> = _events.asSharedFlow()
```

### Collecting Flows di UI Layer:
**presentation/ui/ObservableExampleScreen.kt**
```kotlin
package com.example.mvvmsample.presentation.ui

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.mvvmsample.presentation.viewmodel.ObservableExampleViewModel

@Composable
fun ObservableExampleScreen(
    viewModel: ObservableExampleViewModel = hiltViewModel()
) {
    // Mengobservasi state dari ViewModel
    val state by viewModel.uiState.collectAsState()
    val counter by viewModel.counter.collectAsState()
    val events = viewModel.events.collectAsState(initial = emptyList())
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = "Observable Example",
            style = MaterialTheme.typography.headlineMedium
        )
        
        // Counter display
        Text(
            text = "Counter: $counter",
            style = MaterialTheme.typography.headlineLarge
        )
        
        // Action buttons
        Row(
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Button(onClick = { viewModel.incrementCounter() }) {
                Icon(Icons.Default.Add, contentDescription = "Tambah")
                Text("Tambah")
            }
            
            Button(onClick = { viewModel.decrementCounter() }) {
                Icon(Icons.Default.Remove, contentDescription = "Kurang")
                Text("Kurang")
            }
            
            Button(
                onClick = { viewModel.resetCounter() },
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.errorContainer,
                    contentColor = MaterialTheme.colorScheme.onErrorContainer
                )
            ) {
                Icon(Icons.Default.Replay, contentDescription = "Reset")
                Text("Reset")
            }
        }
        
        // Loading indicator
        if (state.isLoading) {
            CircularProgressIndicator()
        }
        
        // Events history
        OutlinedCard(
            modifier = Modifier.fillMaxWidth()
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "Events:",
                    style = MaterialTheme.typography.titleMedium,
                    modifier = Modifier.padding(bottom = 8.dp)
                )
                
                LazyColumn(
                    modifier = Modifier.height(150.dp)
                ) {
                    items(events.value.size) { index ->
                        val event = events.value[index]
                        Text(
                            text = "â€¢ $event",
                            style = MaterialTheme.typography.bodySmall,
                            modifier = Modifier.padding(vertical = 2.dp)
                        )
                    }
                }
            }
        }
    }
}
```

### One-way vs Two-way Data Binding:
**One-way binding** (direkomendasikan):
```kotlin
// Dari ViewModel ke View (read only)
val userName: StateFlow<String> = _userName.asStateFlow()

// Penggunaan di Composable
@Composable
fun UserProfileScreen(viewModel: UserProfileViewModel) {
    val userName by viewModel.userName.collectAsState()
    
    Text(text = "Hello, $userName!") // Hanya baca
}
```

**Two-way binding** (untuk input):
```kotlin
// ViewModel
fun updateUserName(newName: String) {
    _userName.value = newName
}

// Composable dengan two-way binding
@Composable
fun EditableUserProfileScreen(viewModel: UserProfileViewModel) {
    var userNameInput by remember { mutableStateOf("") }
    val userName by viewModel.userName.collectAsState()
    
    // Sinkronisasi satu arah dari ViewModel ke input
    LaunchedEffect(userName) {
        userNameInput = userName
    }
    
    OutlinedTextField(
        value = userNameInput,
        onValueChange = { 
            userNameInput = it
            // Kirim perubahan ke ViewModel
            viewModel.updateUserName(it)
        }
    )
}
```

### UI State Representation:
**presentation/state/UiStates.kt**
```kotlin
package com.example.mvvmsample.presentation.state

import com.example.mvvmsample.domain.model.User

/**
 * Representasi UI State yang bisa digunakan di berbagai screen
 */
sealed class UiState<out T> {
    object Loading : UiState<Nothing>()
    object Idle : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(val message: String) : UiState<Nothing>()
    
    companion object {
        fun <T> success(data: T) = Success(data)
        fun error(message: String) = Error(message)
        fun loading() = Loading
        fun idle() = Idle
    }
}

/**
 * Custom UI State untuk form
 */
data class FormUiState(
    val fieldErrors: Map<String, String> = emptyMap(),
    val isLoading: Boolean = false,
    val isSuccess: Boolean = false,
    val errorMessage: String? = null
) {
    val hasErrors: Boolean get() = fieldErrors.isNotEmpty() || errorMessage != null
    val isValid: Boolean get() = !hasErrors && !isLoading
}

/**
 * UI State untuk search
 */
data class SearchUiState<T>(
    val query: String = "",
    val results: List<T> = emptyList(),
    val isLoading: Boolean = false,
    val hasError: Boolean = false,
    val errorMessage: String? = null,
    val isIdle: Boolean = true
) {
    val isEmpty: Boolean get() = results.isEmpty() && query.isNotEmpty() && !isLoading
}

/**
 * UI State untuk pagination
 */
data class PaginatedUiState<T>(
    val items: List<T> = emptyList(),
    val isLoading: Boolean = false,
    val isLoadingMore: Boolean = false,
    val hasError: Boolean = false,
    val errorMessage: String? = null,
    val currentPage: Int = 0,
    val isEndReached: Boolean = false
) {
    val canLoadMore: Boolean get() = !isLoading && !isLoadingMore && !isEndReached
    val hasContent: Boolean get() = items.isNotEmpty()
}
```

### Implementation ViewModel dengan Observables:
**presentation/viewmodel/ObservableExampleViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mvvmsample.presentation.state.UiState
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import timber.log.Timber

class ObservableExampleViewModel : ViewModel() {
    
    // UI State
    private val _uiState = MutableStateFlow(UiState.Idle)
    val uiState: StateFlow<UiState<*>> = _uiState.asStateFlow()
    
    // Counter
    private val _counter = MutableStateFlow(0)
    val counter: StateFlow<Int> = _counter.asStateFlow()
    
    // Events stream
    private val _events = Channel<String>(Channel.UNLIMITED)
    val events: StateFlow<List<String>> = _events
        .receiveAsFlow()
        .scan(mutableListOf()) { acc, event ->
            acc.add(event)
            if (acc.size > 10) acc.removeAt(0) // Batasi jumlah event
            acc.toList()
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
    
    // Form state
    private val _formState = MutableStateFlow(FormState())
    val formState: StateFlow<FormState> = _formState.asStateFlow()
    
    // Search state
    private val _searchState = MutableStateFlow(SearchState(""))
    val searchState: StateFlow<SearchState> = _searchState.asStateFlow()
    
    init {
        Timber.d("ObservableExampleViewModel initialized")
        
        // Setup observers
        observeCounter()
    }
    
    private fun observeCounter() {
        viewModelScope.launch {
            counter.collect { value ->
                if (value % 5 == 0 && value != 0) {
                    _events.send("Counter reached $value!")
                }
            }
        }
    }
    
    fun incrementCounter() {
        _counter.value++
    }
    
    fun decrementCounter() {
        _counter.value = (_counter.value - 1).coerceAtLeast(0)
    }
    
    fun resetCounter() {
        _counter.value = 0
        _events.send("Counter reset!")
    }
    
    fun performAsyncTask() {
        _uiState.value = UiState.Loading
        
        viewModelScope.launch {
            try {
                // Simulasi async task
                delay(2000)
                
                _uiState.value = UiState.success("Task completed!")
                
                // Kirim event
                _events.send("Async task completed")
            } catch (e: Exception) {
                _uiState.value = UiState.error(e.message ?: "Unknown error")
            }
        }
    }
    
    fun updateFormField(fieldName: String, value: String) {
        _formState.update { currentState ->
            currentState.copy(
                fields = currentState.fields + (fieldName to value),
                lastUpdatedField = fieldName
            )
        }
    }
    
    fun validateForm(): Boolean {
        val currentState = _formState.value
        val errors = mutableMapOf<String, String>()
        
        // Validasi sederhana
        if (currentState.getFieldValue("name").isNullOrBlank()) {
            errors["name"] = "Name is required"
        }
        
        if (currentState.getFieldValue("email").isNullOrBlank()) {
            errors["email"] = "Email is required"
        }
        
        _formState.update { currentState ->
            currentState.copy(fieldErrors = errors)
        }
        
        return errors.isEmpty()
    }
    
    fun updateSearchQuery(query: String) {
        _searchState.update { currentState ->
            currentState.copy(query = query)
        }
        
        // Simulasi pencarian (delay untuk debounce)
        viewModelScope.launch {
            delay(500) // Debounce
            if (query.length >= 2) {
                performSearch(query)
            } else {
                _searchState.update { currentState ->
                    currentState.copy(results = emptyList())
                }
            }
        }
    }
    
    private fun performSearch(query: String) {
        viewModelScope.launch {
            _searchState.update { currentState ->
                currentState.copy(isLoading = true, hasError = false)
            }
            
            try {
                // Simulasi pencarian
                delay(1000)
                
                val mockResults = (1..3).map { i ->
                    "Result ${i} for '$query'"
                }
                
                _searchState.update { currentState ->
                    currentState.copy(
                        results = mockResults,
                        isLoading = false
                    )
                }
            } catch (e: Exception) {
                _searchState.update { currentState ->
                    currentState.copy(
                        hasError = true,
                        errorMessage = e.message,
                        isLoading = false
                    )
                }
            }
        }
    }
    
    override fun onCleared() {
        super.onCleared()
        // Channel akan ditutup otomatis
        Timber.d("ObservableExampleViewModel cleared")
    }
}

// Data classes pendukung
data class FormState(
    val fields: Map<String, String> = emptyMap(),
    val fieldErrors: Map<String, String> = emptyMap(),
    val lastUpdatedField: String? = null
) {
    fun getFieldValue(fieldName: String): String? = fields[fieldName]
    val hasErrors: Boolean get() = fieldErrors.isNotEmpty()
}

data class SearchState(
    val query: String = "",
    val results: List<String> = emptyList(),
    val isLoading: Boolean = false,
    val hasError: Boolean = false,
    val errorMessage: String? = null
) {
    val hasResults: Boolean get() = results.isNotEmpty()
    val isSearching: Boolean get() = isLoading && query.isNotEmpty()
}
```

### ğŸ“ Penjelasan Konsep:
**Data Binding & Observables seperti Sistem Irigasi:**
- **StateFlow**: Pipa air yang mengalirkan data state
- **SharedFlow**: Pipa untuk event (one-shot communications)
- **@Composable**: Tanaman yang merespons aliran air
- **collectAsState**: Akar tanaman yang menyerap air

**One-way vs Two-way:**
- **One-way**: Data hanya mengalir dari ViewModel ke View (read-only)
- **Two-way**: Perubahan di View langsung diteruskan ke ViewModel

**Keunggulan Observables:**
- **Reactive**: UI otomatis update saat data berubah
- **Efficient**: Hanya update yang benar-benar berubah
- **Thread-safe**: Coroutine scopes menangani concurrency

---

## 6ï¸âƒ£ State Management ğŸ”„

### Konsep Dasar
State Management seperti sistem manajemen inventaris ğŸ“¦ - mengelola dan menyinkronkan data di seluruh aplikasi!

### UI State Pattern:
**presentation/state/UiStatePattern.kt**
```kotlin
package com.example.mvvmsample.presentation.state

import androidx.compose.runtime.Immutable

/**
 * Sealed class untuk mengelola state UI
 * Immutable untuk keamanan thread
 */
@Immutable
sealed class UiState<out T> {
    object Loading : UiState<Nothing>()
    object Empty : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(val message: String) : UiState<Nothing>()
    
    companion object {
        fun <T> success(data: T) = Success(data)
        fun error(message: String) = Error(message)
        fun loading() = Loading
        fun empty() = Empty
    }
}

/**
 * Sealed class untuk event (untuk satu kali pemakaian)
 */
sealed class UiEvent {
    object ShowToast : UiEvent()
    data class Navigate(val destination: String) : UiEvent()
    data class ShowError(val message: String) : UiEvent()
    data class ShowSuccess(val message: String) : UiEvent()
}

/**
 * Sealed class untuk form state
 */
@Immutable
data class FormState(
    val fields: Map<String, Any> = emptyMap(),
    val errors: Map<String, String> = emptyMap(),
    val isSubmitting: Boolean = false,
    val submissionSuccess: Boolean = false,
    val submissionError: String? = null
) {
    val isValid: Boolean get() = errors.isEmpty() && !isSubmitting
    val hasSubmissionError: Boolean get() = submissionError != null
}
```

### State Hoisting:
**State hoisting** adalah praktik mengangkat state ke komponen induk sehingga bisa dibagikan dan dimanipulasi:

**presentation/ui/state_management/StateHoistingExample.kt**
```kotlin
package com.example.mvvmsample.presentation.ui.state_management

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.example.mvvmsample.presentation.state.FormState

// State hoisted ke parent
@Composable
fun StateHoistingParent() {
    var counter by remember { mutableStateOf(0) }
    var text by remember { mutableStateOf("") }
    var formState by remember { mutableStateOf(FormState()) }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Child komponen menerima state dan callback
        CounterComponent(
            count = counter,
            onIncrement = { counter++ },
            onDecrement = { counter = (counter - 1).coerceAtLeast(0) },
            onReset = { counter = 0 }
        )
        
        TextFieldComponent(
            value = text,
            onValueChange = { text = it },
            onClear = { text = "" }
        )
        
        FormComponent(
            state = formState,
            onFieldChange = { field, value ->
                formState = formState.copy(
                    fields = formState.fields + (field to value)
                )
            },
            onSubmit = {
                // Validasi dan submit form
                val hasErrors = formState.fields.isEmpty()
                if (hasErrors) {
                    formState = formState.copy(
                        submissionError = "Form tidak boleh kosong"
                    )
                } else {
                    formState = formState.copy(
                        submissionSuccess = true,
                        submissionError = null
                    )
                    // Reset setelah sukses
                    androidx.compose.runtime.launchedEffect(true) {
                        kotlinx.coroutines.delay(2000)
                        formState = FormState()
                    }
                }
            }
        )
    }
}

@Composable
fun CounterComponent(
    count: Int,
    onIncrement: () -> Unit,
    onDecrement: () -> Unit,
    onReset: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Counter: $count",
                style = MaterialTheme.typography.headlineLarge
            )
            
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 16.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(
                    onClick = onDecrement,
                    modifier = Modifier.weight(1f)
                ) {
                    Text("-")
                }
                
                Button(
                    onClick = onReset,
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.errorContainer,
                        contentColor = MaterialTheme.colorScheme.onErrorContainer
                    )
                ) {
                    Text("Reset")
                }
                
                Button(
                    onClick = onIncrement,
                    modifier = Modifier.weight(1f)
                ) {
                    Text("+")
                }
            }
        }
    }
}

@Composable
fun TextFieldComponent(
    value: String,
    onValueChange: (String) -> Unit,
    onClear: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            OutlinedTextField(
                value = value,
                onValueChange = onValueChange,
                label = { Text("Masukkan teks") },
                modifier = Modifier.fillMaxWidth(),
                trailingIcon = {
                    if (value.isNotEmpty()) {
                        IconButton(onClick = onClear) {
                            Icon(Icons.Default.Clear, contentDescription = "Clear")
                        }
                    }
                }
            )
            
            if (value.isNotEmpty()) {
                Text(
                    text = "Teks saat ini: $value",
                    modifier = Modifier.padding(top = 8.dp)
                )
            }
        }
    }
}
```

### Immutable State Objects:
**Immutable state** adalah state yang tidak bisa diubah setelah dibuat. Ini penting untuk thread safety dan kemudahan debugging:

**presentation/state/ImmutableState.kt**
```kotlin
package com.example.mvvmsample.presentation.state

import androidx.compose.runtime.Immutable

/**
 * Immutable state untuk user profile
 */
@Immutable
data class UserProfileState(
    val id: Int,
    val name: String,
    val email: String,
    val avatarUrl: String?,
    val isEditing: Boolean = false,
    val isLoading: Boolean = false,
    val error: String? = null,
    val preferences: UserPreferencesState = UserPreferencesState()
) {
    val isLoaded: Boolean get() = !isLoading && error == null
    
    fun copyWithLoading(loading: Boolean = true) = copy(
        isLoading = loading,
        error = if (loading) null else error
    )
    
    fun copyWithError(errorMsg: String? = null) = copy(
        error = errorMsg,
        isLoading = errorMsg?.let { false } ?: isLoading
    )
}

@Immutable
data class UserPreferencesState(
    val theme: AppTheme = AppTheme.SYSTEM,
    val notificationsEnabled: Boolean = true,
    val language: String = "en",
    val privacy: PrivacySettingsState = PrivacySettingsState()
)

@Immutable
data class PrivacySettingsState(
    val profileVisible: Boolean = true,
    val showOnlineStatus: Boolean = true,
    val allowContact: Boolean = true
)

enum class AppTheme {
    LIGHT, DARK, SYSTEM
}

/**
 * Immutable state untuk list data
 */
@Immutable
data class ListState<T>(
    val items: List<T> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null,
    val isRefreshing: Boolean = false,
    val isEmpty: Boolean = false,
    val hasNextPage: Boolean = false,
    val loadingMore: Boolean = false
) {
    val hasContent: Boolean get() = items.isNotEmpty()
    val showError: Boolean get() = error != null && !isLoading
    
    companion object {
        fun <T> initial() = ListState<T>()
        fun <T> loading() = ListState<T>(isLoading = true)
        fun <T> empty() = ListState<T>(isEmpty = true)
    }
}

/**
 * Immutable state untuk authentication
 */
@Immutable
data class AuthState(
    val isAuthenticated: Boolean = false,
    val userId: String? = null,
    val username: String? = null,
    val roles: List<String> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
) {
    val isGuest: Boolean get() = !isAuthenticated
    val hasError: Boolean get() = error != null
    val isLoggedIn: Boolean get() = isAuthenticated && userId != null
    
    fun withLoading(loading: Boolean = true) = copy(isLoading = loading)
    fun withError(errorMsg: String? = null) = copy(error = errorMsg, isLoading = false)
}
```

### State Updates dan Recomposition:
**presentation/viewmodel/StateManagementViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mvvmsample.domain.model.User
import com.example.mvvmsample.domain.repository.UserRepository
import com.example.mvvmsample.presentation.state.*
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class StateManagementViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    // Multiple state streams
    private val _uiState = MutableStateFlow<UiState<List<User>>>(UiState.Loading)
    val uiState: StateFlow<UiState<List<User>>> = _uiState.asStateFlow()
    
    private val _authState = MutableStateFlow(AuthState())
    val authState: StateFlow<AuthState> = _authState.asStateFlow()
    
    private val _userProfileState = MutableStateFlow<UserProfileState>(
        UserProfileState(
            id = 0,
            name = "",
            email = "",
            avatarUrl = null
        )
    )
    val userProfileState: StateFlow<UserProfileState> = _userProfileState.asStateFlow()
    
    private val _listState = MutableStateFlow(ListState<User>.initial())
    val listState: StateFlow<ListState<User>> = _listState.asStateFlow()
    
    // Search state
    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()
    
    private val _searchResults = MutableStateFlow<List<User>>(emptyList())
    val searchResults: StateFlow<List<User>> = _searchResults.asStateFlow()
    
    init {
        loadInitialData()
    }
    
    private fun loadInitialData() {
        viewModelScope.launch {
            _listState.value = ListState.loading()
            
            try {
                val users = userRepository.getUsers()
                _listState.value = ListState(
                    items = users,
                    isEmpty = users.isEmpty()
                )
            } catch (e: Exception) {
                _listState.value = ListState<User>().copy(
                    error = e.message
                )
            }
        }
    }
    
    fun refreshData() {
        _listState.value = _listState.value.copy(isRefreshing = true)
        loadInitialData()
    }
    
    fun loadMoreData() {
        if (!_listState.value.hasNextPage || _listState.value.loadingMore) return
        
        viewModelScope.launch {
            _listState.value = _listState.value.copy(loadingMore = true)
            
            try {
                // Tambahkan logika load more di sini
                delay(1000) // Simulasi loading
                val currentItems = _listState.value.items
                val moreUsers = userRepository.getUsers().drop(currentItems.size).take(10)
                
                _listState.value = _listState.value.copy(
                    items = currentItems + moreUsers,
                    loadingMore = false,
                    hasNextPage = currentItems.size + moreUsers.size < 100 // Misalnya
                )
            } catch (e: Exception) {
                _listState.value = _listState.value.copy(
                    loadingMore = false,
                    error = e.message
                )
            }
        }
    }
    
    fun searchUsers(query: String) {
        _searchQuery.value = query
        
        viewModelScope.launch {
            delay(500) // Debounce
            
            if (query.length >= 2) {
                _listState.value = _listState.value.copy(isLoading = true)
                
                try {
                    val results = userRepository.searchUsers(query)
                    _searchResults.value = results
                    
                    _listState.value = _listState.value.copy(
                        items = results,
                        isEmpty = results.isEmpty() && query.isNotEmpty()
                    )
                } catch (e: Exception) {
                    _listState.value = _listState.value.copy(
                        error = e.message
                    )
                }
            } else {
                // Kembali ke state normal jika query kurang dari 2 karakter
                _listState.value = _listState.value.copy(
                    items = _searchResults.value, // Kembali ke hasil sebelumnya
                    isEmpty = false,
                    error = null
                )
            }
        }
    }
    
    fun updateUserProfile(userId: Int) {
        viewModelScope.launch {
            _userProfileState.value = _userProfileState.value.copyWithLoading()
            
            try {
                val user = userRepository.getUserById(userId)
                if (user != null) {
                    _userProfileState.value = UserProfileState(
                        id = user.id,
                        name = user.name,
                        email = user.email,
                        avatarUrl = "https://example.com/avatar/${user.id}", // Contoh URL
                        isEditing = false,
                        isLoading = false
                    )
                } else {
                    _userProfileState.value = _userProfileState.value.copyWithError("User not found")
                }
            } catch (e: Exception) {
                _userProfileState.value = _userProfileState.value.copyWithError(e.message)
            }
        }
    }
    
    fun updateUserPreferences(preferences: UserPreferencesState) {
        // Update local state - bisa juga disimpan ke database
        viewModelScope.launch {
            _userProfileState.value = _userProfileState.value.copy(
                preferences = preferences
            )
            
            // Simpan ke repository
            try {
                // userRepository.updateUserPreferences(userId, preferences)
            } catch (e: Exception) {
                // Tangani error
            }
        }
    }
    
    fun authenticateUser(credentials: Credentials) {
        viewModelScope.launch {
            _authState.value = _authState.value.withLoading()
            
            try {
                // Simulasi auth call
                val authResult = authenticate(credentials)
                
                _authState.value = AuthState(
                    isAuthenticated = authResult.isAuthenticated,
                    userId = authResult.userId,
                    username = authResult.username,
                    roles = authResult.roles,
                    isLoading = false
                )
            } catch (e: Exception) {
                _authState.value = _authState.value.withError(e.message)
            }
        }
    }
    
    fun logout() {
        _authState.value = AuthState()
        _userProfileState.value = UserProfileState(id = 0, name = "", email = "", avatarUrl = null)
    }
    
    private suspend fun authenticate(credentials: Credentials): AuthResult {
        // Simulasi call ke auth service
        delay(1000)
        return AuthResult(
            isAuthenticated = true,
            userId = credentials.username.hashCode().toString(),
            username = credentials.username,
            roles = listOf("USER")
        )
    }
}

// Data classes pendukung
data class Credentials(
    val username: String,
    val password: String,
    val rememberMe: Boolean = false
)

data class AuthResult(
    val isAuthenticated: Boolean,
    val userId: String,
    val username: String,
    val roles: List<String>
)
```

### Loading, Success, Error States:
**presentation/ui/state_management/StateHandling.kt**
```kotlin
package com.example.mvvmsample.presentation.ui.state_management

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.example.mvvmsample.presentation.state.UiState

@Composable
fun <T> StatefulContent(
    uiState: UiState<T>,
    onRetry: (() -> Unit)? = null,
    content: @Composable (T) -> Unit
) {
    when (uiState) {
        is UiState.Loading -> LoadingContent()
        is UiState.Empty -> EmptyContent(onRetry)
        is UiState.Success -> content(uiState.data)
        is UiState.Error -> ErrorContent(uiState.message, onRetry)
    }
}

@Composable
fun LoadingContent() {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            CircularProgressIndicator(
                modifier = Modifier.padding(bottom = 8.dp)
            )
            Text("Memuat data...")
        }
    }
}

@Composable
fun EmptyContent(onRetry: (() -> Unit)? = null) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = Icons.Default.Inbox,
                contentDescription = "Empty",
                modifier = Modifier.size(64.dp)
            )
            Text(
                text = "Tidak ada data",
                style = MaterialTheme.typography.headlineSmall,
                modifier = Modifier.padding(vertical = 8.dp)
            )
            if (onRetry != null) {
                Button(
                    onClick = onRetry,
                    modifier = Modifier.padding(top = 8.dp)
                ) {
                    Text("Muat Ulang")
                }
            }
        }
    }
}

@Composable
fun ErrorContent(errorMessage: String, onRetry: (() -> Unit)? = null) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = Icons.Default.ErrorOutline,
                contentDescription = "Error",
                tint = MaterialTheme.colorScheme.error,
                modifier = Modifier.size(64.dp)
            )
            Text(
                text = "Terjadi kesalahan",
                style = MaterialTheme.typography.headlineSmall,
                color = MaterialTheme.colorScheme.error,
                modifier = Modifier.padding(vertical = 8.dp)
            )
            Text(
                text = errorMessage,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                modifier = Modifier.padding(bottom = 16.dp)
            )
            if (onRetry != null) {
                Button(onClick = onRetry) {
                    Text("Coba Lagi")
                }
            }
        }
    }
}
```

### Sealed Classes untuk State:
**presentation/state/SealedStateExample.kt**
```kotlin
package com.example.mvvmsample.presentation.state

import androidx.compose.runtime.Immutable

/**
 * Sealed class untuk representasi state data
 */
@Immutable
sealed class DataState<out T> {
    object Loading : DataState<Nothing>()
    object Empty : DataState<Nothing>()
    data class Success<T>(val data: T) : DataState<T>()
    data class Error(val message: String, val exception: Exception? = null) : DataState<Nothing>()
    
    companion object {
        fun <T> success(data: T) = Success(data)
        fun error(message: String, exception: Exception? = null) = Error(message, exception)
        fun loading() = Loading
        fun empty() = Empty
        
        fun <T> fromResult(result: Result<T>): DataState<T> {
            return result.fold(
                onSuccess = { success(it) },
                onFailure = { error(it.message ?: "Unknown error", it) }
            )
        }
    }
}

/**
 * Sealed class untuk representasi loading state
 */
@Immutable
sealed class LoadingState {
    object Idle : LoadingState()
    object Loading : LoadingState()
    object Success : LoadingState()
    data class Error(val message: String) : LoadingState()
    
    val isLoading get() = this is Loading
    val isSuccess get() = this is Success
    val hasError get() = this is Error
    val isIdle get() = this is Idle
}

/**
 * Sealed class untuk representasi form state
 */
@Immutable
sealed class FormState {
    object Idle : FormState()
    object Loading : FormState()
    data class Success(val message: String) : FormState()
    data class Error(val message: String) : FormState()
    data class ValidationError(val field: String, val error: String) : FormState()
    
    val isLoading get() = this is Loading
    val isSuccess get() = this is Success
    val hasError get() = this is Error
    val hasValidationError get() = this is ValidationError
    val isIdle get() = this is Idle
}

/**
 * Sealed class untuk representasi pagination state
 */
@Immutable
sealed class PaginationState<T> {
    object Initial : PaginationState<Nothing>()
    data class Loading<T>(val data: List<T> = emptyList()) : PaginationState<T>()
    data class Success<T>(val data: List<T>, val hasMore: Boolean, val nextPage: Int? = null) : PaginationState<T>()
    data class Error<T>(val message: String, val data: List<T> = emptyList()) : PaginationState<T>()
    data class LoadingMore<T>(val data: List<T>, val hasMore: Boolean) : PaginationState<T>()
    
    val isLoading get() = this is Loading || this is LoadingMore
    val isLoadingMore get() = this is LoadingMore
    val isInitial get() = this is Initial
    val hasData get() = when (this) {
        is Success -> data.isNotEmpty()
        is Error -> data.isNotEmpty()
        is Loading -> data.isNotEmpty()
        is LoadingMore -> data.isNotEmpty()
        is Initial -> false
    }
    
    fun getAllData(): List<T> = when (this) {
        is Success -> data
        is Error -> data
        is Loading -> data
        is LoadingMore -> data
        is Initial -> emptyList()
    }
}
```

### State Restoration:
Android menyediakan mekanisme untuk menyimpan dan mengembalikan state saat configuration changes:

**presentation/viewmodel/RestoreableStateViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

class RestoreableStateViewModel @Inject constructor(
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    companion object {
        private const val KEY_COUNTER = "counter"
        private const val KEY_SEARCH_QUERY = "search_query"
        private const val KEY_USER_ID = "user_id"
    }
    
    // Gunakan savedStateHandle untuk menyimpan state yang akan disimpan
    private val _counter = savedStateHandle.getStateFlow(KEY_COUNTER, 0)
    val counter: StateFlow<Int> = _counter.asStateFlow()
    
    private val _searchQuery = savedStateHandle.getStateFlow(KEY_SEARCH_QUERY, "")
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()
    
    private val _userId = savedStateHandle.getStateFlow<Int?>(KEY_USER_ID, null)
    val userId: StateFlow<Int?> = _userId.asStateFlow()
    
    // State yang tidak disimpan tapi tetap reactive
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()
    
    fun incrementCounter() {
        savedStateHandle[KEY_COUNTER] = counter.value + 1
    }
    
    fun decrementCounter() {
        savedStateHandle[KEY_COUNTER] = (counter.value - 1).coerceAtLeast(0)
    }
    
    fun updateSearchQuery(query: String) {
        savedStateHandle[KEY_SEARCH_QUERY] = query
    }
    
    fun setUserId(id: Int) {
        savedStateHandle[KEY_USER_ID] = id
    }
    
    fun clearUserId() {
        savedStateHandle[KEY_USER_ID] = null
    }
    
    // Contoh fungsi async yang tidak disimpan
    fun performAsyncOperation() {
        viewModelScope.launch {
            _isLoading.value = true
            
            try {
                // Simulasi operasi async
                kotlinx.coroutines.delay(2000)
                
                // Operasi selesai, kembalikan ke idle
                _isLoading.value = false
            } catch (e: Exception) {
                _error.value = e.message
                _isLoading.value = false
            }
        }
    }
}
```

### ğŸ“ Penjelasan Konsep:
**State Management seperti Sistem Manajemen Inventaris:**
- **StateFlow**: Gudang utama (selalu bisa diakses)
- **SharedFlow**: Sistem pemberitahuan (untuk event sekali jalan)
- **Sealed classes**: Klasifikasi barang (state yang pasti)
- **Immutable objects**: Barang yang tak bisa dirusak
- **State hoisting**: Pusat distribusi (manajemen dari atas)

**State Patterns:**
- **Loading**: Saat data sedang dimuat
- **Success**: Saat data berhasil dimuat
- **Error**: Saat terjadi kesalahan
- **Empty**: Saat tidak ada data

**State Restoration:**
- **SavedStateHandle**: Penyimpanan persisten saat config change
- **StateFlow with savedState**: State yang bertahan saat rotasi
- **SavedState**: Untuk data sederhana

**Best Practices:**
- Gunakan Sealed classes untuk state definitif
- Gunakan Immutable objects untuk thread safety
- Gunakan StateFlow untuk reactive UI
- Gunakan SharedFlow untuk event sekali jalan
- Gunakan savedStateHandle untuk state yang bertahan

---

## 7ï¸âƒ£ Communication Patterns ğŸ’¬

### Konsep Dasar
Communication Patterns seperti sistem komunikasi ğŸ“¡ - mengatur bagaimana data dan event mengalir antar komponen!

### View â†’ ViewModel: Events
Event dari View ke ViewModel biasanya berupa:

**presentation/viewmodel/EventBasedViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

class EventBasedViewModel : ViewModel() {
    
    // State - untuk data yang persisten
    private val _counter = MutableStateFlow(0)
    val counter: StateFlow<Int> = _counter.asStateFlow()
    
    private val _users = MutableStateFlow<List<String>>(emptyList())
    val users: StateFlow<List<String>> = _users.asStateFlow()
    
    // Events - untuk aksi satu kali (one-shot)
    private val _events = Channel<UiEvent>()
    val events: Flow<UiEvent> = _events.receiveAsFlow()
    
    // Commands - untuk instruksi spesifik
    private val _commands = Channel<UiCommand>()
    val commands: Flow<UiCommand> = _commands.receiveAsFlow()
    
    fun onIncrementClick() {
        // Kirim event ke View bahwa counter telah ditambah
        _events.trySend(UiEvent.CounterIncremented(_counter.value))
        _counter.value++
    }
    
    fun onAddUserClick(username: String) {
        if (username.isNotEmpty()) {
            val newUserList = _users.value + username
            _users.value = newUserList
            _events.trySend(UiEvent.UserAdded(username))
        }
    }
    
    fun onDeleteUserClick(username: String) {
        val newUserList = _users.value - username
        _users.value = newUserList
        _events.trySend(UiEvent.UserRemoved(username))
    }
    
    fun onNavigateToUserDetail(userId: Int) {
        // Kirim command untuk navigasi
        _commands.trySend(UiCommand.NavigateToUserDetail(userId))
    }
    
    fun onShowToast(message: String) {
        _events.trySend(UiEvent.ShowToast(message))
    }
    
    fun onRefreshClick() {
        _commands.trySend(UiCommand.RefreshData)
    }
    
    fun onUserAction(userAction: UserAction) {
        when (userAction) {
            is UserAction.ViewProfile -> {
                _commands.trySend(UiCommand.NavigateToProfile(userAction.userId))
            }
            is UserAction.EditProfile -> {
                _commands.trySend(UiCommand.NavigateToEditProfile(userAction.userId))
            }
            is UserAction.DeleteUser -> {
                _events.trySend(UiEvent.ConfirmDeleteUser(userAction.userId))
            }
        }
    }
}

// Event classes - untuk one-shot events
sealed class UiEvent {
    data class CounterIncremented(val newValue: Int) : UiEvent()
    data class UserAdded(val username: String) : UiEvent()
    data class UserRemoved(val username: String) : UiEvent()
    data class ShowToast(val message: String) : UiEvent()
    data class ConfirmDeleteUser(val userId: Int) : UiEvent()
    object Unauthorized : UiEvent()
    object NetworkError : UiEvent()
}

// Command classes - untuk instruksi navigasi atau operasi
sealed class UiCommand {
    data class NavigateToUserDetail(val userId: Int) : UiCommand()
    data class NavigateToProfile(val userId: Int) : UiCommand()
    data class NavigateToEditProfile(val userId: Int) : UiCommand()
    object RefreshData : UiCommand()
    data class ShowDialog(val title: String, val message: String) : UiCommand()
    object Logout : UiCommand()
}

// Action classes - untuk representasi aksi pengguna
sealed class UserAction {
    data class ViewProfile(val userId: Int) : UserAction()
    data class EditProfile(val userId: Int) : UserAction()
    data class DeleteUser(val userId: Int) : UserAction()
    data class SendMessage(val userId: Int, val message: String) : UserAction()
}
```

### ViewModel â†’ View: State
Data dari ViewModel ke View umumnya berupa StateFlow/SharedFlow:

**presentation/ui/CommunicationPatternScreen.kt**
```kotlin
package com.example.mvvmsample.presentation.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.onEach

@Composable
fun CommunicationPatternScreen(
    viewModel: EventBasedViewModel = hiltViewModel()
) {
    // Observasi state dari ViewModel
    val counter by viewModel.counter.collectAsState()
    val users by viewModel.users.collectAsState()
    
    // Gunakan LaunchedEffect untuk menangani events dan commands
    val eventState = viewModel.events.collectAsState(initial = null)
    val commandState = viewModel.commands.collectAsState(initial = null)
    val scaffoldState = rememberScaffoldState()
    
    // Handler untuk events
    LaunchedEffect(eventState.value) {
        eventState.value?.let { event ->
            when (event) {
                is UiEvent.CounterIncremented -> {
                    // Bisa menampilkan toast atau action lain
                }
                is UiEvent.UserAdded -> {
                    scaffoldState.snackbarHostState.showSnackbar(
                        message = "User '${event.username}' added successfully"
                    )
                }
                is UiEvent.UserRemoved -> {
                    scaffoldState.snackbarHostState.showSnackbar(
                        message = "User '${event.username}' removed"
                    )
                }
                is UiEvent.ShowToast -> {
                    scaffoldState.snackbarHostState.showSnackbar(
                        message = event.message
                    )
                }
                is UiEvent.ConfirmDeleteUser -> {
                    // Tampilkan dialog konfirmasi hapus
                }
                is UiEvent.Unauthorized -> {
                    // Tangani unauthorized
                }
                is UiEvent.NetworkError -> {
                    // Tangani network error
                }
            }
        }
    }
    
    // Handler untuk commands (navigasi, dll)
    LaunchedEffect(commandState.value) {
        commandState.value?.let { command ->
            when (command) {
                is UiCommand.NavigateToUserDetail -> {
                    // Navigasi ke user detail (dengan NavController)
                }
                is UiCommand.NavigateToProfile -> {
                    // Navigasi ke profile
                }
                is UiCommand.RefreshData -> {
                    // Refresh data
                }
                is UiCommand.ShowDialog -> {
                    // Tampilkan dialog
                }
                is UiCommand.Logout -> {
                    // Proses logout
                }
            }
        }
    }
    
    Scaffold(
        scaffoldState = scaffoldState,
        topBar = {
            TopAppBar(
                title = { Text("Communication Pattern") },
                actions = {
                    IconButton(onClick = { viewModel.onRefreshClick() }) {
                        Icon(Icons.Default.Refresh, contentDescription = "Refresh")
                    }
                }
            )
        },
        content = { padding ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Counter section
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = "Counter",
                            style = MaterialTheme.typography.headlineSmall
                        )
                        Text(
                            text = counter.toString(),
                            style = MaterialTheme.typography.headlineLarge
                        )
                        
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(top = 8.dp),
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            Button(
                                onClick = { viewModel.onIncrementClick() },
                                modifier = Modifier.weight(1f)
                            ) {
                                Text("Increment")
                            }
                            
                            Button(
                                onClick = { 
                                    // Decrement implementation
                                },
                                modifier = Modifier.weight(1f)
                            ) {
                                Text("Decrement")
                            }
                        }
                    }
                }
                
                // Users list
                Card(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                    ) {
                        Text(
                            text = "Users (${users.size})",
                            style = MaterialTheme.typography.headlineSmall
                        )
                        
                        LazyColumn(
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(200.dp)
                                .padding(top = 8.dp),
                            verticalArrangement = Arrangement.spacedBy(4.dp)
                        ) {
                            items(users) { user ->
                                UserItem(
                                    user = user,
                                    onAction = { action ->
                                        when (action) {
                                            UserItemAction.View -> {
                                                viewModel.onUserAction(
                                                    UserAction.ViewProfile(user.hashCode())
                                                )
                                            }
                                            UserItemAction.Edit -> {
                                                viewModel.onUserAction(
                                                    UserAction.EditProfile(user.hashCode())
                                                )
                                            }
                                            UserItemAction.Delete -> {
                                                viewModel.onUserAction(
                                                    UserAction.DeleteUser(user.hashCode())
                                                )
                                            }
                                            UserItemAction.Message -> {
                                                viewModel.onUserAction(
                                                    UserAction.SendMessage(user.hashCode(), "Hello")
                                                )
                                            }
                                        }
                                    }
                                )
                            }
                        }
                        
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(top = 8.dp),
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            var newUsername by remember { mutableStateOf("") }
                            
                            OutlinedTextField(
                                value = newUsername,
                                onValueChange = { newUsername = it },
                                label = { Text("Username") },
                                modifier = Modifier.weight(1f)
                            )
                            
                            Button(
                                onClick = {
                                    if (newUsername.isNotEmpty()) {
                                        viewModel.onAddUserClick(newUsername)
                                        newUsername = ""
                                    }
                                },
                                enabled = newUsername.isNotEmpty()
                            ) {
                                Icon(Icons.Default.Add, contentDescription = "Add")
                            }
                        }
                    }
                }
            }
        }
    )
}

// Item actions
enum class UserItemAction {
    View, Edit, Delete, Message
}

@Composable
fun UserItem(
    user: String,
    onAction: (UserItemAction) -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(8.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(user)
            
            Row(
                horizontalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                IconButton(onClick = { onAction(UserItemAction.View) }) {
                    Icon(Icons.Default.Visibility, contentDescription = "View")
                }
                IconButton(onClick = { onAction(UserItemAction.Edit) }) {
                    Icon(Icons.Default.Edit, contentDescription = "Edit")
                }
                IconButton(onClick = { onAction(UserItemAction.Delete) }) {
                    Icon(Icons.Default.Delete, contentDescription = "Delete")
                }
                IconButton(onClick = { onAction(UserItemAction.Message) }) {
                    Icon(Icons.Default.Message, contentDescription = "Message")
                }
            }
        }
    }
}
```

### Single Events vs State:
Penting membedakan antara single events dan state persistent:

**presentation/viewmodel/SingleEventVsStateViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

class SingleEventVsStateViewModel : ViewModel() {
    
    // STATE - persisten, bisa diobservasi berkali-kali
    private val _counter = MutableStateFlow(0)
    val counter: StateFlow<Int> = _counter.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    private val _userDetails = MutableStateFlow<UserDetail?>(null)
    val userDetails: StateFlow<UserDetail?> = _userDetails.asStateFlow()
    
    // SINGLE EVENTS - hanya sekali jalan, bisa terlewat jika tidak diobservasi
    private val _events = Channel<UiSingleEvent>(Channel.BUFFERED)
    val events: Flow<UiSingleEvent> = _events.receiveAsFlow()
    
    // Dengan StateFlow - event bisa terlewat jika tidak ada listener
    // private val _bufferedEvents = MutableSharedFlow<UiSingleEvent>(replay = 1) // TIDAK DIREKOMENDASIKAN UNTUK EVENT
    
    fun incrementCounter() {
        _counter.value++
        // Ini adalah state, akan selalu tersedia untuk pengamat berikutnya
    }
    
    fun loadUserDetails(userId: Int) {
        viewModelScope.launch {
            _isLoading.value = true
            
            try {
                val user = fetchUserDetails(userId)
                _userDetails.value = user
            } catch (e: Exception) {
                // Kirim event bahwa terjadi error
                _events.send(UiSingleEvent.ShowToast("Error loading user: ${e.message}"))
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    fun showConfirmationDialog(title: String, message: String) {
        // Ini adalah single event - hanya perlu dikirim sekali
        viewModelScope.launch {
            _events.send(
                UiSingleEvent.ShowConfirmationDialog(
                    title = title,
                    message = message,
                    confirmAction = {
                        // Aksi ketika dikonfirmasi
                        _events.trySend(UiSingleEvent.ShowToast("Confirmed!"))
                    },
                    dismissAction = {
                        // Aksi ketika dibatalkan
                    }
                )
            )
        }
    }
    
    fun navigateToProfile(userId: Int) {
        // Ini adalah single event - hanya untuk satu aksi navigasi
        viewModelScope.launch {
            _events.send(UiSingleEvent.NavigateToProfile(userId))
        }
    }
    
    fun showSuccessMessage(message: String) {
        // Ini juga single event - hanya untuk satu kali tampilan
        viewModelScope.launch {
            _events.send(UiSingleEvent.ShowToast(message))
        }
    }
    
    private suspend fun fetchUserDetails(userId: Int): UserDetail {
        // Simulasi fetch user
        kotlinx.coroutines.delay(1000)
        return UserDetail(userId, "User $userId", "user$userId@example.com")
    }
}

// Single event untuk aksi sekali jalan
sealed class UiSingleEvent {
    data class ShowToast(val message: String) : UiSingleEvent()
    data class NavigateToProfile(val userId: Int) : UiSingleEvent()
    data class ShowConfirmationDialog(
        val title: String,
        val message: String,
        val confirmAction: () -> Unit,
        val dismissAction: () -> Unit
    ) : UiSingleEvent()
    data class ShowErrorDialog(val message: String) : UiSingleEvent()
    object ShowSuccess : UiSingleEvent()
}

data class UserDetail(
    val id: Int,
    val name: String,
    val email: String
)
```

### Command Pattern untuk Actions:
**presentation/viewmodel/CommandPatternViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.launch

class CommandPatternViewModel : ViewModel() {
    
    private val _state = MutableStateFlow(AppState.Initial())
    val state = _state.asStateFlow()
    
    private val _commands = Channel<AppCommand>()
    val commands = _commands.receiveAsFlow()
    
    init {
        observeCommands()
    }
    
    private fun observeCommands() {
        viewModelScope.launch {
            _commands.receiveAsFlow().collect { command ->
                when (command) {
                    is AppCommand.LoadUsers -> {
                        loadUsers()
                    }
                    is AppCommand.NavigateTo -> {
                        // Proses navigasi
                    }
                    is AppCommand.ShowDialog -> {
                        // Proses tampilkan dialog
                    }
                    is AppCommand.Refresh -> {
                        loadUsers()
                    }
                }
            }
        }
    }
    
    fun executeCommand(command: AppCommand) {
        viewModelScope.launch {
            _commands.send(command)
        }
    }
    
    private fun loadUsers() {
        viewModelScope.launch {
            _state.update { currentState ->
                currentState.copy(
                    isLoading = true,
                    error = null
                )
            }
            
            try {
                // Simulasi loading
                kotlinx.coroutines.delay(1000)
                val users = listOf("User 1", "User 2", "User 3")
                
                _state.update { currentState ->
                    currentState.copy(
                        users = users,
                        isLoading = false
                    )
                }
            } catch (e: Exception) {
                _state.update { currentState ->
                    currentState.copy(
                        error = e.message,
                        isLoading = false
                    )
                }
            }
        }
    }
}

data class AppState(
    val users: List<String> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
) {
    companion object {
        fun Initial() = AppState()
    }
}

sealed class AppCommand {
    object LoadUsers : AppCommand()
    object Refresh : AppCommand()
    data class NavigateTo(val destination: String) : AppCommand()
    data class ShowDialog(val title: String, val message: String) : AppCommand()
    data class ShowToast(val message: String) : AppCommand()
}
```

### Avoiding Event Loss:
Untuk mencegah event hilang, beberapa pendekatan bisa digunakan:

**presentation/viewmodel/EventHandlingViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.channels.BufferOverflow
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import timber.log.Timber

class EventHandlingViewModel : ViewModel() {
    
    private val _state = MutableStateFlow(AppUiState())
    val state = _state.asStateFlow()
    
    // Gunakan SharedFlow dengan replay = 0 dan BufferOverflow.DROP_OLDEST
    private val _events = MutableSharedFlow<UiEvent>(
        replay = 0,  // Jangan replay ke pengamat baru
        extraBufferCapacity = 10,  // Kapasitas buffer
        onBufferOverflow = BufferOverflow.DROP_OLDEST  // Drop event lama jika buffer penuh
    )
    val events = _events.asSharedFlow()
    
    // Atau gunakan Channel untuk event one-shot
    private val _singleEvents = Channel<UiEvent>()
    val singleEvents = _singleEvents.receiveAsFlow()
    
    fun showUserCreated(userId: Int) {
        // Kirim event yang hanya perlu dilihat sekali
        viewModelScope.launch {
            _events.emit(UiEvent.UserCreated(userId))
        }
    }
    
    fun showUserDeleted(userId: Int) {
        // Gunakan channel untuk satu kali pengiriman
        viewModelScope.launch {
            _singleEvents.send(UiEvent.UserDeleted(userId))
        }
    }
    
    fun performActionWithEvent() {
        viewModelScope.launch {
            try {
                // Lakukan sesuatu
                val result = performApiCall()
                
                // Kirim event ke UI
                _events.emit(UiEvent.ActionSuccess("Operasi berhasil"))
            } catch (e: Exception) {
                _events.emit(UiEvent.ActionFailure("Operasi gagal: ${e.message}"))
            }
        }
    }
    
    private suspend fun performApiCall(): String {
        kotlinx.coroutines.delay(1000) // Simulasi API call
        return "success"
    }
    
    fun updateState(newState: AppUiState) {
        _state.value = newState
    }
}

data class AppUiState(
    val users: List<String> = emptyList(),
    val isLoading: Boolean = false,
    val lastAction: String? = null
)

sealed class UiEvent {
    data class UserCreated(val userId: Int) : UiEvent()
    data class UserDeleted(val userId: Int) : UiEvent()
    data class ActionSuccess(val message: String) : UiEvent()
    data class ActionFailure(val message: String) : UiEvent()
    data class ShowToast(val message: String) : UiEvent()
    data class NavigateTo(val destination: String) : UiEvent()
}
```

### Channel vs SharedFlow untuk Events:
**Channel:**
- Lebih cocok untuk event one-shot
- Lebih mudah dikontrol
- Tersedia berbagai strategi buffering

**SharedFlow:**
- Lebih fleksibel
- Bisa replay ke subscriber baru (jika diinginkan)
- Lebih cocok untuk state yang lebih persisten

### ğŸ“ Penjelasan Konsep:
**Communication Patterns seperti Sistem Komunikasi:**
- **View â†’ ViewModel**: Event pengguna (klik, input)
- **ViewModel â†’ View**: State (data, loading, error)
- **Single Events**: Komunikasi sekali jalan
- **Persistent State**: Data yang bertahan lama

**View â†’ ViewModel (Events):**
- Kirim aksi pengguna
- Tidak perlu respon langsung segera
- Gunakan callback jika perlu respon langsung

**ViewModel â†’ View (State & Events):**
- Gunakan StateFlow untuk data yang persisten
- Gunakan SharedFlow/Channel untuk event satu kali
- Pisahkan state dari event untuk pengelolaan yang jelas

**Single Events vs State:**
- **State**: Persisten, bisa diobservasi berkali-kali
- **Events**: Satu kali jalan, bisa terlewat jika tidak diobservasi

**Best Practices:**
- Gunakan channel untuk event one-shot
- Gunakan StateFlow untuk state persistent
- Gunakan SharedFlow dengan hati-hati (atur replay dan buffer)
- Pisahkan event dari state secara jelas

---

## 8ï¸âƒ£ Testing MVVM ğŸ§ª

### Konsep Dasar
Testing MVVM seperti pemeriksaan medis ğŸ”¬ - memastikan setiap bagian sistem bekerja dengan benar!

### Unit Testing ViewModel:
**PresentationViewModelTest.kt** (dalam test folder)
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import app.cash.turbine.test
import com.example.mvvmsample.domain.model.User
import com.example.mvvmsample.domain.repository.UserRepository
import com.example.mvvmsample.presentation.state.UiState
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestDispatcher
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.mockito.kotlin.*

@OptIn(ExperimentalCoroutinesApi::class)
class UserListViewModelTest {
    
    private lateinit var viewModel: UserListViewModel
    private lateinit var mockRepository: UserRepository
    private lateinit var testDispatcher: TestDispatcher
    
    @Before
    fun setUp() {
        testDispatcher = StandardTestDispatcher()
        Dispatchers.setMain(testDispatcher)
        
        mockRepository = mock()
        viewModel = UserListViewModel(mockRepository)
    }
    
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
    
    @Test
    fun `loadUsers emits Loading then Success with data`() = runTest {
        // Given
        val mockUsers = listOf(
            User(1, "John Doe", "john@example.com", true),
            User(2, "Jane Smith", "jane@example.com", false)
        )
        whenever(mockRepository.getUsers()).thenReturn(mockUsers)
        
        // When
        viewModel.loadUsers()
        
        // Then
        viewModel.uiState.test {
            // Pastikan urutan state: Loading -> Success
            val firstState = awaitItem()
            assertTrue(firstState is UiState.Loading)
            
            val secondState = awaitItem()
            assertTrue(secondState is UiState.Success)
            assertEquals(mockUsers, (secondState as UiState.Success).data)
            
            cancelAndConsumeRemainingEvents()
        }
    }
    
    @Test
    fun `loadUsers emits Loading then Error when repo throws exception`() = runTest {
        // Given
        val errorMessage = "Network error"
        whenever(mockRepository.getUsers()).thenThrow(RuntimeException(errorMessage))
        
        // When
        viewModel.loadUsers()
        
        // Then
        viewModel.uiState.test {
            val firstState = awaitItem()
            assertTrue(firstState is UiState.Loading)
            
            val secondState = awaitItem()
            assertTrue(secondState is UiState.Error)
            assertEquals(errorMessage, (secondState as UiState.Error).message)
            
            cancelAndConsumeRemainingEvents()
        }
    }
    
    @Test
    fun `incrementCounter updates counter state correctly`() = runTest {
        // Given
        val initialState = viewModel.counter.value
        
        // When
        viewModel.incrementCounter()
        
        // Then
        assertEquals(initialState + 1, viewModel.counter.value)
    }
    
    @Test
    fun `deleteUser removes user from list`() = runTest {
        // Given
        val mockUsers = listOf(
            User(1, "John", "john@example.com", true),
            User(2, "Jane", "jane@example.com", false)
        )
        whenever(mockRepository.getUsers()).thenReturn(mockUsers)
        whenever(mockRepository.deleteUser(any())).thenReturn(Unit)
        
        // Load users first
        viewModel.loadUsers()
        
        // When
        viewModel.deleteUser(1)
        
        // Then
        verify(mockRepository).deleteUser(1)
        // Verifikasi bahwa list diupdate (perlu dicek lewat state observation)
    }
}

// Untuk testing events dari ViewModel
@OptIn(ExperimentalCoroutinesApi::class)
class EventBasedViewModelTest {
    
    private lateinit var viewModel: EventBasedViewModel
    private lateinit var testDispatcher: TestDispatcher
    
    @Before
    fun setUp() {
        testDispatcher = StandardTestDispatcher()
        Dispatchers.setMain(testDispatcher)
        viewModel = EventBasedViewModel()
    }
    
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
    
    @Test
    fun `onIncrementClick emits counter event and increases counter`() = runTest {
        // When
        viewModel.onIncrementClick()
        viewModel.onIncrementClick()
        
        // Then
        assertEquals(2, viewModel.counter.value)
        // Untuk testing events dari channel perlu pendekatan khusus
    }
}
```

### Testing Repository:
**UserRepositoryTest.kt**
```kotlin
package com.example.mvvmsample.domain.repository

import app.cash.turbine.test
import com.example.mvvmsample.data.datasource.remote.RemoteDataSource
import com.example.mvvmsample.data.datasource.local.LocalDataSource
import com.example.mvvmsample.domain.model.User
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Before
import org.junit.Test
import org.mockito.ArgumentMatchers.anyInt
import org.mockito.Mockito.*
import org.mockito.kotlin.whenever

class UserRepositoryImplTest {
    
    private lateinit var repository: UserRepositoryImpl
    private lateinit var mockRemote: RemoteDataSource
    private lateinit var mockLocal: LocalDataSource
    
    @Before
    fun setUp() {
        mockRemote = mock()
        mockLocal = mock()
        repository = UserRepositoryImpl(mockLocal, mockRemote)
    }
    
    @Test
    fun `getUsers returns remote data and caches locally`() = runTest {
        // Given
        val remoteUsers = listOf(
            User(1, "John", "john@example.com", true),
            User(2, "Jane", "jane@example.com", false)
        )
        whenever(mockRemote.fetchUsers()).thenReturn(remoteUsers)
        whenever(mockLocal.getAllUsers()).thenReturn(emptyList())
        
        // When
        val result = repository.getUsers()
        
        // Then
        assertEquals(remoteUsers, result)
        verify(mockLocal).saveUser(remoteUsers[0])
        verify(mockLocal).saveUser(remoteUsers[1])
    }
    
    @Test
    fun `getUsers falls back to local when remote fails`() = runTest {
        // Given
        val localUsers = listOf(User(1, "Local User", "local@example.com", true))
        whenever(mockRemote.fetchUsers()).thenThrow(RuntimeException("Network failed"))
        whenever(mockLocal.getAllUsers()).thenReturn(localUsers)
        
        // When
        val result = repository.getUsers()
        
        // Then
        assertEquals(localUsers, result)
    }
    
    @Test
    fun `getUserById returns remote data and caches locally`() = runTest {
        // Given
        val userId = 1
        val remoteUser = User(userId, "John", "john@example.com", true)
        whenever(mockRemote.fetchUserById(userId)).thenReturn(remoteUser)
        whenever(mockLocal.getUserById(userId)).thenReturn(null)
        
        // When
        val result = repository.getUserById(userId)
        
        // Then
        assertEquals(remoteUser, result)
        verify(mockLocal).saveUser(remoteUser)
    }
    
    @Test
    fun `getUserById falls back to local when remote fails`() = runTest {
        // Given
        val userId = 1
        val localUser = User(userId, "Local", "local@example.com", true)
        whenever(mockRemote.fetchUserById(userId)).thenThrow(RuntimeException("Net failed"))
        whenever(mockLocal.getUserById(userId)).thenReturn(localUser)
        
        // When
        val result = repository.getUserById(userId)
        
        // Then
        assertEquals(localUser, result)
    }
}
```

### Testing dengan Turbine untuk Flow:
```kotlin
// Di test file
import app.cash.turbine.test

@Test
fun `getUsersStream emits data`() = runTest {
    // Given
    val testData = listOf(
        User(1, "John", "john@example.com", true),
        User(2, "Jane", "jane@example.com", false)
    )
    val mockFlow = flowOf(testData)
    whenever(mockLocal.getAllUsersStream()).thenReturn(mockFlow)
    
    // When & Then
    repository.getUsersStream().test {
        val result = awaitItem()
        assertEquals(testData, result)
        awaitComplete()
    }
}
```

### Testing Use Cases:
**GetUserUseCaseTest.kt**
```kotlin
package com.example.mvvmsample.domain.usecase

import com.example.mvvmsample.domain.model.User
import com.example.mvvmsample.domain.repository.UserRepository
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever

class GetUserUseCaseTest {
    
    private lateinit var useCase: GetUserUseCase
    private lateinit var mockRepository: UserRepository
    
    @Before
    fun setUp() {
        mockRepository = mock()
        useCase = GetUserUseCase(mockRepository)
    }
    
    @Test
    fun `invoke returns user when repository succeeds`() = runTest {
        // Given
        val userId = 1
        val expectedUser = User(userId, "John", "john@example.com", true)
        whenever(mockRepository.getUserById(userId)).thenReturn(expectedUser)
        
        // When
        val result = useCase(userId)
        
        // Then
        assertEquals(expectedUser, result)
    }
    
    @Test
    fun `invoke returns null when user not found`() = runTest {
        // Given
        val userId = 999
        whenever(mockRepository.getUserById(userId)).thenReturn(null)
        
        // When
        val result = useCase(userId)
        
        // Then
        assertEquals(null, result)
    }
}
```

### Integration Testing:
**UserListIntegrationTest.kt**
```kotlin
package com.example.mvvmsample.integration

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.mvvmsample.domain.model.User
import com.example.mvvmsample.domain.repository.UserRepository
import com.example.mvvmsample.presentation.viewmodel.UserListViewModel
import com.example.mvvmsample.presentation.state.UiState
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.*
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever

@OptIn(ExperimentalCoroutinesApi::class)
class UserListIntegrationTest {
    
    @get:Rule
    val instantTaskExecutorRule = InstantTaskExecutorRule()
    
    private lateinit var viewModel: UserListViewModel
    private lateinit var mockRepository: UserRepository
    private lateinit var testDispatcher: StandardTestDispatcher
    
    @Before
    fun setUp() {
        testDispatcher = StandardTestDispatcher()
        Dispatchers.setMain(testDispatcher)
        
        mockRepository = mock()
        viewModel = UserListViewModel(mockRepository)
    }
    
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
    
    @Test
    fun `loadUsers with data succeeds`() = runTest {
        // Given
        val users = listOf(
            User(1, "John", "john@example.com", true),
            User(2, "Jane", "jane@example.com", false)
        )
        whenever(mockRepository.getUsers()).thenReturn(users)
        
        // When
        viewModel.loadUsers()
        
        // Then
        Assert.assertTrue(viewModel.uiState.value is UiState.Success)
        @Suppress("UNCHECKED_CAST")
        val successState = viewModel.uiState.value as UiState.Success<List<User>>
        Assert.assertEquals(users, successState.data)
    }
}
```

### Testing StateFlow:
**StateFlowTestingExample.kt**
```kotlin
package com.example.mvvmsample.testing

import app.cash.turbine.test
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Test

@OptIn(ExperimentalCoroutinesApi::class)
class StateFlowTestingExample {
    
    @Test
    fun `StateFlow emits initial value`() = runTest {
        // Given
        val stateFlow = MutableStateFlow("initial")
        
        // When & Then
        stateFlow.test {
            assertEquals("initial", awaitItem())
            cancelAndConsumeRemainingEvents()
        }
    }
    
    @Test
    fun `StateFlow emits updated values`() = runTest {
        // Given
        val stateFlow = MutableStateFlow("initial")
        
        // When & Then
        stateFlow.test {
            assertEquals("initial", awaitItem())
            stateFlow.value = "updated"
            assertEquals("updated", awaitItem())
            cancelAndConsumeRemainingEvents()
        }
    }
}
```

### Testing dengan MockK:
```kotlin
// Dalam test file
import org.mockito.kotlin.*

@Test
fun `example with MockK`() = runTest {
    // Given
    val mockRepo = mockk<UserRepository>()
    coEvery { mockRepo.getUsers() } returns listOf(mockk())
    
    val viewModel = UserListViewModel(mockRepo)
    
    // When
    viewModel.loadUsers()
    
    // Then
    coVerify { mockRepo.getUsers() }
    confirmVerified(mockRepo)
}
```

### ğŸ“ Penjelasan Konsep:
**Testing MVVM seperti Pemeriksaan Medis:**
- **Unit Testing**: Periksa setiap organ secara terpisah
- **Integration Testing**: Periksa bagaimana organ bekerja bersama
- **Mocking**: Gunakan organ tiruan untuk pengujian
- **Turbine**: Alat pengujian untuk Flow

**Jenis Testing:**
- **Unit Test**: ViewModel, Repository, Use Case
- **Integration Test**: Koneksi antar layer
- **UI Test**: Menggunakan Compose Test

**Testing Tools:**
- **Turbine**: Untuk pengujian Flow
- **Mockito/MockK**: Untuk mocking dependencies
- **Test Dispatchers**: Untuk test coroutines
- **InstantTaskExecutorRule**: Untuk LiveData (jika digunakan)

**Best Practices:**
- Gunakan StandardTestDispatcher
- Set Main dispatcher di test
- Gunakan Turbine untuk Flow
- Pisahkan happy path dan error path
- Test state transitions
- Test error scenarios

---

## 9ï¸âƒ£ Best Practices âœ¨

### Konsep Dasar
Best Practices seperti aturan emas â­ - pedoman untuk mengembangkan aplikasi MVVM yang hebat!

### ViewModel tidak hold Context/View References:
**âŒ Salah:**
```kotlin
class BadViewModel(private val context: Context) : ViewModel() // JANGAN!
```

**âœ… Benar:**
```kotlin
@HiltViewModel
class GoodViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() // Gunakan dependency injection
```

### Avoid Memory Leaks:
**presentation/viewmodel/GoodViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mvvmsample.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import timber.log.Timber
import javax.inject.Inject

@HiltViewModel
class GoodViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _users = MutableStateFlow<List<User>>(emptyList())
    val users: StateFlow<List<User>> = _users.asStateFlow()
    
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()
    
    // Simpan job reference untuk bisa dibatalkan
    private var loadUsersJob: Job? = null
    
    fun loadUsers() {
        // Batalkan job sebelumnya jika ada
        loadUsersJob?.cancel()
        
        loadUsersJob = viewModelScope.launch {
            _isLoading.value = true
            try {
                val users = userRepository.getUsers()
                _users.value = users
            } catch (e: Exception) {
                Timber.e(e, "Error loading users")
                // Handle error appropriately
            } finally {
                _isLoading.value = false
            }
        }
    }
    
    // Hapus referensi di onCleared
    override fun onCleared() {
        super.onCleared()
        loadUsersJob?.cancel() // Batalkan job saat ViewModel dihapus
        Timber.d("GoodViewModel cleared")
    }
}
```

### Proper Coroutine Scope Usage:
**presentation/viewmodel/CoroutineScopeExample.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import timber.log.Timber

class CoroutineScopeExample : ViewModel() {
    
    private val _state = MutableStateFlow(UiState.Loading)
    val state: StateFlow<UiState> = _state.asStateFlow()
    
    // Gunakan viewModelScope untuk operasi UI-related
    fun loadDataWithTimeout() {
        viewModelScope.launch {
            withTimeoutOrNull(5000) { // Timeout setelah 5 detik
                try {
                    _state.value = UiState.Loading
                    // Simulasi operasi lama
                    delay(6000) // Ini akan timeout
                    _state.value = UiState.Success("Data loaded")
                } catch (e: Exception) {
                    if (e is kotlinx.coroutines.TimeoutCancellationException) {
                        _state.value = UiState.Error("Request timeout")
                    } else {
                        _state.value = UiState.Error("Error: ${e.message}")
                    }
                }
            }
        }
    }
    
    // Gunakan SupvioredCoroutineScope jika perlu restart job
    private val supervisorScope = CoroutineScope(
        viewModelScope.coroutineContext + SupervisorJob() + CoroutineExceptionHandler { _, throwable ->
            Timber.e(throwable, "Error in supervised scope")
        }
    )
    
    fun launchWithSupervisorScope(action: suspend () -> Unit) {
        supervisorScope.launch {
            action()
        }
    }
    
    // Gunakan dengan hati-hati - pastikan job bisa dibatalkan
    private val customScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    
    fun launchCustomScope() {
        customScope.launch {
            // Operasi IO-intensive
            try {
                // Lakukan operasi
            } catch (e: Exception) {
                // Tangani error
            }
        }
    }
    
    override fun onCleared() {
        super.onCleared()
        supervisorScope.cancel()
        customScope.cancel()
    }
}

sealed class UiState {
    object Loading : UiState()
    data class Success(val data: String) : UiState()
    data class Error(val message: String) : UiState()
}
```

### Error Handling Strategies:
**presentation/viewmodel/ErrorHandlingViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mvvmsample.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import timber.log.Timber
import javax.inject.Inject

@HiltViewModel
class ErrorHandlingViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UserListUiState>(UserListUiState.Idle)
    val uiState: StateFlow<UserListUiState> = _uiState.asStateFlow()
    
    private val _errorMessage = MutableSharedFlow<String>()
    val errorMessage: SharedFlow<String> = _errorMessage.asSharedFlow()
    
    fun loadUsers() {
        _uiState.value = UserListUiState.Loading
        
        viewModelScope.launch {
            try {
                val users = userRepository.getUsers()
                _uiState.value = UserListUiState.Success(users)
            } catch (e: Exception) {
                handleException(e)
            }
        }
    }
    
    private suspend fun handleException(throwable: Throwable) {
        val errorMessage = when (throwable) {
            is java.net.UnknownHostException -> "Tidak ada koneksi internet"
            is java.net.SocketTimeoutException -> "Koneksi terlalu lama"
            is retrofit2.HttpException -> {
                when (throwable.code()) {
                    401 -> "Autentikasi gagal"
                    403 -> "Akses ditolak"
                    404 -> "Data tidak ditemukan"
                    500 -> "Server error"
                    else -> "Terjadi kesalahan: ${throwable.message}"
                }
            }
            else -> "Terjadi kesalahan: ${throwable.message}"
        }
        
        _uiState.value = UserListUiState.Error(errorMessage)
        _errorMessage.emit(errorMessage) // Kirim ke snackbar atau toast
    }
    
    fun retryLastAction() {
        // Coba tindakan terakhir lagi
        loadUsers()
    }
}

sealed class UserListUiState {
    object Idle : UserListUiState()
    object Loading : UserListUiState()
    data class Success(val users: List<User>) : UserListUiState()
    data class Error(val message: String) : UserListUiState()
}

data class User(
    val id: Int,
    val name: String,
    val email: String,
    val isActive: Boolean
)
```

### Loading State Management:
**presentation/viewmodel/LoadingStateViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mvvmsample.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class LoadingStateViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    // Single source of truth untuk loading
    private val _loadingCounter = MutableStateFlow(0)
    val isLoading: StateFlow<Boolean> = _loadingCounter.map { it > 0 }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = false
    )
    
    private val _users = MutableStateFlow<List<User>>(emptyList())
    val users: StateFlow<List<User>> = _users.asStateFlow()
    
    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()
    
    private val _refreshing = MutableStateFlow(false)
    val refreshing: StateFlow<Boolean> = _refreshing.asStateFlow()
    
    private var loadUsersJob: Job? = null
    private var refreshJob: Job? = null
    
    fun loadUsers() {
        // Cegah duplicate load
        if (loadUsersJob?.isActive == true) return
        
        loadUsersJob = viewModelScope.launch {
            incrementLoading()
            _error.value = null
            
            try {
                val users = userRepository.getUsers()
                _users.value = users
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                decrementLoading()
            }
        }
    }
    
    fun refresh() {
        if (refreshJob?.isActive == true) return
        
        refreshJob = viewModelScope.launch {
            _refreshing.value = true
            _error.value = null
            
            try {
                val users = userRepository.getUsers()
                _users.value = users
                // Berikan sedikit delay agar refresh animation terlihat
                kotlinx.coroutines.delay(1000)
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _refreshing.value = false
            }
        }
    }
    
    private suspend fun incrementLoading() {
        _loadingCounter.value++
    }
    
    private suspend fun decrementLoading() {
        _loadingCounter.value = (_loadingCounter.value - 1).coerceAtLeast(0)
    }
    
    override fun onCleared() {
        super.onCleared()
        loadUsersJob?.cancel()
        refreshJob?.cancel()
    }
}
```

### Navigation dari ViewModel:
**presentation/viewmodel/NavigationViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mvvmsample.domain.repository.UserRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class NavigationViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _navigationEvents = Channel<NavigationEvent>()
    val navigationEvents: Flow<NavigationEvent> = _navigationEvents.receiveAsFlow()
    
    private val _uiState = MutableStateFlow(NavigationUiState())
    val uiState: StateFlow<NavigationUiState> = _uiState.asStateFlow()
    
    fun navigateToUserProfile(userId: Int) {
        viewModelScope.launch {
            _navigationEvents.send(NavigationEvent.ToUserProfile(userId))
        }
    }
    
    fun navigateToAddUser() {
        viewModelScope.launch {
            _navigationEvents.send(NavigationEvent.ToAddUser)
        }
    }
    
    fun navigateToSettings() {
        viewModelScope.launch {
            _navigationEvents.send(NavigationEvent.ToSettings)
        }
    }
    
    fun navigateBack() {
        viewModelScope.launch {
            _navigationEvents.send(NavigationEvent.Back)
        }
    }
    
    fun performActionAndNavigate() {
        viewModelScope.launch {
            try {
                // Lakukan sesuatu
                userRepository.getUsers()
                
                // Setelah selesai, navigasi
                _navigationEvents.send(NavigationEvent.ToSuccessScreen)
            } catch (e: Exception) {
                // Tangani error
                _uiState.update { it.copy(errorMessage = e.message) }
            }
        }
    }
}

sealed class NavigationEvent {
    data class ToUserProfile(val userId: Int) : NavigationEvent()
    object ToAddUser : NavigationEvent()
    object ToSettings : NavigationEvent()
    object ToSuccessScreen : NavigationEvent()
    object Back : NavigationEvent()
    data class WithResult<T>(val result: T) : NavigationEvent()
}

data class NavigationUiState(
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val successMessage: String? = null
)
```

### ğŸ“ Penjelasan Konsep:
**Best Practices seperti Aturan Emas:**
- **Tidak hold Context/View**: Untuk mencegah memory leaks
- **Proper Coroutine Scope**: Untuk mengelola lifecycle coroutines
- **Error Handling**: Untuk pengalaman pengguna yang baik
- **Loading Management**: Untuk feedback yang jelas
- **Navigation**: Untuk alur aplikasi yang konsisten

**Memory Leak Prevention:**
- Jangan simpan Context/View references
- Batalkan job saat ViewModel dihapus
- Gunakan `viewModelScope`
- Hapus channel subscriptions jika tidak perlu bertahan

**Coroutine Best Practices:**
- Gunakan `viewModelScope`
- Gunakan `SupervisorJob` jika perlu restart job
- Cancel job saat tidak diperlukan
- Tambahkan exception handler

**Error Handling:**
- Tangani berbagai jenis error
- Tampilkan pesan yang manusiawi
- Gunakan strategi retry
- Log error untuk debugging

**Loading State:**
- Tampilkan loading indicator
- Gunakan loading state counter untuk multiple requests
- Tampilkan error state
- Tambahkan refresh mechanism

**Navigation:**
- Gunakan event-based navigation
- Jangan hardcode navigation logic di ViewModel
- Gunakan Channel/SharedFlow untuk events
- Pisahkan data dari navigation concerns

---

## ğŸ”¨ Hands-on Project

### Konsep Dasar
Hands-on Project seperti proyek konstruksi ğŸ—ï¸ - mengimplementasikan semua konsep MVVM secara menyeluruh!

### Complete MVVM Structure Implementation:

#### Domain Layer:
**domain/model/Post.kt**
```kotlin
package com.example.mvvmsample.domain.model

data class Post(
    val id: Int,
    val userId: Int,
    val title: String,
    val body: String,
    val author: User? = null
)

data class Comment(
    val id: Int,
    val postId: Int,
    val name: String,
    val email: String,
    val body: String
)

data class User(
    val id: Int,
    val name: String,
    val username: String,
    val email: String,
    val phone: String,
    val website: String
)
```

#### Data Layer:
**data/repository/PostRepositoryImpl.kt**
```kotlin
package com.example.mvvmsample.data.repository

import com.example.mvvmsample.data.datasource.remote.PostRemoteDataSource
import com.example.mvvmsample.data.datasource.local.PostLocalDataSource
import com.example.mvvmsample.domain.model.Comment
import com.example.mvvmsample.domain.model.Post
import com.example.mvvmsample.domain.repository.PostRepository
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject

class PostRepositoryImpl @Inject constructor(
    private val remoteSource: PostRemoteDataSource,
    private val localSource: PostLocalDataSource
) : PostRepository {
    
    override suspend fun getPosts(): List<Post> {
        return try {
            val remotePosts = remoteSource.getPosts()
            // Simpan ke cache
            remotePosts.forEach { post ->
                localSource.savePost(post)
            }
            remotePosts
        } catch (e: Exception) {
            // Jika gagal dari remote, coba dari cache
            localSource.getAllPosts()
        }
    }
    
    override fun getPostsStream(): Flow<List<Post>> {
        return localSource.getAllPostsStream()
    }
    
    override suspend fun getPostById(id: Int): Post? {
        return try {
            val post = remoteSource.getPostById(id)
            // Cache jika berhasil
            post?.let { localSource.savePost(it) }
            post
        } catch (e: Exception) {
            // Coba dari cache
            localSource.getPostById(id)
        }
    }
    
    override suspend fun getCommentsForPost(postId: Int): List<Comment> {
        return try {
            val comments = remoteSource.getCommentsForPost(postId)
            // Cache komentar
            localSource.saveCommentsForPost(postId, comments)
            comments
        } catch (e: Exception) {
            // Coba dari cache
            localSource.getCommentsForPost(postId)
        }
    }
    
    override suspend fun createPost(post: Post): Post {
        // Kirim ke remote
        val createdPost = remoteSource.createPost(post)
        // Simpan ke cache
        localSource.savePost(createdPost)
        return createdPost
    }
    
    override suspend fun updatePost(post: Post): Post {
        // Update di remote
        val updatedPost = remoteSource.updatePost(post)
        // Update di cache
        localSource.savePost(updatedPost)
        return updatedPost
    }
    
    override suspend fun deletePost(id: Int) {
        // Hapus dari remote
        remoteSource.deletePost(id)
        // Hapus dari cache
        localSource.deletePost(id)
    }
}
```

#### Presentation Layer (ViewModel):
**presentation/post_list/PostListViewModel.kt**
```kotlin
package com.example.mvvmsample.presentation.post_list

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.mvvmsample.domain.model.Post
import com.example.mvvmsample.domain.repository.PostRepository
import com.example.mvvmsample.presentation.common.UiState
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class PostListViewModel @Inject constructor(
    private val postRepository: PostRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UiState<List<Post>>>(UiState.Loading)
    val uiState: StateFlow<UiState<List<Post>>> = _uiState.asStateFlow()
    
    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()
    
    private val _navigationEvents = Channel<NavigationEvent>()
    val navigationEvents: Flow<NavigationEvent> = _navigationEvents.receiveAsFlow()
    
    private var searchJob: Job? = null
    
    init {
        observePosts()
    }
    
    private fun observePosts() {
        viewModelScope.launch {
            postRepository.getPostsStream()
                .catch { e -> 
                    _uiState.value = UiState.Error(e.message ?: "Unknown error")
                }
                .collect { posts ->
                    val currentState = _uiState.value
                    if (currentState !is UiState.Loading) {
                        _uiState.value = UiState.Success(posts)
                    }
                }
        }
    }
    
    fun searchPosts(query: String) {
        _searchQuery.value = query
        
        searchJob?.cancel()
        searchJob = viewModelScope.launch {
            delay(500) // Debounce
            
            if (query.length >= 2) {
                try {
                    val posts = postRepository.getPosts().filter { post ->
                        post.title.contains(query, ignoreCase = true) ||
                        post.body.contains(query, ignoreCase = true)
                    }
                    _uiState.value = UiState.Success(posts)
                } catch (e: Exception) {
                    _uiState.value = UiState.Error("Search failed: ${e.message}")
                }
            } else {
                observePosts() // Kembali ke semua data
            }
        }
    }
    
    fun onPostClick(post: Post) {
        viewModelScope.launch {
            _navigationEvents.send(NavigationEvent.NavigateToPostDetail(post.id))
        }
    }
    
    fun refreshPosts() {
        // Implementasi refresh
        // Biasanya dilakukan dengan invalidasi cache dan reload
    }
    
    fun retry() {
        // Coba lagi load data
        searchPosts(_searchQuery.value)
    }
    
    override fun onCleared() {
        super.onCleared()
        searchJob?.cancel()
    }
}

sealed class NavigationEvent {
    data class NavigateToPostDetail(val postId: Int) : NavigationEvent()
    object NavigateToAddPost : NavigationEvent()
    object NavigateToSettings : NavigationEvent()
    object NavigateBack : NavigationEvent()
}
```

#### Presentation Layer (UI):
**presentation/post_list/PostListScreen.kt**
```kotlin
package com.example.mvvmsample.presentation.post_list

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.example.mvvmsample.domain.model.Post
import com.example.mvvmsample.presentation.common.UiState

@Composable
fun PostListScreen(
    navController: NavController,
    viewModel: PostListViewModel = hiltViewModel<PostListViewModel>()
) {
    val uiState by viewModel.uiState.collectAsState()
    val searchQuery by viewModel.searchQuery.collectAsState()
    
    LaunchedEffect(Unit) {
        viewModel.navigationEvents.collect { event ->
            when (event) {
                is NavigationEvent.NavigateToPostDetail -> {
                    navController.navigate("post_detail/${event.postId}")
                }
                NavigationEvent.NavigateToAddPost -> {
                    // Implementasi navigasi
                }
                NavigationEvent.NavigateToSettings -> {
                    // Implementasi navigasi
                }
                is NavigationEvent.NavigateBack -> {
                    navController.popBackStack()
                }
            }
        }
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Daftar Post") },
                actions = {
                    IconButton(onClick = { /* Refresh */ }) {
                        Icon(Icons.Default.Refresh, contentDescription = "Refresh")
                    }
                }
            )
        },
        content = { padding ->
            PostListContent(
                uiState = uiState,
                searchQuery = searchQuery,
                onSearchChange = { viewModel.searchPosts(it) },
                onPostClick = { post -> viewModel.onPostClick(post) },
                onRetry = { viewModel.retry() },
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
            )
        }
    )
}

@Composable
fun PostListContent(
    uiState: UiState<List<Post>>,
    searchQuery: String,
    onSearchChange: (String) -> Unit,
    onPostClick: (Post) -> Unit,
    onRetry: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier.padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Search bar
        OutlinedTextField(
            value = searchQuery,
            onValueChange = onSearchChange,
            label = { Text("Cari post...") },
            leadingIcon = {
                Icon(Icons.Default.Search, contentDescription = "Search")
            },
            modifier = Modifier.fillMaxWidth()
        )
        
        Spacer(modifier = Modifier.height(8.dp))
        
        // State rendering
        when (uiState) {
            is UiState.Loading -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
            is UiState.Success -> {
                LazyColumn(
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(uiState.data) { post ->
                        PostItem(
                            post = post,
                            onClick = { onPostClick(post) },
                            modifier = Modifier.fillMaxWidth()
                        )
                    }
                }
            }
            is UiState.Error -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Icon(
                            imageVector = Icons.Default.Error,
                            contentDescription = "Error",
                            tint = MaterialTheme.colorScheme.error
                        )
                        Text(
                            text = "Error: ${uiState.message}",
                            color = MaterialTheme.colorScheme.error
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        Button(onClick = onRetry) {
                            Text("Coba Lagi")
                        }
                    }
                }
            }
            is UiState.Empty -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Icon(
                            imageVector = Icons.Default.Inbox,
                            contentDescription = "Empty"
                        )
                        Text("Tidak ada post")
                    }
                }
            }
        }
    }
}

@Composable
fun PostItem(
    post: Post,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.clickable { onClick() }
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text(
                text = post.title,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )
            Spacer(modifier = Modifier.height(4.dp))
            Text(
                text = post.body,
                style = MaterialTheme.typography.bodyMedium,
                maxLines = 3
            )
        }
    }
}
```

#### Testing Complete MVVM:
**PostListViewModelTest.kt**
```kotlin
package com.example.mvvmsample.presentation.post_list

import app.cash.turbine.test
import com.example.mvvmsample.domain.model.Post
import com.example.mvvmsample.domain.repository.PostRepository
import com.example.mvvmsample.presentation.common.UiState
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.resetMain
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.test.setMain
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import org.mockito.kotlin.*

@OptIn(ExperimentalCoroutinesApi::class)
class PostListViewModelTest {
    
    private lateinit var viewModel: PostListViewModel
    private lateinit var mockRepository: PostRepository
    private lateinit var testDispatcher: StandardTestDispatcher
    
    @Before
    fun setUp() {
        testDispatcher = StandardTestDispatcher()
        Dispatchers.setMain(testDispatcher)
        
        mockRepository = mock()
        viewModel = PostListViewModel(mockRepository)
    }
    
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
    
    @Test
    fun `initial state is Loading`() = runTest {
        // When - ViewModel baru dibuat
        
        // Then - State harus Loading
        assertEquals(UiState.Loading, viewModel.uiState.value)
    }
    
    @Test
    fun `load posts emits Success state`() = runTest {
        // Given
        val mockPosts = listOf(
            Post(1, 1, "Title 1", "Body 1"),
            Post(2, 1, "Title 2", "Body 2")
        )
        whenever(mockRepository.getPostsStream())
            .thenReturn(flowOf(mockPosts))
        
        // When - ViewModel dibuat dan observe posts
        
        // Then - Harus emit Success state
        viewModel.uiState.test {
            // Skip initial loading state karena ini di-set di constructor
            val successState = awaitItem()
            // Asumsikan state berubah ke Success karena kita observe stream
            cancelAndConsumeRemainingEvents()
        }
    }
    
    @Test
    fun `searchPosts filters posts correctly`() = runTest {
        // Given
        val allPosts = listOf(
            Post(1, 1, "First Post", "This is the first post"),
            Post(2, 1, "Second Post", "This is about Kotlin")
        )
        whenever(mockRepository.getPostsStream())
            .thenReturn(flowOf(allPosts))
        
        // When
        viewModel.searchPosts("Kotlin")
        
        // Then - Akan menghasilkan filtered posts
        // Implementasi untuk test lebih lanjut
    }
}
```

### ğŸ“ Penjelasan Konsep:
**Hands-on Project seperti Proyek Konstruksi:**
- **Domain Layer**: Fondasi bangunan (Model dan Repository)
- **Data Layer**: Peralatan dan bahan (Remote/Local Data Sources)
- **Presentation Layer**: Desain interior (ViewModel dan UI)
- **Dependency Injection**: Pembagian tanggung jawab (Hilt)
- **Testing**: Quality assurance (Jaminan kualitas)

**Complete MVVM Structure:**
- **Model**: Representasi data domain
- **Repository**: Abstraksi sumber data
- **UseCase**: Logika bisnis spesifik
- **ViewModel**: State management dan business logic
- **UI**: Presentasi dan event handling
- **Navigation**: Alur aplikasi
- **Testing**: Verifikasi dan validasi

**Best Practices dalam Proyek:**
- Gunakan Hilt untuk DI
- Terapkan separation of concerns
- Gunakan StateFlow untuk reactive state
- Gunakan SharedFlow untuk events
- Terapkan error handling
- Gunakan testing framework
- Gunakan logging untuk debugging

---

## ğŸ¯ Kesimpulan

Dengan menguasai MVVM Architecture di Android dengan Jetpack Compose, kamu sekarang memiliki kemampuan untuk:

### 1. **Pengenalan MVVM Pattern**:
- Memahami konsep MVVM dan perbedaannya dengan MVC/MVP
- Mengetahui keunggulan MVVM untuk Android development
- Memahami separation of concerns dalam MVVM

### 2. **Model Layer**:
- Membuat data classes dan domain models
- Mengimplementasikan Repository pattern
- Membedakan Domain models, Data models, dan DTOs
- Menerapkan immutability dalam model
- Melakukan validasi data di model layer

### 3. **View Layer**:
- Menggunakan Compose untuk membuat UI
- Menghindari business logic di View
- Mengikat state dari ViewModel ke View
- Menangani event dari pengguna
- Menggunakan navigation component dengan benar

### 4. **ViewModel Layer**:
- Membuat ViewModel yang sesuai dengan lifecycle
- Menggunakan viewModelScope untuk coroutines
- Mengelola state dengan StateFlow
- Menggunakan SavedStateHandle untuk config changes
- Membersihkan sumber daya di onCleared

### 5. **Data Binding & Observables**:
- Menggunakan StateFlow dan SharedFlow
- Menerapkan reactive programming
- Mengelola one-way dan two-way binding
- Menggunakan collectAsState dalam Compose
- Merepresentasikan UI state dengan proper patterns

### 6. **State Management**:
- Menggunakan sealed classes untuk state
- Menerapkan state hoisting
- Menggunakan immutable state objects
- Mengelola loading, success, error states
- Mengimplementasikan state restoration

### 7. **Communication Patterns**:
- Membuat View ke ViewModel events
- Mengelola ViewModel ke View state dan events
- Membedakan single events dari persistent state
- Menggunakan Channel dan SharedFlow untuk komunikasi
- Menghindari event loss

### 8. **Testing MVVM**:
- Melakukan unit testing pada ViewModel
- Melakukan unit testing pada Repository
- Menggunakan Mocking untuk dependencies
- Menggunakan Turbine untuk menguji Flow
- Melakukan integration testing

### 9. **Best Practices**:
- Tidak menyimpan Context/View references di ViewModel
- Menghindari memory leaks
- Menggunakan coroutine scope dengan benar
- Menerapkan error handling strategies
- Mengelola loading states
- Mengimplementasikan navigation dari ViewModel

### ğŸ”¥ Tips Penting:
1. **Gunakan Hilt** untuk dependency injection
2. **Pisahkan concern** sesuai dengan MVVM
3. **Gunakan StateFlow** untuk reactive state
4. **Gunakan SharedFlow/Channel** untuk events
5. **Terapkan testing** untuk setiap layer
6. **Gunakan immutable objects** untuk thread safety
7. **Hindari View references** dalam ViewModel
8. **Gunakan viewModelScope** untuk coroutines
9. **Terapkan error handling** secara menyeluruh
10. **Gunakan loading indicators** untuk UX yang baik

Kamu sekarang siap untuk membuat aplikasi Android yang robust, scalable, dan maintainable dengan arsitektur MVVM yang solid!