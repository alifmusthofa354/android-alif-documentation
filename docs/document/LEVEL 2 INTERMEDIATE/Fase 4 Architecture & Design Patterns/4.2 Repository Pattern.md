# üèõÔ∏è Panduan Lengkap: Repository Pattern di Jetpack Compose

## üöÄ Pengantar: Arsitektur Data yang Kuat

Bayangkan kamu adalah seorang manajer gudang digital üì¶:
- **Repository Pattern** seperti sistem manajemen gudang - mengatur akses ke data dari berbagai sumber
- **Data Sources** seperti berbagai gudang (lokal dan remote)
- **Caching** seperti rak penyimpanan cepat

Dengan menguasai Repository Pattern, kamu bisa membuat aplikasi yang efisien dan tahan offline!

## üìö Daftar Isi Pembelajaran
1. [üåü Repository Pattern Fundamentals](#1Ô∏è‚É£-repository-pattern-fundamentals-üåü)
2. [üèóÔ∏è Repository Structure](#2Ô∏è‚É£-repository-structure-üèóÔ∏è)
3. [üì° Data Sources](#3Ô∏è‚É£-data-sources-üì°)
4. [üîÑ Repository Implementation Strategies](#4Ô∏è‚É£-repository-implementation-strategies-üîÑ)
5. [üíæ Caching Strategy](#5Ô∏è‚É£-caching-strategy-üíæ)
6. [‚ö° Offline-First Architecture](#6Ô∏è‚É£-offline-first-architecture-‚ö°)
7. [‚ö†Ô∏è Error Handling](#7Ô∏è‚É£-error-handling-‚ö†Ô∏è)
8. [üîÑ Data Transformation](#8Ô∏è‚É£-data-transformation-üîÑ)
9. [üåÄ Repository with Coroutines](#9Ô∏è‚É£-repository-with-coroutines-üåÄ)
10. [üíâ Dependency Injection](#1Ô∏è‚É£0Ô∏è‚É£-dependency-injection-üíâ)
11. [üî® Hands-on Implementation](#1Ô∏è‚É£1Ô∏è‚É£-hands-on-implementation-üî®)
12. [üéØ Kesimpulan](#üéØ-kesimpulan)

---

## 1Ô∏è‚É£ Repository Pattern Fundamentals üåü

### Konsep Dasar
Repository Pattern seperti kepala gudang üè¢ - mengatur semua akses ke data!

### Apa itu Repository Pattern?
Repository Pattern adalah desain pattern yang menyediakan lapisan abstraksi antara lapisan domain (business logic) dan lapisan data (data access). Ini menyembunyikan kompleksitas dari sumber data dan menyediakan antarmuka yang konsisten untuk mengakses data.

### Tujuan dan Manfaat:
- **Abstraksi**: Menyembunyikan implementasi detail dari sumber data
- **Testability**: Mudah diuji karena abstraksi disediakan
- **Maintainability**: Perubahan sumber data tidak mempengaruhi domain logic
- **Flexibility**: Bisa menggabungkan beberapa sumber data (lokal + remote)
- **Single Source of Truth**: Gudang utama untuk data

### Struktur Repository Pattern:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   DOMAIN    ‚îÇ ‚Üê‚Üí ‚îÇ REPOSITORY   ‚îÇ ‚Üê‚Üí ‚îÇ DATA SOURCES     ‚îÇ
‚îÇ  LAYER      ‚îÇ    ‚îÇ INTERFACE    ‚îÇ    ‚îÇ (Local + Remote) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                    ‚îÇ                      ‚îÇ
     ‚îÇ                    ‚ñº                      ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ USE CASES   ‚îÇ    ‚îÇ IMPLEMENTATION‚îÇ    ‚îÇ DATABASE, API    ‚îÇ
‚îÇ             ‚îÇ    ‚îÇ              ‚îÇ    ‚îÇ                  ‚îÇ
‚îÇ BUSINESS    ‚îÇ    ‚îÇ REPOSITORY   ‚îÇ    ‚îÇ ROOM, RETROFIT   ‚îÇ
‚îÇ LOGIC       ‚îÇ    ‚îÇ              ‚îÇ    ‚îÇ DATASTORE, KTOR  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Implementation:
**domain/repository/UserRepository.kt**
```kotlin
package com.example.myrepositoryapp.domain.repository

import com.example.myrepositoryapp.domain.model.User
import kotlinx.coroutines.flow.Flow

/**
 * Interface repository - kontrak untuk akses data pengguna
 * Ini adalah bagian DOMAIN layer
 */
interface UserRepository {
    
    /**
     * Mendapatkan semua pengguna sebagai Flow untuk reactive updates
     */
    fun getUsers(): Flow<List<User>>
    
    /**
     * Mendapatkan pengguna berdasarkan ID
     */
    fun getUserById(id: Int): Flow<User?>
    
    /**
     * Mendapatkan pengguna dari remote dan cache ke lokal
     */
    suspend fun refreshUsers()
    
    /**
     * Membuat pengguna baru
     */
    suspend fun createUser(user: User): Result<Unit>
    
    /**
     * Memperbarui pengguna
     */
    suspend fun updateUser(user: User): Result<Unit>
    
    /**
     * Menghapus pengguna
     */
    suspend fun deleteUser(id: Int): Result<Unit>
    
    /**
     * Mencari pengguna berdasarkan nama
     */
    suspend fun searchUsers(query: String): List<User>
    
    /**
     * Menghitung total pengguna
     */
    suspend fun getUserCount(): Int
}
```

**data/source/local/LocalUserDataSource.kt**
```kotlin
package com.example.myrepositoryapp.data.source.local

import com.example.myrepositoryapp.data.database.entity.UserEntity
import kotlinx.coroutines.flow.Flow

/**
 * Data source lokal - mengakses data dari database
 * Ini adalah bagian DATA layer
 */
interface LocalUserDataSource {
    fun getUsers(): Flow<List<UserEntity>>
    fun getUserById(id: Int): Flow<UserEntity?>
    suspend fun insertUser(user: UserEntity)
    suspend fun insertUsers(users: List<UserEntity>)
    suspend fun updateUser(user: UserEntity)
    suspend fun deleteUser(id: Int)
    suspend fun deleteAllUsers()
    suspend fun searchUsers(query: String): List<UserEntity>
    suspend fun getUserCount(): Int
}
```

**data/source/remote/RemoteUserDataSource.kt**
```kotlin
package com.example.myrepositoryapp.data.source.remote

import com.example.myrepositoryapp.data.dto.ApiResponse
import com.example.myrepositoryapp.data.dto.UserDto

/**
 * Data source remote - mengakses data dari API
 * Ini adalah bagian DATA layer
 */
interface RemoteUserDataSource {
    suspend fun getUsers(): ApiResponse<List<UserDto>>
    suspend fun getUserById(id: Int): ApiResponse<UserDto?>
    suspend fun createUser(user: UserDto): ApiResponse<UserDto>
    suspend fun updateUser(user: UserDto): ApiResponse<UserDto>
    suspend fun deleteUser(id: Int): ApiResponse<Unit>
}
```

**data/repository/UserRepositoryImpl.kt**
```kotlin
package com.example.myrepositoryapp.data.repository

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Implementasi repository - menggabungkan sumber data lokal dan remote
 * Ini adalah bagian DATA layer
 */
@Singleton
class UserRepositoryImpl @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()
        }
    }
    
    override suspend fun refreshUsers() {
        try {
            val remoteUsers = remoteDataSource.getUsers()
            if (remoteUsers.isSuccessful) {
                // Hapus data lama dan simpan data baru
                localDataSource.deleteAllUsers()
                val entities = remoteUsers.data?.map { it.toEntity() } ?: emptyList()
                localDataSource.insertUsers(entities)
            }
        } catch (e: Exception) {
            // Log error atau handle sesuai kebijakan
            throw e
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return try {
            // Kirim ke remote
            val response = remoteDataSource.createUser(user.toDto())
            
            if (response.isSuccessful) {
                // Simpan ke lokal jika berhasil
                localDataSource.insertUser(response.data?.toEntity() ?: user.toEntity())
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return try {
            val response = remoteDataSource.updateUser(user.toDto())
            
            if (response.isSuccessful) {
                localDataSource.updateUser(response.data?.toEntity() ?: user.toEntity())
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return try {
            val response = remoteDataSource.deleteUser(id)
            
            if (response.isSuccessful) {
                localDataSource.deleteUser(id)
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return localDataSource.searchUsers(query).map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
}
```

### üéì Penjelasan Konsep:
**Repository seperti Kepala Gudang:**
- **Abstraction**: Menyembunyikan detail implementasi
- **Single Responsibility**: Hanya mengurus akses data
- **Source Agnostic**: Tidak peduli data dari mana
- **Consistent Interface**: API yang sama untuk semua sumber data

**Manfaat Repository Pattern:**
- **Testability**: Mudah di-mock dan diuji
- **Maintainability**: Perubahan sumber data tidak mempengaruhi domain
- **Flexibility**: Mudah beralih antara strategi caching
- **Separation of Concerns**: Domain logic tidak terikat dengan teknologi data access

---

## 2Ô∏è‚É£ Repository Structure üèóÔ∏è

### Konsep Dasar
Repository Structure seperti blueprint gedung üèóÔ∏è - struktur yang kokoh untuk mengatur data access!

### Interface-Based Repository:

#### 1. **Repository Interface Structure:**
```kotlin
package com.example.myrepositoryapp.domain.repository

import com.example.myrepositoryapp.domain.model.Post
import kotlinx.coroutines.flow.Flow

/**
 * Interface repository untuk Post
 * Mengikuti naming convention: NounRepository (misal: UserRepository, PostRepository)
 */
interface PostRepository {
    
    // Get operations - biasanya mengembalikan Flow untuk reactive updates
    fun getPosts(): Flow<List<Post>>
    fun getPostById(id: Int): Flow<Post?>
    fun getPostsByUserId(userId: Int): Flow<List<Post>>
    
    // Search operations - biasanya mengembulikan suspend function
    suspend fun searchPosts(query: String): List<Post>
    suspend fun getPopularPosts(limit: Int): List<Post>
    
    // CRUD operations - menggunakan suspend functions
    suspend fun createPost(post: Post): Result<Unit>
    suspend fun updatePost(post: Post): Result<Unit>
    suspend fun deletePost(id: Int): Result<Unit>
    
    // Utility operations
    suspend fun getPostCount(): Int
    suspend fun hasPosts(): Boolean
}
```

#### 2. **Repository Implementation Structure:**
```kotlin
package com.example.myrepositoryapp.data.repository

import com.example.myrepositoryapp.data.source.local.LocalPostDataSource
import com.example.myrepositoryapp.data.source.remote.RemotePostDataSource
import com.example.myrepositoryapp.domain.model.Post
import com.example.myrepositoryapp.domain.repository.PostRepository
import com.example.myrepositoryapp.utils.Result
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.combine
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Implementasi repository dengan pendekatan Network Bound Resource
 */
@Singleton
class PostRepositoryImpl @Inject constructor(
    private val localDataSource: LocalPostDataSource,
    private val remoteDataSource: RemotePostDataSource
) : PostRepository {
    
    // 1. PUBLIC METHODS - Suspend functions
    override fun getPosts(): Flow<List<Post>> {
        return localDataSource.getPosts().map { posts ->
            posts.map { it.toDomain() }
        }
    }
    
    override fun getPostById(id: Int): Flow<Post?> {
        return localDataSource.getPostById(id).map { post ->
            post?.toDomain()
        }
    }
    
    override fun getPostsByUserId(userId: Int): Flow<List<Post>> {
        return localDataSource.getPostsByUserId(userId).map { posts ->
            posts.map { it.toDomain() }
        }
    }
    
    override suspend fun searchPosts(query: String): List<Post> {
        return localDataSource.searchPosts(query).map { it.toDomain() }
    }
    
    override suspend fun getPopularPosts(limit: Int): List<Post> {
        return localDataSource.getPopularPosts(limit).map { it.toDomain() }
    }
    
    override suspend fun createPost(post: Post): Result<Unit> {
        return try {
            // Kirim ke remote
            val response = remoteDataSource.createPost(post.toDto())
            
            if (response.isSuccessful) {
                // Simpan ke lokal
                localDataSource.insertPost(response.data?.toEntity() ?: post.toEntity())
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun updatePost(post: Post): Result<Unit> {
        return try {
            // Update di remote
            val response = remoteDataSource.updatePost(post.toDto())
            
            if (response.isSuccessful) {
                // Update di lokal
                localDataSource.updatePost(post.toEntity())
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun deletePost(id: Int): Result<Unit> {
        return try {
            // Hapus di remote
            val response = remoteDataSource.deletePost(id)
            
            if (response.isSuccessful) {
                // Hapus di lokal
                localDataSource.deletePost(id)
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun getPostCount(): Int {
        return localDataSource.getPostCount()
    }
    
    override suspend fun hasPosts(): Boolean {
        return localDataSource.hasPosts()
    }
    
    // 2. PRIVATE HELPER METHODS - Metode pembantu
    private suspend fun cachePost(post: Post) {
        localDataSource.insertPost(post.toEntity())
    }
    
    private suspend fun invalidateCache() {
        localDataSource.deleteAllPosts()
    }
    
    private suspend fun updateLocalOnly(post: Post) {
        localDataSource.updatePost(post.toEntity())
    }
    
    private suspend fun isCacheExpired(): Boolean {
        val lastUpdate = localDataSource.getLastUpdateTimestamp()
        return System.currentTimeMillis() - lastUpdate > CACHE_EXPIRATION_TIME
    }
    
    private suspend fun refreshFromRemote(): Result<Unit> {
        return try {
            val posts = remoteDataSource.getPosts()
            if (posts.isSuccessful && posts.data != null) {
                localDataSource.deleteAllPosts()
                localDataSource.insertPosts(posts.data.map { it.toEntity() })
                Result.success(Unit)
            } else {
                Result.failure(Exception(posts.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    companion object {
        private const val CACHE_EXPIRATION_TIME = 30 * 60 * 1000L // 30 minutes
    }
}
```

#### 3. **Naming Convention & Best Practices:**
```kotlin
// ‚úÖ CORRECT Naming Convention
interface UserRepository
interface PostRepository
interface CommentRepository

class UserRepositoryImpl
class PostRepositoryImpl  
class CommentRepositoryImpl

// ‚úÖ CORRECT Method Naming
fun getUsers(): Flow<List<User>>               // Get operations
suspend fun createUser(user: User): Result<Unit>   // Create operations
suspend fun updateUser(user: User): Result<Unit>   // Update operations
suspend fun deleteUser(id: Int): Result<Unit>      // Delete operations
suspend fun searchUsers(query: String): List<User> // Search operations

// ‚ùå WRONG - Using imperative names
fun fetchUsers()
fun saveUser()
fun removeUser()
```

#### 4. **Return Types Convention:**
```kotlin
interface UserRepository {
    
    // Get operations - Flow untuk reactive updates
    fun getUsers(): Flow<List<User>>
    fun getUserById(id: Int): Flow<User?>
    
    // Operation results - gunakan Result<T> untuk error handling
    suspend fun createUser(user: User): Result<User>
    suspend fun updateUser(user: User): Result<Unit>
    suspend fun deleteUser(id: Int): Result<Unit>
    
    // Simple queries - bisa langsung return T
    suspend fun getUserCount(): Int
    suspend fun existsByEmail(email: String): Boolean
    
    // Search/filter - biasanya mengembalikan List<T>
    suspend fun searchUsers(query: String): List<User>
    suspend fun getUsersByRole(role: String): List<User>
}
```

### Implementation Contoh Lengkap:
**domain/repository/CommentRepository.kt**
```kotlin
package com.example.myrepositoryapp.domain.repository

import com.example.myrepositoryapp.domain.model.Comment
import kotlinx.coroutines.flow.Flow

/**
 * Contoh repository lain untuk menunjukkan struktur konsisten
 */
interface CommentRepository {
    
    // Get operations
    fun getCommentsByPostId(postId: Int): Flow<List<Comment>>
    fun getCommentById(id: Int): Flow<Comment?>
    
    // CRUD operations
    suspend fun createComment(comment: Comment): Result<Unit>
    suspend fun updateComment(comment: Comment): Result<Unit>
    suspend fun deleteComment(id: Int): Result<Unit>
    
    // Batch operations
    suspend fun createComments(comments: List<Comment>): Result<Unit>
    suspend fun deleteCommentsByPostId(postId: Int): Result<Unit>
    
    // Utility operations
    suspend fun getCommentCount(): Int
    suspend fun getCommentsByUserId(userId: Int): List<Comment>
}
```

### üéì Penjelasan Konsep:
**Repository Structure seperti Blueprint Gedung:**
- **Interface**: Kontrak (blueprint dasar)
- **Implementation**: Bangunan aslinya (bagaimana kontrak diimplementasikan)
- **Public Methods**: Pintu masuk ke gedung
- **Private Methods**: Fungsi internal gedung

**Best Practices Structure:**
- **Interface**: Hanya deklarasi, tidak implementasi
- **Implementation**: Implementasi konkret metode
- **Suspend Functions**: Untuk operasi async
- **Flow**: Untuk streaming data
- **`Result<T>`**: Untuk error handling
- **Naming**: Konsisten dan deskriptif

---

## 3Ô∏è‚É£ Data Sources üì°

### Konsep Dasar
Data Sources seperti gudang-gudang üè™ - tempat penyimpanan data yang berbeda!

### Local Data Source (Database):
**data/source/local/LocalUserDataSource.kt**
```kotlin
package com.example.myrepositoryapp.data.source.local

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.myrepositoryapp.data.database.entity.UserEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface LocalUserDataSource {
    
    @Query("SELECT * FROM users ORDER BY name ASC")
    fun getUsers(): Flow<List<UserEntity>>
    
    @Query("SELECT * FROM users WHERE id = :id")
    fun getUserById(id: Int): Flow<UserEntity?>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUser(user: UserEntity)
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUsers(users: List<UserEntity>)
    
    @Update
    suspend fun updateUser(user: UserEntity)
    
    @Query("UPDATE users SET name = :name, email = :email WHERE id = :id")
    suspend fun updateUserFields(id: Int, name: String, email: String)
    
    @Query("DELETE FROM users WHERE id = :id")
    suspend fun deleteUser(id: Int)
    
    @Query("DELETE FROM users")
    suspend fun deleteAllUsers()
    
    @Query("SELECT * FROM users WHERE name LIKE '%' || :query || '%' OR email LIKE '%' || :query || '%'")
    suspend fun searchUsers(query: String): List<UserEntity>
    
    @Query("SELECT COUNT(*) FROM users")
    suspend fun getUserCount(): Int
    
    @Query("SELECT EXISTS(SELECT 1 FROM users WHERE email = :email)")
    suspend fun existsByEmail(email: String): Boolean
}
```

**data/database/entity/UserEntity.kt**
```kotlin
package com.example.myrepositoryapp.data.database.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.ColumnInfo

@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Int = 0,
    
    @ColumnInfo(name = "name")
    val name: String,
    
    @ColumnInfo(name = "email")
    val email: String,
    
    @ColumnInfo(name = "phone")
    val phone: String? = null,
    
    @ColumnInfo(name = "is_active")
    val isActive: Boolean = true,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long = System.currentTimeMillis(),
    
    @ColumnInfo(name = "updated_at")
    val updatedAt: Long = System.currentTimeMillis()
)
```

**data/source/local/impl/LocalUserDataSourceImpl.kt**
```kotlin
package com.example.myrepositoryapp.data.source.local.impl

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.database.dao.UserDao
import com.example.myrepositoryapp.data.database.entity.UserEntity
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject

class LocalUserDataSourceImpl @Inject constructor(
    private val userDao: UserDao
) : LocalUserDataSource {
    
    override fun getUsers(): Flow<List<UserEntity>> {
        return userDao.getUsers()
    }
    
    override fun getUserById(id: Int): Flow<UserEntity?> {
        return userDao.getUserById(id)
    }
    
    override suspend fun insertUser(user: UserEntity): Long {
        return userDao.insertUser(
            user.copy(updatedAt = System.currentTimeMillis())
        )
    }
    
    override suspend fun insertUsers(users: List<UserEntity>) {
        userDao.insertUsers(users.map { it.copy(updatedAt = System.currentTimeMillis()) })
    }
    
    override suspend fun updateUser(user: UserEntity) {
        userDao.updateUser(user.copy(updatedAt = System.currentTimeMillis()))
    }
    
    override suspend fun deleteUser(id: Int) {
        userDao.deleteUser(id)
    }
    
    override suspend fun deleteAllUsers() {
        userDao.deleteAllUsers()
    }
    
    override suspend fun searchUsers(query: String): List<UserEntity> {
        return userDao.searchUsers(query)
    }
    
    override suspend fun getUserCount(): Int {
        return userDao.getUserCount()
    }
    
    override suspend fun existsByEmail(email: String): Boolean {
        return userDao.existsByEmail(email)
    }
}
```

### Remote Data Source (API):
**data/source/remote/RemoteUserDataSource.kt**
```kotlin
package com.example.myrepositoryapp.data.source.remote

import com.example.myrepositoryapp.data.dto.ApiResponse
import com.example.myrepositoryapp.data.dto.UserDto
import retrofit2.http.*

interface RemoteUserDataSource {
    
    @GET("users")
    suspend fun getUsers(): ApiResponse<List<UserDto>>
    
    @GET("users/{id}")
    suspend fun getUserById(@Path("id") id: Int): ApiResponse<UserDto?>
    
    @POST("users")
    suspend fun createUser(@Body user: UserDto): ApiResponse<UserDto>
    
    @PUT("users/{id}")
    suspend fun updateUser(@Path("id") id: Int, @Body user: UserDto): ApiResponse<UserDto>
    
    @DELETE("users/{id}")
    suspend fun deleteUser(@Path("id") id: Int): ApiResponse<Unit>
    
    @GET("users")
    suspend fun searchUsers(@Query("name") query: String): ApiResponse<List<UserDto>>
}
```

**data/dto/UserDto.kt**
```kotlin
package com.example.myrepositoryapp.data.dto

import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

@JsonClass(generateAdapter = true)
data class UserDto(
    @Json(name = "id") val id: Int,
    @Json(name = "name") val name: String,
    @Json(name = "email") val email: String,
    @Json(name = "phone") val phone: String? = null,
    @Json(name = "isActive") val isActive: Boolean = true
)

data class ApiResponse<T>(
    val data: T? = null,
    val errorMessage: String? = null,
    val isSuccessful: Boolean = false,
    val code: Int = 0
)
```

**data/source/remote/impl/RemoteUserDataSourceImpl.kt**
```kotlin
package com.example.myrepositoryapp.data.source.remote.impl

import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.data.dto.ApiResponse
import com.example.myrepositoryapp.data.dto.UserDto
import com.example.myrepositoryapp.network.UserService
import javax.inject.Inject

class RemoteUserDataSourceImpl @Inject constructor(
    private val userService: UserService
) : RemoteUserDataSource {
    
    override suspend fun getUsers(): ApiResponse<List<UserDto>> {
        return try {
            val response = userService.getUsers()
            ApiResponse(
                data = response,
                isSuccessful = true
            )
        } catch (e: Exception) {
            ApiResponse(
                errorMessage = e.message,
                isSuccessful = false
            )
        }
    }
    
    override suspend fun getUserById(id: Int): ApiResponse<UserDto?> {
        return try {
            val response = userService.getUserById(id)
            ApiResponse(
                data = response,
                isSuccessful = true
            )
        } catch (e: Exception) {
            ApiResponse(
                errorMessage = e.message,
                isSuccessful = false
            )
        }
    }
    
    override suspend fun createUser(user: UserDto): ApiResponse<UserDto> {
        return try {
            val response = userService.createUser(user)
            ApiResponse(
                data = response,
                isSuccessful = true
            )
        } catch (e: Exception) {
            ApiResponse(
                errorMessage = e.message,
                isSuccessful = false
            )
        }
    }
    
    override suspend fun updateUser(id: Int, user: UserDto): ApiResponse<UserDto> {
        return try {
            val response = userService.updateUser(id, user)
            ApiResponse(
                data = response,
                isSuccessful = true
            )
        } catch (e: Exception) {
            ApiResponse(
                errorMessage = e.message,
                isSuccessful = false
            )
        }
    }
    
    override suspend fun deleteUser(id: Int): ApiResponse<Unit> {
        return try {
            userService.deleteUser(id)
            ApiResponse(
                data = Unit,
                isSuccessful = true
            )
        } catch (e: Exception) {
            ApiResponse(
                errorMessage = e.message,
                isSuccessful = false
            )
        }
    }
    
    override suspend fun searchUsers(query: String): ApiResponse<List<UserDto>> {
        return try {
            val response = userService.searchUsers(query)
            ApiResponse(
                data = response,
                isSuccessful = true
            )
        } catch (e: Exception) {
            ApiResponse(
                errorMessage = e.message,
                isSuccessful = false
            )
        }
    }
}
```

### Data Source with DataStore:
**data/source/local/PreferenceDataSource.kt**
```kotlin
package com.example.myrepositoryapp.data.source.local

import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.stringPreferencesKey
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PreferenceDataSource @Inject constructor(
    private val dataStore: DataStore<Preferences>
) {
    
    private object PreferencesKeys {
        val USER_PREFERENCES_KEY = stringPreferencesKey("user_preferences")
        val APP_THEME_KEY = stringPreferencesKey("app_theme")
        val FIRST_LAUNCH_KEY = stringPreferencesKey("first_launch")
    }
    
    val userPreferences: Flow<String> = dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.USER_PREFERENCES_KEY] ?: ""
        }
    
    val appTheme: Flow<String> = dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.APP_THEME_KEY] ?: "system"
        }
    
    val isFirstLaunch: Flow<Boolean> = dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.FIRST_LAUNCH_KEY] ?: true
        }
    
    suspend fun saveUserPreferences(preferences: String) {
        dataStore.edit { store ->
            store[PreferencesKeys.USER_PREFERENCES_KEY] = preferences
        }
    }
    
    suspend fun saveAppTheme(theme: String) {
        dataStore.edit { store ->
            store[PreferencesKeys.APP_THEME_KEY] = theme
        }
    }
    
    suspend fun markFirstLaunchComplete() {
        dataStore.edit { store ->
            store[PreferencesKeys.FIRST_LAUNCH_KEY] = false
        }
    }
}
```

### üéì Penjelasan Konsep:
**Data Sources seperti Gudang-Gudang:**
- **Local**: Database lokal (Room, DataStore)
- **Remote**: API eksternal (Retrofit, Ktor)
- **Cache**: Penyimpanan sementara (memory, disk)
- Each source has specific purpose and characteristics

**Jenis Data Sources:**
- **Local (Room)**: Data persisten offline
- **Remote (API)**: Data real-time dari server
- **Preference (DataStore)**: Data konfigurasi
- **Memory Cache**: Data sementara di RAM

**Best Practices:**
- Pisahkan interface dari implementasi
- Gunakan DAO untuk Room
- Gunakan DTO untuk API
- Gunakan abstraksi untuk testability
- Tambahkan error handling
- Gunakan type safety

---

## 4Ô∏è‚É£ Repository Implementation Strategies üîÑ

### Konsep Dasar
Repository Implementation Strategies seperti strategi pengiriman üöö - bagaimana data diambil dan disimpan!

### 1. Network-First Strategy (Network-first approach):

#### Implementation:
**data/repository/strategy/NetworkFirstUserRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.strategy

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Network-first strategy: Coba dari network dulu, fallback ke cache jika gagal
 */
@Singleton
class NetworkFirstUserRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()
        }
    }
    
    override suspend fun refreshUsers() {
        try {
            // Ambil dari remote dulu
            val response = remoteDataSource.getUsers()
            
            if (response.isSuccessful && response.data != null) {
                // Simpan ke lokal
                val entities = response.data.map { it.toEntity() }
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(entities)
            }
        } catch (e: Exception) {
            // Biarkan lokal tetap utuh jika remote gagal
            // Kita tetap bisa menampilkan data lama
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return try {
            // Kirim ke remote dulu
            val response = remoteDataSource.createUser(user.toDto())
            
            if (response.isSuccessful) {
                // Simpan ke lokal jika berhasil
                localDataSource.insertUser(response.data?.toEntity() ?: user.toEntity())
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            // Jika remote gagal, simpan ke lokal untuk sync nanti
            localDataSource.insertUser(user.toEntity())
            // Kembalikan failure - client harus handle sync queue
            Result.failure(e)
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return try {
            val response = remoteDataSource.updateUser(user.id, user.toDto())
            
            if (response.isSuccessful) {
                localDataSource.updateUser(user.toEntity())
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            // Update lokal dulu, queue untuk sync nanti
            localDataSource.updateUser(user.toEntity())
            Result.failure(e)
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return try {
            val response = remoteDataSource.deleteUser(id)
            
            if (response.isSuccessful) {
                localDataSource.deleteUser(id)
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            // Queue untuk sync nanti
            Result.failure(e)
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        // Coba dari lokal dulu
        val localResults = localDataSource.searchUsers(query)
        return localResults.map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
}
```

### 2. Cache-First Strategy (Cache-first approach):

#### Implementation:
**data/repository/strategy/CacheFirstUserRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.strategy

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Cache-first strategy: Ambil dari cache dulu, update dari network di background
 */
@Singleton
class CacheFirstUserRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()
        }
    }
    
    override suspend fun refreshUsers() {
        try {
            // Update di background tanpa blocking UI
            val response = remoteDataSource.getUsers()
            
            if (response.isSuccessful && response.data != null) {
                // Update cache dengan data fresh
                val entities = response.data.map { it.toEntity() }
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(entities)
            }
        } catch (e: Exception) {
            // Log error, tapi tidak throw - cache tetap valid
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return try {
            // Simpan ke lokal dulu (offline support)
            localDataSource.insertUser(user.toEntity())
            
            // Kirim ke remote di background
            val response = remoteDataSource.createUser(user.toDto())
            
            if (response.isSuccessful) {
                // Update lokal jika perlu (mungkin server generate ID baru)
                response.data?.let { newRemoteUser ->
                    localDataSource.updateUser(newRemoteUser.toEntity())
                }
                Result.success(Unit)
            } else {
                // Biarkan lokal tetap, kembalikan error
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            // Jika remote gagal, tetap sukses - data sudah ada di lokal
            Result.success(Unit)
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return try {
            // Update lokal dulu
            localDataSource.updateUser(user.toEntity())
            
            // Update remote di background
            val response = remoteDataSource.updateUser(user.id, user.toDto())
            
            if (response.isSuccessful) {
                // Update lokal dengan data dari server jika perlu
                response.data?.let { serverUser ->
                    localDataSource.updateUser(serverUser.toEntity())
                }
                Result.success(Unit)
            } else {
                // Biarkan lokal tetap, kembalikan error
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            // Jika remote gagal, tetap sukses - data lokal tetap valid
            Result.success(Unit)
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return try {
            // Hapus dari lokal dulu
            localDataSource.deleteUser(id)
            
            // Hapus dari remote di background
            val response = remoteDataSource.deleteUser(id)
            
            if (response.isSuccessful) {
                Result.success(Unit)
            } else {
                // Hapus lokal tetap berhasil, kembalikan error
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            // Jika remote gagal, data lokal tetap dihapus
            Result.success(Unit)
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return localDataSource.searchUsers(query).map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
}
```

### 3. Network-Bound Resource Strategy (Network-bound resource):

#### Implementation:
**data/repository/strategy/NetworkBoundResourceRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.strategy

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.*
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Network-bound resource: Gunakan cache untuk UI, update dari network di background
 * Ini menggabungkan performa cache dan freshness dari network
 */
@Singleton
class NetworkBoundResourceRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return flow {
            // Emit cached data dulu untuk UI yang responsif
            val cachedUsers = localDataSource.getUsers().first()
            emit(cachedUsers.map { it.toDomain() })
            
            // Check apakah cache perlu di-refresh
            val shouldRefresh = shouldRefreshCache()
            
            if (shouldRefresh) {
                try {
                    // Ambil data fresh dari network
                    val freshUsers = remoteDataSource.getUsers()
                    
                    if (freshUsers.isSuccessful && freshUsers.data != null) {
                        // Update cache dengan data fresh
                        val entities = freshUsers.data.map { it.toEntity() }
                        localDataSource.deleteAllUsers()
                        localDataSource.insertUsers(entities)
                        
                        // Emit data yang diperbarui
                        val updatedUsers = localDataSource.getUsers().first()
                        emit(updatedUsers.map { it.toDomain() })
                    }
                } catch (e: Exception) {
                    // Jika network gagal, tetap gunakan cached data
                    // Tidak throw exception - gunakan fallback
                }
            }
        }.flowOn(kotlinx.coroutines.Dispatchers.IO)
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return flow {
            // Emit cached data dulu
            val cachedUser = localDataSource.getUserById(id).first()
            emit(cachedUser?.toDomain())
            
            // Check apakah cache perlu di-refresh untuk user spesifik
            if (cachedUser != null && shouldRefreshUser(cachedUser.updatedAt)) {
                try {
                    // Ambil dari network
                    val freshUser = remoteDataSource.getUserById(id)
                    
                    if (freshUser.isSuccessful && freshUser.data != null) {
                        // Update cache
                        localDataSource.insertUser(freshUser.data.toEntity())
                        
                        // Emit data terupdate
                        val updatedUser = localDataSource.getUserById(id).first()
                        emit(updatedUser?.toDomain())
                    }
                } catch (e: Exception) {
                    // Gunakan cached data jika network gagal
                }
            }
        }.flowOn(kotlinx.coroutines.Dispatchers.IO)
    }
    
    private suspend fun shouldRefreshCache(): Boolean {
        val lastUpdateTime = localDataSource.getUsers().first().maxOfOrNull { it.updatedAt } ?: 0
        val currentTime = System.currentTimeMillis()
        val cacheExpirationTime = TimeUnit.MINUTES.toMillis(5) // 5 menit
        
        return (currentTime - lastUpdateTime) > cacheExpirationTime
    }
    
    private fun shouldRefreshUser(lastUpdated: Long): Boolean {
        val currentTime = System.currentTimeMillis()
        val cacheExpirationTime = TimeUnit.MINUTES.toMillis(5) // 5 menit
        return (currentTime - lastUpdated) > cacheExpirationTime
    }
    
    override suspend fun refreshUsers() {
        // Force refresh regardless of cache age
        try {
            val response = remoteDataSource.getUsers()
            if (response.isSuccessful && response.data != null) {
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(response.data.map { it.toEntity() })
            }
        } catch (e: Exception) {
            // Log error - tidak throw karena ini operasi background
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return try {
            // Simpan ke lokal dulu untuk offline support
            val localId = localDataSource.insertUser(user.toEntity())
            
            // Kirim ke remote di background
            val response = remoteDataSource.createUser(user.toDto())
            
            if (response.isSuccessful && response.data != null) {
                // Update lokal dengan ID dari server jika perlu
                val serverUser = response.data.toEntity()
                if (serverUser.id != localId) {
                    // Server mungkin membuat ID baru
                    localDataSource.updateUser(serverUser)
                }
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            // Jika remote gagal, tetap sukses - data sudah tersimpan lokal
            Result.success(Unit)
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return try {
            // Update lokal dulu
            localDataSource.updateUser(user.toEntity())
            
            // Update remote di background
            val response = remoteDataSource.updateUser(user.id, user.toDto())
            
            if (response.isSuccessful) {
                response.data?.let { serverUser ->
                    // Update lokal dengan data dari server
                    localDataSource.updateUser(serverUser.toEntity())
                }
                Result.success(Unit)
            } else {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            }
        } catch (e: Exception) {
            // Jika remote gagal, tetap sukses - data lokal sudah terupdate
            Result.success(Unit)
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return try {
            // Hapus dari lokal dulu
            localDataSource.deleteUser(id)
            
            // Hapus dari remote di background
            val response = remoteDataSource.deleteUser(id)
            
            if (!response.isSuccessful) {
                Result.failure(Exception(response.errorMessage ?: "Unknown error"))
            } else {
                Result.success(Unit)
            }
        } catch (e: Exception) {
            Result.success(Unit) // Hapus lokal tetap berhasil
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        // Cari di cache dulu
        val localResults = localDataSource.searchUsers(query)
        return localResults.map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
}
```

### 4. Strategy Selector Pattern:
**data/repository/strategy/StrategySelectorRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.strategy

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.ConnectivityHelper
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository dengan dynamic strategy selection berdasarkan kondisi
 */
@Singleton
class StrategySelectorRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource,
    private val connectivityHelper: ConnectivityHelper
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()
        }
    }
    
    override suspend fun refreshUsers() {
        val strategy = determineStrategy()
        
        when (strategy) {
            Strategy.NETWORK_FIRST -> {
                networkFirstRefresh()
            }
            Strategy.CACHE_FIRST -> {
                cacheFirstRefresh()
            }
            Strategy.NETWORK_BOUND -> {
                networkBoundRefresh()
            }
        }
    }
    
    private suspend fun networkFirstRefresh() {
        try {
            val response = remoteDataSource.getUsers()
            if (response.isSuccessful && response.data != null) {
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(response.data.map { it.toEntity() })
            }
        } catch (e: Exception) {
            // Fallback to no-op
        }
    }
    
    private suspend fun cacheFirstRefresh() {
        try {
            val response = remoteDataSource.getUsers()
            if (response.isSuccessful && response.data != null) {
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(response.data.map { it.toEntity() })
            }
        } catch (e: Exception) {
            // Log error, tidak throw
        }
    }
    
    private suspend fun networkBoundRefresh() {
        // Gunakan pendekatan network-bound resource
        try {
            val response = remoteDataSource.getUsers()
            if (response.isSuccessful && response.data != null) {
                val cachedUsers = localDataSource.getUsers().first()
                
                // Update hanya jika cache kosong atau lama
                if (cachedUsers.isEmpty() || shouldRefreshCache(cachedUsers)) {
                    localDataSource.deleteAllUsers()
                    localDataSource.insertUsers(response.data.map { it.toEntity() })
                }
            }
        } catch (e: Exception) {
            // Log error, tidak throw
        }
    }
    
    private fun shouldRefreshCache(users: List<UserEntity>): Boolean {
        val currentTime = System.currentTimeMillis()
        val lastUpdated = users.maxOfOrNull { it.updatedAt } ?: 0
        return (currentTime - lastUpdated) > CACHE_EXPIRATION_TIME_MS
    }
    
    private fun determineStrategy(): Strategy {
        return if (connectivityHelper.isConnected()) {
            if (connectivityHelper.isWiFi()) {
                Strategy.NETWORK_FIRST // WiFi cepat, ambil dari network dulu
            } else {
                Strategy.NETWORK_BOUND  // Cellular, gunakan cache dulu
            }
        } else {
            Strategy.CACHE_FIRST      // Offine, gunakan cache
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return try {
            // Selalu simpan ke lokal dulu untuk offline support
            localDataSource.insertUser(user.toEntity())
            
            val strategy = determineStrategy()
            
            when (strategy) {
                Strategy.NETWORK_FIRST -> {
                    try {
                        val response = remoteDataSource.createUser(user.toDto())
                        if (response.isSuccessful) {
                            response.data?.let { localDataSource.updateUser(it.toEntity()) }
                        }
                        Result.success(Unit)
                    } catch (e: Exception) {
                        Result.success(Unit) // Offline support
                    }
                }
                Strategy.CACHE_FIRST -> {
                    try {
                        val response = remoteDataSource.createUser(user.toDto())
                        if (response.isSuccessful) {
                            response.data?.let { localDataSource.updateUser(it.toEntity()) }
                        }
                    } catch (e: Exception) {
                        // Continue with success
                    }
                    Result.success(Unit)
                }
                Strategy.NETWORK_BOUND -> {
                    // Kirim ke network async di background
                    try {
                        kotlinx.coroutines.GlobalScope.launch {
                            val response = remoteDataSource.createUser(user.toDto())
                            if (response.isSuccessful) {
                                response.data?.let { localDataSource.updateUser(it.toEntity()) }
                            }
                        }
                    } catch (e: Exception) {
                        // Continue with success - async operation
                    }
                    Result.success(Unit)
                }
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        // Implementasi serupa untuk update
        localDataSource.updateUser(user.toEntity())
        
        when (determineStrategy()) {
            Strategy.NETWORK_FIRST -> {
                try {
                    val response = remoteDataSource.updateUser(user.id, user.toDto())
                    if (response.isSuccessful) {
                        response.data?.let { localDataSource.updateUser(it.toEntity()) }
                    }
                    return Result.success(Unit)
                } catch (e: Exception) {
                    return Result.success(Unit)
                }
            }
            Strategy.CACHE_FIRST -> {
                try {
                    val response = remoteDataSource.updateUser(user.id, user.toDto())
                    if (response.isSuccessful) {
                        response.data?.let { localDataSource.updateUser(it.toEntity()) }
                    }
                } catch (e: Exception) {
                    // Continue
                }
                return Result.success(Unit)
            }
            Strategy.NETWORK_BOUND -> {
                try {
                    kotlinx.coroutines.GlobalScope.launch {
                        val response = remoteDataSource.updateUser(user.id, user.toDto())
                        if (response.isSuccessful) {
                            response.data?.let { localDataSource.updateUser(it.toEntity()) }
                        }
                    }
                } catch (e: Exception) {
                    // Continue
                }
                return Result.success(Unit)
            }
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        // Implementasi serupa untuk delete
        localDataSource.deleteUser(id)
        
        when (determineStrategy()) {
            Strategy.NETWORK_FIRST -> {
                try {
                    val response = remoteDataSource.deleteUser(id)
                    if (response.isSuccessful) {
                        localDataSource.deleteUser(id)
                    }
                    return Result.success(Unit)
                } catch (e: Exception) {
                    return Result.success(Unit)
                }
            }
            Strategy.CACHE_FIRST -> {
                try {
                    val response = remoteDataSource.deleteUser(id)
                    if (response.isSuccessful) {
                        localDataSource.deleteUser(id)
                    }
                } catch (e: Exception) {
                    // Continue
                }
                return Result.success(Unit)
            }
            Strategy.NETWORK_BOUND -> {
                try {
                    kotlinx.coroutines.GlobalScope.launch {
                        val response = remoteDataSource.deleteUser(id)
                        if (response.isSuccessful) {
                            localDataSource.deleteUser(id)
                        }
                    }
                } catch (e: Exception) {
                    // Continue
                }
                return Result.success(Unit)
            }
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return localDataSource.searchUsers(query).map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
    
    companion object {
        private const val CACHE_EXPIRATION_TIME_MS = 5 * 60 * 1000L // 5 minutes
    }
}

enum class Strategy {
    NETWORK_FIRST,
    CACHE_FIRST,
    NETWORK_BOUND
}

// Helper untuk connectivity
class ConnectivityHelper {
    fun isConnected(): Boolean = true // Implementasi sebenarnya dibutuhkan
    fun isWiFi(): Boolean = true     // Implementasi sebenarnya dibutuhkan
}
```

### üéì Penjelasan Konsep:
**Repository Implementation Strategies seperti Strategi Logistik:**
- **Network-First**: Ambil dari server dulu, fallback ke cache
- **Cache-First**: Ambil dari cache dulu, update network di background
- **Network-Bound**: Gunakan cache untuk responsivitas, update dari network

**Kapan Menggunakan Masing-Masing:**
- **Network-First**: Data harus sangat fresh (real-time)
- **Cache-First**: Offline-first apps (chat, email)
- **Network-Bound**: Aplikasi yang butuh balance (news, social media)

**Best Practices:**
- Gunakan Flow untuk reactive updates
- Simpan data lokal untuk offline support
- Tambahkan error handling
- Gunakan strategy selection dinamis
- Perhatikan kondisi jaringan
- Gunakan caching policies

---

## 5Ô∏è‚É£ Caching Strategy üíæ

### Konsep Dasar
Caching Strategy seperti rak penyimpanan cepat üóÇÔ∏è - menyimpan data yang sering diakses!

### In-Memory Caching:

#### Implementation:
**data/cache/MemoryCache.kt**
```kotlin
package com.example.myrepositoryapp.data.cache

import android.util.LruCache
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.time.Duration
import kotlin.time.DurationUnit
import kotlin.time.toDuration

/**
 * Memory cache untuk menyimpan data di RAM
 */
@Singleton
class MemoryCache @Inject constructor() {
    
    private val lruCache = object : LruCache<String, CacheEntry<Any>>(MAX_CACHE_SIZE) {
        override fun sizeOf(key: String, value: CacheEntry<Any>): Int {
            // Hitung ukuran dalam byte
            return key.length + (value.data?.toString()?.length ?: 0)
        }
    }
    
    fun <T> put(key: String, data: T, ttl: Duration = DEFAULT_TTL) {
        val entry = CacheEntry(
            data = data,
            expiryTime = System.currentTimeMillis() + ttl.inWholeMilliseconds
        )
        lruCache.put(key, entry as CacheEntry<Any>)
    }
    
    fun <T> get(key: String): T? {
        val entry = lruCache.get(key) as? CacheEntry<T>
        return if (entry != null && !entry.isExpired()) {
            entry.data
        } else {
            // Hapus entry yang expired
            lruCache.remove(key)
            null
        }
    }
    
    fun remove(key: String) {
        lruCache.remove(key)
    }
    
    fun clear() {
        lruCache.evictAll()
    }
    
    fun contains(key: String): Boolean {
        val entry = lruCache.get(key)
        return entry != null && !entry.isExpired()
    }
    
    private fun CacheEntry<*>.isExpired(): Boolean {
        return System.currentTimeMillis() > expiryTime
    }
    
    companion object {
        private const val MAX_CACHE_SIZE = 1024 * 1024 // 1MB
        private val DEFAULT_TTL = 5.toDuration(DurationUnit.MINUTES)
    }
}

data class CacheEntry<T>(
    val data: T,
    val expiryTime: Long
)
```

### Disk Caching with Room:

#### Implementation:
**data/cache/DiskCacheDao.kt**
```kotlin
package com.example.myrepositoryapp.data.cache

import androidx.room.*
import androidx.room.OnConflictStrategy.REPLACE
import com.example.myrepositoryapp.data.cache.entity.CacheEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface DiskCacheDao {
    
    @Insert(onConflict = REPLACE)
    suspend fun insert(cache: CacheEntity)
    
    @Insert(onConflict = REPLACE)
    suspend fun insertAll(caches: List<CacheEntity>)
    
    @Query("SELECT * FROM cache WHERE key = :key AND expiry_time > :currentTime")
    suspend fun get(key: String, currentTime: Long = System.currentTimeMillis()): CacheEntity?
    
    @Query("SELECT * FROM cache WHERE key = :key AND expiry_time > :currentTime")
    fun getFlow(key: String, currentTime: Long = System.currentTimeMillis()): Flow<CacheEntity?>
    
    @Query("SELECT * FROM cache WHERE expiry_time > :currentTime")
    fun getAll(currentTime: Long = System.currentTimeMillis()): Flow<List<CacheEntity>>
    
    @Query("DELETE FROM cache WHERE key = :key")
    suspend fun remove(key: String)
    
    @Query("DELETE FROM cache WHERE expiry_time <= :currentTime")
    suspend fun clearExpired(currentTime: Long = System.currentTimeMillis())
    
    @Query("DELETE FROM cache")
    suspend fun clearAll()
    
    @Query("SELECT COUNT(*) FROM cache WHERE key = :key AND expiry_time > :currentTime")
    suspend fun contains(key: String, currentTime: Long = System.currentTimeMillis()): Boolean
}
```

**data/cache/entity/CacheEntity.kt**
```kotlin
package com.example.myrepositoryapp.data.cache.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.ColumnInfo

@Entity(tableName = "cache")
data class CacheEntity(
    @PrimaryKey
    @ColumnInfo(name = "key")
    val key: String,
    
    @ColumnInfo(name = "data")
    val data: String,
    
    @ColumnInfo(name = "expiry_time")
    val expiryTime: Long,
    
    @ColumnInfo(name = "timestamp")
    val timestamp: Long = System.currentTimeMillis(),
    
    @ColumnInfo(name = "group")
    val group: String = "default"
)
```

### Cache Repository Implementation:
**data/repository/cache/CacheRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.cache

import com.example.myrepositoryapp.data.cache.MemoryCache
import com.example.myrepositoryapp.data.cache.DiskCacheDao
import com.example.myrepositoryapp.data.cache.entity.CacheEntity
import com.example.myrepositoryapp.utils.fromJson
import com.example.myrepositoryapp.utils.toJson
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.time.Duration
import kotlin.time.DurationUnit

@Singleton
class CacheRepository @Inject constructor(
    private val memoryCache: MemoryCache,
    private val diskCacheDao: DiskCacheDao
) {
    
    suspend fun <T> getOrSet(
        key: String,
        group: String = "default",
        ttl: Duration = 5.toDuration(DurationUnit.MINUTES),
        loader: suspend () -> T
    ): T {
        // Cek memory cache dulu
        val memoryResult = memoryCache.get<T>(key)
        if (memoryResult != null) {
            return memoryResult
        }
        
        // Cek disk cache
        val diskResult = diskCacheDao.get(key)
        if (diskResult != null) {
            val data = diskResult.data.fromJson<T>()
            
            // Simpan ke memory cache
            memoryCache.put(key, data, ttl)
            return data
        }
        
        // Load dari sumber asli
        val freshData = loader()
        
        // Simpan ke cache
        put(key, freshData, ttl, group)
        return freshData
    }
    
    suspend fun <T> get(key: String): T? {
        // Cek memory dulu
        val memoryResult = memoryCache.get<T>(key)
        if (memoryResult != null) {
            return memoryResult
        }
        
        // Cek disk
        val diskResult = diskCacheDao.get(key)
        return diskResult?.data?.fromJson<T>()
    }
    
    suspend fun <T> put(key: String, data: T, ttl: Duration = 5.toDuration(DurationUnit.MINUTES), group: String = "default") {
        val jsonData = data.toJson()
        
        // Simpan ke memory
        memoryCache.put(key, data, ttl)
        
        // Simpan ke disk
        val cacheEntity = CacheEntity(
            key = key,
            data = jsonData,
            expiryTime = System.currentTimeMillis() + ttl.inWholeMilliseconds,
            group = group
        )
        
        diskCacheDao.insert(cacheEntity)
    }
    
    suspend fun remove(key: String) {
        memoryCache.remove(key)
        diskCacheDao.remove(key)
    }
    
    suspend fun clearGroup(group: String) {
        // Hapus dari memory yang sesuai group
        // Implementasi memory cache group clearing
        
        // Hapus dari disk
        // Implementasi disk cache group clearing
    }
    
    suspend fun clearExpired() {
        diskCacheDao.clearExpired()
    }
    
    suspend fun clearAll() {
        memoryCache.clear()
        diskCacheDao.clearAll()
    }
    
    fun <T> getFlow(key: String): Flow<T?> {
        return diskCacheDao.getFlow(key).map { cacheEntity ->
            cacheEntity?.data?.fromJson<T>()
        }
    }
    
    fun <T> getAllInGroup(group: String): Flow<List<T>> {
        return diskCacheDao.getAll().map { cacheEntities ->
            cacheEntities
                .filter { it.group == group }
                .mapNotNull { it.data.fromJson<T>() }
        }
    }
    
    suspend fun contains(key: String): Boolean {
        return memoryCache.contains(key) || diskCacheDao.contains(key)
    }
}
```

### Cache Invalidation Strategies:
**data/repository/cache/CacheInvalidationRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.cache

import com.example.myrepositoryapp.data.cache.MemoryCache
import com.example.myrepositoryapp.data.cache.DiskCacheDao
import com.example.myrepositoryapp.data.cache.entity.CacheEntity
import com.example.myrepositoryapp.utils.fromJson
import com.example.myrepositoryapp.utils.toJson
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class CacheInvalidationRepository @Inject constructor(
    private val memoryCache: MemoryCache,
    private val diskCacheDao: DiskCacheDao,
    private val userRepository: UserRepository  // Repository asli
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        val cacheKey = "users_all"
        
        return diskCacheDao.getFlow(cacheKey).map { cacheEntity ->
            if (cacheEntity != null) {
                cacheEntity.data.fromJson<List<User>>()
            } else {
                emptyList()
            }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        val cacheKey = "user_$id"
        
        return diskCacheDao.getFlow(cacheKey).map { cacheEntity ->
            cacheEntity?.data?.fromJson<User>()
        }
    }
    
    override suspend fun refreshUsers() {
        // Load fresh data
        try {
            val freshUsers = userRepository.getUsers().first()
            
            // Update cache
            val cacheKey = "users_all"
            diskCacheDao.insert(
                CacheEntity(
                    key = cacheKey,
                    data = freshUsers.toJson(),
                    expiryTime = System.currentTimeMillis() + TIME_TO_LIVE_MS
                )
            )
            
            // Update individual user caches
            freshUsers.forEach { user ->
                diskCacheDao.insert(
                    CacheEntity(
                        key = "user_${user.id}",
                        data = user.toJson(),
                        expiryTime = System.currentTimeMillis() + TIME_TO_LIVE_MS
                    )
                )
            }
        } catch (e: Exception) {
            // Handle error
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        val result = userRepository.createUser(user)
        
        if (result.isSuccess) {
            // Invalidate related caches
            invalidateRelatedCachesForUserCreation(user)
        }
        
        return result
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        val result = userRepository.updateUser(user)
        
        if (result.isSuccess) {
            // Invalidate caches that affected by this user
            invalidateUserSpecificCaches(user.id)
        }
        
        return result
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        val result = userRepository.deleteUser(id)
        
        if (result.isSuccess) {
            // Remove from cache
            memoryCache.remove("user_$id")
            diskCacheDao.remove("user_$id")
            
            // Invalidate related caches
            invalidateRelatedCachesForUserDeletion(id)
        }
        
        return result
    }
    
    private suspend fun invalidateUserSpecificCaches(userId: Int) {
        // Remove user-specific cache
        memoryCache.remove("user_$userId")
        diskCacheDao.remove("user_$userId")
        
        // Invalidate user list cache
        memoryCache.remove("users_all")
        diskCacheDao.remove("users_all")
    }
    
    private suspend fun invalidateRelatedCachesForUserCreation(user: User) {
        // Clear all users cache
        memoryCache.remove("users_all")
        diskCacheDao.remove("users_all")
        
        // Clear search caches if any
        // Implement search cache invalidation
    }
    
    private suspend fun invalidateRelatedCachesForUserDeletion(userId: Int) {
        // Remove user-specific cache
        memoryCache.remove("user_$userId")
        diskCacheDao.remove("user_$userId")
        
        // Clear all users cache
        memoryCache.remove("users_all")
        diskCacheDao.remove("users_all")
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        val cacheKey = "search_$query"
        
        // Try cache first
        val cachedResult = diskCacheDao.get(cacheKey)
        if (cachedResult != null) {
            return cachedResult.data.fromJson<List<User>>()
        }
        
        // Load fresh
        val freshResult = userRepository.searchUsers(query)
        
        // Cache result
        diskCacheDao.insert(
            CacheEntity(
                key = cacheKey,
                data = freshResult.toJson(),
                expiryTime = System.currentTimeMillis() + SEARCH_CACHE_TTL_MS
            )
        )
        
        return freshResult
    }
    
    override suspend fun getUserCount(): Int {
        return userRepository.getUserCount()
    }
    
    companion object {
        private const val TIME_TO_LIVE_MS = 5 * 60 * 1000L // 5 minutes
        private const val SEARCH_CACHE_TTL_MS = 30 * 1000L // 30 seconds
    }
}
```

### Cache Policies:
**data/repository/cache/PolicyBasedCacheRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.cache

import com.example.myrepositoryapp.data.cache.MemoryCache
import com.example.myrepositoryapp.data.cache.DiskCacheDao
import com.example.myrepositoryapp.data.cache.entity.CacheEntity
import com.example.myrepositoryapp.utils.fromJson
import com.example.myrepositoryapp.utils.toJson
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

enum class CachePolicy {
    CACHE_ONLY,
    NETWORK_ONLY,
    CACHE_FIRST,
    NETWORK_FIRST,
    CACHE_AND_NETWORK
}

@Singleton
class PolicyBasedCacheRepository @Inject constructor(
    private val memoryCache: MemoryCache,
    private val diskCacheDao: DiskCacheDao,
    private val userRepository: UserRepository
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return getUsersWithPolicy(CachePolicy.CACHE_FIRST)
    }
    
    fun getUsersWithPolicy(policy: CachePolicy): Flow<List<User>> {
        return when (policy) {
            CachePolicy.CACHE_ONLY -> {
                diskCacheDao.getFlow("users_all").map { cacheEntity ->
                    cacheEntity?.data?.fromJson<List<User>>() ?: emptyList()
                }
            }
            CachePolicy.NETWORK_ONLY -> {
                // Bypass cache, always network
                userRepository.getUsers()
            }
            CachePolicy.CACHE_FIRST -> {
                diskCacheDao.getFlow("users_all").map { cacheEntity ->
                    if (cacheEntity != null) {
                        cacheEntity.data.fromJson<List<User>>()
                    } else {
                        // Fallback to network
                        // Implementasi async network fetch
                        emptyList()
                    }
                }
            }
            CachePolicy.NETWORK_FIRST -> {
                // Implementasi network first
                userRepository.getUsers()
            }
            CachePolicy.CACHE_AND_NETWORK -> {
                // Fetch from cache and update in background
                diskCacheDao.getFlow("users_all").map { cacheEntity ->
                    val cachedData = cacheEntity?.data?.fromJson<List<User>>() ?: emptyList()
                    
                    // Update cache in background
                    kotlinx.coroutines.GlobalScope.launch {
                        try {
                            val freshData = userRepository.getUsers().first()
                            cacheDataToDisk("users_all", freshData)
                        } catch (e: Exception) {
                            // Log error
                        }
                    }
                    
                    cachedData
                }
            }
        }
    }
    
    private suspend fun cacheDataToDisk(key: String, data: List<User>) {
        diskCacheDao.insert(
            CacheEntity(
                key = key,
                data = data.toJson(),
                expiryTime = System.currentTimeMillis() + TIME_TO_LIVE_MS
            )
        )
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return diskCacheDao.getFlow("user_$id").map { cacheEntity ->
            cacheEntity?.data?.fromJson<User>()
        }
    }
    
    override suspend fun refreshUsers() {
        userRepository.refreshUsers()
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return userRepository.createUser(user)
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return userRepository.updateUser(user)
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return userRepository.deleteUser(id)
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return userRepository.searchUsers(query)
    }
    
    override suspend fun getUserCount(): Int {
        return userRepository.getUserCount()
    }
    
    companion object {
        private const val TIME_TO_LIVE_MS = 5 * 60 * 1000L // 5 minutes
    }
}
```

### üéì Penjelasan Konsep:
**Caching Strategy seperti Rak Penyimpanan:**
- **In-Memory**: Rak paling cepat (RAM)
- **Disk Caching**: Rak permanen (database)
- **Cache Invalidation**: Membersihkan rak yang kadaluarsa
- **Cache Policies**: Aturan kapan menggunakan cache

**Jenis Caching:**
- **LRU (Least Recently Used)**: Hapus item jarang digunakan
- **TTL (Time To Live)**: Hapus item setelah waktu tertentu
- **Write-through**: Update cache dan storage bersamaan
- **Write-back**: Update cache dulu, storage nanti

**Best Practices:**
- Gunakan TTL untuk cache expiration
- Hapus cache saat data berubah
- Gunakan memory cache untuk akses cepat
- Gunakan disk cache untuk data persisten
- Monitor penggunaan memory
- Handle cache size limits

---

## 6Ô∏è‚É£ Offline-First Architecture ‚ö°

### Konsep Dasar
Offline-First Architecture seperti perpustakaan lokal üìö - bekerja secara lokal, lalu sinkronisasi dengan server!

### Implementation:
**data/repository/offline_first/OfflineFirstUserRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.offline_first

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.data.source.local.OfflineOperationDao
import com.example.myrepositoryapp.data.source.local.OfflineOperationEntity
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Offline-first repository - lokal sebagai single source of truth
 */
@Singleton
class OfflineFirstUserRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource,
    private val offlineOperationDao: OfflineOperationDao,
    private val connectivityHelper: ConnectivityHelper
) : UserRepository {
    
    private val mutex = Mutex()
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()
        }
    }
    
    override suspend fun refreshUsers() {
        if (!connectivityHelper.isConnected()) {
            return // Tidak bisa refresh offline
        }
        
        try {
            val response = remoteDataSource.getUsers()
            if (response.isSuccessful && response.data != null) {
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(response.data.map { it.toEntity() })
            }
        } catch (e: Exception) {
            // Log error - tidak throw karena ini async operation
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> = mutex.withLock {
        return try {
            // Simpan ke lokal dulu
            val localId = localDataSource.insertUser(user.toEntity())
            
            // Jika online, kirim ke server sekarang
            if (connectivityHelper.isConnected()) {
                val response = remoteDataSource.createUser(user.toDto())
                
                if (response.isSuccessful && response.data != null) {
                    // Update lokal dengan ID dari server
                    val serverEntity = response.data.toEntity()
                    if (serverEntity.id != localId) {
                        // Server memberikan ID baru
                        localDataSource.updateUser(serverEntity)
                    }
                    Result.success(Unit)
                } else {
                    // Jika server gagal, tambahkan ke operasi offline
                    queueOfflineOperation(
                        operationType = "CREATE",
                        operationData = user.toJson(),
                        entityId = localId.toString()
                    )
                    Result.failure(Exception(response.errorMessage ?: "Server error"))
                }
            } else {
                // Offline - tambahkan ke operasi offline
                queueOfflineOperation(
                    operationType = "CREATE",
                    operationData = user.toJson(),
                    entityId = localId.toString()
                )
                Result.success(Unit)
            }
        } catch (e: Exception) {
            // Tambahkan ke operasi offline jika gagal
            queueOfflineOperation(
                operationType = "CREATE",
                operationData = user.toJson(),
                entityId = user.id.toString() // Gunakan ID yang tersedia
            )
            Result.success(Unit) // Offline support tetap sukses
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> = mutex.withLock {
        return try {
            // Update ke lokal dulu
            localDataSource.updateUser(user.toEntity())
            
            if (connectivityHelper.isConnected()) {
                val response = remoteDataSource.updateUser(user.id, user.toDto())
                
                if (response.isSuccessful) {
                    Result.success(Unit)
                } else {
                    queueOfflineOperation(
                        operationType = "UPDATE",
                        operationData = user.toJson(),
                        entityId = user.id.toString()
                    )
                    Result.failure(Exception(response.errorMessage ?: "Server error"))
                }
            } else {
                queueOfflineOperation(
                    operationType = "UPDATE",
                    operationData = user.toJson(),
                    entityId = user.id.toString()
                )
                Result.success(Unit)
            }
        } catch (e: Exception) {
            queueOfflineOperation(
                operationType = "UPDATE",
                operationData = user.toJson(),
                entityId = user.id.toString()
            )
            Result.success(Unit) // Offline support
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> = mutex.withLock {
        return try {
            // Hapus dari lokal dulu
            localDataSource.deleteUser(id)
            
            if (connectivityHelper.isConnected()) {
                val response = remoteDataSource.deleteUser(id)
                
                if (response.isSuccessful) {
                    Result.success(Unit)
                } else {
                    queueOfflineOperation(
                        operationType = "DELETE",
                        operationData = id.toString(),
                        entityId = id.toString()
                    )
                    Result.failure(Exception(response.errorMessage ?: "Server error"))
                }
            } else {
                queueOfflineOperation(
                    operationType = "DELETE",
                    operationData = id.toString(),
                    entityId = id.toString()
                )
                Result.success(Unit)
            }
        } catch (e: Exception) {
            queueOfflineOperation(
                operationType = "DELETE",
                operationData = id.toString(),
                entityId = id.toString()
            )
            Result.success(Unit) // Offline support
        }
    }
    
    /**
     * Sync operasi offline saat koneksi kembali
     */
    suspend fun syncOfflineOperations(): Result<Unit> = mutex.withLock {
        if (!connectivityHelper.isConnected()) {
            return Result.success(Unit)
        }
        
        try {
            val operations = offlineOperationDao.getAllPending()
            
            for (operation in operations) {
                when (operation.operationType) {
                    "CREATE" -> {
                        val user = operation.operationData.fromJson<User>()
                        val response = remoteDataSource.createUser(user.toDto())
                        
                        if (response.isSuccessful) {
                            offlineOperationDao.markAsSynced(operation.id)
                        }
                    }
                    "UPDATE" -> {
                        val user = operation.operationData.fromJson<User>()
                        val response = remoteDataSource.updateUser(user.id, user.toDto())
                        
                        if (response.isSuccessful) {
                            offlineOperationDao.markAsSynced(operation.id)
                        }
                    }
                    "DELETE" -> {
                        val userId = operation.operationData.toInt()
                        val response = remoteDataSource.deleteUser(userId)
                        
                        if (response.isSuccessful) {
                            offlineOperationDao.markAsSynced(operation.id)
                        }
                    }
                }
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun queueOfflineOperation(
        operationType: String,
        operationData: String,
        entityId: String
    ) {
        val operation = OfflineOperationEntity(
            operationType = operationType,
            operationData = operationData,
            entityId = entityId,
            createdAt = System.currentTimeMillis(),
            synced = false
        )
        
        offlineOperationDao.insert(operation)
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return localDataSource.searchUsers(query).map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
}

// Helper untuk connectivity
class ConnectivityHelper @Inject constructor() {
    fun isConnected(): Boolean {
        // Implementasi sebenarnya mengakses konektivitas jaringan
        return true // Placeholder
    }
    
    fun isWiFi(): Boolean {
        // Implementasi sebenarnya
        return false // Placeholder
    }
    
    fun isMobileData(): Boolean {
        // Implementasi sebenarnya
        return false // Placeholder
    }
}
```

### Conflict Resolution:
**data/repository/offline_first/ConflictResolutionRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.offline_first

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton
import java.util.Date

@Singleton
class ConflictResolutionRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource,
    private val connectivityHelper: ConnectivityHelper
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()
        }
    }
    
    override suspend fun refreshUsers() {
        if (!connectivityHelper.isConnected()) return
        
        try {
            val response = remoteDataSource.getUsers()
            
            if (response.isSuccessful && response.data != null) {
                // Check for conflicts and resolve
                val remoteUsers = response.data
                val localUsers = localDataSource.getUsers().first()
                
                val resolvedUsers = resolveConflicts(localUsers, remoteUsers)
                
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(resolvedUsers.map { it.toEntity() })
            }
        } catch (e: Exception) {
            // Handle error gracefully
        }
    }
    
    private fun resolveConflicts(
        localUsers: List<UserEntity>,
        remoteUsers: List<UserDto>
    ): List<UserDto> {
        val conflictResolved = mutableListOf<UserDto>()
        val localMap = localUsers.associateBy { it.id }
        val remoteMap = remoteUsers.associateBy { it.id }
        
        // Resolusi konflik berdasarkan timestamp atau strategi custom
        for ((id, remoteUser) in remoteMap) {
            val localUser = localMap[id]
            
            if (localUser != null) {
                // Ada konflik - resolve berdasarkan strategi
                val resolvedUser = resolveSingleConflict(localUser, remoteUser)
                conflictResolved.add(resolvedUser)
            } else {
                // User hanya ada di remote - tambahkan
                conflictResolved.add(remoteUser)
            }
        }
        
        // Tambahkan user yang hanya ada di lokal
        for ((id, localUser) in localMap) {
            if (!remoteMap.containsKey(id)) {
                conflictResolved.add(localUser.toDto()) // Butuh implementasi toDto untuk entity
            }
        }
        
        return conflictResolved
    }
    
    private fun resolveSingleConflict(
        localUser: UserEntity,
        remoteUser: UserDto
    ): UserDto {
        // Contoh strategi: server wins (server menang)
        // Alternatif: timestamp terbaru menang, user memilih, dll
        if (localUser.updatedAt > remoteUser.lastModified) { // Asumsikan lastModified di DTO
            return localUser.toDto()
        }
        return remoteUser
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        // Offline-first: simpan ke lokal dulu
        localDataSource.insertUser(user.toEntity())
        
        if (connectivityHelper.isConnected()) {
            try {
                val response = remoteDataSource.createUser(user.toDto())
                return if (response.isSuccessful && response.data != null) {
                    // Update lokal dengan data dari server
                    localDataSource.updateUser(response.data.toEntity())
                    Result.success(Unit)
                } else {
                    Result.failure(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: Exception) {
                // Offline operation queue
                queueOfflineOperation("CREATE", user.toJson(), user.id.toString())
                return Result.success(Unit)
            }
        } else {
            queueOfflineOperation("CREATE", user.toJson(), user.id.toString())
            return Result.success(Unit)
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        // Check apakah user ada di lokal
        val localUser = localDataSource.getUserById(user.id).first()
        
        if (localUser == null) {
            return Result.failure(Exception("User tidak ditemukan"))
        }
        
        // Update lokal
        localDataSource.updateUser(user.toEntity())
        
        if (connectivityHelper.isConnected()) {
            try {
                val response = remoteDataSource.updateUser(user.id, user.toDto())
                return if (response.isSuccessful) {
                    Result.success(Unit)
                } else {
                    Result.failure(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: Exception) {
                // Queue offline operation
                queueOfflineOperation("UPDATE", user.toJson(), user.id.toString())
                return Result.success(Unit)
            }
        } else {
            queueOfflineOperation("UPDATE", user.toJson(), user.id.toString())
            return Result.success(Unit)
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        // Cek dulu apakah user ada
        val localUser = localDataSource.getUserById(id).first()
        
        if (localUser == null) {
            return Result.failure(Exception("User tidak ditemukan"))
        }
        
        // Hapus dari lokal
        localDataSource.deleteUser(id)
        
        if (connectivityHelper.isConnected()) {
            try {
                val response = remoteDataSource.deleteUser(id)
                return if (response.isSuccessful) {
                    Result.success(Unit)
                } else {
                    Result.failure(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: Exception) {
                queueOfflineOperation("DELETE", id.toString(), id.toString())
                return Result.success(Unit)
            }
        } else {
            queueOfflineOperation("DELETE", id.toString(), id.toString())
            return Result.success(Unit)
        }
    }
    
    private suspend fun queueOfflineOperation(
        operationType: String,
        operationData: String,
        entityId: String
    ) {
        // Implementasi queue offline operation
        // Bisa menggunakan database lokal untuk menyimpan operasi yang belum disinkronkan
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return localDataSource.searchUsers(query).map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
}
```

### Background Sync Workers:
**data/worker/SyncWorker.kt**
```kotlin
package com.example.myrepositoryapp.data.worker

import android.content.Context
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.example.myrepositoryapp.data.repository.offline_first.OfflineFirstUserRepository
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import kotlinx.coroutines.coroutineScope

@HiltWorker
class SyncWorker @AssistedInject constructor(
    @Assisted context: Context,
    @Assisted workerParams: WorkerParameters,
    private val offlineFirstUserRepository: OfflineFirstUserRepository
) : CoroutineWorker(context, workerParams) {
    
    override suspend fun doWork(): Result = coroutineScope {
        return@coroutineScope try {
            offlineFirstUserRepository.syncOfflineOperations()
            Result.success()
        } catch (e: Exception) {
            // Retry jika gagal (tergantung strategi retry)
            if (runAttemptCount < 3) {
                Result.retry()
            } else {
                Result.failure()
            }
        }
    }
}

// Registration di Application class
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // Setup worker periodic sync
        val syncRequest = PeriodicWorkRequestBuilder<SyncWorker>(
            repeatInterval = 15, 
            repeatIntervalTimeUnit = TimeUnit.MINUTES
        ).build()
        
        WorkManager.getInstance(this).enqueue(
            ExistingPeriodicWorkPolicy.KEEP,
            syncRequest
        )
    }
}
```

### Online/Offline Status Handling:
**utils/ConnectivityManager.kt**
```kotlin
package com.example.myrepositoryapp.utils

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import androidx.core.content.getSystemService
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ConnectivityManager @Inject constructor(
    private val context: Context
) {
    
    fun getNetworkStatus(): Flow<NetworkStatus> = callbackFlow {
        val connectivityManager = context.getSystemService<ConnectivityManager>()
        
        val networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                trySend(NetworkStatus.Available(getNetworkType(network)))
            }
            
            override fun onLost(network: Network) {
                trySend(NetworkStatus.Unavailable)
            }
            
            override fun onCapabilitiesChanged(
                network: Network,
                networkCapabilities: NetworkCapabilities
            ) {
                if (!networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
                    trySend(NetworkStatus.Unavailable)
                }
            }
        }
        
        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()
        
        connectivityManager?.registerNetworkCallback(request, networkCallback)
        
        awaitClose {
            connectivityManager?.unregisterNetworkCallback(networkCallback)
        }
    }
    
    private fun getNetworkType(network: Network): NetworkType {
        val connectivityManager = context.getSystemService<ConnectivityManager>()
        val capabilities = connectivityManager?.getNetworkCapabilities(network)
        
        return when {
            capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) == true -> NetworkType.Wifi
            capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) == true -> NetworkType.Cellular
            capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) == true -> NetworkType.Ethernet
            else -> NetworkType.Unknown
        }
    }
    
    fun isConnected(): Boolean {
        val connectivityManager = context.getSystemService<ConnectivityManager>()
        val networks = connectivityManager?.allNetworks ?: return false
        
        return networks.any { network ->
            val capabilities = connectivityManager.getNetworkCapabilities(network)
            capabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) == true
        }
    }
}

sealed class NetworkStatus {
    object Unavailable : NetworkStatus()
    data class Available(val type: NetworkType) : NetworkStatus()
}

enum class NetworkType {
    Wifi, Cellular, Ethernet, Unknown
}
```

### üéì Penjelasan Konsep:
**Offline-First Architecture seperti Perpustakaan:**
- **Local First**: Database lokal sebagai single source of truth
- **Sync Later**: Sinkronisasi saat konektivitas tersedia
- **Queue Operations**: Antrian operasi saat offline
- **Conflict Resolution**: Penyelesaian konflik saat sync

**Strategi Konflik:**
- **Server Wins**: Data server menang
- **Client Wins**: Data lokal menang
- **Timestamp**: Data terbaru menang
- **Merge**: Gabungkan perubahan

**Best Practices:**
- Gunakan lokal sebagai primary source
- Queue operasi saat offline
- Implementasi conflict resolution
- Gunakan background workers untuk sync
- Monitor status jaringan
- Tampilkan feedback kepada pengguna saat offline

---

## 7Ô∏è‚É£ Error Handling ‚ö†Ô∏è

### Konsep Dasar
Error Handling seperti sistem keselamatan üõ°Ô∏è - menangani kesalahan dengan elegan dan informatif!

### Result Wrapper Class:
**utils/ResultWrapper.kt**
```kotlin
package com.example.myrepositoryapp.utils

/**
 * Wrapper untuk handle success dan error dengan satu type
 */
sealed class ResultWrapper<out T> {
    data class Success<out T>(val data: T) : ResultWrapper<T>()
    data class Error(val exception: Exception) : ResultWrapper<Nothing>()
    data class Loading(val message: String? = null) : ResultWrapper<Nothing>()
    
    companion object {
        fun <T> success(data: T): ResultWrapper<T> = Success(data)
        fun error(message: String, exception: Throwable? = null): ResultWrapper<Nothing> = 
            Error(Exception(message, exception))
        fun error(exception: Exception): ResultWrapper<Nothing> = Error(exception)
        fun loading(message: String? = null): ResultWrapper<Nothing> = Loading(message)
    }
}

/**
 * Extension untuk convert ke ResultWrapper
 */
suspend fun <T> safeApiCall(apiCall: suspend () -> T): ResultWrapper<T> {
    return try {
        ResultWrapper.success(apiCall())
    } catch (e: Exception) {
        ResultWrapper.error(e)
    }
}

/**
 * Generic Result class untuk operasi
 */
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()
    
    companion object {
        fun <T> success(data: T): Result<T> = Success(data)
        fun error(message: String, exception: Exception? = null): Result<Nothing> = 
            Error(Exception(message, exception))
        fun error(exception: Exception): Result<Nothing> = Error(exception)
    }
}
```

### Implementation Error Handling:
**data/repository/error_handling/ErrorHandlingUserRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.error_handling

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.Result
import com.example.myrepositoryapp.utils.safeApiCall
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.catch
import timber.log.Timber
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ErrorHandlingUserRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }.catch { exception ->
            Timber.e(exception, "Error getting users from local data source")
            // Kita tetap ingin melanjutkan, jadi tidak re-throw exception di sini
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()
        }.catch { exception ->
            Timber.e(exception, "Error getting user by id: $id")
        }
    }
    
    override suspend fun refreshUsers() {
        try {
            val response = remoteDataSource.getUsers()
            
            if (response.isSuccessful && response.data != null) {
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(response.data.map { it.toEntity() })
            } else {
                throw Exception(response.errorMessage ?: "Unknown error")
            }
        } catch (e: Exception) {
            Timber.e(e, "Error refreshing users")
            // Kita bisa log error atau simpan untuk sync nanti
            throw mapNetworkException(e)
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return try {
            // Coba kirim ke remote dulu
            val response = remoteDataSource.createUser(user.toDto())
            
            if (response.isSuccessful && response.data != null) {
                // Simpan ke lokal
                localDataSource.insertUser(response.data.toEntity())
                Result.success(Unit)
            } else {
                val error = Exception(response.errorMessage ?: "Unknown server error")
                Result.error(mapNetworkException(error))
            }
        } catch (e: Exception) {
            Timber.e(e, "Error creating user")
            
            // Simpan ke lokal untuk sync nanti (offline support)
            try {
                localDataSource.insertUser(user.toEntity())
            } catch (localError: Exception) {
                Timber.e(localError, "Error saving user to local database")
            }
            
            Result.error(mapNetworkException(e))
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return try {
            // Cek apakah user ada di lokal
            val existingUser = localDataSource.getUserById(user.id).first()
            if (existingUser == null) {
                return Result.error(Exception("User tidak ditemukan"))
            }
            
            // Update ke remote dulu
            val response = remoteDataSource.updateUser(user.id, user.toDto())
            
            if (response.isSuccessful) {
                // Update ke lokal
                localDataSource.updateUser(user.toEntity())
                Result.success(Unit)
            } else {
                val error = Exception(response.errorMessage ?: "Unknown server error")
                Result.error(mapNetworkException(error))
            }
        } catch (e: Exception) {
            Timber.e(e, "Error updating user: ${user.id}")
            
            try {
                // Update ke lokal untuk tetap berjalan saat offline
                localDataSource.updateUser(user.toEntity())
            } catch (localError: Exception) {
                Timber.e(localError, "Error updating user in local database")
            }
            
            Result.error(mapNetworkException(e))
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return try {
            // Cek apakah user ada di lokal
            val existingUser = localDataSource.getUserById(id).first()
            if (existingUser == null) {
                return Result.error(Exception("User tidak ditemukan"))
            }
            
            // Coba delete dari remote dulu
            val response = remoteDataSource.deleteUser(id)
            
            if (response.isSuccessful) {
                // Delete dari lokal
                localDataSource.deleteUser(id)
                Result.success(Unit)
            } else {
                val error = Exception(response.errorMessage ?: "Unknown server error")
                Result.error(mapNetworkException(error))
            }
        } catch (e: Exception) {
            Timber.e(e, "Error deleting user: $id")
            
            try {
                // Hapus dari lokal untuk tetap berjalan saat offline
                localDataSource.deleteUser(id)
            } catch (localError: Exception) {
                Timber.e(localError, "Error deleting user from local database")
            }
            
            Result.error(mapNetworkException(e))
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return try {
            localDataSource.searchUsers(query).map { it.toDomain() }
        } catch (e: Exception) {
            Timber.e(e, "Error searching users with query: $query")
            emptyList() // Kembalikan list kosong jika terjadi error
        }
    }
    
    override suspend fun getUserCount(): Int {
        return try {
            localDataSource.getUserCount()
        } catch (e: Exception) {
            Timber.e(e, "Error getting user count")
            0 // Kembalikan 0 jika terjadi error
        }
    }
    
    /**
     * Mapping exception ke error yang lebih user-friendly
     */
    private fun mapNetworkException(e: Exception): Exception {
        return when (e) {
            is java.net.UnknownHostException -> {
                Exception("Tidak ada koneksi internet. Silakan periksa jaringan Anda.", e)
            }
            is java.net.SocketTimeoutException -> {
                Exception("Waktu koneksi habis. Silakan coba lagi.", e)
            }
            is java.io.IOException -> {
                Exception("Kesalahan jaringan. Silakan periksa koneksi Anda.", e)
            }
            is retrofit2.HttpException -> {
                when (e.code()) {
                    401 -> Exception("Autentikasi gagal. Silakan login kembali.", e)
                    403 -> Exception("Akses ditolak.", e)
                    404 -> Exception("Data tidak ditemukan.", e)
                    429 -> Exception("Terlalu banyak permintaan. Silakan coba lagi nanti.", e)
                    500 -> Exception("Kesalahan server. Silakan coba lagi nanti.", e)
                    502, 503, 504 -> Exception("Server tidak merespon. Silakan coba lagi.", e)
                    else -> Exception("Kesalahan jaringan: ${e.message}", e)
                }
            }
            else -> e
        }
    }
}
```

### Network Error Handling:
**data/repository/error_handling/NetworkErrorHandlingRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.error_handling

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.Result
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withTimeoutOrNull
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class NetworkErrorHandlingRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()
        }
    }
    
    override suspend fun refreshUsers() {
        withTimeoutOrNull(REQUEST_TIMEOUT_MS) {
            try {
                val response = remoteDataSource.getUsers()
                
                if (response.isSuccessful && response.data != null) {
                    localDataSource.deleteAllUsers()
                    localDataSource.insertUsers(response.data.map { it.toEntity() })
                }
            } catch (e: Exception) {
                // Log error dan lanjutkan, jangan throw
                handleNetworkError(e)
            }
        } ?: run {
            throw Exception("Permintaan network timeout")
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return withTimeoutOrNull(REQUEST_TIMEOUT_MS) {
            try {
                val response = remoteDataSource.createUser(user.toDto())
                
                if (response.isSuccessful && response.data != null) {
                    localDataSource.insertUser(response.data.toEntity())
                    Result.success(Unit)
                } else {
                    Result.error(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: Exception) {
                handleNetworkError(e)
                Result.error(e)
            }
        } ?: run {
            Result.error(Exception("Request timeout"))
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return withTimeoutOrNull(REQUEST_TIMEOUT_MS) {
            try {
                val response = remoteDataSource.updateUser(user.id, user.toDto())
                
                if (response.isSuccessful) {
                    localDataSource.updateUser(user.toEntity())
                    Result.success(Unit)
                } else {
                    Result.error(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: Exception) {
                handleNetworkError(e)
                Result.error(e)
            }
        } ?: run {
            Result.error(Exception("Request timeout"))
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return withTimeoutOrNull(REQUEST_TIMEOUT_MS) {
            try {
                val response = remoteDataSource.deleteUser(id)
                
                if (response.isSuccessful) {
                    localDataSource.deleteUser(id)
                    Result.success(Unit)
                } else {
                    Result.error(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: Exception) {
                handleNetworkError(e)
                Result.error(e)
            }
        } ?: run {
            Result.error(Exception("Request timeout"))
        }
    }
    
    private fun handleNetworkError(e: Exception) {
        when (e) {
            is java.net.UnknownHostException,
            is java.net.ConnectException -> {
                // Tidak ada koneksi internet
                println("Tidak ada koneksi internet: ${e.message}")
            }
            is java.net.SocketTimeoutException -> {
                // Timeout
                println("Request timeout: ${e.message}")
            }
            is retrofit2.HttpException -> {
                // HTTP errors
                println("HTTP Error ${e.code()}: ${e.message()}")
            }
            is java.io.IOException -> {
                // Network errors
                println("IO Error: ${e.message}")
            }
            else -> {
                // Other errors
                println("General error: ${e.message}")
            }
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return localDataSource.searchUsers(query).map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
    
    companion object {
        private const val REQUEST_TIMEOUT_MS = 30_000L // 30 seconds
    }
}
```

### User-Friendly Error Messages:
**utils/ErrorMessageMapper.kt**
```kotlin
package com.example.myrepositoryapp.utils

import java.net.UnknownHostException
import java.net.SocketTimeoutException
import java.io.IOException
import retrofit2.HttpException

object ErrorMessageMapper {
    
    fun getErrorMessage(throwable: Throwable): String {
        return when (throwable) {
            is UnknownHostException -> {
                "Tidak dapat terhubung ke server. Pastikan Anda terhubung ke internet."
            }
            is SocketTimeoutException -> {
                "Koneksi terlalu lama. Silakan coba lagi."
            }
            is IOException -> {
                "Kesalahan jaringan. Silakan periksa koneksi internet Anda."
            }
            is HttpException -> {
                when (throwable.code()) {
                    400 -> "Permintaan tidak valid."
                    401 -> "Silakan login kembali."
                    403 -> "Akses ditolak."
                    404 -> "Data tidak ditemukan."
                    429 -> "Terlalu banyak permintaan. Silakan coba lagi nanti."
                    500 -> "Kesalahan server. Silakan coba lagi nanti."
                    502 -> "Server sedang tidak merespon. Silakan coba lagi."
                    503 -> "Server sedang sibuk. Silakan coba lagi."
                    504 -> "Timeout gateway. Silakan coba lagi."
                    else -> "Terjadi kesalahan: ${throwable.message}"
                }
            }
            else -> {
                "Terjadi kesalahan: ${throwable.message ?: "Unknown error"}"
            }
        }
    }
    
    fun getActionableMessage(throwable: Throwable): Pair<String, String?> {
        val errorMessage = getErrorMessage(throwable)
        val actionButton = when (throwable) {
            is UnknownHostException,
            is SocketTimeoutException,
            is IOException -> "Coba Lagi"
            else -> null
        }
        
        return Pair(errorMessage, actionButton)
    }
}
```

### üéì Penjelasan Konsep:
**Error Handling seperti Sistem Keselamatan:**
- **Result Wrapper**: Mengelola success/error dalam satu type
- **Exception Mapping**: Mengubah error teknis ke pesan user-friendly
- **Network Error**: Menangani berbagai jenis error jaringan
- **Graceful Degradation**: Aplikasi tetap bisa digunakan saat error

**Jenis Error yang Ditangani:**
- **Network Error**: Koneksi tidak tersedia
- **Timeout Error**: Request terlalu lama
- **HTTP Error**: Response server (4xx, 5xx)
- **Database Error**: Gagal akses lokal
- **Validation Error**: Data tidak valid

**Best Practices:**
- Gunakan sealed class untuk error handling
- Mapping exception ke pesan user-friendly
- Berikan opsi retry saat error jaringan
- Log error untuk debugging
- Tampilkan informasi error yang berguna
- Tetap berfungsi saat offline (offline support)

---

## 8Ô∏è‚É£ Data Transformation üîÑ

### Konsep Dasar
Data Transformation seperti mesin konverter ‚öôÔ∏è - mengubah data dari satu bentuk ke bentuk lain!

### Mapping Functions:
**utils/MapperExtensions.kt**
```kotlin
package com.example.myrepositoryapp.utils

import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.data.database.entity.UserEntity
import com.example.myrepositoryapp.data.dto.UserDto

/**
 * Extension functions untuk mengkonversi antara domain, data, dan DTO layer
 */

// Domain to Entity
fun User.toEntity(): UserEntity {
    return UserEntity(
        id = this.id,
        name = this.name,
        email = this.email,
        phone = this.phone,
        isActive = this.isActive
    )
}

// Entity to Domain
fun UserEntity.toDomain(): User {
    return User(
        id = this.id,
        name = this.name,
        email = this.email,
        phone = this.phone,
        isActive = this.isActive
    )
}

// Domain to DTO
fun User.toDto(): UserDto {
    return UserDto(
        id = this.id,
        name = this.name,
        email = this.email,
        phone = this.phone,
        isActive = this.isActive
    )
}

// DTO to Domain
fun UserDto.toDomain(): User {
    return User(
        id = this.id,
        name = this.name,
        email = this.email,
        phone = this.phone,
        isActive = this.isActive
    )
}

// DTO to Entity
fun UserDto.toEntity(): UserEntity {
    return UserEntity(
        id = this.id,
        name = this.name,
        email = this.email,
        phone = this.phone,
        isActive = this.isActive
    )
}

// Entity to DTO
fun UserEntity.toDto(): UserDto {
    return UserDto(
        id = this.id,
        name = this.name,
        email = this.email,
        phone = this.phone,
        isActive = this.isActive
    )
}

// List conversions
fun List<User>.toEntities(): List<UserEntity> = this.map { it.toEntity() }
fun List<UserEntity>.toDomains(): List<User> = this.map { it.toDomain() }
fun List<User>.toDtos(): List<UserDto> = this.map { it.toDto() }
fun List<UserDto>.toDomains(): List<User> = this.map { it.toDomain() }
fun List<UserDto>.toEntities(): List<UserEntity> = this.map { it.toEntity() }
fun List<UserEntity>.toDtos(): List<UserDto> = this.map { it.toDto() }
```

### DTO (Data Transfer Objects):
**data/dto/UserDto.kt**
```kotlin
package com.example.myrepositoryapp.data.dto

import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass

@JsonClass(generateAdapter = true)
data class UserDto(
    @Json(name = "id") val id: Int,
    @Json(name = "name") val name: String,
    @Json(name = "email") val email: String,
    @Json(name = "phone") val phone: String? = null,
    @Json(name = "is_active") val isActive: Boolean = true,
    @Json(name = "created_at") val createdAt: String? = null,
    @Json(name = "updated_at") val updatedAt: String? = null
)

@JsonClass(generateAdapter = true)
data class ApiResponse<T>(
    @Json(name = "data") val data: T? = null,
    @Json(name = "error") val error: ApiError? = null,
    @Json(name = "success") val success: Boolean = false
)

@JsonClass(generateAdapter = true)
data class ApiError(
    @Json(name = "code") val code: Int? = null,
    @Json(name = "message") val message: String? = null,
    @Json(name = "details") val details: List<String>? = null
)

// DTO untuk berbagai kasus
@JsonClass(generateAdapter = true)
data class CreateUserRequestDto(
    @Json(name = "name") val name: String,
    @Json(name = "email") val email: String,
    @Json(name = "phone") val phone: String? = null
)

@JsonClass(generateAdapter = true)
data class UpdateUserRequestDto(
    @Json(name = "name") val name: String? = null,
    @Json(name = "email") val email: String? = null,
    @Json(name = "phone") val phone: String? = null
)

@JsonClass(generateAdapter = true)
data class UserListResponseDto(
    @Json(name = "users") val users: List<UserDto>,
    @Json(name = "total") val total: Int,
    @Json(name = "page") val page: Int,
    @Json(name = "has_more") val hasMore: Boolean
)
```

### Entity Mapping:
**data/database/entity/UserEntity.kt**
```kotlin
package com.example.myrepositoryapp.data.database.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.ColumnInfo

@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Int = 0,
    
    @ColumnInfo(name = "name")
    val name: String,
    
    @ColumnInfo(name = "email")
    val email: String,
    
    @ColumnInfo(name = "phone")
    val phone: String? = null,
    
    @ColumnInfo(name = "is_active")
    val isActive: Boolean = true,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long = System.currentTimeMillis(),
    
    @ColumnInfo(name = "updated_at")
    val updatedAt: Long = System.currentTimeMillis()
)

@Entity(tableName = "posts")
data class PostEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Int = 0,
    
    @ColumnInfo(name = "user_id")
    val userId: Int,
    
    @ColumnInfo(name = "title")
    val title: String,
    
    @ColumnInfo(name = "content")
    val content: String,
    
    @ColumnInfo(name = "is_published")
    val isPublished: Boolean = false,
    
    @ColumnInfo(name = "created_at")
    val createdAt: Long = System.currentTimeMillis()
)
```

### Transformation in Repository:
**data/repository/transformation/TransformationRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.transformation

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.Result
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class TransformationRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { entity -> 
                // Transformasi entity ke domain model
                entity.toDomain()
            }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()  // Transformasi jika tidak null
        }
    }
    
    override suspend fun refreshUsers() {
        try {
            val response = remoteDataSource.getUsers()
            
            if (response.isSuccessful && response.data != null) {
                // Transformasi DTO ke Entity untuk disimpan ke lokal
                val entities = response.data.map { dto ->
                    dto.toEntity()
                }
                
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(entities)
            }
        } catch (e: Exception) {
            // Handle error - tidak melempar error ke atas
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return try {
            // Transformasi domain ke DTO untuk dikirim ke server
            val requestDto = user.toDto()
            val response = remoteDataSource.createUser(requestDto)
            
            if (response.isSuccessful && response.data != null) {
                // Transformasi response DTO ke Entity untuk disimpan ke lokal
                val entity = response.data.toEntity()
                localDataSource.insertUser(entity)
                Result.success(Unit)
            } else {
                Result.error(Exception(response.errorMessage ?: "Server error"))
            }
        } catch (e: Exception) {
            // Simpan ke lokal untuk offline support
            localDataSource.insertUser(user.toEntity())
            Result.success(Unit) // Sukses karena offline support
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return try {
            val requestDto = user.toDto()
            val response = remoteDataSource.updateUser(user.id, requestDto)
            
            if (response.isSuccessful) {
                // Transformasi jika server mengembalikan data terupdate
                response.data?.let { serverUser ->
                    localDataSource.updateUser(serverUser.toEntity())
                } ?: run {
                    // Jika server tidak mengembalikan data, gunakan data lokal
                    localDataSource.updateUser(user.toEntity())
                }
                Result.success(Unit)
            } else {
                Result.error(Exception(response.errorMessage ?: "Server error"))
            }
        } catch (e: Exception) {
            // Update lokal untuk offline support
            localDataSource.updateUser(user.toEntity())
            Result.success(Unit)
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return try {
            val response = remoteDataSource.deleteUser(id)
            
            if (response.isSuccessful) {
                localDataSource.deleteUser(id)
                Result.success(Unit)
            } else {
                Result.error(Exception(response.errorMessage ?: "Server error"))
            }
        } catch (e: Exception) {
            // Hapus lokal untuk offline support
            localDataSource.deleteUser(id)
            Result.success(Unit)
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return localDataSource.searchUsers(query).map { entity ->
            entity.toDomain()
        }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
}
```

### List Transformations:
**utils/ListTransformations.kt**
```kotlin
package com.example.myrepositoryapp.utils

import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.data.database.entity.UserEntity
import com.example.myrepositoryapp.data.dto.UserDto

/**
 * Extension functions untuk transformasi list
 */

// Transformasi list secara efisien
fun List<UserDto>.mapToDomain(): List<User> = this.map { it.toDomain() }
fun List<UserDto>.mapToEntity(): List<UserEntity> = this.map { it.toEntity() }

fun List<UserEntity>.mapToDomain(): List<User> = this.map { it.toDomain() }
fun List<UserEntity>.mapToDto(): List<UserDto> = this.map { it.toDto() }

fun List<User>.mapToEntity(): List<UserEntity> = this.map { it.toEntity() }
fun List<User>.mapToDto(): List<UserDto> = this.map { it.toDto() }

/**
 * Fungsi untuk filter dan transformasi bersamaan
 */
fun List<UserDto>.filterAndMapToDomain(
    predicate: (UserDto) -> Boolean = { true }
): List<User> = this.filter(predicate).map { it.toDomain() }

fun List<UserEntity>.filterAndMapToDomain(
    predicate: (UserEntity) -> Boolean = { true }
): List<User> = this.filter(predicate).map { it.toDomain() }

/**
 * Group by transformation
 */
fun List<User>.groupByActiveStatus(): Map<Boolean, List<User>> = this.groupBy { it.isActive }

fun List<User>.groupByInitial(): Map<Char, List<User>> = this.groupBy { 
    it.name.firstOrNull()?.uppercaseChar() ?: 'X' 
}

/**
 * Sort transformation
 */
fun List<User>.sortByAlphabetical(): List<User> = this.sortedBy { it.name.lowercase() }
fun List<User>.sortByActivation(): List<User> = this.sortedByDescending { it.isActive }

/**
 * Safe transformation (dengan error handling)
 */
fun List<UserDto>?.safeMapToDomain(): List<User> = this?.mapNotNull { dto ->
    try {
        dto.toDomain()
    } catch (e: Exception) {
        println("Gagal mentransformasi DTO: $dto, Error: ${e.message}")
        null
    }
} ?: emptyList()

fun List<UserEntity>?.safeMapToDomain(): List<User> = this?.mapNotNull { entity ->
    try {
        entity.toDomain()
    } catch (e: Exception) {
        println("Gagal mentransformasi Entity: $entity, Error: ${e.message}")
        null
    }
} ?: emptyList()
```

### Null Safety Handling:
**utils/NullSafetyExtensions.kt**
```kotlin
package com.example.myrepositoryapp.utils

/**
 * Extension functions untuk nullable handling dalam transformasi
 */

// Safe conversion untuk nullable objects
fun UserDto?.toDomainSafe(): User? = this?.let { 
    try {
        it.toDomain()
    } catch (e: Exception) {
        println("Gagal konversi DTO ke Domain: ${e.message}")
        null
    }
}

fun UserEntity?.toDomainSafe(): User? = this?.let {
    try {
        it.toDomain()
    } catch (e: Exception) {
        println("Gagal konversi Entity ke Domain: ${e.message}")
        null
    }
}

// Safe conversion untuk list dengan nullable handling
fun List<UserDto?>.mapToDomainSafe(): List<User> = this.mapNotNull { it?.toDomainSafe() }
fun List<UserEntity?>.mapToDomainSafe(): List<User> = this.mapNotNull { it?.toDomainSafe() }

// Nullable extension untuk validasi
fun String?.isValidEmail(): Boolean = this?.let { email ->
    android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()
} ?: false

fun String?.isNotBlankAndValidEmail(): Boolean = this.isNotNullOrBlank() && this.isValidEmail()

fun String?.isNotNullOrBlank(): Boolean = !this.isNullOrBlank()

fun Int?.isValidId(): Boolean = this != null && this > 0

// Safe getters
fun List<String>.getSafe(index: Int): String? = if (index >= 0 && index < this.size) this[index] else null
fun <T> List<T>.getSafe(index: Int, default: T): T = if (index >= 0 && index < this.size) this[index] else default
```

### üéì Penjelasan Konsep:
**Data Transformation seperti Mesin Konverter:**
- **DTO**: Data Transfer Object (untuk network)
- **Entity**: Local database objects (untuk Room)
- **Domain**: Business layer objects (untuk logic)

**Layer Transformasi:**
- **Remote ‚Üî DTO**: Network communication
- **DTO ‚Üî Entity**: Storage conversion  
- **Entity ‚Üî Domain**: Business logic layer
- **Domain ‚Üî UI**: View layer

**Best Practices:**
- Gunakan extension functions untuk transformasi
- Tambahkan null safety handling
- Gunakan sealed classes untuk type safety
- Tidak mentransformasi dalam loop (gunakan map)
- Simpan transformasi yang kompleks dalam fungsi terpisah
- Gunakan Moshi/Retrofit adapter untuk JSON
- Gunakan Room for local persistence

**Mapping Patterns:**
- **toEntity()**, **toDomain()**, **toDto()**: Transformation functions
- **map{}**: List transformations
- **safeMap{}**: Safe transformations with error handling
- **filterAndMap**: Filter + transform in one pass

---

## 9Ô∏è‚É£ Repository dengan Coroutines üåÄ

### Konsep Dasar
Repository dengan Coroutines seperti sistem kerja paralel ‚ö° - menangani operasi async dengan elegan!

### Suspend Functions in Repository:
**data/repository/coroutine/SuspendFunctionRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.coroutine

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.Result
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.withContext
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SuspendFunctionRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()
        }
    }
    
    override suspend fun refreshUsers() {
        // Gunakan withContext untuk thread switching jika diperlukan
        withContext(Dispatchers.IO) {
            val response = remoteDataSource.getUsers()
            
            if (response.isSuccessful && response.data != null) {
                val entities = response.data.map { it.toEntity() }
                
                // Gunakan withContext untuk operasi database
                withContext(Dispatchers.IO) {
                    localDataSource.deleteAllUsers()
                    localDataSource.insertUsers(entities)
                }
            }
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return withContext(Dispatchers.IO) {
            try {
                val response = remoteDataSource.createUser(user.toDto())
                
                if (response.isSuccessful && response.data != null) {
                    // Concurrent operations using async
                    val localSave = async {
                        localDataSource.insertUser(response.data.toEntity())
                    }
                    
                    // Wait for local save to complete
                    localSave.await()
                    
                    Result.success(Unit)
                } else {
                    Result.error(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: Exception) {
                // Save to local for offline support
                withContext(Dispatchers.IO) {
                    localDataSource.insertUser(user.toEntity())
                }
                Result.success(Unit) // Success karena offline support
            }
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return withContext(Dispatchers.IO) {
            try {
                // Parallel operations: update remote and local simultaneously
                val remoteUpdate = async {
                    remoteDataSource.updateUser(user.id, user.toDto())
                }
                
                val response = remoteUpdate.await()
                
                if (response.isSuccessful) {
                    withContext(Dispatchers.IO) {
                        response.data?.let { serverUser ->
                            localDataSource.updateUser(serverUser.toEntity())
                        } ?: run {
                            localDataSource.updateUser(user.toEntity())
                        }
                    }
                    Result.success(Unit)
                } else {
                    Result.error(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: Exception) {
                // Update local for offline support
                withContext(Dispatchers.IO) {
                    localDataSource.updateUser(user.toEntity())
                }
                Result.success(Unit) // Success karena offline support
            }
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return withContext(Dispatchers.IO) {
            try {
                val response = remoteDataSource.deleteUser(id)
                
                if (response.isSuccessful) {
                    withContext(Dispatchers.IO) {
                        localDataSource.deleteUser(id)
                    }
                    Result.success(Unit)
                } else {
                    Result.error(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: Exception) {
                // Delete local for consistency
                withContext(Dispatchers.IO) {
                    localDataSource.deleteUser(id)
                }
                Result.success(Unit)
            }
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return withContext(Dispatchers.IO) {
            localDataSource.searchUsers(query).map { it.toDomain() }
        }
    }
    
    override suspend fun getUserCount(): Int {
        return withContext(Dispatchers.IO) {
            localDataSource.getUserCount()
        }
    }
}
```

### Flow untuk Reactive Data:
**data/repository/coroutine/FlowRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.coroutine

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.Result
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FlowRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers()
            .map { entities -> entities.map { it.toDomain() } }
            .flowOn(Dispatchers.IO)  // Perform transformation on IO dispatcher
            .catch { e ->
                // Log error dan continue stream
                println("Error getting users: ${e.message}")
                emit(emptyList())
            }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id)
            .map { entity -> entity?.toDomain() }
            .flowOn(Dispatchers.IO)
            .catch { e ->
                println("Error getting user by id: ${e.message}")
                emit(null)
            }
    }
    
    override suspend fun refreshUsers() {
        // Gunakan flow untuk refresh async
        flow {
            val response = remoteDataSource.getUsers()
            emit(response)
        }
        .flowOn(Dispatchers.IO)
        .catch { e ->
            println("Error refreshing users: ${e.message}")
            // Tidak melempar error - aplikasi tetap berjalan
        }
        .collect { response ->
            if (response.isSuccessful && response.data != null) {
                val entities = response.data.map { it.toEntity() }
                
                // Perform database operation on IO dispatcher
                withContext(Dispatchers.IO) {
                    localDataSource.deleteAllUsers()
                    localDataSource.insertUsers(entities)
                }
            }
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return try {
            remoteDataSource.createUser(user.toDto())
                .let { response ->
                    if (response.isSuccessful && response.data != null) {
                        // Save to local on IO dispatcher
                        withContext(Dispatchers.IO) {
                            localDataSource.insertUser(response.data.toEntity())
                        }
                        Result.success(Unit)
                    } else {
                        Result.error(Exception(response.errorMessage ?: "Server error"))
                    }
                }
        } catch (e: Exception) {
            // Save to local for offline support
            withContext(Dispatchers.IO) {
                localDataSource.insertUser(user.toEntity())
            }
            Result.success(Unit)
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return try {
            remoteDataSource.updateUser(user.id, user.toDto())
                .let { response ->
                    if (response.isSuccessful) {
                        withContext(Dispatchers.IO) {
                            response.data?.let { serverUser ->
                                localDataSource.updateUser(serverUser.toEntity())
                            } ?: run {
                                localDataSource.updateUser(user.toEntity())
                            }
                        }
                        Result.success(Unit)
                    } else {
                        Result.error(Exception(response.errorMessage ?: "Server error"))
                    }
                }
        } catch (e: Exception) {
            withContext(Dispatchers.IO) {
                localDataSource.updateUser(user.toEntity())
            }
            Result.success(Unit)
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return try {
            remoteDataSource.deleteUser(id)
                .let { response ->
                    if (response.isSuccessful) {
                        withContext(Dispatchers.IO) {
                            localDataSource.deleteUser(id)
                        }
                        Result.success(Unit)
                    } else {
                        Result.error(Exception(response.errorMessage ?: "Server error"))
                    }
                }
        } catch (e: Exception) {
            withContext(Dispatchers.IO) {
                localDataSource.deleteUser(id)
            }
            Result.success(Unit)
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return localDataSource.searchUsers(query)
            .map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
}
```

### Cancellation Support:
**data/repository/coroutine/CancelableRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.coroutine

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.Result
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class CancelableRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers()
            .map { entities -> entities.map { it.toDomain() } }
            .catch { e ->
                if (e !is CancellationException) {
                    println("Error in getUsers flow: ${e.message}")
                    emit(emptyList())
                } else {
                    // Cancellation is expected, rethrow
                    throw e
                }
            }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id)
            .map { entity -> entity?.toDomain() }
            .catch { e ->
                if (e !is CancellationException) {
                    println("Error in getUserById flow: ${e.message}")
                    emit(null)
                } else {
                    throw e
                }
            }
    }
    
    override suspend fun refreshUsers() {
        withContext(Dispatchers.IO + Job()) {  // Add cancellation support
            try {
                val response = withTimeout(30000) {  // Timeout 30 seconds
                    remoteDataSource.getUsers()
                }
                
                if (response.isSuccessful && response.data != null) {
                    val entities = response.data.map { it.toEntity() }
                    localDataSource.deleteAllUsers()
                    localDataSource.insertUsers(entities)
                }
            } catch (e: CancellationException) {
                // Job cancelled, propagate the exception
                throw e
            } catch (e: Exception) {
                // Other exceptions - log and continue
                println("Error refreshing users: ${e.message}")
            }
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return withContext(Dispatchers.IO + Job()) {
            try {
                val response = withTimeout(30000) {
                    remoteDataSource.createUser(user.toDto())
                }
                
                if (response.isSuccessful && response.data != null) {
                    localDataSource.insertUser(response.data.toEntity())
                    Result.success(Unit)
                } else {
                    Result.error(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: CancellationException) {
                // Propagate cancellation
                throw e
            } catch (e: Exception) {
                // Offline support
                localDataSource.insertUser(user.toEntity())
                Result.success(Unit)
            }
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return withContext(Dispatchers.IO + Job()) {
            try {
                val response = withTimeout(30000) {
                    remoteDataSource.updateUser(user.id, user.toDto())
                }
                
                if (response.isSuccessful) {
                    response.data?.let { serverUser ->
                        localDataSource.updateUser(serverUser.toEntity())
                    } ?: run {
                        localDataSource.updateUser(user.toEntity())
                    }
                    Result.success(Unit)
                } else {
                    Result.error(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: CancellationException) {
                throw e
            } catch (e: Exception) {
                localDataSource.updateUser(user.toEntity())
                Result.success(Unit)
            }
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return withContext(Dispatchers.IO + Job()) {
            try {
                val response = withTimeout(30000) {
                    remoteDataSource.deleteUser(id)
                }
                
                if (response.isSuccessful) {
                    localDataSource.deleteUser(id)
                    Result.success(Unit)
                } else {
                    Result.error(Exception(response.errorMessage ?: "Server error"))
                }
            } catch (e: CancellationException) {
                throw e
            } catch (e: Exception) {
                localDataSource.deleteUser(id)
                Result.success(Unit)
            }
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        // Search tidak perlu timeout atau cancellation
        return localDataSource.searchUsers(query).map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
    
    /**
     * Fungsi untuk mendemonstrasikan cancellation
     */
    fun createLongRunningOperation(): Flow<Result<String>> = flow {
        emit(Result.success("Starting operation..."))
        
        repeat(100) { index ->
            // Check for cancellation
            ensureActive()
            
            delay(500) // Simulate work
            emit(Result.success("Progress: ${index + 1}/100"))
        }
        
        emit(Result.success("Operation completed!"))
    }
        .flowOn(Dispatchers.IO)
        .catch { e ->
            if (e is CancellationException) {
                emit(Result.success("Operation cancelled by user"))
            } else {
                emit(Result.error(e))
            }
        }
}
```

### üéì Penjelasan Konsep:
**Coroutines in Repository seperti Pekerja Paralel:**
- **suspend functions**: Fungsi async yang bisa dihentikan dan dilanjutkan
- **withContext**: Swap thread untuk operasi berbeda
- **async**: Operasi paralel
- **Flow**: Stream data reaktif
- **Cancellation**: Mendukung pembatalan operasi

**Best Practices:**
- Gunakan withContext untuk thread switching
- Tambahkan timeout untuk network calls
- Gunakan cancellation untuk operasi lama
- Flow untuk reactive data streams
- Catch exceptions dengan benar
- Gunakan Dispatchers.IO untuk operasi I/O
- Gunakan Job untuk cancellation support

**Coroutine Scopes:**
- **viewModelScope**: Di ViewModel, auto-cancel saat lifecycle selesai
- **lifecycleScope**: Di Activity/Fragment, auto-cancel saat lifecycle selesai
- **GlobalScope**: TIDAK DISARANKAN - bisa memory leak
- **Custom scope**: Untuk repository, dengan lifecycle management

---

## üîß Dependency Injection üì¶

### Konsep Dasar
Dependency Injection seperti sistem pengiriman barang üöö - memberikan komponen yang mereka butuhkan!

### Hilt Setup:
**di/RepositoryModule.kt**
```kotlin
package com.example.myrepositoryapp.di

import com.example.myrepositoryapp.data.repository.cache.CacheInvalidationRepository
import com.example.myrepositoryapp.data.repository.coroutine.FlowRepository
import com.example.myrepositoryapp.data.repository.error_handling.ErrorHandlingUserRepository
import com.example.myrepositoryapp.data.repository.offline_first.OfflineFirstUserRepository
import com.example.myrepositoryapp.data.repository.strategy.NetworkBoundResourceRepository
import com.example.myrepositoryapp.data.repository.transformation.TransformationRepository
import com.example.myrepositoryapp.data.source.local.LocalUserDataSourceImpl
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSourceImpl
import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.network.UserService
import dagger.Binds
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import retrofit2.Retrofit
import retrofit2.create
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    
    @Binds
    abstract fun bindUserRepository(
        repository: CacheInvalidationRepository
    ): UserRepository
    
    @Binds
    abstract fun bindLocalUserDataSource(
        dataSource: LocalUserDataSourceImpl
    ): LocalUserDataSource
    
    @Binds
    abstract fun bindRemoteUserDataSource(
        dataSource: RemoteUserDataSourceImpl
    ): RemoteUserDataSource
}

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideUserService(retrofit: Retrofit): UserService {
        return retrofit.create()
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideUserDao(database: AppDatabase): UserDao {
        return database.userDao()
    }
}

@Module
@InstallIn(SingletonComponent::class)
object DataSourceModule {
    
    @Provides
    @Singleton
    fun provideLocalUserDataSource(
        userDao: UserDao
    ): LocalUserDataSource {
        return LocalUserDataSourceImpl(userDao)
    }
    
    @Provides
    @Singleton
    fun provideRemoteUserDataSource(
        userService: UserService
    ): RemoteUserDataSource {
        return RemoteUserDataSourceImpl(userService)
    }
}
```

### Repository with DI:
**data/repository/di/RepositoryWithDI.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.di

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.Result
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository yang menggunakan dependency injection
 */
@Singleton
class RepositoryWithDI @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return localDataSource.getUserById(id).map { entity ->
            entity?.toDomain()
        }
    }
    
    override suspend fun refreshUsers() {
        try {
            val response = remoteDataSource.getUsers()
            if (response.isSuccessful && response.data != null) {
                val entities = response.data.map { it.toEntity() }
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(entities)
            }
        } catch (e: Exception) {
            // Handle error appropriately
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return try {
            val response = remoteDataSource.createUser(user.toDto())
            
            if (response.isSuccessful && response.data != null) {
                localDataSource.insertUser(response.data.toEntity())
                Result.success(Unit)
            } else {
                Result.error(Exception(response.errorMessage ?: "Server error"))
            }
        } catch (e: Exception) {
            // Save to local for offline support
            localDataSource.insertUser(user.toEntity())
            Result.success(Unit)
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return try {
            val response = remoteDataSource.updateUser(user.id, user.toDto())
            
            if (response.isSuccessful) {
                response.data?.let { serverUser ->
                    localDataSource.updateUser(serverUser.toEntity())
                } ?: run {
                    localDataSource.updateUser(user.toEntity())
                }
                Result.success(Unit)
            } else {
                Result.error(Exception(response.errorMessage ?: "Server error"))
            }
        } catch (e: Exception) {
            localDataSource.updateUser(user.toEntity())
            Result.success(Unit)
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return try {
            val response = remoteDataSource.deleteUser(id)
            
            if (response.isSuccessful) {
                localDataSource.deleteUser(id)
                Result.success(Unit)
            } else {
                Result.error(Exception(response.errorMessage ?: "Server error"))
            }
        } catch (e: Exception) {
            localDataSource.deleteUser(id)
            Result.success(Unit)
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return localDataSource.searchUsers(query).map { it.toDomain() }
    }
    
    override suspend fun getUserCount(): Int {
        return localDataSource.getUserCount()
    }
}
```

### Testing with Fake Repositories:
**data/repository/testing/FakeUserRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository.testing

import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Repository palsu untuk testing
 */
@Singleton
class FakeUserRepository @Inject constructor() : UserRepository {
    
    private val _users = MutableStateFlow<List<User>>(emptyList())
    val users: Flow<List<User>> = _users.asStateFlow()
    
    override fun getUsers(): Flow<List<User>> {
        return users
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        return flow {
            val user = _users.value.find { it.id == id }
            emit(user)
        }
    }
    
    override suspend fun refreshUsers() {
        // Simulate network delay
        delay(500)
        // For testing, we might reload from a predefined set
        // In real implementation, this would fetch from remote
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        // Simulate network delay
        delay(300)
        
        try {
            // Add to local list
            val currentUsers = _users.value.toMutableList()
            currentUsers.add(user.copy(id = currentUsers.size + 1))
            _users.value = currentUsers
            
            return Result.success(Unit)
        } catch (e: Exception) {
            return Result.failure(e)
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        delay(300)
        
        try {
            val currentUsers = _users.value.toMutableList()
            val index = currentUsers.indexOfFirst { it.id == user.id }
            
            if (index != -1) {
                currentUsers[index] = user
                _users.value = currentUsers
                return Result.success(Unit)
            } else {
                return Result.failure(Exception("User not found with id: ${user.id}"))
            }
        } catch (e: Exception) {
            return Result.failure(e)
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        delay(300)
        
        try {
            val currentUsers = _users.value.toMutableList()
            val index = currentUsers.indexOfFirst { it.id == id }
            
            if (index != -1) {
                currentUsers.removeAt(index)
                _users.value = currentUsers
                return Result.success(Unit)
            } else {
                return Result.failure(Exception("User not found with id: $id"))
            }
        } catch (e: Exception) {
            return Result.failure(e)
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return _users.value.filter { user ->
            user.name.contains(query, ignoreCase = true) ||
            user.email.contains(query, ignoreCase = true)
        }
    }
    
    override suspend fun getUserCount(): Int {
        return _users.value.size
    }
    
    // Helper functions for testing
    fun setUsers(users: List<User>) {
        _users.value = users
    }
    
    fun addUser(user: User) {
        val currentUsers = _users.value.toMutableList()
        currentUsers.add(user)
        _users.value = currentUsers
    }
    
    fun clearUsers() {
        _users.value = emptyList()
    }
}
```

### Testing Module:
**di/TestingModule.kt**
```kotlin
package com.example.myrepositoryapp.di

import com.example.myrepositoryapp.data.repository.testing.FakeUserRepository
import com.example.myrepositoryapp.domain.repository.UserRepository
import dagger.Binds
import dagger.Module
import dagger.hilt.components.SingletonComponent
import dagger.hilt.testing.HiltAndroidTest

@Module
@HiltAndroidTest
@InstallIn(SingletonComponent::class)
abstract class TestRepositoryModule {
    
    @Binds
    abstract fun bindUserRepository(
        repository: FakeUserRepository
    ): UserRepository
}
```

### üéì Penjelasan Konsep:
**Dependency Injection seperti Sistem Pengiriman:**
- **Constructor Injection**: Dependency diberikan melalui constructor
- **@Inject**: Menandakan tempat dependency harus disisipkan
- **@Singleton**: Hanya satu instance sepanjang aplikasi
- **@Binds**: Binding interface ke implementasi
- **@Provides**: Fungsi yang menyediakan dependency

**Manfaat DI:**
- **Testability**: Mudah untuk mocking
- **Maintainability**: Lebih mudah mengganti implementasi
- **Scalability**: Struktur yang lebih modular
- **Decoupling**: Komponen tidak terikat dengan implementasi

**Hilt Components:**
- **@SingletonComponent**: Instance sepanjang aplikasi
- **@ActivityRetainedComponent**: Instance sepanjang activity
- **@ActivityComponent**: Instance per activity
- **@FragmentComponent**: Instance per fragment
- **@ViewModelComponent**: Instance per ViewModel

**Best Practices:**
- Gunakan constructor injection
- Gunakan @Binds untuk interface binding
- Gunakan @Provides untuk object creation
- Gunakan @Qualifier untuk multiple instances
- Gunakan @Singleton untuk shared instances
- Buat fake repositories untuk testing

---

## 8Ô∏è‚É£ Hands-on Implementation üõ†Ô∏è

### Konsep Dasar
Hands-on Implementation seperti proyek nyata üèóÔ∏è - menggabungkan semua konsep dalam contoh nyata!

### Complete Repository Implementation:
**data/repository/CompleteUserRepository.kt**
```kotlin
package com.example.myrepositoryapp.data.repository

import com.example.myrepositoryapp.data.source.local.LocalUserDataSource
import com.example.myrepositoryapp.data.source.remote.RemoteUserDataSource
import com.example.myrepositoryapp.data.cache.CacheRepository
import com.example.myrepositoryapp.domain.model.User
import com.example.myrepositoryapp.domain.repository.UserRepository
import com.example.myrepositoryapp.utils.Result
import com.example.myrepositoryapp.utils.toDomain
import com.example.myrepositoryapp.utils.toEntity
import com.example.myrepositoryapp.utils.toDto
import com.example.myrepositoryapp.utils.ErrorMessageMapper
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import timber.log.Timber
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.time.Duration
import kotlin.time.DurationUnit

/**
 * Complete User Repository implementation menggabungkan semua konsep
 */
@Singleton
class CompleteUserRepository @Inject constructor(
    private val localDataSource: LocalUserDataSource,
    private val remoteDataSource: RemoteUserDataSource,
    private val cacheRepository: CacheRepository
) : UserRepository {
    
    override fun getUsers(): Flow<List<User>> {
        // Gunakan caching untuk efisiensi
        return localDataSource.getUsers().map { entities ->
            entities.map { it.toDomain() }
        }
    }
    
    override fun getUserById(id: Int): Flow<User?> {
        // Gunakan cache dengan TTL
        val cacheKey = "user_$id"
        
        return cacheRepository.getFlow<User>(cacheKey).map { cachedUser ->
            cachedUser ?: run {
                // Jika tidak ada di cache, ambil dari lokal
                localDataSource.getUserById(id).first()?.toDomain()
            }
        }
    }
    
    override suspend fun refreshUsers() {
        try {
            val response = remoteDataSource.getUsers()
            
            if (response.isSuccessful && response.data != null) {
                // Gunakan cache invalidation
                cacheRepository.clearGroup("users")
                
                localDataSource.deleteAllUsers()
                localDataSource.insertUsers(response.data.map { it.toEntity() })
                
                // Cache individual users
                response.data.forEach { userDto ->
                    cacheRepository.put(
                        key = "user_${userDto.id}",
                        data = userDto.toDomain(),
                        ttl = 5.toDuration(DurationUnit.MINUTES)
                    )
                }
            } else {
                throw Exception(response.errorMessage ?: "Unknown error")
            }
        } catch (e: Exception) {
            val mappedError = ErrorMessageMapper.getErrorMessage(e)
            Timber.e(e, "Error refreshing users: $mappedError")
            throw e
        }
    }
    
    override suspend fun createUser(user: User): Result<Unit> {
        return try {
            // Simpan ke lokal dulu (offline support)
            val localId = localDataSource.insertUser(user.toEntity())
            
            // Kirim ke remote dan update jika berhasil
            val response = remoteDataSource.createUser(user.toDto())
            
            if (response.isSuccessful && response.data != null) {
                // Update lokal dengan data server (mungkin ada ID baru)
                val serverUser = response.data.toEntity()
                if (serverUser.id != localId) {
                    // Hapus dengan ID lama dan simpan dengan ID baru
                    localDataSource.deleteUser(localId.toInt())
                }
                localDataSource.insertUser(serverUser)
                
                // Update cache
                cacheRepository.put(
                    key = "user_${serverUser.id}",
                    data = serverUser.toDomain(),
                    ttl = 5.toDuration(DurationUnit.MINUTES)
                )
                cacheRepository.remove("users_all") // Invalidasi list cache
                
                Result.success(Unit)
            } else {
                // Simpan ke offline queue untuk sync nanti
                Result.error(Exception(response.errorMessage ?: "Server error"))
            }
        } catch (e: Exception) {
            val mappedError = ErrorMessageMapper.getErrorMessage(e)
            Timber.e(e, "Error creating user: $mappedError")
            
            // Tetap sukses untuk offline support
            Result.success(Unit)
        }
    }
    
    override suspend fun updateUser(user: User): Result<Unit> {
        return try {
            // Update lokal dulu
            localDataSource.updateUser(user.toEntity())
            
            // Update cache
            cacheRepository.put(
                key = "user_${user.id}",
                data = user,
                ttl = 5.toDuration(DurationUnit.MINUTES)
            )
            
            // Kirim ke remote
            val response = remoteDataSource.updateUser(user.id, user.toDto())
            
            if (response.isSuccessful) {
                response.data?.let { serverUser ->
                    // Update lokal dan cache dengan data server
                    val entity = serverUser.toEntity()
                    localDataSource.updateUser(entity)
                    cacheRepository.put(
                        key = "user_${entity.id}",
                        data = entity.toDomain(),
                        ttl = 5.toDuration(DurationUnit.MINUTES)
                    )
                }
                
                Result.success(Unit)
            } else {
                Result.error(Exception(response.errorMessage ?: "Server error"))
            }
        } catch (e: Exception) {
            val mappedError = ErrorMessageMapper.getErrorMessage(e)
            Timber.e(e, "Error updating user: $mappedError")
            
            // Tetap sukses karena lokal sudah diupdate
            Result.success(Unit)
        }
    }
    
    override suspend fun deleteUser(id: Int): Result<Unit> {
        return try {
            // Hapus dari lokal dulu
            localDataSource.deleteUser(id)
            
            // Hapus dari cache
            cacheRepository.remove("user_$id")
            
            // Kirim ke remote
            val response = remoteDataSource.deleteUser(id)
            
            if (response.isSuccessful) {
                // Invalidasi list cache
                cacheRepository.remove("users_all")
                Result.success(Unit)
            } else {
                Result.error(Exception(response.errorMessage ?: "Server error"))
            }
        } catch (e: Exception) {
            val mappedError = ErrorMessageMapper.getErrorMessage(e)
            Timber.e(e, "Error deleting user: $mappedError")
            
            // Tetap sukses karena lokal sudah dihapus
            Result.success(Unit)
        }
    }
    
    override suspend fun searchUsers(query: String): List<User> {
        return try {
            val cachedResult = cacheRepository.get<List<User>>("search_$query")
            cachedResult ?: run {
                val result = localDataSource.searchUsers(query).map { it.toDomain() }
                
                // Cache hasil pencarian
                cacheRepository.put(
                    key = "search_$query",
                    data = result,
                    ttl = 30.toDuration(DurationUnit.SECONDS)
                )
                
                result
            }
        } catch (e: Exception) {
            val mappedError = ErrorMessageMapper.getErrorMessage(e)
            Timber.e(e, "Error searching users: $mappedError")
            emptyList()
        }
    }
    
    override suspend fun getUserCount(): Int {
        return try {
            localDataSource.getUserCount()
        } catch (e: Exception) {
            val mappedError = ErrorMessageMapper.getErrorMessage(e)
            Timber.e(e, "Error getting user count: $mappedError")
            0
        }
    }
}
```

### Repository Module for Complete Implementation:
**di/CompleteRepositoryModule.kt**
```kotlin
package com.example.myrepositoryapp.di

import com.example.myrepositoryapp.data.repository.CompleteUserRepository
import com.example.myrepositoryapp.data.repository.offline_first.OfflineFirstUserRepository
import com.example.myrepositoryapp.data.repository.error_handling.ErrorHandlingUserRepository
import com.example.myrepositoryapp.domain.repository.UserRepository
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
abstract class CompleteRepositoryModule {
    
    @Binds
    @Singleton
    abstract fun bindUserRepository(
        repository: CompleteUserRepository
    ): UserRepository
}

// Alternate implementations bisa ditukar dengan qualifier
@Module
@InstallIn(SingletonComponent::class)
abstract class AlternativeRepositoryModule {
    
    // Gunakan qualifier jika diperlukan
    /*
    @Binds
    @Named("offline_first")
    abstract fun bindOfflineFirstRepository(
        repository: OfflineFirstUserRepository
    ): UserRepository
    
    @Binds
    @Named("error_handling")
    abstract fun bindErrorHandlingRepository(
        repository: ErrorHandlingUserRepository
    ): UserRepository
    */
}
```

### Complete Implementation Example:
**ui/screens/CompleteRepositoryExampleScreen.kt**
```kotlin
package com.example.myrepositoryapp.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.myrepositoryapp.presentation.viewmodel.UserViewModel
import dagger.hilt.android.AndroidEntryPoint

@Composable
fun CompleteRepositoryExampleScreen(
    viewModel: UserViewModel = hiltViewModel()
) {
    var searchQuery by remember { mutableStateOf("") }
    var showAddDialog by remember { mutableStateOf(false) }
    
    LaunchedEffect(Unit) {
        viewModel.loadUsers()
    }
    
    Column(
        modifier = Modifier.fillMaxSize()
    ) {
        // Search bar
        OutlinedTextField(
            value = searchQuery,
            onValueChange = { searchQuery = it },
            label = { Text("Cari pengguna...") },
            leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        )
        
        // Main content
        when (val uiState = viewModel.uiState.collectAsState().value) {
            is UserUiState.Loading -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            }
            is UserUiState.Success -> {
                LazyColumn(
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(uiState.users) { user ->
                        UserItem(
                            user = user,
                            onEditClick = { /* Handle edit */ },
                            onDeleteClick = { viewModel.deleteUser(user.id) },
                            onToggleActive = { 
                                val updatedUser = user.copy(isActive = !user.isActive)
                                viewModel.updateUser(updatedUser)
                            }
                        )
                    }
                }
            }
            is UserUiState.Error -> {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Icon(
                            imageVector = Icons.Default.Error,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.error,
                            modifier = Modifier.size(48.dp)
                        )
                        Text(
                            text = uiState.message,
                            color = MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.headlineSmall
                        )
                        Button(
                            onClick = { viewModel.loadUsers() },
                            modifier = Modifier.padding(top = 16.dp)
                        ) {
                            Text("Coba Lagi")
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun UserItem(
    user: User,
    onEditClick: () -> Unit,
    onDeleteClick: () -> Unit,
    onToggleActive: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Status indicator
            Box(
                modifier = Modifier
                    .size(12.dp)
                    .background(
                        color = if (user.isActive) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline,
                        shape = androidx.compose.foundation.shape.CircleShape
                    )
            )
            
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = user.name,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = user.email,
                    fontSize = 12.sp,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            
            IconButton(onClick = onToggleActive) {
                Icon(
                    imageVector = if (user.isActive) Icons.Default.CheckCircle else Icons.Default.RadioButtonUnchecked,
                    contentDescription = if (user.isActive) "Active" else "Inactive",
                    tint = if (user.isActive) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline
                )
            }
            
            IconButton(onClick = onEditClick) {
                Icon(Icons.Default.Edit, contentDescription = "Edit")
            }
            
            IconButton(onClick = onDeleteClick) {
                Icon(Icons.Default.Delete, contentDescription = "Delete")
            }
        }
    }
}

// ViewModel yang menggunakan repository
@HiltViewModel
class UserViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UserUiState>(UserUiState.Loading)
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()
    
    fun loadUsers() {
        viewModelScope.launch {
            _uiState.value = UserUiState.Loading
            
            try {
                val users = userRepository.getUsers().first()
                _uiState.value = UserUiState.Success(users)
            } catch (e: Exception) {
                _uiState.value = UserUiState.Error(ErrorMessageMapper.getErrorMessage(e))
            }
        }
    }
    
    fun createUser(user: User) {
        viewModelScope.launch {
            val result = userRepository.createUser(user)
            if (result.isSuccess) {
                loadUsers() // Refresh list
            } else {
                // Handle error - mungkin tampilkan snack bar
                println("Error creating user: ${result.exceptionOrNull()?.message}")
            }
        }
    }
    
    fun updateUser(user: User) {
        viewModelScope.launch {
            val result = userRepository.updateUser(user)
            if (result.isSuccess) {
                loadUsers() // Refresh list
            } else {
                println("Error updating user: ${result.exceptionOrNull()?.message}")
            }
        }
    }
    
    fun deleteUser(id: Int) {
        viewModelScope.launch {
            val result = userRepository.deleteUser(id)
            if (result.isSuccess) {
                loadUsers() // Refresh list
            } else {
                println("Error deleting user: ${result.exceptionOrNull()?.message}")
            }
        }
    }
}

// UI State sealed class
sealed class UserUiState {
    object Loading : UserUiState()
    data class Success(val users: List<User>) : UserUiState()
    data class Error(val message: String) : UserUiState()
}
```

### üéì Penjelasan Konsep:
**Complete Implementation seperti Proyek Nyata:**
- **Gabungan semua konsep**: State management, caching, error handling, dll
- **Production ready**: Siap untuk aplikasi nyata
- **Modular**: Struktur yang bisa diganti dan diuji
- **Best practices**: Mengikuti semua pattern yang benar

**Komponen Lengkap:**
- **Repository**: Implementasi lengkap dengan caching, offline support, error handling
- **Data Sources**: Local dan remote
- **ViewModel**: State management dan business logic
- **UI**: Compose components yang terhubung
- **DI**: Hilt untuk dependency injection
- **Testing**: Structur yang bisa diuji

**Best Practices dalam Complete Implementation:**
- Gunakan sealed classes untuk state
- Implementasi error handling menyeluruh
- Gunakan caching untuk efisiensi
- Support offline-first
- Gunakan DI untuk modularitas
- Terapkan clean architecture
- Gunakan coroutines dengan benar
- Gunakan Flow untuk reactive programming

---

## üìÅ Struktur Project Lengkap
```
MyComposeApp/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java/com/example/myrepositoryapp/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LifecycleDemoScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ColorSystemExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TypographyExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ShapeExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MaterialThemeExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorHandlingExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TransformationRepositoryExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SuspendFunctionExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FlowExamplesScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CompleteRepositoryExampleScreen.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ theme/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Theme.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Type.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Color.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Shape.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CustomComponents.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MapperExtensions.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorMessageMapper.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ResultWrapper.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ListTransformations.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConnectivityManager.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entity/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserEntity.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dao/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserDao.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AppDatabase.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserDto.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ApiResponse.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ source/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ local/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LocalUserDataSource.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LocalUserDataSourceImpl.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OfflineOperationDao.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ remote/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ RemoteUserDataSource.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ RemoteUserDataSourceImpl.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repository/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ UserRepository.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CompleteUserRepository.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ErrorHandlingUserRepository.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CacheInvalidationRepository.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ OfflineFirstUserRepository.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ NetworkBoundResourceRepository.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ FlowRepository.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ testing/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ FakeUserRepository.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ network/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UserService.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ presentation/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ viewmodel/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ UserViewModel.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ state/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ UserUiState.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ di/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RepositoryModule.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NetworkModule.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DatabaseModule.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DataSourceModule.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CompleteRepositoryModule.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TestModule.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MainActivity.kt
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ res/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ values/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ strings.xml
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AndroidManifest.xml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ java/com/example/myrepositoryapp/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ repository/
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ UserRepositoryTest.kt
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ build.gradle.kts
‚îú‚îÄ‚îÄ gradle/
‚îÇ   ‚îî‚îÄ‚îÄ wrapper/
‚îú‚îÄ‚îÄ build.gradle.kts
‚îî‚îÄ‚îÄ settings.gradle.kts
```

## üéØ Kesimpulan

Dengan menguasai Compose Fundamentals, kamu sekarang memiliki kemampuan untuk:

### 1. **Pengenalan Jetpack Compose:**
- Memahami konsep declarative UI
- Memahami perbedaan dengan view system tradisional
- Menguasai arsitektur Compose

### 2. **@Composable Functions:**
- Membuat komponen UI dengan @Composable
- Mengikuti naming convention yang benar
- Memahami aturan Composable functions
- Menghindari side effects yang tidak perlu

### 3. **Compose Lifecycle:**
- Memahami Composition, Recomposition, dan Decomposition
- Mengenal smart recomposition
- Memahami kapan recomposition terjadi
- Mengoptimalkan performa dengan skipping

### 4. **Preview:**
- Menggunakan @Preview dengan berbagai parameter
- Membuat multiple previews
- Menguji di berbagai device dan theme
- Menggunakan interactive mode

### 5. **Project Structure:**
- Membuat struktur project yang modular
- Mengintegrasikan Compose dengan project
- Mengelola dependencies dengan baik

### 6. **Debugging Compose:**
- Menggunakan Layout Inspector untuk Compose
- Mengidentifikasi recomposition counts
- Memantau performa dengan tools

### 7. **Additional Concepts Covered:**
- State management dengan mutableStateOf
- Caching strategies
- Error handling dengan Result wrapper
- Data transformation patterns
- Integration with coroutines
- Dependency injection dengan Hilt

### üöÄ Best Practices Penting:
1. **Gunakan Declarative Approach**: Gambarkan UI bukan langkah-langkah membuatnya
2. **Ikuti Naming Convention**: PascalCase untuk Composable functions
3. **Hindari Side Effects**: Tempatkan efek samping di tempat yang tepat
4. **Gunakan Preview**: Periksa tampilan sebelum run aplikasi
5. **Optimalkan Recomposition**: Gunakan remember, derivedStateOf dengan bijak
6. **Manajemen State yang Baik**: Pisahkan state dari UI logic
7. **Gunakan Sealed Classes**: Untuk state management yang type-safe
8. **Error Handling**: Selalu tangani kasus error dengan elegan
9. **Testing**: Gunakan preview dan unit test untuk validasi
10. **Dependency Injection**: Gunakan Hilt untuk manajemen dependensi yang baik

Kamu sekarang siap membuat aplikasi Jetpack Compose yang modern, efisien, dan skalabel dengan mengikuti prinsip-prinsip Compose Fundamentals yang telah dipelajari!