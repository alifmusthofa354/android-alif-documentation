## **6.4 Migration** (2 hari) ⭐⭐

### **Teknologi Modern:**
- Database migration strategies

### **Teknologi yang Ditinggalkan:**
- Uninstall-reinstall

### **Sub-topik Detail:**

#### 1. Database Versioning Basics
- Schema versions
- Migration paths
- Forward compatibility
- Backward compatibility
- Migration testing
- Rollback strategies

#### 2. Simple Migrations

**Adding a Column:**
```kotlin
// Version 1
@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase()

@Entity
data class User(
    @PrimaryKey val id: Long,
    val name: String,
    val email: String
)

// Version 2 - Add phone column
@Database(entities = [User::class], version = 2)
abstract class AppDatabase : RoomDatabase()

@Entity
data class User(
    @PrimaryKey val id: Long,
    val name: String,
    val email: String,
    val phone: String? = null // New column, nullable
)

val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("ALTER TABLE User ADD COLUMN phone TEXT")
    }
}
```

**Changing Column Type:**
```kotlin
// Version 2 to 3 - Change age from Int to String
val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // SQLite doesn't support ALTER COLUMN
        // Need to recreate table
        
        // 1. Create new table
        database.execSQL("""
            CREATE TABLE User_new (
                id INTEGER PRIMARY KEY NOT NULL,
                name TEXT NOT NULL,
                email TEXT NOT NULL,
                phone TEXT,
                age TEXT
            )
        """)
        
        // 2. Copy data with type conversion
        database.execSQL("""
            INSERT INTO User_new (id, name, email, phone, age)
            SELECT id, name, email, phone, CAST(age AS TEXT)
            FROM User
        """)
        
        // 3. Drop old table
        database.execSQL("DROP TABLE User")
        
        // 4. Rename new table
        database.execSQL("ALTER TABLE User_new RENAME TO User")
    }
}
```

#### 3. Complex Migrations

**Adding a New Table:**
```kotlin
val MIGRATION_3_4 = object : Migration(3, 4) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Create new table
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS Post (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                userId INTEGER NOT NULL,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                createdAt INTEGER NOT NULL,
                FOREIGN KEY(userId) REFERENCES User(id) ON DELETE CASCADE
            )
        """)
        
        // Create index
        database.execSQL("CREATE INDEX IF NOT EXISTS index_Post_userId ON Post(userId)")
    }
}
```

**Renaming a Column:**
```kotlin
val MIGRATION_4_5 = object : Migration(4, 5) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // SQLite doesn't support RENAME COLUMN directly in old versions
        
        // 1. Create new table with new column name
        database.execSQL("""
            CREATE TABLE User_new (
                id INTEGER PRIMARY KEY NOT NULL,
                fullName TEXT NOT NULL,  -- renamed from 'name'
                email TEXT NOT NULL,
                phone TEXT,
                age TEXT
            )
        """)
        
        // 2. Copy data
        database.execSQL("""
            INSERT INTO User_new (id, fullName, email, phone, age)
            SELECT id, name, email, phone, age
            FROM User
        """)
        
        // 3. Drop old table
        database.execSQL("DROP TABLE User")
        
        // 4. Rename
        database.execSQL("ALTER TABLE User_new RENAME TO User")
        
        // 5. Recreate indices if any
        database.execSQL("CREATE INDEX IF NOT EXISTS index_User_email ON User(email)")
    }
}
```

**Splitting a Table:**
```kotlin
val MIGRATION_5_6 = object : Migration(5, 6) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Split User table into User and UserProfile
        
        // 1. Create UserProfile table
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS UserProfile (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                userId INTEGER NOT NULL,
                bio TEXT,
                avatarUrl TEXT,
                FOREIGN KEY(userId) REFERENCES User(id) ON DELETE CASCADE
            )
        """)
        
        // 2. Migrate data from User to UserProfile
        database.execSQL("""
            INSERT INTO UserProfile (userId, bio, avatarUrl)
            SELECT id, bio, avatarUrl
            FROM User
        """)
        
        // 3. Create new User table without bio and avatarUrl
        database.execSQL("""
            CREATE TABLE User_new (
                id INTEGER PRIMARY KEY NOT NULL,
                fullName TEXT NOT NULL,
                email TEXT NOT NULL,
                phone TEXT
            )
        """)
        
        // 4. Copy remaining user data
        database.execSQL("""
            INSERT INTO User_new (id, fullName, email, phone)
            SELECT id, fullName, email, phone
            FROM User
        """)
        
        // 5. Drop old User table
        database.execSQL("DROP TABLE User")
        
        // 6. Rename
        database.execSQL("ALTER TABLE User_new RENAME TO User")
    }
}
```

#### 4. Destructive Migration

**For Development Only:**
```kotlin
Room.databaseBuilder(context, AppDatabase::class.java, "database")
    .fallbackToDestructiveMigration() // Deletes all data!
    .build()
```

**Selective Destructive Migration:**
```kotlin
Room.databaseBuilder(context, AppDatabase::class.java, "database")
    .fallbackToDestructiveMigrationFrom(1, 2) // Only for versions 1→2
    .fallbackToDestructiveMigrationOnDowngrade() // Only on downgrade
    .build()
```

#### 5. Migration Testing

**Automated Migration Test:**
```kotlin
@RunWith(AndroidJUnit4::class)
class MigrationTest {
    private val TEST_DB = "migration-test"
    
    @get:Rule
    val helper: MigrationTestHelper = MigrationTestHelper(
        InstrumentationRegistry.getInstrumentation(),
        AppDatabase::class.java
    )
    
    @Test
    fun migrate1To2() {
        // Create database with version 1
        helper.createDatabase(TEST_DB, 1).apply {
            execSQL("INSERT INTO User (id, name, email) VALUES (1, 'John', 'john@test.com')")
            close()
        }
        
        // Run migration to version 2
        helper.runMigrationsAndValidate(TEST_DB, 2, true, MIGRATION_1_2)
        
        // Verify data
        helper.openDatabase(TEST_DB).apply {
            val cursor = query("SELECT * FROM User WHERE id = 1")
            assertTrue(cursor.moveToFirst())
            
            // Check new column exists and is null
            val phoneIndex = cursor.getColumnIndex("phone")
            assertTrue(phoneIndex >= 0)
            assertTrue(cursor.isNull(phoneIndex))
            
            cursor.close()
            close()
        }
    }
    
    @Test
    fun migrateAll() {
        // Create version 1
        helper.createDatabase(TEST_DB, 1).apply {
            execSQL("INSERT INTO User (id, name, email) VALUES (1, 'John', 'john@test.com')")
            close()
        }
        
        // Migrate through all versions
        Room.databaseBuilder(
            InstrumentationRegistry.getInstrumentation().targetContext,
            AppDatabase::class.java,
            TEST_DB
        )
            .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4)
            .build()
            .apply {
                openHelper.writableDatabase.close()
            }
    }
}
```

#### 6. Data Preservation During Migration

**Preserve User Data:**
```kotlin
val MIGRATION_6_7 = object : Migration(6, 7) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Add default values for existing rows
        database.execSQL("ALTER TABLE User ADD COLUMN isActive INTEGER NOT NULL DEFAULT 1")
        
        // Update based on existing data
        database.execSQL("""
            UPDATE User
            SET isActive = CASE
                WHEN lastLoginDate > ${System.currentTimeMillis() - 30L * 24 * 60 * 60 * 1000}
                THEN 1
                ELSE 0
            END
        """)
    }
}
```

#### 7. Multiple Migration Paths

```kotlin
val MIGRATION_1_2 = object : Migration(1, 2) { ... }
val MIGRATION_2_3 = object : Migration(2, 3) { ... }
val MIGRATION_3_4 = object : Migration(3, 4) { ... }

// Direct migration path (skip intermediate versions)
val MIGRATION_1_4 = object : Migration(1, 4) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Apply all changes at once
        // More efficient than running 1→2, 2→3, 3→4
    }
}

Room.databaseBuilder(context, AppDatabase::class.java, "database")
    .addMigrations(
        MIGRATION_1_2,
        MIGRATION_2_3,
        MIGRATION_3_4,
        MIGRATION_1_4 // Shortcut path
    )
    .build()
```

#### 8. Pre-Packaged Database

**Ship App with Pre-Populated Database:**
```kotlin
Room.databaseBuilder(context, AppDatabase::class.java, "database")
    .createFromAsset("databases/prepopulated.db")
    .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
    .build()
```

**With Destructive Migration Fallback:**
```kotlin
Room.databaseBuilder(context, AppDatabase::class.java, "database")
    .createFromAsset("databases/prepopulated.db")
    .fallbackToDestructiveMigrationFrom(1) // Reset if migration from v1 fails
    .build()
```

#### 9. Handling Migration Failures

**Callback for Migration Success/Failure:**
```kotlin
val callback = object : RoomDatabase.Callback() {
    override fun onCreate(db: SupportSQLiteDatabase) {
        super.onCreate(db)
        Log.d("Database", "Database created")
    }
    
    override fun onOpen(db: SupportSQLiteDatabase) {
        super.onOpen(db)
        Log.d("Database", "Database opened")
    }
}

Room.databaseBuilder(context, AppDatabase::class.java, "database")
    .addMigrations(MIGRATION_1_2)
    .addCallback(callback)
    .build()
```

**Try-Catch Migration:**
```kotlin
val MIGRATION_7_8 = object : Migration(7, 8) {
    override fun migrate(database: SupportSQLiteDatabase) {
        try {
            database.execSQL("ALTER TABLE User ADD COLUMN newColumn TEXT")
            
            // Complex data transformation
            database.execSQL("""
                UPDATE User
                SET newColumn = someComplexCalculation()
            """)
        } catch (e: SQLException) {
            Log.e("Migration", "Migration 7→8 failed", e)
            // Handle error - maybe set default values
            database.execSQL("ALTER TABLE User ADD COLUMN newColumn TEXT DEFAULT ''")
        }
    }
}
```

#### 10. Best Practices
✅ Always provide migration paths
✅ Test migrations thoroughly
✅ Preserve user data
✅ Use fallbackToDestructiveMigration only in development
✅ Version your database schema
✅ Document migration changes
✅ Handle migration failures gracefully
✅ Consider direct migration paths for performance
✅ Export schema for validation
✅ Test on real devices with real data

#### 11. Schema Export

**Enable Schema Export:**
```kotlin
// build.gradle.kts
android {
    defaultConfig {
        javaCompileOptions {
            annotationProcessorOptions {
                arguments += mapOf(
                    "room.schemaLocation" to "$projectDir/schemas",
                    "room.incremental" to "true"
                )
            }
        }
    }
}

kapt {
    arguments {
        arg("room.schemaLocation", "$projectDir/schemas")
    }
}
```

**This generates JSON schema files:**
```
schemas/
  com.example.AppDatabase/
    1.json
    2.json
    3.json
```

#### 12. Migration Strategies Summary

**Strategy 1: Always Migrate (Recommended for Production)**
```kotlin
Room.databaseBuilder(context, AppDatabase::class.java, "database")
    .addMigrations(ALL_MIGRATIONS...)
    .build()
```

**Strategy 2: Destructive for Development**
```kotlin
Room.databaseBuilder(context, AppDatabase::class.java, "database")
    .apply {
        if (BuildConfig.DEBUG) {
            fallbackToDestructiveMigration()
        } else {
            addMigrations(ALL_MIGRATIONS...)
        }
    }
    .build()
```

**Strategy 3: Hybrid**
```kotlin
Room.databaseBuilder(context, AppDatabase::class.java, "database")
    .addMigrations(MIGRATION_1_2, MIGRATION_2_3)
    .fallbackToDestructiveMigrationFrom(1) // Only from v1
    .build()
```

#### 13. Hands-on Exercises
- Create initial database schema
- Add new columns with migrations
- Rename columns/tables
- Create complex migration paths
- Test migrations
- Handle migration failures
- Export and validate schemas
- Implement rollback strategy

---
