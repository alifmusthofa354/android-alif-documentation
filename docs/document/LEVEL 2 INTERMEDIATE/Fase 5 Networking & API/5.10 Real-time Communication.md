

## **5.10 Real-time Communication** (3 hari) ‚≠ê‚≠ê

### **Teknologi Modern:**
- WebSocket
- Server-Sent Events (SSE)

### **Teknologi yang Ditinggalkan:**
- Polling

### **Sub-topik Detail:**

#### 1. Real-Time Communication Methods

**Polling (Traditional - Inefficient):**
```kotlin
// ‚ùå Bad: Constant polling
while (true) {
    val data = apiService.getData()
    updateUI(data)
    delay(5000) // Poll every 5 seconds
}
```

**Long Polling:**
```kotlin
// Better but still inefficient
suspend fun longPoll() {
    while (true) {
        try {
            val data = apiService.longPollData() // Server holds connection
            updateUI(data)
        } catch (e: Exception) {
            delay(1000)
        }
    }
}
```

**WebSocket (Best for Bi-directional):**
- Full-duplex communication
- Low latency
- Persistent connection
- Server can push data

**Server-Sent Events (Best for Server‚ÜíClient):**
- Uni-directional (server to client)
- Auto-reconnection
- Simple protocol
- HTTP-based

#### 2. WebSocket with OkHttp

**Setup:**
```kotlin
class WebSocketManager(
    private val client: OkHttpClient = OkHttpClient()
) {
    private var webSocket: WebSocket? = null
    private val _messages = MutableSharedFlow<String>()
    val messages: SharedFlow<String> = _messages.asSharedFlow()
    
    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)
    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()
    
    fun connect(url: String) {
        val request = Request.Builder()
            .url(url)
            .build()
        
        webSocket = client.newWebSocket(request, object : WebSocketListener() {
            override fun onOpen(webSocket: WebSocket, response: Response) {
                _connectionState.value = ConnectionState.CONNECTED
                Log.d("WebSocket", "Connected")
            }
            
            override fun onMessage(webSocket: WebSocket, text: String) {
                CoroutineScope(Dispatchers.Default).launch {
                    _messages.emit(text)
                }
            }
            
            override fun onMessage(webSocket: WebSocket, bytes: ByteString) {
                onMessage(webSocket, bytes.utf8())
            }
            
            override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
                webSocket.close(1000, null)
                _connectionState.value = ConnectionState.DISCONNECTED
                Log.d("WebSocket", "Closing: $code / $reason")
            }
            
            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
                _connectionState.value = ConnectionState.ERROR
                Log.e("WebSocket", "Error: ${t.message}")
                
                // Auto-reconnect after delay
                CoroutineScope(Dispatchers.Default).launch {
                    delay(5000)
                    connect(url)
                }
            }
        })
    }
    
    fun send(message: String) {
        webSocket?.send(message)
    }
    
    fun disconnect() {
        webSocket?.close(1000, "Client disconnecting")
        webSocket = null
        _connectionState.value = ConnectionState.DISCONNECTED
    }
}

enum class ConnectionState {
    DISCONNECTED, CONNECTING, CONNECTED, ERROR
}
```

**Usage in Repository:**
```kotlin
class ChatRepository(
    private val webSocketManager: WebSocketManager
) {
    fun connectToChat(roomId: String) {
        webSocketManager.connect("wss://api.example.com/chat/$roomId")
    }
    
    fun sendMessage(message: String) {
        val json = JSONObject().apply {
            put("type", "message")
            put("content", message)
            put("timestamp", System.currentTimeMillis())
        }
        webSocketManager.send(json.toString())
    }
    
    fun observeMessages(): Flow<ChatMessage> {
        return webSocketManager.messages
            .map { json ->
                // Parse JSON to ChatMessage
                val jsonObject = JSONObject(json)
                ChatMessage(
                    id = jsonObject.getString("id"),
                    content = jsonObject.getString("content"),
                    userId = jsonObject.getString("userId"),
                    timestamp = jsonObject.getLong("timestamp")
                )
            }
    }
    
    fun disconnect() {
        webSocketManager.disconnect()
    }
}
```

**ViewModel:**
```kotlin
class ChatViewModel(
    private val repository: ChatRepository
) : ViewModel() {
    
    private val _messages = MutableStateFlow<List<ChatMessage>>(emptyList())
    val messages: StateFlow<List<ChatMessage>> = _messages.asStateFlow()
    
    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)
    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()
    
    init {
        // Collect messages
        viewModelScope.launch {
            repository.observeMessages().collect { message ->
                _messages.value = _messages.value + message
            }
        }
    }
    
    fun connectToChat(roomId: String) {
        repository.connectToChat(roomId)
    }
    
    fun sendMessage(content: String) {
        repository.sendMessage(content)
    }
    
    override fun onCleared() {
        super.onCleared()
        repository.disconnect()
    }
}
```

**UI (Compose):**
```kotlin
@Composable
fun ChatScreen(
    viewModel: ChatViewModel = hiltViewModel()
) {
    val messages by viewModel.messages.collectAsState()
    val connectionState by viewModel.connectionState.collectAsState()
    var messageText by remember { mutableStateOf("") }
    
    LaunchedEffect(Unit) {
        viewModel.connectToChat("room123")
    }
    
    Column(modifier = Modifier.fillMaxSize()) {
        // Connection status
        ConnectionStatusBar(connectionState)
        
        // Messages list
        LazyColumn(
            modifier = Modifier.weight(1f),
            reverseLayout = true
        ) {
            items(messages.reversed()) { message ->
                MessageItem(message)
            }
        }
        
        // Input field
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextField(
                value = messageText,
                onValueChange = { messageText = it },
                modifier = Modifier.weight(1f),
                placeholder = { Text("Type a message...") }
            )
            
            IconButton(
                onClick = {
                    if (messageText.isNotBlank()) {
                        viewModel.sendMessage(messageText)
                        messageText = ""
                    }
                }
            ) {
                Icon(Icons.Default.Send, "Send")
            }
        }
    }
}
```

#### 3. Server-Sent Events (SSE)

**SSE Client:**
```kotlin
class SSEManager(
    private val client: OkHttpClient = OkHttpClient.Builder()
        .readTimeout(0, TimeUnit.SECONDS) // No timeout for SSE
        .build()
) {
    private val _events = MutableSharedFlow<ServerEvent>()
    val events: SharedFlow<ServerEvent> = _events.asSharedFlow()
    
    private var currentCall: Call? = null
    
    fun connect(url: String) {
        val request = Request.Builder()
            .url(url)
            .header("Accept", "text/event-stream")
            .build()
        
        currentCall = client.newCall(request)
        
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val response = currentCall?.execute()
                response?.body()?.byteStream()?.bufferedReader()?.use { reader ->
                    var eventType: String? = null
                    var data = StringBuilder()
                    
                    reader.lineSequence().forEach { line ->
                        when {
                            line.startsWith("event:") -> {
                                eventType = line.substringAfter("event:").trim()
                            }
                            line.startsWith("data:") -> {
                                data.append(line.substringAfter("data:").trim())
                            }
                            line.isBlank() -> {
                                // End of event
                                if (data.isNotEmpty()) {
                                    _events.emit(
                                        ServerEvent(
                                            type = eventType ?: "message",
                                            data = data.toString()
                                        )
                                    )
                                    data.clear()
                                    eventType = null
                                }
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e("SSE", "Error: ${e.message}")
                // Auto-reconnect
                delay(5000)
                connect(url)
            }
        }
    }
    
    fun disconnect() {
        currentCall?.cancel()
    }
}

data class ServerEvent(
    val type: String,
    val data: String
)
```

**Usage:**
```kotlin
class NotificationRepository(
    private val sseManager: SSEManager
) {
    fun connectToNotifications(userId: String) {
        sseManager.connect("https://api.example.com/notifications/stream/$userId")
    }
    
    fun observeNotifications(): Flow<Notification> {
        return sseManager.events
            .filter { it.type == "notification" }
            .map { event ->
                // Parse event data
                val json = JSONObject(event.data)
                Notification(
                    id = json.getString("id"),
                    title = json.getString("title"),
                    message = json.getString("message"),
                    timestamp = json.getLong("timestamp")
                )
            }
    }
    
    fun disconnect() {
        sseManager.disconnect()
    }
}
```

#### 4. Heartbeat & Reconnection

**Heartbeat Implementation:**
```kotlin
class WebSocketManager {
    private var heartbeatJob: Job? = null
    
    fun startHeartbeat() {
        heartbeatJob = CoroutineScope(Dispatchers.Default).launch {
            while (isActive) {
                try {
                    webSocket?.send("""{"type":"ping"}""")
                    delay(30_000) // Ping every 30 seconds
                } catch (e: Exception) {
                    Log.e("WebSocket", "Heartbeat failed: ${e.message}")
                    break
                }
            }
        }
    }
    
    fun stopHeartbeat() {
        heartbeatJob?.cancel()
    }
}
```

**Exponential Backoff Reconnection:**
```kotlin
class ReconnectionManager {
    private var reconnectAttempts = 0
    private val maxReconnectAttempts = 5
    private val baseDelay = 1000L // 1 second
    
    suspend fun attemptReconnect(connectAction: suspend () -> Unit) {
        while (reconnectAttempts < maxReconnectAttempts) {
            try {
                val delay = baseDelay * (2.0.pow(reconnectAttempts.toDouble())).toLong()
                Log.d("Reconnection", "Attempting reconnect in ${delay}ms")
                
                delay(delay)
                connectAction()
                
                // Success
                reconnectAttempts = 0
                break
            } catch (e: Exception) {
                reconnectAttempts++
                Log.e("Reconnection", "Attempt $reconnectAttempts failed: ${e.message}")
            }
        }
    }
    
    fun reset() {
        reconnectAttempts = 0
    }
}
```

#### 5. Message Queue for Offline Support

```kotlin
class MessageQueue(
    private val database: AppDatabase
) {
    suspend fun queueMessage(message: PendingMessage) {
        database.pendingMessageDao().insert(message)
    }
    
    suspend fun sendPendingMessages(webSocket: WebSocket) {
        val pending = database.pendingMessageDao().getAllPending()
        
        pending.forEach { message ->
            try {
                webSocket.send(message.content)
                database.pendingMessageDao().delete(message.id)
            } catch (e: Exception) {
                Log.e("MessageQueue", "Failed to send: ${e.message}")
            }
        }
    }
}
```

#### 6. Real-Time Use Cases

**Live Location Tracking:**
```kotlin
fun startLocationUpdates() {
    viewModelScope.launch {
        locationFlow.collect { location ->
            webSocketManager.send(
                """
                {
                    "type": "location_update",
                    "lat": ${location.latitude},
                    "lng": ${location.longitude}
                }
                """.trimIndent()
            )
        }
    }
}
```

**Live Typing Indicator:**
```kotlin
fun onTyping() {
    viewModelScope.launch {
        webSocketManager.send("""{"type":"typing","userId":"$userId"}""")
    }
}

fun onStopTyping() {
    viewModelScope.launch {
        webSocketManager.send("""{"type":"stop_typing","userId":"$userId"}""")
    }
}
```

**Live Collaborative Editing:**
```kotlin
fun sendTextChange(change: TextChange) {
    val json = JSONObject().apply {
        put("type", "text_change")
        put("position", change.position)
        put("text", change.text)
        put("operation", change.operation) // insert, delete
    }
    webSocketManager.send(json.toString())
}
```

#### 7. Best Practices
‚úÖ Implement heartbeat/ping-pong
‚úÖ Handle reconnection with exponential backoff
‚úÖ Queue messages when offline
‚úÖ Show connection status to users
‚úÖ Clean up connections in onCleared()
‚úÖ Handle binary messages if needed
‚úÖ Implement timeout handling
‚úÖ Test with poor network conditions
‚úÖ Secure connections (wss://)
‚úÖ Handle message ordering

#### 8. Hands-on Project
- Build real-time chat application
- Implement WebSocket connection
- Handle reconnection
- Queue offline messages
- Show connection status
- Heartbeat mechanism
- Live typing indicators
- Message delivery status

---

## **Project Akhir Fase 5: Social Media App**

### **Requirements:**
Bangun aplikasi social media dengan fitur:
- User authentication (JWT)
- News feed (infinite scroll)
- Create/edit/delete posts
- Like & comment system
- Real-time notifications
- Offline-first architecture
- Image upload
- User profiles

### **Technical Requirements:**

‚úÖ **Networking:**
- Retrofit untuk REST API
- Proper error handling
- Retry mechanism
- File upload (images)

‚úÖ **Authentication:**
- JWT token management
- Secure token storage
- Auto token refresh
- Logout functionality

‚úÖ **Offline-First:**
- Room database as cache
- Network-bound resource pattern
- Pending operations queue
- Background sync

‚úÖ **Real-Time:**
- WebSocket untuk notifications
- Live comment updates
- Online/offline status

‚úÖ **Image Loading:**
- Coil for image loading
- Caching strategy
- Placeholder & error handling

### **API Endpoints:**
```
POST /auth/login
POST /auth/register
POST /auth/refresh
GET /posts
GET /posts/:id
POST /posts
PUT /posts/:id
DELETE /posts/:id
POST /posts/:id/like
GET /posts/:id/comments
POST /posts/:id/comments
GET /users/:id
PUT /users/:id
POST /upload
WebSocket /ws/notifications
```

### **Architecture:**
- MVVM + Clean Architecture
- Repository pattern
- Use Cases for business logic
- Dependency Injection (Hilt)
- Kotlin Coroutines & Flow

### **Testing:**
- Unit tests untuk Repository
- Unit tests untuk ViewModel
- Integration tests
- Mock API responses

### **Deliverables:**
1. Fully functional app
2. Source code di GitHub
3. README dengan:
   - API documentation
   - Architecture diagram
   - Setup instructions
   - Screenshots/demo video
4. Test coverage report

### **Evaluation Criteria:**
- ‚úÖ Feature completeness (25%)
- ‚úÖ Offline-first implementation (20%)
- ‚úÖ Error handling (15%)
- ‚úÖ Code quality (15%)
- ‚úÖ Real-time features (15%)
- ‚úÖ Testing (10%)

---

**Selamat belajar Networking & API! üöÄ**