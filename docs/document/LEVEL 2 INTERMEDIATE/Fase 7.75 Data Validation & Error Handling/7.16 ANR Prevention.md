




## **7.15 ANR Prevention** (3 hari) ⭐⭐⭐

### **Teknologi Modern:**
- StrictMode
- Main thread detection
- WorkManager untuk background tasks
- Dispatchers yang tepat

### **Teknologi yang Ditinggalkan:**
- Blocking main thread
- Ignoring ANRs
- Long operations di onCreate

### **Sub-topik Detail:**

#### **1. Understanding ANR**

**ANR Causes:**
```kotlin
// ❌ BAD: Blocking main thread
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    // Network on main thread - causes ANR
    val data = URL("https://api.example.com").readText()
    
    // Heavy computation - causes ANR
    repeat(1_000_000) {
        complexCalculation()
    }
    
    // Database on main thread - causes ANR
    val users = database.userDao().getAllUsers()
}

// ✅ GOOD: Use coroutines
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    lifecycleScope.launch {
        val data = withContext(Dispatchers.IO) {
            URL("https://api.example.com").readText()
        }
    }
}
```

#### **2. StrictMode**

**Setup:**
```kotlin
class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()
        
        if (BuildConfig.DEBUG) {
            StrictMode.setThreadPolicy(
                StrictMode.ThreadPolicy.Builder()
                    .detectAll() // Detect all violations
                    .penaltyLog() // Log violations
                    .penaltyDeath() // Crash on violation (untuk testing)
                    .build()
            )
            
            StrictMode.setVmPolicy(
                StrictMode.VmPolicy.Builder()
                    .detectAll()
                    .penaltyLog()
                    .build()
            )
        }
    }
}
```

**Custom Policy:**
```kotlin
StrictMode.setThreadPolicy(
    StrictMode.ThreadPolicy.Builder()
        .detectNetwork() // Detect network calls
        .detectDiskReads() // Detect disk reads
        .detectDiskWrites() // Detect disk writes
        .detectCustomSlowCalls() // Detect custom slow calls
        .penaltyLog()
        .penaltyFlashScreen() // Flash screen on violation
        .build()
)
```

#### **3. Main Thread Detection**

**Check Current Thread:**
```kotlin
fun ensureBackgroundThread() {
    check(Looper.myLooper() != Looper.getMainLooper()) {
        "This should not be called on main thread"
    }
}

fun ensureMainThread() {
    check(Looper.myLooper() == Looper.getMainLooper()) {
        "This should be called on main thread"
    }
}

// Usage
suspend fun saveData(data: Data) = withContext(Dispatchers.IO) {
    ensureBackgroundThread()
    database.insert(data)
}
```

**Annotation-based:**
```kotlin
@WorkerThread
suspend fun fetchFromDatabase(): List<User> {
    return database.userDao().getAllUsers()
}

@MainThread
fun updateUI(data: Data) {
    textView.text = data.toString()
}

@UiThread
fun showDialog() {
    AlertDialog.Builder(this)
        .setMessage("Hello")
        .show()
}
```

#### **4. Proper Dispatcher Usage**

**Dispatcher Guide:**
```kotlin
// UI updates
lifecycleScope.launch(Dispatchers.Main) {
    textView.text = "Hello"
}

// Network/Database
lifecycleScope.launch(Dispatchers.IO) {
    val data = apiService.getData()
    database.insert(data)
}

// Heavy computation
lifecycleScope.launch(Dispatchers.Default) {
    val result = complexCalculation()
}

// Immediate execution
lifecycleScope.launch(Dispatchers.Main.immediate) {
    // Already on main thread, execute immediately
}
```

**Switching Dispatchers:**
```kotlin
suspend fun loadAndDisplay() {
    // Start on Main
    showLoading()
    
    // Switch to IO for network
    val data = withContext(Dispatchers.IO) {
        apiService.getData()
    }
    
    // Switch to Default for processing
    val processed = withContext(Dispatchers.Default) {
        processData(data)
    }
    
    // Back to Main for UI
    hideLoading()
    displayData(processed)
}
```

#### **5. Background Work**

**WorkManager:**
```kotlin
class DataSyncWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        return try {
            syncData()
            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }
    
    private suspend fun syncData() {
        withContext(Dispatchers.IO) {
            val data = apiService.getData()
            database.insert(data)
        }
    }
}

// Schedule work
val syncWork = PeriodicWorkRequestBuilder<DataSyncWorker>(
    repeatInterval = 1,
    repeatIntervalTimeUnit = TimeUnit.HOURS
).build()

WorkManager.getInstance(context).enqueue(syncWork)
```

**Foreground Service:**
```kotlin
class DownloadService : Service() {
    
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        createNotificationChannel()
        
        val notification = NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Downloading")
            .setSmallIcon(R.drawable.ic_download)
            .build()
        
        startForeground(1, notification)
        
        scope.launch {
            downloadFiles()
            stopSelf()
        }
        
        return START_NOT_STICKY
    }
    
    private suspend fun downloadFiles() {
        // Long running task
    }
    
    override fun onBind(intent: Intent?): IBinder? = null
    
    override fun onDestroy() {
        super.onDestroy()
        scope.cancel()
    }
}
```

#### **6. Optimizing Startup**

**Lazy Initialization:**
```kotlin
class MyApp : Application() {
    
    // Lazy initialization
    val database: AppDatabase by lazy {
        Room.databaseBuilder(
            this,
            AppDatabase::class.java,
            "app_db"
        ).build()
    }
    
    override fun onCreate() {
        super.onCreate()
        
        // Start initialization in background
        lifecycleScope.launch(Dispatchers.Default) {
            initializeHeavyLibraries()
        }
    }
    
    private fun initializeHeavyLibraries() {
        // Initialize analytics, crash reporting, etc.
    }
}
```

**App Startup Library:**
```kotlin
dependencies {
    implementation("androidx.startup:startup-runtime:1.1.1")
}

class TimberInitializer : Initializer<Unit> {
    override fun create(context: Context) {
        if (BuildConfig.DEBUG) {
            Timber.plant(Timber.DebugTree())
        }
    }
    
    override fun dependencies(): List<Class<out Initializer<*>>> = emptyList()
}

// AndroidManifest.xml
<provider
    android:name="androidx.startup.InitializationProvider"
    android:authorities="${applicationId}.androidx-startup">
    <meta-data
        android:name="com.example.TimberInitializer"
        android:value="androidx.startup" />
</provider>
```

#### **7. Monitoring ANR**

**ANR Detection:**
```kotlin
class ANRWatchdog : Thread() {
    private val uiHandler = Handler(Looper.getMainLooper())
    private val timeout = 5000L // 5 seconds
    
    @Volatile
    private var tick = 0L
    
    @Volatile
    private var reported = false
    
    override fun run() {
        while (!isInterrupted) {
            val lastTick = tick
            val start = System.currentTimeMillis()
            
            // Post to main thread
            uiHandler.post { tick = System.currentTimeMillis() }
            
            // Wait
            Thread.sleep(timeout)
            
            // Check if main thread responded
            if (tick == lastTick && !reported) {
                reported = true
                val duration = System.currentTimeMillis() - start
                reportANR(duration)
            }
        }
    }
    
    private fun reportANR(duration: Long) {
        Timber.e("ANR detected! Main thread blocked for ${duration}ms")
        FirebaseCrashlytics.getInstance().log("ANR: ${duration}ms")
    }
}
```

#### **8. Best Practices**
✅ Never block main thread
✅ Use coroutines dengan dispatcher yang tepat
✅ Enable StrictMode di debug builds
✅ Use WorkManager untuk background tasks
✅ Optimize app startup
✅ Monitor ANR rate
✅ Keep onCreate() fast
✅ Use lazy initialization
✅ Test on low-end devices

---

## **Hands-on Project: News/Weather App dengan Error Handling**

### **Requirements:**
1. **Input Validation:**
   - Search input dengan validation
   - Handle empty search
   - Show validation errors

2. **Error States:**
   - Loading shimmer
   - Error screen dengan retry
   - Empty state
   - Success state

3. **Logging:**
   - Timber setup
   - Network logging
   - Error logging
   - Crashlytics integration

4. **Crash Handling:**
   - Global exception handler
   - Custom crash screen
   - Crash reporting

5. **Coroutine Exception:**
   - Try-catch di coroutines
   - CoroutineExceptionHandler
   - supervisorScope untuk multiple API calls

6. **ANR Prevention:**
   - StrictMode setup
   - Proper dispatchers
   - Background work dengan WorkManager
   - No blocking operations on main thread

### **Architecture:**
```
app/
├── data/
│   ├── model/
│   ├── repository/
│   └── remote/
├── ui/
│   ├── screens/
│   │   ├── home/
│   │   ├── error/
│   │   └── crash/
│   └── components/
├── util/
│   ├── logging/
│   ├── validation/
│   └── exception/
└── MyApp.kt
```

---