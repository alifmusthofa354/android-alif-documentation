# üé® Panduan Lengkap: Design Patterns di Android

## üöÄ Pengantar: Arsitektur yang Telah Teruji Waktu

Bayangkan kamu adalah seorang arsitek digital üèóÔ∏è:
- **Design Patterns** seperti rencana bangunan standar yang telah teruji
- **Solusi teruji** untuk masalah-masalah umum dalam pengembangan software
- **Komunikasi efisien** antar developer menggunakan istilah yang sama

Dengan menguasai Design Patterns, kamu bisa menulis kode yang lebih bersih, fleksibel, dan mudah dipelihara!

## üìö Daftar Isi Pembelajaran
1. [üåü Pengenalan Design Patterns](#1Ô∏è‚É£-pengenalan-design-patterns-üåü)
2. [üèóÔ∏è Creational Patterns](#2Ô∏è‚É£-creational-patterns-üèóÔ∏è)
3. [üîó Structural Patterns](#3Ô∏è‚É£-structural-patterns-üîó)
4. [üîÑ Behavioral Patterns](#4Ô∏è‚É£-behavioral-patterns-üîÑ)
5. [üì± Android-Specific Patterns](#5Ô∏è‚É£-android-specific-patterns-üì±)
6. [‚ú® Pattern Combinations](#6Ô∏è‚É£-pattern-combinations-‚ú®)
7. [üéØ When to Use Patterns](#7Ô∏è‚É£-when-to-use-patterns-üéØ)
8. [‚ö†Ô∏è Anti-Patterns](#8Ô∏è‚É£-anti-patterns-‚ö†Ô∏è)
9. [üèóÔ∏è Patterns dalam Real Android Apps](#9Ô∏è‚É£-patterns-dalam-real-android-apps-üèóÔ∏è)
10. [üß™ Testing dengan Patterns](#1Ô∏è‚É£0Ô∏è‚É£-testing-dengan-patterns-üß™)
11. [üî® Hands-on Exercises](#1Ô∏è‚É£1Ô∏è‚É£-hands-on-exercises-üî®)
12. [üìö Resources & Further Learning](#1Ô∏è‚É£2Ô∏è‚É£-resources--further-learning-üìö)
13. [üéØ Kesimpulan](#üéØ-kesimpulan)

---

## 1Ô∏è‚É£ Pengenalan Design Patterns üåü

### Konsep Dasar
Design Patterns seperti resep masakan üç≥ - solusi teruji untuk masalah-masalah umum dalam pengembangan software!

### Apa itu Design Patterns:
**Design Patterns** adalah solusi umum yang dapat digunakan kembali untuk masalah-masalah umum dalam desain perangkat lunak. Mereka bukan kode siap pakai, tetapi template bagaimana menyelesaikan masalah dalam berbagai situasi.

### Gang of Four (GoF) Patterns:
Design Patterns pertama kali dipopulerkan oleh **Erich Gamma, Richard Helm, Ralph Johnson, dan John Vlissides** dalam buku mereka "Design Patterns: Elements of Reusable Object-Oriented Software" (1994), dikenal juga sebagai **Gang of Four (GoF)**.

### Klasifikasi Design Patterns:
```
Design Patterns
‚îú‚îÄ‚îÄ Creational Patterns (Pembuatan objek)
‚îÇ   ‚îú‚îÄ‚îÄ Factory
‚îÇ   ‚îú‚îÄ‚îÄ Builder
‚îÇ   ‚îú‚îÄ‚îÄ Singleton
‚îÇ   ‚îî‚îÄ‚îÄ Abstract Factory
‚îú‚îÄ‚îÄ Structural Patterns (Struktur objek)
‚îÇ   ‚îú‚îÄ‚îÄ Adapter
‚îÇ   ‚îú‚îÄ‚îÄ Decorator
‚îÇ   ‚îú‚îÄ‚îÄ Facade
‚îÇ   ‚îî‚îÄ‚îÄ Composite
‚îî‚îÄ‚îÄ Behavioral Patterns (Interaksi antar objek)
    ‚îú‚îÄ‚îÄ Observer
    ‚îú‚îÄ‚îÄ Strategy
    ‚îú‚îÄ‚îÄ Command
    ‚îî‚îÄ‚îÄ State
```

### Patterns di Android:
Kotlin dan Android menggunakan banyak design patterns, beberapa di antaranya:
- **LiveData/Flow** ‚Üí Observer Pattern
- **ViewModel** ‚Üí Model-View-ViewModel Pattern
- **RecyclerView.Adapter** ‚Üí Adapter Pattern
- **Dagger/Hilt** ‚Üí Dependency Injection Pattern
- **Retrofit** ‚Üí Builder Pattern

### Kapan Menggunakan Patterns:
‚úÖ Gunakan ketika:
- Memecahkan masalah yang umum
- Meningkatkan maintainability
- Meningkatkan komunikasi antar developer
- Memastikan kode lebih fleksibel

‚ùå Jangan gunakan ketika:
- Over-engineering masalah sederhana
- Menambah kompleksitas tanpa manfaat
- Tim tidak memahami pattern tersebut
- YAGNI (You Aren't Gonna Need It)

### Contoh Sederhana:

**Sebelum: Tanpa Pattern**
```kotlin
class UserManager {
    fun createUser(name: String, email: String): User {
        // Logic pembuatan user
        return User(name = name, email = email)
    }
    
    fun createAdminUser(name: String, email: String): User {
        // Logic pembuatan admin user
        return User(name = name, email = email, role = "admin")
    }
    
    fun createPremiumUser(name: String, email: String): User {
        // Logic pembuatan premium user
        return User(name = name, email = email, isPremium = true)
    }
}
```

**Sesudah: Dengan Factory Pattern**
```kotlin
interface UserFactory {
    fun createUser(name: String, email: String): User
}

class RegularUserFactory : UserFactory {
    override fun createUser(name: String, email: String): User {
        return User(name = name, email = email)
    }
}

class AdminUserFactory : UserFactory {
    override fun createUser(name: String, email: String): User {
        return User(name = name, email = email, role = "admin")
    }
}

class PremiumUserFactory : UserFactory {
    override fun createUser(name: String, email: String): User {
        return User(name = name, email = email, isPremium = true)
    }
}
```

### üéì Penjelasan Konsep:
**Design Patterns seperti Panduan Arsitektur:**
- **Sudah teruji** secara luas oleh komunitas developer
- **Meningkatkan komunikasi** karena menggunakan istilah umum
- **Membantu pemecahan masalah** secara sistematis
- **Menyediakan template** untuk solusi yang baik

---

## 2Ô∏è‚É£ Creational Patterns üèóÔ∏è

### Konsep Dasar
Creational Patterns seperti pabrikasi üè≠ - mengatur cara objek dibuat agar efisien dan fleksibel!

### 1. Factory Pattern:

**Konsep:**
Factory Pattern menyediakan interface untuk membuat objek, tetapi memungkinkan subclass memutuskan kelas mana yang akan diinstansiasi.

**Problematika:**
- Kompleksitas pembuatan objek
- Logika pembuatan yang bervariasi
- Ketergantungan langsung pada implementasi konkret

**Implementasi:**

**domain/factory/UserFactory.kt**
```kotlin
package com.example.designpatterns.factory

/**
 * Interface untuk semua factory user
 */
interface UserFactory {
    fun createUser(userData: UserData): User
}

/**
 * Factory untuk membuat user biasa
 */
class RegularUserFactory : UserFactory {
    override fun createUser(userData: UserData): User {
        return User(
            id = generateId(),
            name = userData.name,
            email = userData.email,
            role = UserRole.USER,
            isPremium = false,
            createdAt = System.currentTimeMillis()
        )
    }
    
    private fun generateId(): String = "user_${System.currentTimeMillis()}"
}

/**
 * Factory untuk membuat admin user
 */
class AdminUserFactory : UserFactory {
    override fun createUser(userData: UserData): User {
        return User(
            id = generateId(),
            name = userData.name,
            email = userData.email,
            role = UserRole.ADMIN,
            isPremium = true, // Admin otomatis premium
            permissions = getAdminPermissions(),
            createdAt = System.currentTimeMillis()
        )
    }
    
    private fun generateId(): String = "admin_${System.currentTimeMillis()}"
    private fun getAdminPermissions(): List<String> = listOf("all_access", "manage_users")
}

/**
 * Factory untuk membuat premium user
 */
class PremiumUserFactory : UserFactory {
    override fun createUser(userData: UserData): User {
        return User(
            id = generateId(),
            name = userData.name,
            email = userData.email,
            role = UserRole.USER,
            isPremium = true,
            premiumSince = System.currentTimeMillis(),
            premiumFeatures = getPremiumFeatures(),
            createdAt = System.currentTimeMillis()
        )
    }
    
    private fun generateId(): String = "premium_${System.currentTimeMillis()}"
    private fun getPremiumFeatures(): List<String> = listOf("unlimited_access", "priority_support")
}

/**
 * Factory yang bisa mengembalikan berbagai jenis user berdasarkan tipe
 */
class FlexibleUserFactory : UserFactory {
    override fun createUser(userData: UserData): User {
        return when (userData.userType) {
            UserType.NORMAL -> RegularUserFactory().createUser(userData)
            UserType.ADMIN -> AdminUserFactory().createUser(userData)
            UserType.PREMIUM -> PremiumUserFactory().createUser(userData)
        }
    }
}

/**
 * Enum untuk jenis user
 */
enum class UserType {
    NORMAL, ADMIN, PREMIUM
}

/**
 * Data class untuk input user
 */
data class UserData(
    val name: String,
    val email: String,
    val userType: UserType = UserType.NORMAL
)

/**
 * Enum untuk role user
 */
enum class UserRole {
    USER, ADMIN, MODERATOR
}

/**
 * Data class untuk user
 */
data class User(
    val id: String,
    val name: String,
    val email: String,
    val role: UserRole,
    val isPremium: Boolean,
    val permissions: List<String> = emptyList(),
    val premiumSince: Long? = null,
    val premiumFeatures: List<String> = emptyList(),
    val createdAt: Long
)
```

**Use Cases di Android:**
- **ViewModelFactory**: Untuk membuat ViewModel dengan parameter
- **Repository creation**: Berbagai implementasi repository
- **Service creation**: Berbagai implementasi service berdasarkan konfigurasi

**contoh/presentation/factory/ViewModelFactory.kt**
```kotlin
package com.example.designpatterns.factory

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.example.designpatterns.domain.usecase.GetUserUseCase
import com.example.designpatterns.domain.usecase.CreateUserUseCase
import com.example.designpatterns.presentation.viewmodel.UserViewModel

/**
 * Factory untuk membuat ViewModels
 */
class ViewModelFactory(
    private val getUserUseCase: GetUserUseCase,
    private val createUserUseCase: CreateUserUseCase
) : ViewModelProvider.Factory {
    
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        return when {
            modelClass.isAssignableFrom(UserViewModel::class.java) -> {
                UserViewModel(getUserUseCase, createUserUseCase) as T
            }
            else -> throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
        }
    }
}
```

### 2. Builder Pattern:

**Konsep:**
Builder Pattern memungkinkan pembuatan objek kompleks secara bertahap dan menghindari constructor dengan banyak parameter.

**Problematika:**
- Constructor dengan banyak parameter
- Banyak overloading method
- Objek bisa dalam state yang tidak konsisten

**Implementasi:**

**domain/builder/UserBuilder.kt**
```kotlin
package com.example.designpatterns.builder

/**
 * Implementasi Builder Pattern untuk User
 * Menghindari constructor dengan banyak parameter
 */
class User private constructor(
    val id: String,
    val name: String,
    val email: String,
    val age: Int? = null,
    val phone: String? = null,
    val address: String? = null,
    val role: String? = null,
    val isPremium: Boolean = false,
    val preferences: Map<String, String> = emptyMap(),
    val permissions: List<String> = emptyList(),
    val createdAt: Long = System.currentTimeMillis()
) {
    
    class Builder {
        private var id: String = "user_${System.currentTimeMillis()}"
        private var name: String = ""
        private var email: String = ""
        private var age: Int? = null
        private var phone: String? = null
        private var address: String? = null
        private var role: String? = null
        private var isPremium: Boolean = false
        private var preferences: Map<String, String> = emptyMap()
        private var permissions: List<String> = emptyList()
        private var createdAt: Long = System.currentTimeMillis()

        fun id(id: String) = apply { this.id = id }
        fun name(name: String) = apply { this.name = name }
        fun email(email: String) = apply { this.email = email }
        fun age(age: Int) = apply { this.age = age }
        fun phone(phone: String) = apply { this.phone = phone }
        fun address(address: String) = apply { this.address = address }
        fun role(role: String) = apply { this.role = role }
        fun premium(isPremium: Boolean) = apply { this.isPremium = isPremium }
        fun preferences(preferences: Map<String, String>) = apply { this.preferences = preferences }
        fun permissions(permissions: List<String>) = apply { this.permissions = permissions }
        fun createdAt(timestamp: Long) = apply { this.createdAt = timestamp }

        fun build(): User {
            // Validasi sebelum build
            if (name.isBlank()) {
                throw IllegalArgumentException("Name cannot be blank")
            }
            if (email.isBlank() || !email.contains("@")) {
                throw IllegalArgumentException("Invalid email")
            }
            
            return User(
                id = id,
                name = name,
                email = email,
                age = age,
                phone = phone,
                address = address,
                role = role,
                isPremium = isPremium,
                preferences = preferences,
                permissions = permissions,
                createdAt = createdAt
            )
        }
    }
}

/**
 * Contoh penggunaan Builder Pattern
 */
fun demonstrateUserBuilder() {
    val user = User.Builder()
        .name("John Doe")
        .email("john@example.com")
        .age(30)
        .phone("+1234567890")
        .address("123 Main St")
        .premium(true)
        .preferences(mapOf("theme" to "dark", "language" to "en"))
        .permissions(listOf("read", "write"))
        .build()
    
    println("Created user: $user")
}
```

**Use Cases di Android:**
- **Retrofit Builder**: Untuk konfigurasi API client
- **Room Database Builder**: Untuk konfigurasi database
- **AlertDialog Builder**: Untuk konfigurasi dialog
- **Complex configuration objects**: Objek konfigurasi kompleks

**contoh/network/RetrofitClient.kt**
```kotlin
package com.example.designpatterns.network

import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import java.util.concurrent.TimeUnit

/**
 * Contoh Retrofit Client dengan Builder Pattern
 */
class RetrofitClient private constructor(
    private val baseUrl: String,
    private val timeout: Long,
    private val isDebug: Boolean
) {
    
    private val retrofit: Retrofit by lazy {
        val httpClient = OkHttpClient.Builder()
            .connectTimeout(timeout, TimeUnit.SECONDS)
            .readTimeout(timeout, TimeUnit.SECONDS)
            .writeTimeout(timeout, TimeUnit.SECONDS)
        
        if (isDebug) {
            val logging = HttpLoggingInterceptor().apply {
                level = HttpLoggingInterceptor.Level.BODY
            }
            httpClient.addInterceptor(logging)
        }
        
        Retrofit.Builder()
            .baseUrl(baseUrl)
            .client(httpClient.build())
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    fun <T> create(serviceClass: Class<T>): T {
        return retrofit.create(serviceClass)
    }
    
    /**
     * Inner Builder class
     */
    class Builder {
        private var baseUrl: String = ""
        private var timeout: Long = 30
        private var isDebug: Boolean = false
        
        fun baseUrl(url: String) = apply { this.baseUrl = url }
        fun timeout(seconds: Long) = apply { this.timeout = seconds }
        fun debug(enabled: Boolean) = apply { this.isDebug = enabled }
        
        fun build(): RetrofitClient {
            if (baseUrl.isBlank()) {
                throw IllegalArgumentException("Base URL cannot be empty")
            }
            return RetrofitClient(baseUrl, timeout, isDebug)
        }
    }
}

/**
 * Penggunaan:
 * val client = RetrofitClient.Builder()
 *     .baseUrl("https://api.example.com/")
 *     .timeout(60)
 *     .debug(BuildConfig.DEBUG)
 *     .build()
 */
```

### 3. Singleton Pattern:

**Konsep:**
Singleton Pattern memastikan bahwa sebuah kelas hanya memiliki satu instance dan menyediakan akses global ke instance tersebut.

**Problematika:**
- Butuh satu instance global
- Memastikan instance tunggal
- Pengelolaan sumber daya

**Implementasi:**

**data/singleton/DatabaseHelper.kt**
```kotlin
package com.example.designpatterns.singleton

import android.content.Context
import androidx.room.Room
import com.example.designpatterns.data.database.AppDatabase

/**
 * Kotlin way untuk Singleton Pattern
 * Lebih aman dan elegan dibanding Java approach
 */
object DatabaseHelper {
    
    private var instance: AppDatabase? = null
    
    fun getDatabase(context: Context): AppDatabase {
        return instance ?: synchronized(this) {
            val newInstance = Room.databaseBuilder(
                context.applicationContext,
                AppDatabase::class.java,
                "app_database"
            ).build()
            instance = newInstance
            newInstance
        }
    }
}

/**
 * Contoh lain dengan parameter
 */
class SharedPreferencesManager private constructor(
    private val context: Context
) {
    
    private val sharedPreferences = context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE)
    
    companion object {
        @Volatile
        private var instance: SharedPreferencesManager? = null
        
        fun getInstance(context: Context): SharedPreferencesManager {
            return instance ?: synchronized(this) {
                instance ?: SharedPreferencesManager(context.applicationContext).also { instance = it }
            }
        }
    }
    
    fun saveString(key: String, value: String) {
        sharedPreferences.edit().putString(key, value).apply()
    }
    
    fun getString(key: String, defaultValue: String = ""): String {
        return sharedPreferences.getString(key, defaultValue) ?: defaultValue
    }
    
    fun saveBoolean(key: String, value: Boolean) {
        sharedPreferences.edit().putBoolean(key, value).apply()
    }
    
    fun getBoolean(key: String, defaultValue: Boolean = false): Boolean {
        return sharedPreferences.getBoolean(key, defaultValue)
    }
}
```

**Caveats di Android:**
- **Memory leaks**: Dengan Context yang tidak di-release
- **Testing difficulties**: Karena state global
- **Hidden dependencies**: Membuat kode sulit diuji
- **Prefer DI over Singleton**: Gunakan Dependency Injection

**contoh/dependencyinjection/DatabaseModule.kt**
```kotlin
package com.example.designpatterns.di

import android.content.Context
import androidx.room.Room
import com.example.designpatterns.data.database.AppDatabase
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

/**
 * Lebih baik menggunakan Dependency Injection dibanding Singleton
 */
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "app_database"
        ).build()
    }
    
    @Provides
    fun provideUserDao(database: AppDatabase) = database.userDao()
}
```

### üéì Penjelasan Konsep:
**Creational Patterns seperti Pabrikasi:**
- **Factory**: Seperti mesin yang bisa membuat berbagai jenis produk
- **Builder**: Seperti asisten yang membantu merakit sesuatu secara bertahap
- **Singleton**: Seperti direktur perusahaan - hanya ada satu

**Manfaat Creational Patterns:**
- **Fleksibilitas**: Bisa mengganti implementasi
- **Maintainability**: Kode lebih terorganisir
- **Testing**: Lebih mudah diuji dengan mock
- **Reusability**: Kode bisa digunakan di banyak tempat

---

## 3Ô∏è‚É£ Structural Patterns üîó

### Konsep Dasar
Structural Patterns seperti arsitektur gedung üè¢ - mengatur struktur objek agar saling bekerja sama dengan baik!

### 1. Adapter Pattern:

**Konsep:**
Adapter Pattern mengizinkan kelas-kelas dengan interface yang tidak kompatibel untuk bekerja sama, seperti colokan listrik adapter.

**Problematika:**
- Interface yang tidak kompatibel
- Integrasi dengan sistem lama
- Pustaka pihak ketiga dengan interface berbeda

**Implementasi:**

**domain/adapter/PlayerAdapter.kt**
```kotlin
package com.example.designpatterns.adapter

/**
 * Interface untuk media player standar
 */
interface MediaPlayer {
    fun play(audioType: String, fileName: String)
}

/**
 * Interface untuk media player lanjutan
 */
interface AdvancedMediaPlayer {
    fun playVlc(fileName: String)
    fun playMp4(fileName: String)
}

/**
 * Implementasi untuk media player lanjutan
 */
class VlcPlayer : AdvancedMediaPlayer {
    override fun playVlc(fileName: String) {
        println("Playing vlc file. Name: $fileName")
    }
    
    override fun playMp4(fileName: String) {
        // Vlc player tidak bisa memainkan MP4
        println("VLC player cannot play MP4: $fileName")
    }
}

class Mp4Player : AdvancedMediaPlayer {
    override fun playVlc(fileName: String) {
        // MP4 player tidak bisa memainkan VLC
        println("MP4 player cannot play VLC: $fileName")
    }
    
    override fun playMp4(fileName: String) {
        println("Playing mp4 file. Name: $fileName")
    }
}

/**
 * Adapter untuk menghubungkan interface yang tidak kompatibel
 */
class MediaAdapter(type: String) : MediaPlayer {
    private val advancedMusicPlayer: AdvancedMediaPlayer = when (type.lowercase()) {
        "vlc" -> VlcPlayer()
        "mp4" -> Mp4Player()
        else -> throw IllegalArgumentException("Unsupported media type: $type")
    }
    
    override fun play(audioType: String, fileName: String) {
        when (audioType.lowercase()) {
            "vlc" -> advancedMusicPlayer.playVlc(fileName)
            "mp4" -> advancedMusicPlayer.playMp4(fileName)
        }
    }
}

/**
 * Player utama yang bisa menggunakan semua format
 */
class AudioPlayer : MediaPlayer {
    override fun play(audioType: String, fileName: String) {
        when (audioType.lowercase()) {
            "mp3" -> println("Playing mp3 file. Name: $fileName")
            "vlc", "mp4" -> {
                val mediaAdapter = MediaAdapter(audioType)
                mediaAdapter.play(audioType, fileName)
            }
            else -> println("Invalid media. $audioType format not supported")
        }
    }
}
```

**Use Cases di Android:**
- **RecyclerView.Adapter**: Menghubungkan data dengan UI
- **Wrapping legacy code**: Menggunakan kode lama dengan interface baru
- **Third-party library integration**: Menggunakan library dengan interface berbeda

**presentation/adapter/UserAdapter.kt**
```kotlin
package com.example.designpatterns.adapter

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.example.designpatterns.R
import com.example.designpatterns.domain.model.User

/**
 * RecyclerView.Adapter sebagai contoh Adapter Pattern
 */
class UserAdapter(
    private val users: List<User>,
    private val onItemClick: (User) -> Unit
) : RecyclerView.Adapter<UserAdapter.ViewHolder>() {
    
    inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        private val nameText: TextView = view.findViewById(R.id.nameText)
        private val emailText: TextView = view.findViewById(R.id.emailText)
        
        fun bind(user: User) {
            nameText.text = user.name
            emailText.text = user.email
            
            itemView.setOnClickListener {
                onItemClick(user)
            }
        }
    }
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_user, parent, false)
        return ViewHolder(view)
    }
    
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(users[position])
    }
    
    override fun getItemCount(): Int = users.size
}
```

### 2. Decorator Pattern:

**Konsep:**
Decorator Pattern memungkinkan menambahkan fungsi tambahan ke objek tanpa memodifikasi struktur kelasnya.

**Problematika:**
- Inheritance yang terlalu dalam
- Kebutuhan untuk menambahkan fungsi secara dinamis
- Kombinasi fungsi yang kompleks

**Implementasi:**

**domain/decorator/CoffeeDecorator.kt**
```kotlin
package com.example.designpatterns.decorator

/**
 * Interface untuk komponen dasar
 */
interface Coffee {
    fun getCost(): Double
    fun getIngredients(): String
}

/**
 * Implementasi dasar
 */
class SimpleCoffee : Coffee {
    override fun getCost(): Double = 5.0
    override fun getIngredients(): String = "Coffee"
}

/**
 * Abstract decorator
 */
abstract class CoffeeDecorator(protected val decoratedCoffee: Coffee) : Coffee {
    override fun getCost(): Double = decoratedCoffee.getCost()
    override fun getIngredients(): String = decoratedCoffee.getIngredients()
}

/**
 * Decorator untuk tambahan susu
 */
class MilkDecorator(decoratedCoffee: Coffee) : CoffeeDecorator(decoratedCoffee) {
    override fun getCost(): Double = super.getCost() + 1.5
    override fun getIngredients(): String = "${super.getIngredients()}, Milk"
}

/**
 * Decorator untuk tambahan gula
 */
class SugarDecorator(decoratedCoffee: Coffee) : CoffeeDecorator(decoratedCoffee) {
    override fun getCost(): Double = super.getCost() + 0.5
    override fun getIngredients(): String = "${super.getIngredients()}, Sugar"
}

/**
 * Decorator untuk tambahan krim
 */
class CreamDecorator(decoratedCoffee: Coffee) : CoffeeDecorator(decoratedCoffee) {
    override fun getCost(): Double = super.getCost() + 2.0
    override fun getIngredients(): String = "${super.getIngredients()}, Cream"
}

/**
 * Contoh penggunaan
 */
fun demonstrateCoffeeDecorators() {
    var coffee: Coffee = SimpleCoffee()
    println("Base coffee: ${coffee.getIngredients()}, Cost: $${coffee.getCost()}")
    
    coffee = MilkDecorator(coffee)
    println("With milk: ${coffee.getIngredients()}, Cost: $${coffee.getCost()}")
    
    coffee = SugarDecorator(coffee)
    println("With sugar: ${coffee.getIngredients()}, Cost: $${coffee.getCost()}")
    
    coffee = CreamDecorator(coffee)
    println("With cream: ${coffee.getIngredients()}, Cost: $${coffee.getCost()}")
}
```

**Use Cases di Android:**
- **Network layer**: Menambahkan caching, logging, retry
- **UI layer**: Menambahkan efek, animasi
- **Data layer**: Menambahkan transformasi data

**data/decorator/NetworkDecorator.kt**
```kotlin
package com.example.designpatterns.decorator

import com.example.designpatterns.domain.model.ApiResult

/**
 * Interface untuk network service dasar
 */
interface NetworkService {
    suspend fun fetchData(url: String): ApiResult<String>
}

/**
 * Implementasi dasar
 */
class BaseNetworkService : NetworkService {
    override suspend fun fetchData(url: String): ApiResult<String> {
        // Simulasi network call
        return try {
            // Simulasi response
            ApiResult.Success("Data from $url")
        } catch (e: Exception) {
            ApiResult.Error(e.message ?: "Unknown error")
        }
    }
}

/**
 * Decorator untuk logging
 */
class LoggingDecorator(
    private val networkService: NetworkService
) : NetworkService {
    override suspend fun fetchData(url: String): ApiResult<String> {
        println("Fetching data from: $url")
        val result = networkService.fetchData(url)
        println("Result: $result")
        return result
    }
}

/**
 * Decorator untuk caching
 */
class CachingDecorator(
    private val networkService: NetworkService,
    private val cache: MutableMap<String, String> = mutableMapOf()
) : NetworkService {
    override suspend fun fetchData(url: String): ApiResult<String> {
        // Cek cache dulu
        val cached = cache[url]
        if (cached != null) {
            println("Cache hit for: $url")
            return ApiResult.Success(cached)
        }
        
        // Jika tidak ada di cache, fetch dari network
        val result = networkService.fetchData(url)
        
        // Simpan ke cache jika sukses
        if (result is ApiResult.Success) {
            cache[url] = result.data
        }
        
        return result
    }
}

/**
 * Decorator untuk retry
 */
class RetryDecorator(
    private val networkService: NetworkService,
    private val maxRetries: Int = 3
) : NetworkService {
    override suspend fun fetchData(url: String): ApiResult<String> {
        var lastError: String? = null
        
        for (attempt in 1..maxRetries) {
            val result = networkService.fetchData(url)
            if (result is ApiResult.Success) {
                return result
            } else {
                lastError = result.message
                if (attempt < maxRetries) {
                    kotlinx.coroutines.delay(1000 * attempt) // Exponential backoff
                }
            }
        }
        
        return ApiResult.Error("Failed after $maxRetries attempts: $lastError")
    }
}

/**
 * Gabungan semua decorator
 */
fun createNetworkService(): NetworkService {
    val baseService = BaseNetworkService()
    return RetryDecorator(
        CachingDecorator(
            LoggingDecorator(baseService)
        )
    )
}
```

### 3. Facade Pattern:

**Konsep:**
Facade Pattern menyediakan interface sederhana untuk sistem kompleks yang terdiri dari banyak subsistem.

**Problematika:**
- Sistem yang terlalu kompleks
- Interface yang terlalu banyak
- Ketergantungan yang rumit

**Implementasi:**

**domain/facade/MediaPlayerFacade.kt**
```kotlin
package com.example.designpatterns.facade

/**
 * Subsistem 1: Video Decoder
 */
class VideoDecoder {
    fun decodeVideo(videoFile: String): String {
        println("Decoding video: $videoFile")
        return "decoded_video_data"
    }
}

/**
 * Subsistem 2: Audio Decoder
 */
class AudioDecoder {
    fun decodeAudio(audioFile: String): String {
        println("Decoding audio: $audioFile")
        return "decoded_audio_data"
    }
}

/**
 * Subsistem 3: Video Renderer
 */
class VideoRenderer {
    fun renderVideo(videoData: String) {
        println("Rendering video: $videoData")
    }
}

/**
 * Subsistem 4: Audio Renderer
 */
class AudioRenderer {
    fun renderAudio(audioData: String) {
        println("Rendering audio: $audioData")
    }
}

/**
 * Subsistem 5: Media Player
 */
class MediaProcessor {
    private val videoDecoder = VideoDecoder()
    private val audioDecoder = AudioDecoder()
    private val videoRenderer = VideoRenderer()
    private val audioRenderer = AudioRenderer()
    
    /**
     * Facade method yang menyederhanakan proses kompleks
     */
    fun playMedia(videoFile: String, audioFile: String) {
        println("Starting media playback...")
        
        // Decode video
        val videoData = videoDecoder.decodeVideo(videoFile)
        
        // Decode audio
        val audioData = audioDecoder.decodeAudio(audioFile)
        
        // Render video
        videoRenderer.renderVideo(videoData)
        
        // Render audio
        audioRenderer.renderAudio(audioData)
        
        println("Media playback completed!")
    }
    
    fun stopMedia() {
        println("Stopping media playback...")
    }
}

/**
 * Penggunaan: cukup panggil satu method saja
 */
fun demonstrateMediaPlayerFacade() {
    val player = MediaProcessor()
    player.playMedia("movie.mp4", "movie.mp3")
}
```

**Use Cases di Android:**
- **Image loading libraries**: Glide, Picasso
- **Database operations**: Room dengan DAO
- **Network operations**: Retrofit dengan service interface

**presentation/facade/ImageLoaderFacade.kt**
```kotlin
package com.example.designpatterns.facade

import android.content.Context
import android.widget.ImageView
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy

/**
 * Facade untuk image loading
 * Menyembunyikan kompleksitas Glide
 */
class ImageLoaderFacade private constructor() {
    
    companion object {
        @Volatile
        private var instance: ImageLoaderFacade? = null
        
        fun getInstance(): ImageLoaderFacade {
            return instance ?: synchronized(this) {
                instance ?: ImageLoaderFacade().also { instance = it }
            }
        }
    }
    
    fun loadProfileImage(context: Context, url: String, imageView: ImageView) {
        Glide.with(context)
            .load(url)
            .placeholder(R.drawable.ic_user_placeholder)
            .error(R.drawable.ic_user_error)
            .diskCacheStrategy(DiskCacheStrategy.AUTOMATIC)
            .circleCrop()
            .into(imageView)
    }
    
    fun loadImage(context: Context, url: String, imageView: ImageView) {
        Glide.with(context)
            .load(url)
            .placeholder(R.drawable.ic_image_placeholder)
            .error(R.drawable.ic_image_error)
            .into(imageView)
    }
    
    fun loadGif(context: Context, url: String, imageView: ImageView) {
        Glide.with(context)
            .asGif()
            .load(url)
            .placeholder(R.drawable.ic_gif_placeholder)
            .error(R.drawable.ic_gif_error)
            .diskCacheStrategy(DiskCacheStrategy.DATA)
            .into(imageView)
    }
}
```

### 4. Composite Pattern:

**Konsep:**
Composite Pattern memungkinkan menyusun objek-objek dalam struktur pohon dan memperlakukan objek individual dan komposisi dengan cara yang seragam.

**Problematika:**
- Struktur hierarki
- Perlakuan sama untuk objek tunggal dan grup
- Operasi traversal yang kompleks

**Implementasi:**

**domain/composite/FileSystemComposite.kt**
```kotlin
package com.example.designpatterns.composite

/**
 * Interface komponen untuk filesystem
 */
interface FileSystemItem {
    fun getName(): String
    fun getSize(): Long
    fun printStructure(indent: String = "")
}

/**
 * File sebagai komponen dasar
 */
class FileItem(
    private val name: String,
    private val size: Long
) : FileSystemItem {
    override fun getName(): String = name
    override fun getSize(): Long = size
    override fun printStructure(indent: String) {
        println("${indent}File: $name (${size} bytes)")
    }
}

/**
 * Folder sebagai komposit
 */
class FolderItem(
    private val name: String
) : FileSystemItem {
    private val children = mutableListOf<FileSystemItem>()
    
    fun add(item: FileSystemItem) {
        children.add(item)
    }
    
    fun remove(item: FileSystemItem) {
        children.remove(item)
    }
    
    override fun getName(): String = name
    override fun getSize(): Long = children.sumOf { it.getSize() }
    
    override fun printStructure(indent: String) {
        println("${indent}Folder: $name (${getSize()} bytes total)")
        children.forEach { child ->
            child.printStructure("$indent  ")
        }
    }
}

/**
 * Contoh penggunaan
 */
fun demonstrateCompositePattern() {
    val root = FolderItem("root")
    val documents = FolderItem("Documents")
    val pictures = FolderItem("Pictures")
    
    val readme = FileItem("README.txt", 1024)
    val report = FileItem("report.pdf", 2048000)
    val photo1 = FileItem("photo1.jpg", 3072000)
    val photo2 = FileItem("photo2.png", 2048000)
    
    documents.add(readme)
    documents.add(report)
    
    pictures.add(photo1)
    pictures.add(photo2)
    
    root.add(documents)
    root.add(pictures)
    
    root.printStructure()
    println("Total size: ${root.getSize()} bytes")
}
```

### üéì Penjelasan Konsep:
**Structural Patterns seperti Arsitektur Gedung:**
- **Adapter**: Seperti transformator listrik - menghubungkan sistem yang berbeda
- **Decorator**: Seperti furnitur tambahan - menambah fungsi tanpa mengganti dasar
- **Facade**: Seperti tombol satu sentuh - menyederhanakan sistem kompleks
- **Composite**: Seperti organisasi hierarki - struktur pohon yang konsisten

**Manfaat Structural Patterns:**
- **Kompatibilitas**: Menghubungkan sistem yang berbeda
- **Ekstensibilitas**: Menambah fungsi tanpa merusak struktur
- **Kesederhanaan**: Menyembunyikan kompleksitas
- **Konsistensi**: Perlakuan seragam untuk objek tunggal dan grup

---

## 4Ô∏è‚É£ Behavioral Patterns üîÑ

### Konsep Dasar
Behavioral Patterns seperti aturan main tim sepak bola ‚öΩ - mengatur interaksi dan komunikasi antar objek!

### 1. Observer Pattern:

**Konsep:**
Observer Pattern mendefinisikan ketergantungan satu-ke-banyak antara objek sehingga ketika satu objek berubah state, semua dependennya diinformasikan dan diperbarui secara otomatis.

**Problematika:**
- Ketergantungan antar objek
- Update state yang dinamis
- Komunikasi antar komponen

**Implementasi:**

**domain/observer/UserObserver.kt**
```kotlin
package com.example.designpatterns.observer

/**
 * Interface untuk observer
 */
interface Observer<T> {
    fun onChanged(data: T)
}

/**
 * Interface untuk subject (objek yang diamati)
 */
interface Subject<T> {
    fun attach(observer: Observer<T>)
    fun detach(observer: Observer<T>)
    fun notify(data: T)
}

/**
 * Implementasi subject untuk user
 */
class UserSubject : Subject<User> {
    private val observers = mutableListOf<Observer<User>>()
    
    override fun attach(observer: Observer<User>) {
        observers.add(observer)
    }
    
    override fun detach(observer: Observer<User>) {
        observers.remove(observer)
    }
    
    override fun notify(data: User) {
        observers.forEach { it.onChanged(data) }
    }
}

/**
 * Contoh observer untuk user
 */
class UserProfileObserver : Observer<User> {
    override fun onChanged(data: User) {
        println("Profile updated: ${data.name} (${data.email})")
    }
}

class UserActivityObserver : Observer<User> {
    override fun onChanged(data: User) {
        println("User activity: ${data.name} was updated at ${data.lastUpdated}")
    }
}

class UserNotificationObserver : Observer<User> {
    override fun onChanged(data: User) {
        println("Sending notification: User ${data.name} has been updated")
    }
}

/**
 * Contoh penggunaan
 */
class UserService {
    private val userSubject = UserSubject()
    
    fun subscribe(observer: Observer<User>) {
        userSubject.attach(observer)
    }
    
    fun updateUser(userId: String, updates: UserUpdates) {
        // Ambil user dari repository
        var user = getUserById(userId) // misalnya dari repository
        user = user.copy(
            name = updates.name ?: user.name,
            email = updates.email ?: user.email,
            lastUpdated = System.currentTimeMillis()
        )
        
        // Simpan user
        saveUser(user) // misalnya ke repository
        
        // Notify semua observer
        userSubject.notify(user)
    }
    
    private fun getUserById(id: String): User {
        // Implementasi untuk mendapatkan user
        return User("1", "John", "john@example.com", System.currentTimeMillis())
    }
    
    private fun saveUser(user: User) {
        // Implementasi untuk menyimpan user
    }
}

data class UserUpdates(
    val name: String? = null,
    val email: String? = null
)
```

**Use Cases di Android:**
- **LiveData observers**: Pembaruan UI otomatis
- **Flow collectors**: Stream data reaktif
- **Event bus**: Komunikasi antar komponen
- **Callback patterns**: Respon terhadap event

**presentation/observer/LiveDataObserver.kt**
```kotlin
package com.example.designpatterns.observer

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.liveData
import kotlinx.coroutines.delay

/**
 * Contoh Observer Pattern dengan LiveData
 */
class UserViewModel : ViewModel() {
    
    private val _userState = MutableLiveData<UserState>()
    val userState: LiveData<UserState> = _userState
    
    private val _loading = MutableLiveData<Boolean>()
    val loading: LiveData<Boolean> = _loading
    
    fun loadUser(userId: String) {
        // LiveData secara otomatis mengimplementasi Observer Pattern
        _loading.value = true
        
        // Simulasi network call
        kotlinx.coroutines.GlobalScope.launch {
            delay(1000) // Simulate network delay
            
            val user = User(
                id = userId,
                name = "John Doe",
                email = "john@example.com",
                lastUpdated = System.currentTimeMillis()
            )
            
            _userState.postValue(UserState.Success(user))
            _loading.postValue(false)
        }
    }
    
    fun updateUser(userId: String, updates: UserUpdates) {
        val currentState = _userState.value
        if (currentState is UserState.Success) {
            val updatedUser = currentState.user.copy(
                name = updates.name ?: currentState.user.name,
                email = updates.email ?: currentState.user.email,
                lastUpdated = System.currentTimeMillis()
            )
            
            _userState.value = UserState.Success(updatedUser)
        }
    }
}

sealed class UserState {
    object Loading : UserState()
    data class Success(val user: User) : UserState()
    data class Error(val message: String) : UserState()
}

suspend fun <T> liveData(block: suspend () -> T): LiveData<T> {
    // Implementasi sederhana untuk contoh
    return MutableLiveData<T>().apply { 
        value = block() 
    }
}
```

### 2. Strategy Pattern:

**Konsep:**
Strategy Pattern memungkinkan mendefinisikan suatu keluarga algoritma, menempatkannya dalam kelas-kelas terpisah, dan membuat objek-objeknya dapat dipertukarkan.

**Problematika:**
- Algoritma yang bervariasi
- Pemilihan algoritma saat runtime
- Ketergantungan pada kondisi if-else

**Implementasi:**

**domain/strategy/PaymentStrategy.kt**
```kotlin
package com.example.designpatterns.strategy

/**
 * Interface untuk strategy pembayaran
 */
interface PaymentStrategy {
    suspend fun pay(amount: Double): PaymentResult
    fun validate(): ValidationResult
}

/**
 * Implementasi untuk pembayaran kartu kredit
 */
class CreditCardPaymentStrategy(
    private val cardNumber: String,
    private val cvv: String,
    private val expiryDate: String
) : PaymentStrategy {
    
    override suspend fun pay(amount: Double): PaymentResult {
        // Validasi sebelum pembayaran
        val validation = validate()
        if (validation !is ValidationResult.Valid) {
            return PaymentResult.Failure(validation.message)
        }
        
        // Simulasi pembayaran kartu kredit
        return if (simulateCreditCardPayment(amount)) {
            PaymentResult.Success("Credit card payment of $$amount completed")
        } else {
            PaymentResult.Failure("Credit card payment failed")
        }
    }
    
    override fun validate(): ValidationResult {
        if (cardNumber.length != 16 || !cardNumber.all { it.isDigit() }) {
            return ValidationResult.Invalid("Invalid card number")
        }
        if (cvv.length != 3 || !cvv.all { it.isDigit() }) {
            return ValidationResult.Invalid("Invalid CVV")
        }
        if (!isValidExpiryDate(expiryDate)) {
            return ValidationResult.Invalid("Invalid expiry date")
        }
        return ValidationResult.Valid
    }
    
    private fun simulateCreditCardPayment(amount: Double): Boolean {
        // Simulasi pembayaran
        return true
    }
    
    private fun isValidExpiryDate(date: String): Boolean {
        // Validasi format expiry date
        return date.matches(Regex("\\d{2}/\\d{2}"))
    }
}

/**
 * Implementasi untuk pembayaran PayPal
 */
class PayPalPaymentStrategy(
    private val email: String,
    private val password: String
) : PaymentStrategy {
    
    override suspend fun pay(amount: Double): PaymentResult {
        val validation = validate()
        if (validation !is ValidationResult.Valid) {
            return PaymentResult.Failure(validation.message)
        }
        
        return if (simulatePayPalPayment(amount)) {
            PaymentResult.Success("PayPal payment of $$amount completed")
        } else {
            PaymentResult.Failure("PayPal payment failed")
        }
    }
    
    override fun validate(): ValidationResult {
        if (!android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
            return ValidationResult.Invalid("Invalid email")
        }
        if (password.length < 8) {
            return ValidationResult.Invalid("Password must be at least 8 characters")
        }
        return ValidationResult.Valid
    }
    
    private fun simulatePayPalPayment(amount: Double): Boolean {
        // Simulasi pembayaran PayPal
        return true
    }
}

/**
 * Implementasi untuk pembayaran transfer bank
 */
class BankTransferPaymentStrategy(
    private val accountNumber: String,
    private val routingNumber: String
) : PaymentStrategy {
    
    override suspend fun pay(amount: Double): PaymentResult {
        val validation = validate()
        if (validation !is ValidationResult.Valid) {
            return PaymentResult.Failure(validation.message)
        }
        
        return if (simulateBankTransfer(amount)) {
            PaymentResult.Success("Bank transfer of $$amount completed")
        } else {
            PaymentResult.Failure("Bank transfer failed")
        }
    }
    
    override fun validate(): ValidationResult {
        if (accountNumber.length !in 8..12 || !accountNumber.all { it.isDigit() }) {
            return ValidationResult.Invalid("Invalid account number")
        }
        if (routingNumber.length != 9 || !routingNumber.all { it.isDigit() }) {
            return ValidationResult.Invalid("Invalid routing number")
        }
        return ValidationResult.Valid
    }
    
    private fun simulateBankTransfer(amount: Double): Boolean {
        // Simulasi transfer bank
        return true
    }
}

/**
 * Keranjang belanja yang menggunakan strategy pattern
 */
class ShoppingCart(
    private var paymentStrategy: PaymentStrategy
) {
    
    suspend fun checkout(amount: Double): PaymentResult {
        return paymentStrategy.pay(amount)
    }
    
    fun setPaymentMethod(newStrategy: PaymentStrategy) {
        this.paymentStrategy = newStrategy
    }
    
    fun getValidationResult(): ValidationResult {
        return paymentStrategy.validate()
    }
}

/**
 * Hasil pembayaran
 */
sealed class PaymentResult {
    data class Success(val message: String) : PaymentResult()
    data class Failure(val message: String) : PaymentResult()
}

/**
 * Hasil validasi
 */
sealed class ValidationResult {
    object Valid : ValidationResult()
    data class Invalid(val message: String) : ValidationResult()
}
```

**Use Cases di Android:**
- **Different sorting algorithms**: Berbagai metode pengurutan
- **Payment methods**: Berbagai metode pembayaran
- **Authentication strategies**: Berbagai metode otentikasi
- **Validation rules**: Berbagai aturan validasi

**presentation/strategy/SortStrategy.kt**
```kotlin
package com.example.designpatterns.strategy

/**
 * Strategy untuk pengurutan data
 */
interface SortStrategy<T> {
    fun sort(items: List<T>): List<T>
}

/**
 * Strategy untuk pengurutan berdasarkan nama
 */
class NameSortStrategy<T : NamedItem> : SortStrategy<T> {
    override fun sort(items: List<T>): List<T> {
        return items.sortedBy { it.name }
    }
}

/**
 * Strategy untuk pengurutan berdasarkan tanggal
 */
class DateSortStrategy<T : DateItem> : SortStrategy<T> {
    override fun sort(items: List<T>): List<T> {
        return items.sortedBy { it.date }
    }
}

/**
 * Strategy untuk pengurutan berdasarkan prioritas
 */
class PrioritySortStrategy<T : PriorityItem> : SortStrategy<T> {
    override fun sort(items: List<T>): List<T> {
        return items.sortedByDescending { it.priority }
    }
}

/**
 * Strategy untuk pengurutan kustom
 */
class CustomSortStrategy<T>(
    private val comparator: Comparator<T>
) : SortStrategy<T> {
    override fun sort(items: List<T>): List<T> {
        return items.sortedWith(comparator)
    }
}

/**
 * Kelas untuk pengurutan data
 */
class DataSorter<T> {
    private var strategy: SortStrategy<T>? = null
    
    fun setSortStrategy(strategy: SortStrategy<T>) {
        this.strategy = strategy
    }
    
    fun sortData(items: List<T>): List<T> {
        return strategy?.sort(items) ?: items
    }
}

/**
 * Interface untuk item yang bisa diurutkan
 */
interface NamedItem {
    val name: String
}

interface DateItem {
    val date: Long
}

interface PriorityItem {
    val priority: Int
}

/**
 * Contoh implementasi
 */
data class User(
    override val name: String,
    val email: String,
    val joinDate: Long = System.currentTimeMillis()
) : NamedItem

data class Task(
    override val name: String,
    val description: String,
    override val date: Long,
    override val priority: Int
) : NamedItem, DateItem, PriorityItem
```

### 3. Command Pattern:

**Konsep:**
Command Pattern mengubah permintaan menjadi objek terpisah yang berisi semua informasi tentang permintaan tersebut.

**Problematika:**
- Logging dan histori perintah
- Undo/redo operasi
- Antrian perintah
- Manipulasi perintah sebagai objek

**Implementasi:**

**domain/command/CommandPattern.kt**
```kotlin
package com.example.designpatterns.command

/**
 * Interface untuk command
 */
interface Command {
    suspend fun execute()
    suspend fun undo()
    fun getName(): String
}

/**
 * Command untuk menyimpan user
 */
class SaveUserCommand(
    private val userRepository: UserRepository,
    private val user: User
) : Command {
    private var previousUser: User? = null
    
    override suspend fun execute() {
        previousUser = userRepository.findById(user.id)
        userRepository.save(user)
    }
    
    override suspend fun undo() {
        previousUser?.let { userRepository.save(it) }
    }
    
    override fun getName(): String = "Save user: ${user.name}"
}

/**
 * Command untuk menghapus user
 */
class DeleteUserCommand(
    private val userRepository: UserRepository,
    private val userId: String
) : Command {
    private var deletedUser: User? = null
    
    override suspend fun execute() {
        deletedUser = userRepository.findById(userId)
        userRepository.delete(userId)
    }
    
    override suspend fun undo() {
        deletedUser?.let { userRepository.save(it) }
    }
    
    override fun getName(): String = "Delete user: $userId"
}

/**
 * Command untuk memperbarui user
 */
class UpdateUserCommand(
    private val userRepository: UserRepository,
    private val userId: String,
    private val updates: UserUpdates
) : Command {
    private var previousUser: User? = null
    
    override suspend fun execute() {
        previousUser = userRepository.findById(userId)
        previousUser?.let { user ->
            val updatedUser = user.copy(
                name = updates.name ?: user.name,
                email = updates.email ?: user.email
            )
            userRepository.save(updatedUser)
        }
    }
    
    override suspend fun undo() {
        previousUser?.let { userRepository.save(it) }
    }
    
    override fun getName(): String = "Update user: $userId"
}

/**
 * Manager untuk mengelola command
 */
class CommandManager {
    private val commands = mutableListOf<Command>()
    private val undoStack = mutableListOf<Command>()
    
    suspend fun executeCommand(command: Command) {
        command.execute()
        commands.add(command)
        undoStack.add(command)
    }
    
    suspend fun undoLastCommand(): String {
        val command = undoStack.removeLastOrNull() ?: return "No commands to undo"
        command.undo()
        return "Undone: ${command.getName()}"
    }
    
    suspend fun undoAll(): String {
        while (undoStack.isNotEmpty()) {
            val command = undoStack.removeLast()
            command.undo()
        }
        return "All commands undone"
    }
    
    fun getCommandHistory(): List<String> {
        return commands.map { it.getName() }
    }
}

/**
 * Data class untuk updates
 */
data class UserUpdates(
    val name: String? = null,
    val email: String? = null
)

/**
 * Interface untuk repository
 */
interface UserRepository {
    suspend fun findById(id: String): User?
    suspend fun save(user: User)
    suspend fun delete(id: String)
}

/**
 * Data class untuk user
 */
data class User(
    val id: String,
    val name: String,
    val email: String,
    val createdAt: Long = System.currentTimeMillis()
)
```

### 4. State Pattern:

**Konsep:**
State Pattern memungkinkan objek untuk mengubah perilakunya ketika state internalnya berubah.

**Problematika:**
- Logika yang kompleks berdasarkan state
- Banyak kondisi if-else
- Perubahan perilaku dinamis

**Implementasi:**

**domain/state/PlayerState.kt**
```kotlin
package com.example.designpatterns.state

/**
 * Interface untuk state player
 */
interface PlayerState {
    suspend fun play(player: MediaPlayer)
    suspend fun pause(player: MediaPlayer)
    suspend fun stop(player: MediaPlayer)
    fun getStateName(): String
}

/**
 * State untuk player yang sedang memainkan
 */
class PlayingState : PlayerState {
    override suspend fun play(player: MediaPlayer) {
        println("Player is already playing")
    }
    
    override suspend fun pause(player: MediaPlayer) {
        println("Pausing player")
        player.setState(PausedState())
    }
    
    override suspend fun stop(player: MediaPlayer) {
        println("Stopping player")
        player.setState(StoppedState())
    }
    
    override fun getStateName(): String = "PLAYING"
}

/**
 * State untuk player yang sedang dijeda
 */
class PausedState : PlayerState {
    override suspend fun play(player: MediaPlayer) {
        println("Resuming player")
        player.setState(PlayingState())
    }
    
    override suspend fun pause(player: MediaPlayer) {
        println("Player is already paused")
    }
    
    override suspend fun stop(player: MediaPlayer) {
        println("Stopping player")
        player.setState(StoppedState())
    }
    
    override fun getStateName(): String = "PAUSED"
}

/**
 * State untuk player yang berhenti
 */
class StoppedState : PlayerState {
    override suspend fun play(player: MediaPlayer) {
        println("Starting player")
        player.setState(PlayingState())
    }
    
    override suspend fun pause(player: MediaPlayer) {
        println("Cannot pause stopped player")
    }
    
    override suspend fun stop(player: MediaPlayer) {
        println("Player is already stopped")
    }
    
    override fun getStateName(): String = "STOPPED"
}

/**
 * Player yang menggunakan state pattern
 */
class MediaPlayer {
    private var state: PlayerState = StoppedState()
    
    fun setState(newState: PlayerState) {
        this.state = newState
        println("Player state changed to: ${newState.getStateName()}")
    }
    
    suspend fun play() = state.play(this)
    suspend fun pause() = state.pause(this)
    suspend fun stop() = state.stop(this)
    
    fun getCurrentState(): String = state.getStateName()
}

/**
 * Contoh penggunaan
 */
suspend fun demonstratePlayerState() {
    val player = MediaPlayer()
    println("Initial state: ${player.getCurrentState()}")
    
    player.play()
    player.pause()
    player.play()
    player.stop()
}
```

**Use Cases di Android:**
- **UI states**: Loading, Success, Error
- **Player states**: Playing, Paused, Stopped
- **Connection states**: Connected, Disconnected, Connecting
- **Sealed classes di Kotlin**: Implementasi state pattern

**presentation/state/UiState.kt**
```kotlin
package com.example.designpatterns.state

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

/**
 * State pattern dengan sealed classes di Kotlin
 */
sealed class UiState<out T> {
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(val message: String) : UiState<Nothing>()
}

/**
 * ViewModel yang menggunakan state pattern
 */
class UserViewModel(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UiState<List<User>>>(UiState.Loading)
    val uiState: StateFlow<UiState<List<User>>> = _uiState.asStateFlow()
    
    fun loadUsers() {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            
            try {
                val users = userRepository.getUsers()
                _uiState.value = UiState.Success(users)
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message ?: "Unknown error")
            }
        }
    }
    
    fun refreshUsers() {
        loadUsers()
    }
}
```

### 5. Template Method Pattern:

**Konsep:**
Template Method Pattern mendefinisikan kerangka algoritma di kelas induk, tetapi memungkinkan subclass mengganti langkah-langkah tertentu tanpa mengubah struktur algoritma secara keseluruhan.

**Problematika:**
- Algoritma dengan langkah-langkah umum
- Variasi dalam implementasi langkah
- Mencegah duplikasi kode

**Implementasi:**

**domain/template/DataProcessorTemplate.kt**
```kotlin
package com.example.designpatterns.template

/**
 * Abstract class untuk processor template
 */
abstract class DataProcessor<T> {
    
    /**
     * Template method - algoritma utama
     */
    suspend fun process(data: T): ProcessingResult {
        return try {
            // Langkah-langkah yang tetap sama untuk semua implementasi
            val validated = validate(data)
            val transformed = transform(validated)
            val processed = performProcessing(transformed)
            
            ProcessingResult.Success(processed)
        } catch (e: Exception) {
            ProcessingResult.Error(e.message ?: "Unknown error")
        }
    }
    
    // Langkah-langkah abstract yang harus diimplementasi oleh subclass
    protected abstract suspend fun validate(data: T): T
    protected abstract suspend fun transform(data: T): T
    protected abstract suspend fun performProcessing(data: T): String
    
    // Langkah opsional yang bisa di-override
    protected open suspend fun logProcessing(data: T) {
        println("Processing data: $data")
    }
    
    protected open suspend fun postProcess(result: String) {
        println("Post-processing result: $result")
    }
}

/**
 * Implementasi untuk user data
 */
class UserDataProcessor : DataProcessor<UserData>() {
    override suspend fun validate(data: UserData): UserData {
        if (data.name.isBlank()) {
            throw IllegalArgumentException("Name cannot be blank")
        }
        if (!data.email.contains("@")) {
            throw IllegalArgumentException("Invalid email")
        }
        return data.copy(
            name = data.name.trim(),
            email = data.email.lowercase()
        )
    }
    
    override suspend fun transform(data: UserData): UserData {
        return data.copy(
            name = data.name.replaceFirstChar { it.uppercase() }
        )
    }
    
    override suspend fun performProcessing(data: UserData): String {
        return "Processed user: ${data.name} (${data.email})"
    }
    
    override suspend fun logProcessing(data: UserData) {
        println("Processing user data: ${data.name}")
    }
}

/**
 * Implementasi untuk order data
 */
class OrderDataProcessor : DataProcessor<OrderData>() {
    override suspend fun validate(data: OrderData): OrderData {
        if (data.items.isEmpty()) {
            throw IllegalArgumentException("Order must have items")
        }
        if (data.totalAmount <= 0) {
            throw IllegalArgumentException("Invalid total amount")
        }
        return data
    }
    
    override suspend fun transform(data: OrderData): OrderData {
        return data.copy(
            processedAt = System.currentTimeMillis(),
            items = data.items.map { it.copy(processed = true) }
        )
    }
    
    override suspend fun performProcessing(data: OrderData): String {
        return "Processed order with ${data.items.size} items, total: $${data.totalAmount}"
    }
    
    override suspend fun logProcessing(data: OrderData) {
        println("Processing order: ${data.id}")
    }
}

/**
 * Data classes
 */
data class UserData(
    val name: String,
    val email: String
)

data class OrderData(
    val id: String,
    val items: List<OrderItem>,
    val totalAmount: Double,
    val processedAt: Long? = null
)

data class OrderItem(
    val name: String,
    val price: Double,
    var processed: Boolean = false
)

/**
 * Hasil processing
 */
sealed class ProcessingResult {
    data class Success(val data: String) : ProcessingResult()
    data class Error(val message: String) : ProcessingResult()
}
```

### üéì Penjelasan Konsep:
**Behavioral Patterns seperti Aturan Main:**
- **Observer**: Seperti sistem peringatan - memberi tahu perubahan
- **Strategy**: Seperti pilihan metode - bisa diganti-ganti
- **Command**: Seperti antrian instruksi - bisa diundur/diulang
- **State**: Seperti mood - perilaku berubah sesuai kondisi
- **Template**: Seperti resep - struktur tetap, variasi bisa diisi

**Manfaat Behavioral Patterns:**
- **Komunikasi**: Mengatur interaksi antar objek
- **Ekstensibilitas**: Mudah menambah perilaku baru
- **Kontrol**: Menangani alur eksekusi kompleks
- **Fleksibilitas**: Perilaku bisa diubah secara dinamis

---

## 5Ô∏è‚É£ Android-Specific Patterns üì±

### Konsep Dasar
Android-Specific Patterns seperti komponen khusus Android ü§ñ - pola yang dirancang khusus untuk platform Android!

### 1. ViewHolder Pattern dalam RecyclerView:

**Konsep:**
ViewHolder Pattern digunakan dalam RecyclerView untuk menyimpan referensi view dan mengoptimalkan kinerja dengan menghindari pencarian view yang berulang-ulang.

**Problematika:**
- Kinerja scroll yang buruk
- Pencarian view yang tidak efisien
- Konsumsi memory yang tinggi

**Implementasi:**

**presentation/adapter/CustomViewHolder.kt**
```kotlin
package com.example.designpatterns.android

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.example.designpatterns.R

/**
 * ViewHolder Pattern - mengoptimalkan RecyclerView
 */
class UserViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    
    private val nameText: TextView = itemView.findViewById(R.id.nameText)
    private val emailText: TextView = itemView.findViewById(R.id.emailText)
    private val statusText: TextView = itemView.findViewById(R.id.statusText)
    
    fun bind(user: User, onItemClick: (User) -> Unit) {
        nameText.text = user.name
        emailText.text = user.email
        statusText.text = if (user.isActive) "Active" else "Inactive"
        
        itemView.setOnClickListener {
            onItemClick(user)
        }
    }
    
    companion object {
        fun create(parent: ViewGroup): UserViewHolder {
            val view = LayoutInflater.from(parent.context)
                .inflate(R.layout.item_user, parent, false)
            return UserViewHolder(view)
        }
    }
}

/**
 * Adapter yang menggunakan ViewHolder
 */
class UserAdapter(
    private val users: List<User>,
    private val onItemClick: (User) -> Unit
) : RecyclerView.Adapter<UserViewHolder>() {
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {
        return UserViewHolder.create(parent)
    }
    
    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {
        holder.bind(users[position], onItemClick)
    }
    
    override fun getItemCount(): Int = users.size
}

/**
 * Data class untuk user
 */
data class User(
    val id: String,
    val name: String,
    val email: String,
    val isActive: Boolean = true
)
```

### 2. Repository Pattern:

**Konsep:**
Repository Pattern menyediakan lapisan abstraksi antara layer domain dan data, menyembunyikan detail implementasi bagaimana data diakses.

**Problematika:**
- Tidak ada abstraksi data access
- Tight coupling antar layer
- Sulit untuk testing

**Implementasi:**

**data/repository/UserRepositoryImpl.kt**
```kotlin
package com.example.designpatterns.data.repository

import com.example.designpatterns.domain.model.User
import com.example.designpatterns.domain.repository.UserRepository
import com.example.designpatterns.data.datasource.local.UserLocalDataSource
import com.example.designpatterns.data.datasource.remote.UserRemoteDataSource

/**
 * Implementasi dari Repository Pattern
 */
class UserRepositoryImpl(
    private val remoteDataSource: UserRemoteDataSource,
    private val localDataSource: UserLocalDataSource
) : UserRepository {
    
    override suspend fun getUserById(id: String): User? {
        // Coba ambil dari lokal dulu
        var user = localDataSource.getUserById(id)
        
        if (user == null) {
            // Jika tidak ada di lokal, ambil dari remote
            user = remoteDataSource.fetchUserById(id)
            user?.let { 
                // Cache ke lokal
                localDataSource.saveUser(it) 
            }
        }
        
        return user
    }
    
    override suspend fun getUsers(): List<User> {
        // Ambil dari lokal dan remote, lalu cocokkan
        val localUsers = localDataSource.getUsers()
        val remoteUsers = remoteDataSource.fetchUsers()
        
        // Update lokal dengan data terbaru dari remote
        remoteUsers.forEach { user ->
            localDataSource.saveUser(user)
        }
        
        return localDataSource.getUsers()
    }
    
    override suspend fun saveUser(user: User) {
        // Simpan ke remote dan lokal
        remoteDataSource.saveUser(user)
        localDataSource.saveUser(user)
    }
    
    override suspend fun deleteUser(id: String) {
        // Hapus dari remote dan lokal
        remoteDataSource.deleteUser(id)
        localDataSource.deleteUser(id)
    }
}
```

### 3. Delegation Pattern:

**Konsov:**
Delegation Pattern memungkinkan sebuah objek untuk mendelegasikan tanggung jawabnya kepada objek lain.

**Problematika:**
- Penulisan ulang fungsionalitas
- Ketergantungan yang tidak diperlukan
- Code duplication

**Implementasi:**

**domain/delegation/DelegationPattern.kt**
```kotlin
package com.example.designpatterns.delegation

/**
 * Interface dasar
 */
interface Printer {
    fun print()
}

/**
 * Implementasi asli
 */
class ConsolePrinter : Printer {
    override fun print() {
        println("Printing to console")
    }
}

/**
 * Class yang mendelegasikan fungsionalitas printing
 */
class Document(private val printer: Printer) : Printer by printer {
    fun createContent(content: String) {
        println("Creating document with content: $content")
    }
}

/**
 * Contoh delegasi property di Kotlin
 */
class User {
    var name: String by observable("", ::onNameChanged)
    
    private fun onNameChanged(property: kotlin.reflect.KProperty<*>, oldValue: String, newValue: String) {
        println("Name changed from '$oldValue' to '$newValue'")
    }
}

/**
 * Contoh delegasi koleksi
 */
class Team {
    private val members = mutableListOf<String>()
    val size: Int by members::size
    val isEmpty: Boolean by members::isEmpty
    
    fun addMember(name: String) = members.add(name)
    fun removeMember(name: String) = members.remove(name)
    fun getMembers() = members.toList()
}

/**
 * Contoh delegasi untuk lazy initialization
 */
class ExpensiveObject {
    init {
        println("ExpensiveObject created")
    }
    
    fun doWork() {
        println("Working with expensive object")
    }
}

class ObjectOwner {
    val expensiveObject: ExpensiveObject by lazy {
        ExpensiveObject() // Hanya dibuat saat pertama kali diakses
    }
}
```

### 4. Event Bus Pattern:

**Konsep:**
Event Bus Pattern menyediakan komunikasi antar komponen tanpa ketergantungan langsung.

**Problematika:**
- Tight coupling antar komponen
- Kesulitan dalam testing
- Pemrograman event-driven yang kompleks

**Implementasi:**

**presentation/eventbus/EventBus.kt**
```kotlin
package com.example.designpatterns.eventbus

import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.Flow

/**
 * Simple Event Bus menggunakan Kotlin Flow
 */
class EventBus {
    private val _events = MutableSharedFlow<UiEvent>()
    val events: Flow<UiEvent> = _events.asSharedFlow()
    
    suspend fun postEvent(event: UiEvent) {
        _events.emit(event)
    }
}

/**
 * Interface untuk semua event
 */
sealed class UiEvent {
    data class ShowToast(val message: String) : UiEvent()
    data class NavigateTo(val destination: String) : UiEvent()
    data class ShowLoading(val show: Boolean) : UiEvent()
    data class ShowError(val message: String) : UiEvent()
}

/**
 * ViewModel yang menggunakan event bus
 */
class EventViewModel(
    private val eventBus: EventBus
) {
    suspend fun showError(message: String) {
        eventBus.postEvent(UiEvent.ShowError(message))
    }
    
    suspend fun showSuccessMessage(message: String) {
        eventBus.postEvent(UiEvent.ShowToast(message))
    }
    
    suspend fun navigateTo(destination: String) {
        eventBus.postEvent(UiEvent.NavigateTo(destination))
    }
}
```

### 5. Data Binding Pattern:

**Konsep:**
Data Binding Pattern menyediakan cara deklaratif untuk mengikat komponen UI ke data dalam aplikasi.

**Problematika:**
- Pemrograman UI yang verbose
- Banyak findViewById
- Kode yang tidak efisien

**Implementasi:**

**layout/activity_user.xml (dalam res/layout)**
```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    
    <data>
        <variable
            name="user"
            type="com.example.designpatterns.domain.model.User" />
    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{user.name}" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{user.email}" />

    </LinearLayout>
</layout>
```

**presentation/binding/UserBindingAdapter.kt**
```kotlin
package com.example.designpatterns.binding

import android.widget.TextView
import androidx.databinding.BindingAdapter
import com.example.designpatterns.domain.model.User

/**
 * Binding adapter untuk user
 */
@BindingAdapter("userEmail")
fun setUserEmail(textView: TextView, user: User?) {
    textView.text = user?.email ?: "No email"
}

@BindingAdapter("userName")
fun setUserName(textView: TextView, user: User?) {
    textView.text = user?.name ?: "Unknown"
}
```

### 6. Navigation Component Pattern:

**Konsep:**
Navigation Component Pattern menyediakan struktur dan logika untuk navigasi dalam aplikasi Android.

**Problematika:**
- Manajemen intent yang kompleks
- Deep linking yang rumit
- Back stack management yang error-prone

**Implementation:**
```kotlin
// navigation_graph.xml (dalam res/navigation)
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/nav_graph"
    app:startDestination="@id/homeFragment">

    <fragment
        android:id="@+id/homeFragment"
        android:name="com.example.designpatterns.HomeFragment" />

    <fragment
        android:id="@+id/userDetailFragment"
        android:name="com.example.designpatterns.UserDetailFragment">
        
        <argument
            android:name="userId"
            app:argType="string" />
    </fragment>
</navigation>
```

### üéì Penjelasan Konsep:
**Android-Specific Patterns seperti Komponen Khusus:**
- **ViewHolder**: Seperti karyawan yang mengingat posisi barang
- **Repository**: Seperti gudang yang mengatur persediaan
- **Delegation**: Seperti asisten yang mengerjakan tugas
- **Event Bus**: Seperti sistem pengumuman internal
- **Data Binding**: Seperti kabel yang menghubungkan dua sistem

**Manfaat Android-Specific Patterns:**
- **Optimalisasi**: Kinerja yang lebih baik
- **Maintainability**: Kode lebih mudah dipelihara
- **Integration**: Lebih baik dengan sistem Android
- **Best Practices**: Mengikuti praktik terbaik Android

---

## 6Ô∏è‚É£ Pattern Combinations ‚ú®

### Konsep Dasar
Pattern Combinations seperti orkestra musik üéº - menggabungkan berbagai pattern untuk menciptakan solusi yang harmonis!

### 1. Factory + Singleton:

**Konsep:**
Menggabungkan Factory Pattern untuk pembuatan objek dan Singleton Pattern untuk memastikan instance tunggal.

**Implementasi:**

**domain/combinations/FactorySingleton.kt**
```kotlin
package com.example.designpatterns.combinations

/**
 * Factory dengan singleton instance
 */
object DatabaseFactory {
    @Volatile
    private var instance: Database? = null
    
    fun getDatabase(): Database {
        return instance ?: synchronized(this) {
            instance ?: createDatabase().also { instance = it }
        }
    }
    
    private fun createDatabase(): Database {
        println("Creating new database instance")
        return Database()
    }
}

class Database {
    fun executeQuery(sql: String) {
        println("Executing query: $sql")
    }
    
    fun connect() {
        println("Database connected")
    }
}

/**
 * Lebih fleksibel: Factory dengan singleton instance per jenis database
 */
class FlexibleDatabaseFactory private constructor() {
    companion object {
        @Volatile
        private var instance: FlexibleDatabaseFactory? = null
        
        fun getInstance(): FlexibleDatabaseFactory {
            return instance ?: synchronized(this) {
                instance ?: FlexibleDatabaseFactory().also { instance = it }
            }
        }
    }
    
    private val databases = mutableMapOf<String, Database>()
    
    fun getDatabase(type: DatabaseType): Database {
        return databases.getOrPut(type.name) { createDatabase(type) }
    }
    
    private fun createDatabase(type: DatabaseType): Database {
        return when (type) {
            DatabaseType.SQLITE -> SQLiteDatabase()
            DatabaseType.POSTGRES -> PostgresDatabase()
            DatabaseType.MONGODB -> MongoDatabase()
        }
    }
}

enum class DatabaseType {
    SQLITE, POSTGRES, MONGODB
}

interface Database {
    fun executeQuery(sql: String)
    fun connect()
}

class SQLiteDatabase : Database {
    override fun executeQuery(sql: String) = println("SQLite: $sql")
    override fun connect() = println("SQLite connected")
}

class PostgresDatabase : Database {
    override fun executeQuery(sql: String) = println("PostgreSQL: $sql")
    override fun connect() = println("PostgreSQL connected")
}

class MongoDatabase : Database {
    override fun executeQuery(sql: String) = println("MongoDB: $sql")
    override fun connect() = println("MongoDB connected")
}
```

### 2. Strategy + Factory:

**Konsep:**
Menggabungkan Strategy Pattern untuk algoritma yang bisa dipilih dan Factory Pattern untuk pembuatan strategy.

**Implementasi:**

**domain/combinations/StrategyFactory.kt**
```kotlin
package com.example.designpatterns.combinations

/**
 * Strategy pattern untuk sorting
 */
interface SortStrategy {
    fun <T> sort(list: List<T>): List<T>
}

class BubbleSortStrategy : SortStrategy {
    override fun <T : Comparable<T>> sort(list: List<T>): List<T> {
        // Implementasi bubble sort
        return list.toMutableList().apply {
            for (i in indices) {
                for (j in 0 until size - i - 1) {
                    if (this[j] > this[j + 1]) {
                        val temp = this[j]
                        this[j] = this[j + 1]
                        this[j + 1] = temp
                    }
                }
            }
        }
    }
}

class QuickSortStrategy : SortStrategy {
    override fun <T : Comparable<T>> sort(list: List<T>): List<T> {
        // Implementasi quick sort
        return if (list.size <= 1) list else {
            val pivot = list[list.size / 2]
            val smaller = list.filter { it < pivot }
            val equal = list.filter { it == pivot }
            val larger = list.filter { it > pivot }
            sort(smaller) + equal + sort(larger)
        }
    }
}

class MergeSortStrategy : SortStrategy {
    override fun <T : Comparable<T>> sort(list: List<T>): List<T> {
        // Implementasi merge sort
        return if (list.size <= 1) list else {
            val middle = list.size / 2
            val left = sort(list.subList(0, middle))
            val right = sort(list.subList(middle, list.size))
            merge(left, right)
        }
    }
    
    private fun <T : Comparable<T>> merge(left: List<T>, right: List<T>): List<T> {
        val result = mutableListOf<T>()
        var i = 0
        var j = 0
        
        while (i < left.size && j < right.size) {
            if (left[i] <= right[j]) {
                result.add(left[i++])
            } else {
                result.add(right[j++])
            }
        }
        
        result.addAll(left.subList(i, left.size))
        result.addAll(right.subList(j, right.size))
        return result
    }
}

/**
 * Factory untuk membuat sort strategy
 */
interface SortStrategyFactory {
    fun createStrategy(type: SortType): SortStrategy
}

class DefaultSortStrategyFactory : SortStrategyFactory {
    override fun createStrategy(type: SortType): SortStrategy {
        return when (type) {
            SortType.BUBBLE -> BubbleSortStrategy()
            SortType.QUICK -> QuickSortStrategy()
            SortType.MERGE -> MergeSortStrategy()
        }
    }
}

enum class SortType {
    BUBBLE, QUICK, MERGE
}

/**
 * Class yang menggabungkan factory dan strategy
 */
class SortManager(
    private val factory: SortStrategyFactory = DefaultSortStrategyFactory()
) {
    fun <T : Comparable<T>> sort(data: List<T>, sortType: SortType): List<T> {
        val strategy = factory.createStrategy(sortType)
        return strategy.sort(data)
    }
    
    fun <T : Comparable<T>> sortWithDefault(data: List<T>): List<T> {
        // Gunakan default strategy
        return sort(data, SortType.QUICK) // Quick sort sebagai default
    }
}

/**
 * Demonstrasi penggunaan
 */
fun demonstrateSortManager() {
    val manager = SortManager()
    val data = listOf(64, 34, 25, 12, 22, 11, 90)
    
    println("Original: $data")
    println("Bubble sort: ${manager.sort(data, SortType.BUBBLE)}")
    println("Quick sort: ${manager.sort(data, SortType.QUICK)}")
    println("Merge sort: ${manager.sort(data, SortType.MERGE)}")
}
```

### 3. Observer + Singleton:

**Konsep:**
Menggabungkan Observer Pattern untuk komunikasi event dan Singleton Pattern untuk satu instance event manager.

**Implementasi:**

**domain/combinations/ObserverSingleton.kt**
```kotlin
package com.example.designpatterns.combinations

/**
 * Singleton event manager yang menggabungkan observer pattern
 */
object EventManager {
    private val observers = mutableMapOf<String, MutableList<(Any) -> Unit>>()
    
    fun subscribe(eventType: String, observer: (Any) -> Unit) {
        if (!observers.containsKey(eventType)) {
            observers[eventType] = mutableListOf()
        }
        observers[eventType]?.add(observer)
    }
    
    fun unsubscribe(eventType: String, observer: (Any) -> Unit) {
        observers[eventType]?.remove(observer)
    }
    
    fun postEvent(eventType: String, data: Any) {
        observers[eventType]?.forEach { it(data) }
    }
    
    fun clearObservers(eventType: String? = null) {
        if (eventType != null) {
            observers.remove(eventType)
        } else {
            observers.clear()
        }
    }
}

/**
 * Kelas-kelas event spesifik
 */
sealed class AppEvent {
    object UserLoggedIn : AppEvent()
    object UserLoggedOut : AppEvent()
    data class UserUpdated(val userId: String) : AppEvent()
    data class NetworkStatusChanged(val isConnected: Boolean) : AppEvent()
}

/**
 * Contoh penggunaan
 */
class UserService {
    private var isLoggedIn = false
    
    fun login() {
        isLoggedIn = true
        EventManager.postEvent("user_login", AppEvent.UserLoggedIn)
    }
    
    fun logout() {
        isLoggedIn = false
        EventManager.postEvent("user_logout", AppEvent.UserLoggedOut)
    }
    
    fun updateUser(userId: String) {
        EventManager.postEvent("user_update", AppEvent.UserUpdated(userId))
    }
}

class NetworkService {
    fun updateNetworkStatus(isConnected: Boolean) {
        EventManager.postEvent("network_change", AppEvent.NetworkStatusChanged(isConnected))
    }
}

/**
 * Contoh subscriber
 */
class UiUpdater {
    init {
        EventManager.subscribe("user_login") { event ->
            println("UI: User logged in")
        }
        
        EventManager.subscribe("user_logout") { event ->
            println("UI: User logged out")
        }
        
        EventManager.subscribe("user_update") { event ->
            if (event is AppEvent.UserUpdated) {
                println("UI: User ${event.userId} updated")
            }
        }
    }
}
```

### 4. Builder + Factory:

**Konsep:**
Menggabungkan Builder Pattern untuk objek kompleks dan Factory Pattern untuk pembuatan berbagai jenis builder.

**Implementasi:**

**domain/combinations/BuilderFactory.kt**
```kotlin
package com.example.designpatterns.combinations

/**
 * Product yang kompleks
 */
class User private constructor(
    val id: String,
    val name: String,
    val email: String,
    val age: Int? = null,
    val phone: String? = null,
    val address: String? = null,
    val role: String? = null,
    val isPremium: Boolean = false,
    val permissions: List<String> = emptyList(),
    val preferences: Map<String, String> = emptyMap()
) {
    
    class Builder {
        private var id: String = "user_${System.currentTimeMillis()}"
        private var name: String = ""
        private var email: String = ""
        private var age: Int? = null
        private var phone: String? = null
        private var address: String? = null
        private var role: String? = null
        private var isPremium: Boolean = false
        private var permissions: List<String> = emptyList()
        private var preferences: Map<String, String> = emptyMap()
        
        fun id(id: String) = apply { this.id = id }
        fun name(name: String) = apply { this.name = name }
        fun email(email: String) = apply { this.email = email }
        fun age(age: Int) = apply { this.age = age }
        fun phone(phone: String) = apply { this.phone = phone }
        fun address(address: String) = apply { this.address = address }
        fun role(role: String) = apply { this.role = role }
        fun premium(isPremium: Boolean) = apply { this.isPremium = isPremium }
        fun permissions(permissions: List<String>) = apply { this.permissions = permissions }
        fun preferences(preferences: Map<String, String>) = apply { this.preferences = preferences }
        
        fun build(): User {
            require(name.isNotBlank()) { "Name cannot be blank" }
            require(email.isNotBlank() && email.contains("@")) { "Valid email required" }
            
            return User(
                id = id,
                name = name,
                email = email,
                age = age,
                phone = phone,
                address = address,
                role = role,
                isPremium = isPremium,
                permissions = permissions,
                preferences = preferences
            )
        }
    }
}

/**
 * Factory untuk membuat builder dengan konfigurasi berbeda
 */
interface UserBuilderFactory {
    fun createUserBuilder(): User.Builder
}

class RegularUserBuilderFactory : UserBuilderFactory {
    override fun createUserBuilder(): User.Builder {
        return User.Builder()
            .role("USER")
            .premium(false)
    }
}

class AdminUserBuilderFactory : UserBuilderFactory {
    override fun createUserBuilder(): User.Builder {
        return User.Builder()
            .role("ADMIN")
            .premium(true)
            .permissions(listOf("ALL_ACCESS", "MANAGE_USERS"))
    }
}

class PremiumUserBuilderFactory : UserBuilderFactory {
    override fun createUserBuilder(): User.Builder {
        return User.Builder()
            .premium(true)
            .preferences(mapOf("theme" to "dark", "notifications" to "enabled"))
    }
}

/**
 * Manager yang menggunakan factory untuk membuat builder
 */
class UserCreationManager(
    private val factory: UserBuilderFactory
) {
    fun createUser(userData: UserData): User {
        val builder = factory.createUserBuilder()
        
        return builder
            .name(userData.name)
            .email(userData.email)
            .age(userData.age)
            .build()
    }
}

data class UserData(
    val name: String,
    val email: String,
    val age: Int? = null
)

/**
 * Factory untuk memilih builder berdasarkan tipe user
 */
class FlexibleUserBuilderFactory : UserBuilderFactory {
    private val factories = mapOf(
        "regular" to RegularUserBuilderFactory(),
        "admin" to AdminUserBuilderFactory(),
        "premium" to PremiumUserBuilderFactory()
    )
    
    fun createUserBuilder(userType: String): User.Builder {
        val factory = factories[userType] ?: RegularUserBuilderFactory()
        return factory.createUserBuilder()
    }
    
    override fun createUserBuilder(): User.Builder {
        return RegularUserBuilderFactory().createUserBuilder()
    }
}
```

### 5. Decorator + Strategy:

**Konsep:**
Menggabungkan Decorator Pattern untuk menambah fungsionalitas dan Strategy Pattern untuk algoritma yang bisa diganti.

**Implementasi:**

**domain/combinations/DecoratorStrategy.kt**
```kotlin
package com.example.designpatterns.combinations

/**
 * Strategy interface untuk enkripsi
 */
interface EncryptionStrategy {
    fun encrypt(data: String): String
    fun decrypt(encryptedData: String): String
}

class AesEncryptionStrategy : EncryptionStrategy {
    override fun encrypt(data: String): String {
        return "AES_ENCRYPTED_$data"
    }
    
    override fun decrypt(encryptedData: String): String {
        return encryptedData.removePrefix("AES_ENCRYPTED_")
    }
}

class RsaEncryptionStrategy : EncryptionStrategy {
    override fun encrypt(data: String): String {
        return "RSA_ENCRYPTED_$data"
    }
    
    override fun decrypt(encryptedData: String): String {
        return encryptedData.removePrefix("RSA_ENCRYPTED_")
    }
}

/**
 * Decorator untuk menambahkan fungsionalitas tambahan
 */
abstract class EncryptionDecorator(
    protected val encryptionStrategy: EncryptionStrategy
) : EncryptionStrategy {
    override fun encrypt(data: String): String = encryptionStrategy.encrypt(data)
    override fun decrypt(encryptedData: String): String = encryptionStrategy.decrypt(encryptedData)
}

/**
 * Decorator untuk logging
 */
class LoggingEncryptionDecorator(
    encryptionStrategy: EncryptionStrategy
) : EncryptionDecorator(encryptionStrategy) {
    
    override fun encrypt(data: String): String {
        println("Encrypting: $data")
        val result = super.encrypt(data)
        println("Encrypted result: $result")
        return result
    }
    
    override fun decrypt(encryptedData: String): String {
        println("Decrypting: $encryptedData")
        val result = super.decrypt(encryptedData)
        println("Decrypted result: $result")
        return result
    }
}

/**
 * Decorator untuk compression
 */
class CompressionEncryptionDecorator(
    encryptionStrategy: EncryptionStrategy
) : EncryptionDecorator(encryptionStrategy) {
    
    override fun encrypt(data: String): String {
        val compressed = compress(data)
        return super.encrypt(compressed)
    }
    
    override fun decrypt(encryptedData: String): String {
        val decrypted = super.decrypt(encryptedData)
        return decompress(decrypted)
    }
    
    private fun compress(data: String): String {
        // Simple compression simulation
        return "COMPRESSED_$data"
    }
    
    private fun decompress(data: String): String {
        return data.removePrefix("COMPRESSED_")
    }
}

/**
 * Decorator untuk caching
 */
class CachingEncryptionDecorator(
    encryptionStrategy: EncryptionStrategy
) : EncryptionDecorator(encryptionStrategy) {
    
    private val encryptionCache = mutableMapOf<String, String>()
    private val decryptionCache = mutableMapOf<String, String>()
    
    override fun encrypt(data: String): String {
        return encryptionCache.getOrPut(data) {
            super.encrypt(data)
        }
    }
    
    override fun decrypt(encryptedData: String): String {
        return decryptionCache.getOrPut(encryptedData) {
            super.decrypt(encryptedData)
        }
    }
}

/**
 * Manager untuk menggabungkan decorator dan strategy
 */
class EncryptionManager {
    private var encryptionStrategy: EncryptionStrategy = AesEncryptionStrategy()
    
    fun setEncryptionStrategy(strategy: EncryptionStrategy) {
        this.encryptionStrategy = strategy
    }
    
    fun enableLogging() {
        this.encryptionStrategy = LoggingEncryptionDecorator(encryptionStrategy)
    }
    
    fun enableCompression() {
        this.encryptionStrategy = CompressionEncryptionDecorator(encryptionStrategy)
    }
    
    fun enableCaching() {
        this.encryptionStrategy = CachingEncryptionDecorator(encryptionStrategy)
    }
    
    fun encrypt(data: String): String {
        return encryptionStrategy.encrypt(data)
    }
    
    fun decrypt(encryptedData: String): String {
        return encryptionStrategy.decrypt(encryptedData)
    }
}

/**
 * Demonstrasi kombinasi decorator dan strategy
 */
fun demonstrateEncryptionCombinations() {
    val manager = EncryptionManager()
    
    // Gunakan RSA encryption dengan logging dan compression
    manager.setEncryptionStrategy(RsaEncryptionStrategy())
    manager.enableLogging()
    manager.enableCompression()
    
    val originalData = "Secret message"
    val encrypted = manager.encrypt(originalData)
    val decrypted = manager.decrypt(encrypted)
    
    println("Original: $originalData")
    println("Encrypted: $encrypted")  
    println("Decrypted: $decrypted")
}
```

### 6. MVVM dengan Berbagai Patterns:

**Konsep:**
Menggabungkan berbagai pattern dalam arsitektur MVVM untuk solusi komprehensif.

**presentation/mvvm/CombinedPatternsViewModel.kt**
```kotlin
package com.example.designpatterns.mvvm

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import com.example.designpatterns.strategy.PaymentStrategy
import com.example.designpatterns.observer.Observer

/**
 * ViewModel yang menggabungkan berbagai pattern
 */
class CombinedPatternsViewModel(
    private val userRepository: UserRepository,
    private val paymentStrategyFactory: PaymentStrategyFactory,
    private val eventObserver: Observer<AppEvent>
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UiState<User>>(UiState.Loading)
    val uiState: StateFlow<UiState<User>> = _uiState.asStateFlow()
    
    private val _paymentResult = MutableStateFlow<PaymentResult?>(null)
    val paymentResult: StateFlow<PaymentResult?> = _paymentResult.asStateFlow()
    
    fun loadUser(userId: String) {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            
            try {
                val user = userRepository.getUserById(userId)
                _uiState.value = if (user != null) {
                    UiState.Success(user)
                } else {
                    UiState.Error("User not found")
                }
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message ?: "Unknown error")
            }
        }
    }
    
    suspend fun processPayment(
        userId: String,
        amount: Double,
        paymentType: PaymentType
    ) {
        val paymentStrategy = paymentStrategyFactory.createStrategy(paymentType)
        val result = paymentStrategy.pay(amount)
        
        _paymentResult.value = result
        
        // Kirim event jika payment sukses
        if (result is PaymentResult.Success) {
            eventObserver.onChanged(AppEvent.PaymentSuccess(userId, amount))
        }
    }
    
    fun retryPayment() {
        val currentResult = _paymentResult.value
        if (currentResult is PaymentResult.Failure) {
            // Implementasi retry logic
        }
    }
}

/**
 * Enum untuk tipe payment
 */
enum class PaymentType {
    CREDIT_CARD, PAYPAL, BANK_TRANSFER
}

/**
 * Hasil UI
 */
sealed class UiState<out T> {
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(val message: String) : UiState<Nothing>()
}

/**
 * Hasil payment
 */
sealed class PaymentResult {
    data class Success(val message: String) : PaymentResult()
    data class Failure(val message: String) : PaymentResult()
}

/**
 * Event aplikasi
 */
sealed class AppEvent {
    data class PaymentSuccess(val userId: String, val amount: Double) : AppEvent()
}

/**
 * Interface untuk factory
 */
interface PaymentStrategyFactory {
    fun createStrategy(paymentType: PaymentType): PaymentStrategy
}

/**
 * Interface untuk repository
 */
interface UserRepository {
    suspend fun getUserById(id: String): User?
}
```

### üéì Penjelasan Konsep:
**Pattern Combinations seperti Orkestra:**
- **Harmonis**: Berbagai pattern bekerja bersama
- **Koordinasi**: Setiap pattern berperan sesuai fungsinya
- **Efektif**: Solusi lebih kuat dari kombinasi
- **Fleksibel**: Bisa disusun berbagai cara

**Manfaat Pattern Combinations:**
- **Solusi Komprehensif**: Menangani banyak aspek sekaligus
- **Maintainability**: Setiap pattern tetap fokus pada perannya
- **Ekstensibilitas**: Mudah menambah pattern baru
- **Best Practices**: Mengikuti praktik terbaik industri

---

## 7Ô∏è‚É£ When to Use Patterns üéØ

### Konsep Dasar
When to Use Patterns seperti buku panduan üìñ - kapan dan mengapa menggunakan pattern tertentu!

### 1. DO Use Patterns When:

**‚úÖ Problem fits pattern perfectly:**
```kotlin
// Gunakan Factory Pattern ketika:
// - Ada pembuatan objek yang kompleks
// - Ada beberapa implementasi dari interface yang sama
// - Tipe objek ditentukan saat runtime

interface Shape {
    fun draw()
}

class Circle : Shape { override fun draw() = println("Drawing circle") }
class Square : Shape { override fun draw() = println("Drawing square") }
class Triangle : Shape { override fun draw() = println("Drawing triangle") }

class ShapeFactory {
    fun createShape(type: String): Shape {
        return when (type.lowercase()) {
            "circle" -> Circle()
            "square" -> Square()
            "triangle" -> Triangle()
            else -> throw IllegalArgumentException("Unknown shape type")
        }
    }
}

// Penggunaan yang tepat
val factory = ShapeFactory()
val circle = factory.createShape("circle") // ‚úÖ Cocok untuk factory pattern
```

**‚úÖ Code becomes more maintainable:**
```kotlin
// Gunakan Strategy Pattern ketika:
// - Ada algoritma yang bisa berubah
// - Perlu menghindari if-else yang banyak

interface SortStrategy {
    fun <T : Comparable<T>> sort(list: List<T>): List<T>
}

class BubbleSortStrategy : SortStrategy {
    override fun <T : Comparable<T>> sort(list: List<T>): List<T> {
        // Implementasi bubble sort
        return list.toMutableList().sorted()
    }
}

class QuickSortStrategy : SortStrategy {
    override fun <T : Comparable<T>> sort(list: List<T>): List<T> {
        // Implementasi quick sort
        return list.sorted()
    }
}

class DataProcessor(
    private var sortStrategy: SortStrategy
) {
    fun processData(data: List<Int>): List<Int> {
        // Kode lebih mudah dipelihara karena algoritma bisa diubah
        return sortStrategy.sort(data)
    }
    
    fun changeSortStrategy(newStrategy: SortStrategy) {
        this.sortStrategy = newStrategy // ‚úÖ Memudahkan perubahan algoritma
    }
}
```

**‚úÖ Team understands the pattern:**
```kotlin
// Gunakan Observer Pattern ketika:
// - Tim memahami pattern ini
// - Ada kebutuhan untuk notifikasi event

interface Observer<T> {
    fun onUpdated(data: T)
}

interface Subject<T> {
    fun subscribe(observer: Observer<T>)
    fun unsubscribe(observer: Observer<T>)
    fun notify(data: T)
}

// Jika tim terbiasa dengan LiveData/Flow, maka Observer pattern cocok
class UserSubject : Subject<User> {
    private val observers = mutableListOf<Observer<User>>()
    
    override fun subscribe(observer: Observer<User>) {
        observers.add(observer) // ‚úÖ Tim mengerti cara kerja subscription
    }
    
    // ... implementasi lainnya
}
```

**‚úÖ Future extensibility needed:**
```kotlin
// Gunakan Command Pattern ketika:
// - Akan ada fitur undo/redo
// - Akan ada lebih banyak command di masa depan

interface Command {
    suspend fun execute()
    suspend fun undo()
}

class SaveUserCommand(
    private val userRepository: UserRepository,
    private val user: User
) : Command {
    private var previousUser: User? = null
    
    override suspend fun execute() {
        previousUser = userRepository.findById(user.id)
        userRepository.save(user) // ‚úÖ Mudah ditambah command lain
    }
    
    override suspend fun undo() {
        previousUser?.let { userRepository.save(it) }
    }
}

// Karena desainnya fleksibel, mudah menambah command baru
class DeleteUserCommand(
    private val userRepository: UserRepository,
    private val userId: String
) : Command {
    // Implementasi untuk delete command
    override suspend fun execute() { /* ... */ }
    override suspend fun undo() { /* ... */ }
}
```

### 2. DON'T Use Patterns When:

**‚ùå Over-engineering simple problems:**
```kotlin
// ‚ùå Terlalu berlebihan untuk fungsi sederhana
interface CalculatorStrategy {
    fun calculate(a: Int, b: Int): Int
}

class AddStrategy : CalculatorStrategy {
    override fun calculate(a: Int, b: Int) = a + b
}

class CalculatorService(
    private val strategy: CalculatorStrategy
) {
    fun add(a: Int, b: Int) = strategy.calculate(a, b) // ‚ùå Berlebihan!
}

// ‚úÖ Solusi yang lebih sederhana
object SimpleCalculator {
    fun add(a: Int, b: Int) = a + b // ‚úÖ Cukup untuk fungsi sederhana
}
```

**‚ùå Team unfamiliar with pattern:**
```kotlin
// ‚ùå Jangan gunakan pattern yang tidak dipahami tim
class ComplexDecoratorExample(
    private val processor: DataProcessor,
    private val validator: DataValidator,
    private val transformer: DataTransformer
) {
    // Jika tim tidak paham decorator pattern, jangan gunakan
    // Karena akan membuat kode lebih sulit dipelihara
}
```

**‚ùå Adds unnecessary complexity:**
```kotlin
// ‚ùå Pattern menambah kompleksitas tanpa manfaat
class UnnecessarySingleton {
    companion object {
        @Volatile
        private var instance: UnnecessarySingleton? = null
        
        fun getInstance(): UnnecessarySingleton {
            return instance ?: synchronized(this) {
                instance ?: UnnecessarySingleton().also { instance = it }
            }
        }
    }
    
    fun doSomething() {
        // Jika fungsi ini tidak perlu instance tunggal,
        // maka singleton tidak diperlukan dan menambah kompleksitas
    }
}

// ‚úÖ Solusi lebih sederhana
class SimpleService {
    fun doSomething() {
        // Cukup sebagai fungsi biasa
    }
}
```

**‚ùå YAGNI (You Aren't Gonna Need It):**
```kotlin
// ‚ùå Jangan antisipasi fitur yang mungkin tidak akan dibutuhkan
interface PaymentProcessor {
    suspend fun processPayment(amount: Double): PaymentResult
}

class FlexiblePaymentProcessor(
    private val strategies: Map<PaymentMethod, PaymentStrategy>
) : PaymentProcessor {
    // Jika hanya ada satu metode pembayaran saat ini,
    // maka fleksibilitas ini mungkin tidak dibutuhkan sekarang
    
    override suspend fun processPayment(amount: Double): PaymentResult {
        // Kode menjadi kompleks untuk sesuatu yang belum tentu dibutuhkan
    }
}

// ‚úÖ Mulai sederhana
class SimplePaymentProcessor {
    suspend fun processPayment(amount: Double): PaymentResult {
        // Implementasi langsung sesuai kebutuhan saat ini
        return PaymentResult.Success("Paid $$amount")
    }
}
```

### 3. Pattern Selection Guidelines:

**Matriks Pemilihan Pattern:**
```
Kasus Kehidupan Nyata ‚Üí Pattern yang Cocok

1. Pembuatan objek kompleks ‚Üí Builder Pattern
2. Ada beberapa tipe objek ‚Üí Factory Pattern  
3. Butuh instance tunggal ‚Üí Singleton Pattern
4. Algoritma bisa berubah ‚Üí Strategy Pattern
5. Update otomatis dibutuhkan ‚Üí Observer Pattern
6. Perilaku berubah saat runtime ‚Üí State Pattern
7. Logging/monitoring dibutuhkan ‚Üí Decorator Pattern
8. Komunikasi antar komponen ‚Üí Event Bus Pattern
9. Sistem kompleks perlu disederhanakan ‚Üí Facade Pattern
10. Struktur pohon diperlukan ‚Üí Composite Pattern
```

**Kriteria Evaluasi:**
```kotlin
class PatternEvaluator {
    fun shouldUsePattern(
        currentComplexity: Int,
        expectedComplexity: Int,
        teamKnowledge: Boolean,
        futureExtensibility: Boolean
    ): Boolean {
        // Gunakan pattern jika:
        // - Kompleksitas akan meningkat
        // - Tim paham pattern
        // - Memudahkan ekstensibilitas
        // - Tidak over-engineering
        return expectedComplexity > currentComplexity &&
               teamKnowledge &&
               futureExtensibility
    }
}
```

### 4. Migration Strategy:

**Langkah-langkah mengadopsi pattern:**
```kotlin
class PatternAdoptionStrategy {
    fun gradualAdoption() {
        // 1. Identifikasi area bermasalah
        // 2. Pilih pattern yang paling cocok
        // 3. Terapkan secara bertahap
        // 4. Test dan refaktor jika perlu
        // 5. Training tim jika diperlukan
    }
    
    fun patternSelection(
        problemType: ProblemType,
        context: Context
    ): PatternRecommendation {
        return when (problemType) {
            ProblemType.OBJECT_CREATION -> PatternRecommendation.FactoryPattern
            ProblemType.ALGORITHM_VARIATION -> PatternRecommendation.StrategyPattern
            ProblemType.EVENT_HANDLING -> PatternRecommendation.ObserverPattern
            ProblemType.STATE_DEPENDENT -> PatternRecommendation.StatePattern
            ProblemType.COMPLEX_SYSTEM -> PatternRecommendation.FacadePattern
            else -> PatternRecommendation.NoPattern
        }
    }
}

enum class ProblemType {
    OBJECT_CREATION,
    ALGORITHM_VARIATION,
    EVENT_HANDLING,
    STATE_DEPENDENT,
    COMPLEX_SYSTEM
}

enum class PatternRecommendation {
    FactoryPattern,
    StrategyPattern,
    ObserverPattern,
    StatePattern,
    FacadePattern,
    NoPattern
}

data class Context(
    val complexityLevel: Int,
    val performanceNeeds: Boolean,
    val teamExpertise: Int
)
```

### üéì Penjelasan Konsep:
**Kapan Menggunakan Pattern seperti Navigasi:**
- **Tujuan jelas**: Tahu masalah yang dihadapi
- **Peta baca**: Tahu pattern yang tersedia
- **Kondisi diperhitungkan**: Tim, waktu, kompleksitas
- **Jalan yang benar**: Pilihan pattern yang tepat

**Prinsip dalam Pemilihan Pattern:**
- **Start Simple**: Mulai dari solusi sederhana
- **Evolve Gradually**: Kembangkan saat diperlukan
- **Team First**: Pertimbangkan kemampuan tim
- **Problem Focused**: Fokus pada masalah, bukan pattern

---

## 8Ô∏è‚É£ Anti-Patterns ‚ö†Ô∏è

### Konsep Dasar
Anti-Patterns seperti jebakan yang harus dihindari üö´ - pola yang tampak bagus tapi sebenarnya merusak!

### 1. God Object:

**Konsep:**
God Object adalah objek yang melakukan terlalu banyak hal dan mengetahui terlalu banyak.

**Problematika:**
- Melanggar SRP (Single Responsibility Principle)
- Sulit diuji dan dipelihara
- Coupling yang tinggi
- Sering berubah

**Contoh Anti-Pattern:**
```kotlin
// ‚ùå GOD OBJECT - ANTI PATTERN
class GodObject {
    // Network operations
    fun makeApiCall(url: String, data: String): String {
        val connection = URL(url).openConnection() as HttpURLConnection
        connection.requestMethod = "POST"
        connection.doOutput = true
        // ... implementation
        return "response"
    }
    
    // Database operations  
    fun saveToDatabase(entity: Any) {
        // SQLite implementation
    }
    
    // UI operations
    fun updateUI(view: View, data: String) {
        // UI update logic
    }
    
    // File operations
    fun saveToFile(filename: String, data: String) {
        // File handling
    }
    
    // Analytics operations
    fun logEvent(event: String) {
        // Analytics implementation
    }
    
    // Validation operations
    fun validateEmail(email: String): Boolean {
        return email.contains("@")
    }
    
    // Encryption operations
    fun encryptData(data: String): String {
        // Encryption logic
    }
    
    // Notification operations
    fun sendNotification(title: String, message: String) {
        // Notification logic
    }
    
    // Cache operations
    fun cacheData(key: String, data: String) {
        // Cache logic
    }
    
    // Logging operations
    fun log(message: String) {
        // Logging logic
    }
    
    // Dan banyak method lainnya...
}
```

**Solusi:**
```kotlin
// ‚úÖ PEMECAHAN GOD OBJECT
interface NetworkService {
    suspend fun makeApiCall(url: String, data: String): String
}

interface DatabaseService {
    suspend fun save(entity: Any)
}

interface UIService {
    fun updateUI(view: View, data: String)
}

interface FileService {
    suspend fun save(filename: String, data: String)
}

interface AnalyticsService {
    suspend fun logEvent(event: String)
}

class UserService(
    private val networkService: NetworkService,
    private val databaseService: DatabaseService,
    private val validationService: ValidationService
) {
    // Hanya fokus pada user-specific logic
}
```

### 2. Spaghetti Code:

**Konsep:**
Kode yang tidak terstruktur dengan kontrol alur yang kompleks dan sulit dipahami.

**Problematika:**
- Struktur kontrol yang kompleks
- Banyak nested if-else
- Goto statements (jarang di Kotlin)
- Fungsi yang terlalu panjang

**Contoh Anti-Pattern:**
```kotlin
// ‚ùå SPAGHETTI CODE - ANTI PATTERN
fun complexBusinessLogic(input: String): String {
    var result = ""
    
    if (input.isNotEmpty()) {
        if (input.contains("@")) {
            if (input.length > 5) {
                if (input.startsWith("admin")) {
                    // 20 baris logika kompleks di sini
                    if (someCondition1()) {
                        if (someCondition2()) {
                            if (someCondition3()) {
                                // bahkan lebih banyak nested if
                                result = "admin_valid"
                            } else {
                                result = "admin_invalid_condition3"
                            }
                        } else {
                            result = "admin_invalid_condition2"
                        }
                    } else {
                        result = "admin_invalid_condition1"
                    }
                } else if (input.startsWith("user")) {
                    // lebih banyak nested logic
                    if (anotherCondition()) {
                        // ... dan seterusnya
                        result = "user_valid"
                    } else {
                        result = "user_invalid"
                    }
                } else {
                    result = "unknown_type"
                }
            } else {
                result = "too_short"
            }
        } else {
            result = "invalid_format"
        }
    } else {
        result = "empty_input"
    }
    
    return result
}
```

**Solusi:**
```kotlin
// ‚úÖ PEMECAHAN SPAGHETTI CODE
class InputValidator {
    fun validate(input: String): ValidationResult {
        return when {
            input.isBlank() -> ValidationResult.Empty
            input.length < MIN_LENGTH -> ValidationResult.TooShort
            !isValidFormat(input) -> ValidationResult.InvalidFormat
            isSpecialCase(input) -> handleSpecialCase(input)
            else -> ValidationResult.Valid
        }
    }
    
    private fun isSpecialCase(input: String): Boolean = 
        input.startsWith("admin") || input.startsWith("user")
    
    private fun handleSpecialCase(input: String): ValidationResult {
        return when {
            input.startsWith("admin") -> validateAdminInput(input)
            input.startsWith("user") -> validateUserInput(input)
            else -> ValidationResult.UnknownType
        }
    }
    
    private fun validateAdminInput(input: String): ValidationResult {
        // logika validasi admin
        return if (adminConditionsMet(input)) ValidationResult.Valid else ValidationResult.Invalid
    }
    
    private fun validateUserInput(input: String): ValidationResult {
        // logika validasi user
        return if (userConditionsMet(input)) ValidationResult.Valid else ValidationResult.Invalid
    }
    
    companion object {
        private const val MIN_LENGTH = 5
    }
}

sealed class ValidationResult {
    object Valid : ValidationResult()
    object Empty : ValidationResult()
    object TooShort : ValidationResult()
    object InvalidFormat : ValidationResult()
    object UnknownType : ValidationResult()
    object Invalid : ValidationResult()
}
```

### 3. Lava Flow:

**Konsep:**
Kode mati yang tetap ada dalam sistem, seperti lava yang sudah mengeras tapi masih menghalangi jalan.

**Problematika:**
- Kode yang tidak pernah dipanggil
- Fungsi yang tidak digunakan
- Komentar yang membingungkan
- Duplikasi kode

**Contoh Anti-Pattern:**
```kotlin
// ‚ùå LAVA FLOW - ANTI PATTERN
class LavaFlowExample {
    // Fungsi yang tidak pernah dipanggil
    fun obsoleteFunction() {
        // kode lama yang tidak digunakan
    }
    
    // Variabel yang tidak digunakan
    var unusedVariable = "ini tidak pernah digunakan"
    
    // Fungsi dengan logika lama yang tidak relevan
    fun oldCalculationLogic() {
        // kode yang tidak relevan dengan bisnis saat ini
        // tapi tidak dihapus karena takut rusak
    }
    
    // Komentar yang membingungkan
    fun complexFunction() {
        // TODO: refactor this - ditulis 2 tahun lalu
        // FIXME: this is broken - tetap belum diperbaiki
        // BUG: something is wrong here - tidak pernah ditelusuri
        
        // Banyak kode yang sekarang tidak relevan
    }
    
    // Duplikasi logika
    fun processUser1(user: User) {
        // logika validasi dan pemrosesan
    }
    
    fun processUser2(user: User) {
        // kode yang sama persis dengan processUser1
    }
    
    fun processUser3(user: User) {
        // dan satu lagi duplikat
    }
}
```

**Solusi:**
```kotlin
// ‚úÖ PEMECAHAN LAVA FLOW
class CleanExample {
    // Hanya fungsi yang digunakan
    fun processUser(user: User): ProcessResult {
        return validateUser(user)
            .takeIf { it.isValid }
            ?.let { processData(user) }
            ?: ProcessResult.InvalidUser
    }
    
    private fun validateUser(user: User): ValidationResult {
        // logika validasi yang reusable
    }
    
    private fun processData(user: User): ProcessResult {
        // logika pemrosesan yang reusable
    }
}

data class ProcessResult(val success: Boolean, val message: String)
```

### 4. Golden Hammer:

**Konsep:**
Penggunaan satu pattern untuk semua masalah tanpa mempertimbangkan kecocokan.

**Problematika:**
- Penggunaan pattern yang tidak tepat
- Over-engineering
- Kompleksitas tidak perlu
- Kode yang sulit dipahami

**Contoh Anti-Pattern:**
```kotlin
// ‚ùå GOLDEN HAMMER - ANTI PATTERN
// Menggunakan observer pattern untuk semua hal
class ObserverObsessed {
    private val userObservers = mutableListOf<(User) -> Unit>()
    private val stringObservers = mutableListOf<(String) -> Unit>()
    private val intObservers = mutableListOf<(Int) -> Unit>()
    private val booleanObservers = mutableListOf<(Boolean) -> Unit>()
    
    // Bahkan untuk fungsi sederhana
    fun simpleAddition(a: Int, b: Int): Int {
        val result = a + b
        intObservers.forEach { it(result) }  // ‚ùå Tidak perlu!
        return result
    }
    
    fun simpleValidation(email: String): Boolean {
        val isValid = email.contains("@")
        booleanObservers.forEach { it(isValid) }  // ‚ùå Tidak perlu!
        return isValid
    }
    
    fun simpleConcatenation(str1: String, str2: String): String {
        val result = str1 + str2
        stringObservers.forEach { it(result) }  // ‚ùå Tidak perlu!
        return result
    }
}
```

**Solusi:**
```kotlin
// ‚úÖ PENGGUNAAN YANG TEPAT
class AppropriateUsage {
    // Gunakan observer pattern hanya ketika diperlukan
    private val userChangeObservers = mutableListOf<(User) -> Unit>()
    
    fun notifyUserChange(user: User) {
        // Observer cocok untuk notifikasi perubahan user
        userChangeObservers.forEach { it(user) }
    }
    
    // Fungsi sederhana tidak perlu observer
    fun simpleAddition(a: Int, b: Int): Int = a + b  // ‚úÖ Cukup sederhana
    
    fun simpleValidation(email: String): Boolean = email.contains("@")  // ‚úÖ Cukup sederhana
}
```

### 5. Premature Optimization:

**Konsep:**
Mengoptimasi kode sebelum mengetahui apakah benar-benar perlu dioptimasi.

**Problematika:**
- Kode menjadi kompleks tanpa manfaat
- Pemborosan waktu dan sumber daya
- Debugging yang sulit
- Potensi bug baru

**Contoh Anti-Pattern:**
```kotlin
// ‚ùå PREMATURE OPTIMIZATION - ANTI PATTERN
class PrematureOptimizationExample {
    // Membuat caching kompleks untuk fungsi sederhana
    private val cache = mutableMapOf<String, String>()
    private val cacheLock = java.util.concurrent.locks.ReentrantLock()
    
    fun processSimpleData(input: String): String {
        // Caching untuk operasi yang cepat
        cacheLock.lock()
        try {
            return cache.getOrPut(input) {
                // operasi sederhana yang cepat
                input.uppercase().trim()
            }
        } finally {
            cacheLock.unlock()
        }
    }
    
    // Membuat async untuk operasi yang tidak perlu async
    fun getSimpleValue(): String = runBlocking {
        withContext(Dispatchers.Default) {
            // operasi yang cepat di-thread lain
            "value".uppercase()
        }
    }
    
    // Membuat kompleksitas untuk performa yang tidak terlihat
    fun processData(list: List<String>): List<String> {
        // Menggunakan parallel processing untuk list kecil
        return list.parallelStream().map { 
            it.uppercase() 
        }.collect(Collectors.toList())
    }
}
```

**Solusi:**
```kotlin
// ‚úÖ PENDEKATAN YANG BENAR
class ProperOptimization {
    // Mulai sederhana, optimasi saat diperlukan
    fun processSimpleData(input: String): String {
        return input.uppercase().trim()  // ‚úÖ Sederhana dan cukup
    }
    
    // Baru tambahkan optimasi saat ada masalah
    fun processLargeData(input: String): String {
        // Setelah profiling, ternyata caching dibutuhkan
        return expensiveOperation(input)
    }
    
    private fun expensiveOperation(input: String): String {
        // Operasi yang benar-benar mahal
        return input.uppercase().trim()
    }
    
    // Gunakan async hanya ketika benar-benar perlu
    suspend fun processAsync(input: String): String {
        return withContext(Dispatchers.IO) {
            // Operasi I/O yang mahal
            performIOOperation(input)
        }
    }
    
    private fun performIOOperation(input: String): String {
        // Operasi I/O sebenarnya
        return input
    }
}
```

### 6. Magic Numbers/Strings:

**Konsep:**
Menggunakan angka atau string langsung dalam kode tanpa penjelasan.

**Problematika:**
- Tidak jelas maknanya
- Sulit diubah
- Rawan kesalahan
- Tidak maintainable

**Contoh Anti-Pattern:**
```kotlin
// ‚ùå MAGIC NUMBERS/STRINGS - ANTI PATTERN
class MagicNumbersExample {
    fun validateUser(user: User): Boolean {
        // Angka dan string misterius
        if (user.age < 18) return false  // ‚ùå Angka misterius
        if (user.balance > 1000000) return false  // ‚ùå Angka misterius
        
        val status = user.status
        if (status == "ACT") return true  // ‚ùå String misterius
        if (status == "INACT") return false  // ‚ùå String misterius
        
        return user.type == "PREMIUM"  // ‚ùå String misterius
    }
    
    fun processOrder(order: Order) {
        // Lebih banyak magic numbers
        if (order.quantity > 100) {
            order.discount = 0.1  // ‚ùå Angka misterius
        } else if (order.quantity > 50) {
            order.discount = 0.05  // ‚ùå Angka misterius
        }
        
        if (order.priority == 1) return  // ‚ùå Angka misterius
        if (order.category == "ELEC") return  // ‚ùå String misterius
    }
    
    fun handleNetworkResponse(response: String) {
        if (response.startsWith("200")) {  // ‚ùå String misterius
            // handle success
        } else if (response.startsWith("404")) {  // ‚ùå String misterius
            // handle not found
        } else if (response.startsWith("500")) {  // ‚ùå String misterius
            // handle server error
        }
    }
}
```

**Solusi:**
```kotlin
// ‚úÖ PEMECAHAN MAGIC NUMBERS/STRINGS
class ConstantsExample {
    companion object {
        // Definisikan konstanta dengan nama yang jelas
        const val LEGAL_AGE = 18
        const val MAX_BALANCE = 1_000_000
        const val PREMIUM_THRESHOLD = 100
        const val REGULAR_THRESHOLD = 50
        const val HIGH_PRIORITY = 1
        
        const val STATUS_ACTIVE = "ACTIVE"
        const val STATUS_INACTIVE = "INACTIVE"
        const val USER_TYPE_PREMIUM = "PREMIUM"
        
        const val CATEGORY_ELECTRONICS = "ELECTRONICS"
        const val CATEGORY_CLOTHING = "CLOTHING"
        
        const val HTTP_SUCCESS = "200"
        const val HTTP_NOT_FOUND = "404" 
        const val HTTP_SERVER_ERROR = "500"
    }
}

class ProperConstantsUsage {
    fun validateUser(user: User): Boolean {
        if (user.age < ConstantsExample.LEGAL_AGE) return false  // ‚úÖ Jelas maksudnya
        if (user.balance > ConstantsExample.MAX_BALANCE) return false  // ‚úÖ Jelas maksudnya
        
        return when (user.status) {
            ConstantsExample.STATUS_ACTIVE -> true
            ConstantsExample.STATUS_INACTIVE -> false
            else -> user.type == ConstantsExample.USER_TYPE_PREMIUM
        }
    }
    
    fun processOrder(order: Order) {
        order.discount = when {
            order.quantity > ConstantsExample.PREMIUM_THRESHOLD -> 0.1
            order.quantity > ConstantsExample.REGULAR_THRESHOLD -> 0.05
            else -> 0.0
        }
        
        if (order.priority == ConstantsExample.HIGH_PRIORITY) return
    }
}
```

### 7. Circular Dependencies:

**Konsep:**
Ketika dua atau lebih class saling tergantung satu sama lain secara siklik.

**Problematika:**
- Kesulitan testing
- Tight coupling
- Masalah inisialisasi
- Sulit dipelihara

**Contoh Anti-Pattern:**
```kotlin
// ‚ùå CIRCULAR DEPENDENCIES - ANTI PATTERN
class UserManager {
    private val notificationManager = NotificationManager(this)  // ‚ùå Tergantung ke NotificationManager
    
    fun createUser() {
        // logic pembuatan user
        notificationManager.sendWelcomeNotification()  // ‚ùå Menggunakan NotificationManager
    }
}

class NotificationManager(private val userManager: UserManager) {  // ‚ùå Tergantung ke UserManager
    fun sendWelcomeNotification() {
        // logic kirim notifikasi
        userManager.updateUserStatus()  // ‚ùå Menggunakan UserManager
    }
    
    fun updateUserStatus() {
        // logic update status
    }
}
```

**Solusi:**
```kotlin
// ‚úÖ PEMECAHAN CIRCULAR DEPENDENCIES
interface UserEventNotifier {
    fun notifyUserCreated(userId: String)
    fun notifyUserUpdated(userId: String)
}

class UserManager(private val eventNotifier: UserEventNotifier) {
    fun createUser(): String {
        val userId = generateUserId()
        // logic pembuatan user
        eventNotifier.notifyUserCreated(userId)  // ‚úÖ Tidak tergantung NotificationManager langsung
        return userId
    }
}

class NotificationManager : UserEventNotifier {
    override fun notifyUserCreated(userId: String) {
        // logic kirim notifikasi
        sendWelcomeNotification(userId)
    }
    
    override fun notifyUserUpdated(userId: String) {
        // logic kirim notifikasi update
    }
    
    private fun sendWelcomeNotification(userId: String) {
        // logic kirim welcome notification
    }
}

// Atau dengan event bus
object EventBus {
    private val listeners = mutableListOf<(UserEvent) -> Unit>()
    
    fun subscribe(listener: (UserEvent) -> Unit) {
        listeners.add(listener)
    }
    
    fun publish(event: UserEvent) {
        listeners.forEach { it(event) }
    }
}
```

### üéì Penjelasan Konsep:
**Anti-Patterns seperti Jalan Berlubang:**
- **Harus dihindari**: Tidak membawa manfaat
- **Berbahaya**: Bisa merusak arsitektur
- **Sulit dideteksi**: Tampak bagus tapi berbahaya
- **Perlu kesadaran**: Harus diwaspadai tim

**Cara Menghindari Anti-Patterns:**
- **Code Review**: Deteksi dini
- **Refactoring**: Perbaiki saat ditemukan
- **Training**: Edukasi tim
- **Tools**: Gunakan static analysis

---

## 9Ô∏è‚É£ Patterns dalam Real Android Apps üèóÔ∏è

### Konsep Dasar
Patterns dalam Real Android Apps seperti fondasi gedung sebenarnya üè¢ - penerapan nyata dalam aplikasi produksi!

### 1. MVVM = Observer + Repository:

**Konsep:**
Kombinasi Observer Pattern (LiveData/Flow) dan Repository Pattern dalam arsitektur MVVM.

**Implementasi:**
```kotlin
// domain/repository/UserRepository.kt
interface UserRepository {
    suspend fun getUserById(id: String): User?
    suspend fun getUsers(): List<User>
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
    fun observeUsers(): Flow<List<User>>
}

// data/repository/UserRepositoryImpl.kt
class UserRepositoryImpl(
    private val localDataSource: UserLocalDataSource,
    private val remoteDataSource: UserRemoteDataSource
) : UserRepository {
    
    override suspend fun getUserById(id: String): User? {
        // Coba lokal dulu, jika tidak ada ambil dari remote dan cache
        var user = localDataSource.getUserById(id)
        if (user == null) {
            user = remoteDataSource.fetchUserById(id)
            user?.let { localDataSource.saveUser(it) }
        }
        return user
    }
    
    override suspend fun getUsers(): List<User> {
        val localUsers = localDataSource.getUsers()
        val remoteUsers = remoteDataSource.fetchUsers()
        
        // Update lokal dengan data terbaru
        remoteUsers.forEach { user ->
            localDataSource.saveUser(user)
        }
        
        return localDataSource.getUsers()
    }
    
    override fun observeUsers(): Flow<List<User>> {
        // Gunakan flow untuk live data
        return localDataSource.observeUsers()
    }
}

// presentation/viewmodel/UserViewModel.kt
class UserViewModel(
    private val getUserUseCase: GetUserUseCase,
    private val getUsersUseCase: GetUsersUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UiState<List<User>>>(UiState.Loading)
    val uiState: StateFlow<UiState<List<User>>> = _uiState.asStateFlow()
    
    private val _selectedUser = MutableStateFlow<User?>(null)
    val selectedUser: StateFlow<User?> = _selectedUser.asStateFlow()
    
    init {
        loadUsers()
    }
    
    fun loadUsers() {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            
            try {
                // Gunakan flow untuk observasi data
                getUsersUseCase().collect { users ->
                    _uiState.value = UiState.Success(users)
                }
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message ?: "Unknown error")
            }
        }
    }
    
    fun selectUser(user: User) {
        _selectedUser.value = user
    }
}

// presentation/ui/UserListScreen.kt (untuk Jetpack Compose)
@Composable
fun UserListScreen(
    viewModel: UserViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val selectedUser by viewModel.selectedUser.collectAsState()
    
    Column {
        when (val state = uiState) {
            is UiState.Loading -> {
                CircularProgressIndicator()
            }
            is UiState.Success -> {
                LazyColumn {
                    items(state.data) { user ->
                        UserItem(
                            user = user,
                            onClick = { viewModel.selectUser(user) }
                        )
                    }
                }
            }
            is UiState.Error -> {
                Text("Error: ${state.message}")
            }
        }
        
        // Tampilkan user yang dipilih
        selectedUser?.let { user ->
            Text("Selected: ${user.name}")
        }
    }
}
```

### 2. Clean Architecture = Layers + DIP:

**Konsep:**
Kombinasi berbagai pattern dalam arsitektur Clean untuk pemisahan concern yang jelas.

**Struktur:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PRESENTATION  ‚îÇ    ‚îÇ    DOMAIN        ‚îÇ    ‚îÇ     DATA        ‚îÇ
‚îÇ   ViewModel     ‚îÇ ‚Üê‚Üí ‚îÇ   Use Cases      ‚îÇ ‚Üê‚Üí ‚îÇ   Repository    ‚îÇ
‚îÇ   UI            ‚îÇ    ‚îÇ   Interfaces     ‚îÇ    ‚îÇ   Implementations‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                       ‚îÇ                        ‚îÇ
       ‚ñº                       ‚ñº                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   COMPOSABLES   ‚îÇ    ‚îÇ     MODEL        ‚îÇ    ‚îÇ Data Sources    ‚îÇ
‚îÇ   Activities    ‚îÇ    ‚îÇ     Entities     ‚îÇ    ‚îÇ API, Database   ‚îÇ
‚îÇ   Fragments     ‚îÇ    ‚îÇ   Validation     ‚îÇ    ‚îÇ SharedPrefs     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Implementasi:**
```kotlin
// domain/usecase/GetUserUseCase.kt
class GetUserUseCase(
    private val repository: UserRepository
) {
    suspend operator fun invoke(userId: String): User? {
        return repository.getUserById(userId)
    }
}

class GetUsersUseCase(
    private val repository: UserRepository
) {
    operator fun invoke(): Flow<List<User>> {
        return repository.observeUsers()
    }
}

// domain/model/User.kt
data class User(
    val id: String,
    val name: String,
    val email: String,
    val isActive: Boolean = true,
    val createdAt: Long = System.currentTimeMillis()
)

// domain/validation/UserValidator.kt
object UserValidator {
    fun validateEmail(email: String): ValidationResult {
        return if (email.isBlank() || !email.contains("@")) {
            ValidationResult.Error("Invalid email format")
        } else {
            ValidationResult.Success
        }
    }
}

// data/repository/UserRepositoryImpl.kt (sudah dilihat sebelumnya)

// presentation/di/RepositoryModule.kt
@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {
    
    @Provides
    @Singleton
    fun provideUserRepository(
        localDataSource: UserLocalDataSource,
        remoteDataSource: UserRemoteDataSource
    ): UserRepository {
        return UserRepositoryImpl(localDataSource, remoteDataSource)
    }
}

// presentation/di/UseCaseModule.kt
@Module
@InstallIn(SingletonComponent::class)
object UseCaseModule {
    
    @Provides
    fun provideGetUserUseCase(repository: UserRepository): GetUserUseCase {
        return GetUserUseCase(repository)
    }
    
    @Provides  
    fun provideGetUsersUseCase(repository: UserRepository): GetUsersUseCase {
        return GetUsersUseCase(repository)
    }
}
```

### 3. Retrofit = Builder + Factory + Adapter:

**Konsep:**
Kombinasi Builder Pattern untuk konfigurasi, Factory Pattern untuk pembuatan service, dan Adapter Pattern untuk kompatibilitas.

**Implementasi:**
```kotlin
// data/network/ApiClient.kt
object ApiClient {
    private var retrofit: Retrofit? = null
    
    fun getRetrofit(): Retrofit {
        if (retrofit == null) {
            synchronized(this) {
                if (retrofit == null) {
                    retrofit = Retrofit.Builder()
                        .baseUrl("https://api.example.com/")
                        .addConverterFactory(GsonConverterFactory.create())
                        .client(
                            OkHttpClient.Builder()
                                .addInterceptor(
                                    HttpLoggingInterceptor().apply {
                                        level = if (BuildConfig.DEBUG) {
                                            HttpLoggingInterceptor.Level.BODY
                                        } else {
                                            HttpLoggingInterceptor.Level.NONE
                                        }
                                    }
                                )
                                .connectTimeout(30, TimeUnit.SECONDS)
                                .readTimeout(30, TimeUnit.SECONDS)
                                .build()
                        )
                        .build()
                }
            }
        }
        return retrofit!!
    }
}

// data/network/UserApiService.kt
interface UserApiService {
    @GET("users")
    suspend fun getUsers(): Response<List<UserDto>>
    
    @GET("users/{id}")
    suspend fun getUser(@Path("id") id: String): Response<UserDto>
    
    @POST("users")
    suspend fun createUser(@Body user: UserDto): Response<UserDto>
    
    @PUT("users/{id}")
    suspend fun updateUser(@Path("id") id: String, @Body user: UserDto): Response<UserDto>
    
    @DELETE("users/{id}")
    suspend fun deleteUser(@Path("id") id: String): Response<Unit>
}

// data/network/NetworkAdapterFactory.kt
class NetworkAdapterFactory {
    companion object {
        fun <T> createService(serviceClass: Class<T>): T {
            return ApiClient.getRetrofit().create(serviceClass)
        }
    }
}

// data/network/NetworkModule.kt
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideApiService(): UserApiService {
        return ApiClient.getRetrofit().create(UserApiService::class.java)
    }
}

// data/dto/UserDto.kt
data class UserDto(
    val id: String,
    val name: String,
    val email: String,
    val isActive: Boolean
)

// data/mapper/UserMapper.kt
fun UserDto.toDomain(): User {
    return User(
        id = this.id,
        name = this.name,
        email = this.email,
        isActive = this.isActive
    )
}

fun User.toDto(): UserDto {
    return UserDto(
        id = this.id,
        name = this.name,
        email = this.email,
        isActive = this.isActive
    )
}
```

### 4. Room = Builder + DAO + Repository:

**Konsep:**
Kombinasi Builder Pattern untuk konfigurasi database, DAO Pattern untuk akses data, dan Repository Pattern untuk abstraksi.

**Implementasi:**
```kotlin
// data/database/AppDatabase.kt
@Database(
    entities = [UserEntity::class],
    version = 1,
    exportSchema = false
)
@TypeConverters(Converters::class)
abstract class AppDatabase : RoomDatabase() {
    
    abstract fun userDao(): UserDao
    
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        
        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_database"
                )
                .fallbackToDestructiveMigration() // untuk development
                .build()
                INSTANCE = instance
                instance
            }
        }
    }
}

// data/database/dao/UserDao.kt
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun observeAllUsers(): Flow<List<UserEntity>>
    
    @Query("SELECT * FROM users WHERE id = :id")
    suspend fun getUserById(id: String): UserEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUser(user: UserEntity)
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUsers(users: List<UserEntity>)
    
    @Update
    suspend fun updateUser(user: UserEntity)
    
    @Delete
    suspend fun deleteUser(user: UserEntity)
    
    @Query("DELETE FROM users WHERE id = :id")
    suspend fun deleteUserById(id: String)
}

// data/database/entity/UserEntity.kt
@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey
    val id: String,
    val name: String,
    val email: String,
    val isActive: Boolean,
    val createdAt: Long = System.currentTimeMillis()
)

// data/database/Converters.kt
class Converters {
    @TypeConverter
    fun fromTimestamp(value: Long?): Date? {
        return value?.let { Date(it) }
    }

    @TypeConverter
    fun dateToTimestamp(date: Date?): Long? {
        return date?.time
    }
}

// data/database/DatabaseModule.kt
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
        return AppDatabase.getDatabase(context)
    }
    
    @Provides
    fun provideUserDao(database: AppDatabase): UserDao {
        return database.userDao()
    }
}
```

### 5. RecyclerView = Adapter + ViewHolder + Observer:

**Konsep:**
Kombinasi Adapter Pattern untuk menghubungkan data dengan UI, ViewHolder Pattern untuk optimasi kinerja, dan Observer Pattern untuk update otomatis.

**Implementasi:**
```kotlin
// presentation/adapter/UserAdapter.kt
class UserAdapter(
    private val onItemClick: (User) -> Unit,
    private val onItemLongClick: (User) -> Boolean = { false }
) : ListAdapter<User, UserAdapter.UserViewHolder>(UserDiffCallback()) {
    
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {
        val binding = ItemUserBinding.inflate(
            LayoutInflater.from(parent.context),
            parent,
            false
        )
        return UserViewHolder(binding)
    }
    
    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {
        holder.bind(getItem(position), onItemClick, onItemLongClick)
    }
    
    inner class UserViewHolder(
        private val binding: ItemUserBinding
    ) : RecyclerView.ViewHolder(binding.root) {
        
        fun bind(
            user: User,
            onItemClick: (User) -> Unit,
            onItemLongClick: (User) -> Boolean
        ) {
            binding.apply {
                textName.text = user.name
                textEmail.text = user.email
                switchActive.isChecked = user.isActive
                
                root.setOnClickListener { onItemClick(user) }
                
                root.setOnLongClickListener {
                    onItemLongClick(user)
                    true
                }
            }
        }
    }
}

// presentation/adapter/UserDiffCallback.kt
class UserDiffCallback : DiffUtil.ItemCallback<User>() {
    override fun areItemsTheSame(oldItem: User, newItem: User): Boolean {
        return oldItem.id == newItem.id
    }

    override fun areContentsTheSame(oldItem: User, newItem: User): Boolean {
        return oldItem == newItem
    }
}

// presentation/ui/MainActivity.kt
class MainActivity : ComponentActivity() {
    private lateinit var binding: ActivityMainBinding
    private lateinit var userAdapter: UserAdapter
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        setupRecyclerView()
        observeData()
    }
    
    private fun setupRecyclerView() {
        userAdapter = UserAdapter(
            onItemClick = { user ->
                // Handle item click
                Toast.makeText(this, "Clicked: ${user.name}", Toast.LENGTH_SHORT).show()
            },
            onItemLongClick = { user ->
                // Handle item long click
                true
            }
        )
        
        binding.recyclerView.apply {
            adapter = userAdapter
            layoutManager = LinearLayoutManager(this@MainActivity)
        }
    }
    
    private fun observeData() {
        // ViewModel sudah diinject melalui Hilt
        val viewModel: UserViewModel by viewModels()
        
        lifecycleScope.launch {
            viewModel.uiState.collect { state ->
                when (state) {
                    is UiState.Success -> {
                        userAdapter.submitList(state.data)
                    }
                    is UiState.Error -> {
                        Toast.makeText(this@MainActivity, state.message, Toast.LENGTH_LONG).show()
                    }
                    UiState.Loading -> {
                        // Tampilkan loading indicator
                    }
                }
            }
        }
    }
}
```

### 6. Dependency Injection = DIP + Factory:

**Konsep:**
Kombinasi Dependency Inversion Principle dan Factory Pattern untuk manajemen dependensi.

**Implementasi:**
```kotlin
// di/NetworkModule.kt
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .addInterceptor {
                // Tambahkan logging, auth, dll
                it.proceed(it.request())
            }
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    @Provides
    fun provideApiService(retrofit: Retrofit): UserApiService {
        return retrofit.create(UserApiService::class.java)
    }
}

// di/RepositoryModule.kt
@Module
@InstallIn(SingletonComponent::class)
object RepositoryModule {
    
    @Provides
    @Singleton
    fun provideUserRepository(
        apiService: UserApiService,
        userDao: UserDao
    ): UserRepository {
        return UserRepositoryImpl(apiService, userDao)
    }
}

// di/UseCaseModule.kt
@Module
@InstallIn(SingletonComponent::class)
object UseCaseModule {
    
    @Provides
    fun provideGetUsersUseCase(repository: UserRepository): GetUsersUseCase {
        return GetUsersUseCase(repository)
    }
    
    @Provides
    fun provideGetUserUseCase(repository: UserRepository): GetUserUseCase {
        return GetUserUseCase(repository)
    }
}

// di/ViewModelModule.kt
@Module
@InstallIn(ActivityRetainedComponent::class)
object ViewModelModule {
    
    @Provides
    @ViewModelScoped
    fun provideUserViewModel(
        getUsersUseCase: GetUsersUseCase,
        getUserUseCase: GetUserUseCase
    ): UserViewModel {
        return UserViewModel(getUsersUseCase, getUserUseCase)
    }
}

// di/HiltApplication.kt
@HiltAndroidApp
class HiltApplication : Application()
```

### üéì Penjelasan Konsep:
**Patterns dalam Real Android Apps seperti Bangunan Sebenarnya:**
- **Teruji**: Sudah dipakai di aplikasi nyata
- **Terintegrasi**: Bekerja bersama secara harmonis
- **Maintainable**: Mudah dipelihara dan dikembangkan
- **Scalable**: Bisa berkembang dengan aplikasi

**Keunggulan Kombinasi Pattern dalam Real Apps:**
- **Performance**: Optimized untuk mobile
- **Maintainability**: Mudah diubah dan dipelihara
- **Testability**: Mudah diuji unit dan integrasi
- **Scalability**: Bisa berkembang seiring aplikasi

---

## 1Ô∏è‚É£0Ô∏è‚É£ Testing dengan Patterns üß™

### Konsep Dasar
Testing dengan Patterns seperti uji kualitas produk üß™ - memastikan pattern berfungsi sesuai ekspektasi!

### 1. Factory Pattern: Easy to Create Test Objects:

**Konsep:**
Factory Pattern memudahkan pembuatan objek untuk testing karena bisa digunakan untuk membuat objek dengan konfigurasi berbeda.

**Implementasi Testing:**
```kotlin
// domain/factory/UserFactory.kt
interface UserFactory {
    fun createUser(userData: UserData): User
}

class RegularUserFactory : UserFactory {
    override fun createUser(userData: UserData): User {
        return User(
            id = generateId(),
            name = userData.name,
            email = userData.email,
            role = UserRole.USER,
            isPremium = false
        )
    }
    
    private fun generateId() = "user_${System.currentTimeMillis()}"
}

class AdminUserFactory : UserFactory {
    override fun createUser(userData: UserData): User {
        return User(
            id = generateId(),
            name = userData.name,
            email = userData.email,
            role = UserRole.ADMIN,
            isPremium = true,
            permissions = listOf("ALL_ACCESS")
        )
    }
    
    private fun generateId() = "admin_${System.currentTimeMillis()}"
}

// Test file
@OptIn(ExperimentalCoroutinesApi::class)
class UserFactoryTest {
    
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()
    
    @Test
    fun `RegularUserFactory should create user with correct properties`() = runTest {
        // Given
        val factory = RegularUserFactory()
        val userData = UserData("John Doe", "john@example.com")
        
        // When
        val user = factory.createUser(userData)
        
        // Then
        assertEquals("John Doe", user.name)
        assertEquals("john@example.com", user.email)
        assertEquals(UserRole.USER, user.role)
        assertFalse(user.isPremium)
        assertTrue(user.permissions.isEmpty())
    }
    
    @Test
    fun `AdminUserFactory should create admin user with permissions`() = runTest {
        // Given
        val factory = AdminUserFactory()
        val userData = UserData("Admin User", "admin@example.com")
        
        // When
        val user = factory.createUser(userData)
        
        // Then
        assertEquals("Admin User", user.name)
        assertEquals("admin@example.com", user.email)
        assertEquals(UserRole.ADMIN, user.role)
        assertTrue(user.isPremium)
        assertTrue(user.permissions.contains("ALL_ACCESS"))
    }
    
    @Test
    fun `Different factories should create different user types`() = runTest {
        // Given
        val regularFactory = RegularUserFactory()
        val adminFactory = AdminUserFactory()
        val userData = UserData("Test User", "test@example.com")
        
        // When
        val regularUser = regularFactory.createUser(userData)
        val adminUser = adminFactory.createUser(userData)
        
        // Then
        assertNotEquals(regularUser.role, adminUser.role)
        assertNotEquals(regularUser.permissions, adminUser.permissions)
    }
}
```

### 2. Strategy Pattern: Easy to Test Different Strategies:

**Konsep:**
Strategy Pattern memudahkan testing berbagai implementasi algoritma karena bisa ditest secara terpisah dan digunakan dalam testing.

**Implementasi Testing:**
```kotlin
// domain/strategy/SortStrategy.kt
interface SortStrategy<T> {
    fun sort(items: List<T>): List<T>
}

class BubbleSortStrategy<T : Comparable<T>> : SortStrategy<T> {
    override fun sort(items: List<T>): List<T> {
        val result = items.toMutableList()
        for (i in result.indices) {
            for (j in 0 until result.size - i - 1) {
                if (result[j] > result[j + 1]) {
                    result[j] = result[j + 1].also { result[j + 1] = result[j] }
                }
            }
        }
        return result
    }
}

class QuickSortStrategy<T : Comparable<T>> : SortStrategy<T> {
    override fun sort(items: List<T>): List<T> {
        return if (items.size <= 1) items else {
            val pivot = items[items.size / 2]
            val left = items.filter { it < pivot }
            val middle = items.filter { it == pivot }
            val right = items.filter { it > pivot }
            sort(left) + middle + sort(right)
        }
    }
}

// Test file
class SortStrategyTest {
    
    @Test
    fun `BubbleSortStrategy should sort numbers correctly`() {
        // Given
        val strategy = BubbleSortStrategy<Int>()
        val input = listOf(3, 1, 4, 1, 5, 9, 2, 6)
        val expected = listOf(1, 1, 2, 3, 4, 5, 6, 9)
        
        // When
        val result = strategy.sort(input)
        
        // Then
        assertEquals(expected, result)
    }
    
    @Test
    fun `QuickSortStrategy should sort strings correctly`() {
        // Given
        val strategy = QuickSortStrategy<String>()
        val input = listOf("banana", "apple", "cherry", "date")
        val expected = listOf("apple", "banana", "cherry", "date")
        
        // When
        val result = strategy.sort(input)
        
        // Then
        assertEquals(expected, result)
    }
    
    @Test
    fun `Different strategies should produce same result for same input`() {
        // Given
        val bubbleSort = BubbleSortStrategy<Int>()
        val quickSort = QuickSortStrategy<Int>()
        val input = listOf(5, 2, 8, 1, 9, 3)
        val expected = listOf(1, 2, 3, 5, 8, 9)
        
        // When
        val bubbleResult = bubbleSort.sort(input)
        val quickResult = quickSort.sort(input)
        
        // Then
        assertEquals(expected, bubbleResult)
        assertEquals(expected, quickResult)
        assertEquals(bubbleResult, quickResult)
    }
    
    // Test untuk class yang menggunakan strategy
    class DataProcessor<T>(private var strategy: SortStrategy<T>) {
        fun processData(data: List<T>): List<T> {
            return strategy.sort(data)
        }
        
        fun setSortStrategy(newStrategy: SortStrategy<T>) {
            this.strategy = newStrategy
        }
    }
    
    @Test
    fun `DataProcessor should work with different strategies`() {
        // Given
        val bubbleSort = BubbleSortStrategy<Int>()
        val processor = DataProcessor(bubbleSort)
        val input = listOf(3, 1, 4, 2)
        val expected = listOf(1, 2, 3, 4)
        
        // When
        val result = processor.processData(input)
        
        // Then
        assertEquals(expected, result)
    }
}
```

### 3. Observer Pattern: Test Notifications:

**Konsep:**
Observer Pattern memudahkan testing notifikasi dan perubahan state karena bisa melacak pemanggilan observer.

**Implementasi Testing:**
```kotlin
// domain/observer/EventManager.kt
interface Observer<T> {
    fun onChanged(data: T)
}

interface Subject<T> {
    fun subscribe(observer: Observer<T>)
    fun unsubscribe(observer: Observer<T>)
    fun notify(data: T)
}

class UserEventManager : Subject<User> {
    private val observers = mutableListOf<Observer<User>>()
    
    override fun subscribe(observer: Observer<User>) {
        observers.add(observer)
    }
    
    override fun unsubscribe(observer: Observer<User>) {
        observers.remove(observer)
    }
    
    override fun notify(data: User) {
        observers.forEach { it.onChanged(data) }
    }
}

// Test file
class ObserverPatternTest {
    
    @Test
    fun `Observer should be notified when subject changes`() {
        // Given
        val eventManager = UserEventManager()
        val mockObserver = MockUserObserver()
        val user = User("1", "John Doe", "john@example.com")
        
        // When
        eventManager.subscribe(mockObserver)
        eventManager.notify(user)
        
        // Then
        assertTrue(mockObserver.receivedNotifications.isNotEmpty())
        assertEquals(user, mockObserver.receivedNotifications[0])
    }
    
    @Test
    fun `Observer should not be notified after unsubscribing`() {
        // Given
        val eventManager = UserEventManager()
        val mockObserver = MockUserObserver()
        val user = User("1", "John Doe", "john@example.com")
        
        // When
        eventManager.subscribe(mockObserver)
        eventManager.notify(user) // Observer akan menerima notifikasi
        
        eventManager.unsubscribe(mockObserver)
        eventManager.notify(user.copy(name = "Jane Doe")) // Observer TIDAK akan menerima notifikasi
        
        // Then
        assertEquals(1, mockObserver.receivedNotifications.size)
        assertEquals("John Doe", mockObserver.receivedNotifications[0].name)
    }
    
    @Test
    fun `Multiple observers should all be notified`() {
        // Given
        val eventManager = UserEventManager()
        val observer1 = MockUserObserver()
        val observer2 = MockUserObserver()
        val user = User("1", "John Doe", "john@example.com")
        
        // When
        eventManager.subscribe(observer1)
        eventManager.subscribe(observer2)
        eventManager.notify(user)
        
        // Then
        assertEquals(1, observer1.receivedNotifications.size)
        assertEquals(1, observer2.receivedNotifications.size)
        assertEquals(user, observer1.receivedNotifications[0])
        assertEquals(user, observer2.receivedNotifications[0])
    }
}

// Mock observer untuk testing
class MockUserObserver : Observer<User> {
    val receivedNotifications = mutableListOf<User>()
    
    override fun onChanged(data: User) {
        receivedNotifications.add(data)
    }
}
```

### 4. Adapter Pattern: Test Conversions:

**Konsep:**
Adapter Pattern memudahkan testing konversi dan kompatibilitas karena bisa menguji input/output dari sistem yang berbeda.

**Implementasi Testing:**
```kotlin
// domain/adapter/DataAdapter.kt
interface DataProvider {
    fun getData(): List<String>
}

interface ModernDataConsumer {
    fun processData(data: List<DataModel>)
}

class LegacyDataProvider : DataProvider {
    override fun getData(): List<String> {
        return listOf("legacy1", "legacy2", "legacy3")
    }
}

class DataModel(val id: String, val value: String, val timestamp: Long = System.currentTimeMillis())

class LegacyDataToModernAdapter(
    private val legacyProvider: LegacyDataProvider
) : ModernDataConsumer {
    private val processedData = mutableListOf<DataModel>()
    
    override fun processData(data: List<DataModel>) {
        // Ini seharusnya mengkonsumsi data dari provider
        processedData.addAll(data)
    }
    
    fun convertLegacyToModern(): List<DataModel> {
        return legacyProvider.getData().map { raw ->
            DataModel(
                id = "converted_${raw.hashCode()}",
                value = raw.uppercase()
            )
        }
    }
}

// Test file
class AdapterPatternTest {
    
    @Test
    fun `LegacyDataToModernAdapter should convert legacy data correctly`() {
        // Given
        val legacyProvider = LegacyDataProvider()
        val adapter = LegacyDataToModernAdapter(legacyProvider)
        
        // When
        val converted = adapter.convertLegacyToModern()
        
        // Then
        assertEquals(3, converted.size)
        converted.forEach { model ->
            assertTrue(model.id.startsWith("converted_"))
            assertTrue(model.value.all { it.isUpperCase() })
        }
    }
    
    @Test
    fun `Adapter conversion should maintain data integrity`() {
        // Given
        val legacyProvider = LegacyDataProvider()
        val adapter = LegacyDataToModernAdapter(legacyProvider)
        
        // When
        val original = legacyProvider.getData()
        val converted = adapter.convertLegacyToModern()
        
        // Then
        assertEquals(original.size, converted.size)
        // Verify that the transformation is consistent
        original.forEachIndexed { index, originalValue ->
            assertTrue(converted[index].value.contains(originalValue.uppercase()))
        }
    }
    
    @Test
    fun `Adapter should handle empty data gracefully`() {
        // Given
        val emptyProvider = object : DataProvider {
            override fun getData(): List<String> = emptyList()
        }
        val adapter = LegacyDataToModernAdapter(emptyProvider as LegacyDataProvider)
        
        // When
        val converted = adapter.convertLegacyToModern()
        
        // Then
        assertTrue(converted.isEmpty())
    }
}
```

### 5. Repository Pattern: Mock Implementations:

**Konsep:**
Repository Pattern sangat cocok untuk testing karena bisa diganti dengan mock implementations untuk menghindari ketergantungan pada database atau network.

**Implementasi Testing:**
```kotlin
// domain/repository/UserRepository.kt
interface UserRepository {
    suspend fun getUserById(id: String): User?
    suspend fun getUsers(): List<User>
    suspend fun saveUser(user: User)
    suspend fun deleteUser(id: String)
}

// Test implementation
class InMemoryUserRepository : UserRepository {
    private val users = mutableMapOf<String, User>()
    
    override suspend fun getUserById(id: String): User? {
        return users[id]
    }
    
    override suspend fun getUsers(): List<User> {
        return users.values.toList()
    }
    
    override suspend fun saveUser(user: User) {
        users[user.id] = user
    }
    
    override suspend fun deleteUser(id: String) {
        users.remove(id)
    }
}

// domain/usecase/GetUserUseCase.kt
class GetUserUseCase(
    private val repository: UserRepository
) {
    suspend operator fun invoke(userId: String): User? {
        return repository.getUserById(userId)
    }
}

// Test file
@OptIn(ExperimentalCoroutinesApi::class)
class RepositoryPatternTest {
    
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()
    
    @Test
    fun `GetUserUseCase should return user from repository`() = runTest {
        // Given
        val testUser = User("1", "John Doe", "john@example.com")
        val mockRepository = InMemoryUserRepository()
        mockRepository.saveUser(testUser) // Setup test data
        
        val useCase = GetUserUseCase(mockRepository)
        
        // When
        val result = useCase("1")
        
        // Then
        assertNotNull(result)
        assertEquals(testUser, result)
    }
    
    @Test
    fun `GetUserUseCase should return null for non-existent user`() = runTest {
        // Given
        val mockRepository = InMemoryUserRepository()
        val useCase = GetUserUseCase(mockRepository)
        
        // When
        val result = useCase("nonexistent")
        
        // Then
        assertNull(result)
    }
    
    @Test
    fun `Repository should handle multiple users correctly`() = runTest {
        // Given
        val mockRepository = InMemoryUserRepository()
        val users = listOf(
            User("1", "User 1", "user1@example.com"),
            User("2", "User 2", "user2@example.com"),
            User("3", "User 3", "user3@example.com")
        )
        
        // When
        users.forEach { mockRepository.saveUser(it) }
        val result = mockRepository.getUsers()
        
        // Then
        assertEquals(3, result.size)
        assertTrue(result.containsAll(users))
    }
    
    @Test
    fun `Repository should allow user deletion`() = runTest {
        // Given
        val mockRepository = InMemoryUserRepository()
        val user = User("1", "John Doe", "john@example.com")
        mockRepository.saveUser(user)
        
        // When
        val beforeDelete = mockRepository.getUserById("1")
        mockRepository.deleteUser("1")
        val afterDelete = mockRepository.getUserById("1")
        
        // Then
        assertNotNull(beforeDelete) // User exists before deletion
        assertNull(afterDelete) // User doesn't exist after deletion
    }
}

// Mockk example for more sophisticated testing
class MockkRepositoryTest {
    
    @Test
    fun `UseCase should handle repository errors gracefully`() = runTest {
        // Given
        val mockRepository = mockk<UserRepository>()
        val useCase = GetUserUseCase(mockRepository)
        
        coEvery { mockRepository.getUserById("1") } throws Exception("Network error")
        
        // When & Then
        assertFailsWith<Exception> {
            runBlocking { useCase("1") }
        }
        
        coVerify { mockRepository.getUserById("1") }
    }
    
    @Test
    fun `UseCase should save user successfully`() = runTest {
        // Given
        val mockRepository = mockk<UserRepository>()
        val testUser = User("1", "John Doe", "john@example.com")
        
        coEvery { mockRepository.saveUser(any()) } just runs
        
        // When
        mockRepository.saveUser(testUser)
        
        // Then
        coVerify { mockRepository.saveUser(testUser) }
    }
}
```

### 6. Builder Pattern: Test Object Construction:

**Konsep:**
Builder Pattern memudahkan testing konstruksi objek karena bisa menguji berbagai kombinasi parameter.

**Implementasi Testing:**
```kotlin
// domain/builder/UserBuilder.kt
class User private constructor(
    val id: String,
    val name: String,
    val email: String,
    val age: Int? = null,
    val phone: String? = null,
    val address: String? = null,
    val isPremium: Boolean = false,
    val preferences: Map<String, String> = emptyMap()
) {
    
    class Builder {
        private var id: String = "user_${System.currentTimeMillis()}"
        private var name: String = ""
        private var email: String = ""
        private var age: Int? = null
        private var phone: String? = null
        private var address: String? = null
        private var isPremium: Boolean = false
        private var preferences: Map<String, String> = emptyMap()
        
        fun id(id: String) = apply { this.id = id }
        fun name(name: String) = apply { this.name = name }
        fun email(email: String) = apply { this.email = email }
        fun age(age: Int) = apply { this.age = age }
        fun phone(phone: String) = apply { this.phone = phone }
        fun address(address: String) = apply { this.address = address }
        fun premium(isPremium: Boolean) = apply { this.isPremium = isPremium }
        fun preferences(preferences: Map<String, String>) = apply { this.preferences = preferences }
        
        fun build(): User {
            require(name.isNotBlank()) { "Name cannot be blank" }
            require(email.contains("@")) { "Valid email required" }
            return User(id, name, email, age, phone, address, isPremium, preferences)
        }
    }
}

// Test file
class BuilderPatternTest {
    
    @Test
    fun `Builder should create user with required fields`() {
        // Given
        val expectedName = "John Doe"
        val expectedEmail = "john@example.com"
        
        // When
        val user = User.Builder()
            .name(expectedName)
            .email(expectedEmail)
            .build()
        
        // Then
        assertEquals(expectedName, user.name)
        assertEquals(expectedEmail, user.email)
        assertFalse(user.isPremium) // Default value
    }
    
    @Test
    fun `Builder should create user with all optional fields`() {
        // Given
        val expectedAge = 30
        val expectedPhone = "+1234567890"
        val expectedAddress = "123 Main St"
        val expectedPreferences = mapOf("theme" to "dark", "lang" to "en")
        
        // When
        val user = User.Builder()
            .name("John Doe")
            .email("john@example.com")
            .age(expectedAge)
            .phone(expectedPhone)
            .address(expectedAddress)
            .premium(true)
            .preferences(expectedPreferences)
            .build()
        
        // Then
        assertEquals(expectedAge, user.age)
        assertEquals(expectedPhone, user.phone)
        assertEquals(expectedAddress, user.address)
        assertTrue(user.isPremium)
        assertEquals(expectedPreferences, user.preferences)
    }
    
    @Test
    fun `Builder should validate required fields`() {
        // When & Then
        assertFailsWith<IllegalArgumentException> {
            User.Builder()
                .name("John Doe")
                // email missing - should fail
                .build()
        }
        
        assertFailsWith<IllegalArgumentException> {
            User.Builder()
                .email("invalid-email") // invalid email - should fail
                .build()
        }
        
        assertFailsWith<IllegalArgumentException> {
            User.Builder()
                .build() // both required fields missing - should fail
        }
    }
    
    @Test
    fun `Builder should create different users with same builder`() {
        // Given
        val builder = User.Builder()
        
        // When
        val user1 = builder
            .name("User 1")
            .email("user1@example.com")
            .build()
        
        val user2 = User.Builder() // Fresh builder
            .name("User 2")
            .email("user2@example.com")
            .build()
        
        // Then
        assertNotEquals(user1.id, user2.id) // Different IDs due to timestamp
        assertNotEquals(user1.name, user2.name)
        assertNotEquals(user1.email, user2.email)
    }
    
    @Test
    fun `Builder should have method chaining working correctly`() {
        // Given - When (all in one chain)
        val user = User.Builder()
            .name("Chained User")
            .email("chained@example.com")
            .age(25)
            .premium(true)
            .apply {
                // Additional configuration through apply
                phone("+1234567890")
                address("456 Chain St")
            }
            .build()
        
        // Then
        assertEquals("Chained User", user.name)
        assertEquals("chained@example.com", user.email)
        assertEquals(25, user.age)
        assertTrue(user.isPremium)
        assertEquals("+1234567890", user.phone)
        assertEquals("456 Chain St", user.address)
    }
}
```

### 7. Comprehensive Integration Testing:

**Konsep:**
Testing kombinasi beberapa pattern untuk memastikan integrasi berjalan dengan baik.

**Implementasi Testing:**
```kotlin
// Integration test for multiple patterns working together
@OptIn(ExperimentalCoroutinesApi::class)
class PatternIntegrationTest {
    
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()
    
    @Test
    fun `MVVM with Repository and Strategy patterns should work together`() = runTest {
        // Given: Repository with mock data
        val mockRepository = InMemoryUserRepository()
        val users = listOf(
            User("1", "User 1", "user1@example.com"),
            User("2", "User 2", "user2@example.com")
        )
        users.forEach { mockRepository.saveUser(it) }
        
        // Use case using the repository
        val getUsersUseCase = GetUsersUseCase(mockRepository)
        
        // ViewModel using the use case
        val viewModel = UserViewModel(getUsersUseCase)
        
        // When: Load users
        viewModel.loadUsers()
        
        // Then: Verify state
        val state = viewModel.uiState.value
        assertTrue(state is UiState.Success)
        assertEquals(2, (state as UiState.Success).data.size)
    }
    
    @Test
    fun `Factory creating objects used by Strategy pattern`() = runTest {
        // Given: Factory creating different user types
        val regularFactory = RegularUserFactory()
        val adminFactory = AdminUserFactory()
        
        val userData = UserData("Test User", "test@example.com")
        
        // Strategy for processing different user types
        val userProcessor = UserProcessor()
        
        // When: Create users with different factories
        val regularUser = regularFactory.createUser(userData)
        val adminUser = adminFactory.createUser(userData)
        
        // Process users with strategy
        val regularProcessed = userProcessor.processUser(regularUser)
        val adminProcessed = userProcessor.processUser(adminUser)
        
        // Then: Verify different processing results
        assertNotEquals(regularProcessed, adminProcessed)
        assertTrue(regularProcessed.contains("regular"))
        assertTrue(adminProcessed.contains("admin"))
    }
}

class UserProcessor {
    fun processUser(user: User): String {
        return when (user.role) {
            UserRole.USER -> "regular_user_processed_${user.id}"
            UserRole.ADMIN -> "admin_user_processed_${user.id}"
            else -> "unknown_user_processed_${user.id}"
        }
    }
}
```

### üéì Penjelasan Konsep:
**Testing dengan Patterns seperti Uji Laboratorium:**
- **Isolasi**: Setiap pattern bisa ditest sendiri
- **Integrasi**: Pola bekerja bersama bisa ditest
- **Mocking**: Mudah ganti implementasi
- **Validasi**: Memastikan behavior sesuai ekspektasi

**Manfaat Testing dengan Patterns:**
- **Maintainability**: Kode lebih mudah dipelihara
- **Confidence**: Percaya bahwa perubahan tidak merusak
- **Documentation**: Tes menjadi dokumentasi behavior
- **Quality**: Kode lebih berkualitas dan stabil

---

## 1Ô∏è‚É£1Ô∏è‚É£ Hands-on Exercises üî®

### Konsep Dasar
Hands-on Exercises seperti laboratorium praktis üî¨ - tempat mencoba dan mengaplikasikan Design Patterns secara langsung!

### Exercise 1: Identify Patterns in Existing Code

**Task:** Analisis kode berikut dan identifikasi pattern apa yang digunakan

```kotlin
// Code to analyze
class UserManager {
    private val users = mutableListOf<User>()
    private val observers = mutableListOf<(List<User>) -> Unit>()
    
    fun addUser(user: User) {
        users.add(user)
        notifyObservers()
    }
    
    fun removeUser(id: String) {
        users.removeIf { it.id == id }
        notifyObservers()
    }
    
    fun getAllUsers(): List<User> = users.toList()
    
    fun subscribe(observer: (List<User>) -> Unit) {
        observers.add(observer)
    }
    
    private fun notifyObservers() {
        observers.forEach { it(users) }
    }
}
```

**Answer:**
```kotlin
// Jawaban: Observer Pattern
// - Notifikasi otomatis saat data berubah
// - Multiple observers bisa subscribe
// - Subject (UserManager) dan Observer terpisah
```

### Exercise 2: Implement Factory Pattern

**Task:** Buat Factory Pattern untuk membuat berbagai jenis notification

```kotlin
// TODO: Implementasi
// Buat interface Notification
// Buat implementasi EmailNotification, SmsNotification, PushNotification
// Buat NotificationFactory
// Gunakan enum untuk tipe notification

interface Notification {
    fun send()
}

// Jawaban:
class FactoryPatternExercise {
    // Implementasi di sini
}
```

**Solution:**
```kotlin
interface Notification {
    fun send()
}

class EmailNotification(private val to: String, private val message: String) : Notification {
    override fun send() {
        println("Sending email to $to: $message")
    }
}

class SmsNotification(private val to: String, private val message: String) : Notification {
    override fun send() {
        println("Sending SMS to $to: $message")
    }
}

class PushNotification(private val token: String, private val message: String) : Notification {
    override fun send() {
        println("Sending push notification to $token: $message")
    }
}

enum class NotificationType {
    EMAIL, SMS, PUSH
}

interface NotificationFactory {
    fun createNotification(type: NotificationType, recipient: String, message: String): Notification
}

class DefaultNotificationFactory : NotificationFactory {
    override fun createNotification(type: NotificationType, recipient: String, message: String): Notification {
        return when (type) {
            NotificationType.EMAIL -> EmailNotification(recipient, message)
            NotificationType.SMS -> SmsNotification(recipient, message)
            NotificationType.PUSH -> PushNotification(recipient, message)
        }
    }
}

// Testing
fun testFactoryPattern() {
    val factory = DefaultNotificationFactory()
    
    val emailNotification = factory.createNotification(
        NotificationType.EMAIL, 
        "user@example.com", 
        "Welcome!"
    )
    emailNotification.send()
    
    val pushNotification = factory.createNotification(
        NotificationType.PUSH,
        "device_token_123",
        "New message"
    )
    pushNotification.send()
}
```

### Exercise 3: Implement Strategy Pattern

**Task:** Buat Strategy Pattern untuk berbagai metode pembayaran

```kotlin
// TODO: Implementasi
// Buat interface PaymentStrategy
// Buat implementasi CreditCardPayment, PayPalPayment, BankTransferPayment
// Gunaklan dalam PaymentProcessor

interface PaymentStrategy {
    suspend fun pay(amount: Double): PaymentResult
}

// Jawaban:
class StrategyPatternExercise {
    // Implementasi di sini
}
```

**Solution:**
```kotlin
interface PaymentStrategy {
    suspend fun pay(amount: Double): PaymentResult
}

class CreditCardPayment(
    private val cardNumber: String,
    private val cvv: String
) : PaymentStrategy {
    override suspend fun pay(amount: Double): PaymentResult {
        // Simulasi validasi dan pembayaran kartu kredit
        if (cardNumber.length != 16 || cvv.length != 3) {
            return PaymentResult.Failure("Invalid card details")
        }
        return PaymentResult.Success("Paid $$amount via Credit Card")
    }
}

class PayPalPayment(
    private val email: String,
    private val password: String
) : PaymentStrategy {
    override suspend fun pay(amount: Double): PaymentResult {
        // Simulasi validasi dan pembayaran PayPal
        if (!android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) {
            return PaymentResult.Failure("Invalid email")
        }
        return PaymentResult.Success("Paid $$amount via PayPal")
    }
}

class BankTransferPayment(
    private val accountNumber: String,
    private val routingNumber: String
) : PaymentStrategy {
    override suspend fun pay(amount: Double): PaymentResult {
        // Simulasi validasi dan pembayaran transfer bank
        if (accountNumber.length !in 8..12 || routingNumber.length != 9) {
            return PaymentResult.Failure("Invalid bank details")
        }
        return PaymentResult.Success("Paid $$amount via Bank Transfer")
    }
}

sealed class PaymentResult {
    data class Success(val message: String) : PaymentResult()
    data class Failure(val message: String) : PaymentResult()
}

class PaymentProcessor {
    suspend fun processPayment(
        strategy: PaymentStrategy,
        amount: Double
    ): PaymentResult {
        return strategy.pay(amount)
    }
}

// Testing
suspend fun testStrategyPattern() {
    val processor = PaymentProcessor()
    
    val creditCardStrategy = CreditCardPayment("1234567812345678", "123")
    val result1 = processor.processPayment(creditCardStrategy, 100.0)
    println("Credit Card Result: $result1")
    
    val paypalStrategy = PayPalPayment("user@example.com", "password")
    val result2 = processor.processPayment(paypalStrategy, 50.0)
    println("PayPal Result: $result2")
}
```

### Exercise 4: Refactor Code Using Patterns

**Task:** Refactor kode berikut menggunakan beberapa pattern

```kotlin
// Kode yang perlu direfactor
class ReportGenerator {
    fun generateReport(type: String, data: List<String>): String {
        return when (type) {
            "pdf" -> {
                // Logic untuk PDF
                "PDF Report: ${data.joinToString(", ")}"
            }
            "excel" -> {
                // Logic untuk Excel  
                "Excel Report: ${data.joinToString(", ")}"
            }
            "csv" -> {
                // Logic untuk CSV
                "CSV Report: ${data.joinToString(", ")}"
            }
            else -> "Unknown report type"
        }
    }
}
```

**Solution:**
```kotlin
// Gunakan Strategy Pattern + Factory Pattern
interface ReportGenerator {
    fun generateReport(data: List<String>): String
}

class PdfReportGenerator : ReportGenerator {
    override fun generateReport(data: List<String>): String {
        return "PDF Report: ${data.joinToString(", ")}"
    }
}

class ExcelReportGenerator : ReportGenerator {
    override fun generateReport(data: List<String>): String {
        return "Excel Report: ${data.joinToString(", ")}"
    }
}

class CsvReportGenerator : ReportGenerator {
    override fun generateReport(data: List<String>): String {
        return "CSV Report: ${data.joinToString(", ")}"
    }
}

enum class ReportType {
    PDF, EXCEL, CSV
}

class ReportGeneratorFactory {
    fun createGenerator(type: ReportType): ReportGenerator {
        return when (type) {
            ReportType.PDF -> PdfReportGenerator()
            ReportType.EXCEL -> ExcelReportGenerator()
            ReportType.CSV -> CsvReportGenerator()
        }
    }
}

class ReportService {
    private val factory = ReportGeneratorFactory()
    
    fun generateReport(type: ReportType, data: List<String>): String {
        val generator = factory.createGenerator(type)
        return generator.generateReport(data)
    }
}

// Testing
fun testRefactoredCode() {
    val service = ReportService()
    
    val data = listOf("item1", "item2", "item3")
    
    val pdfReport = service.generateReport(ReportType.PDF, data)
    val excelReport = service.generateReport(ReportType.EXCEL, data)
    val csvReport = service.generateReport(ReportType.CSV, data)
    
    println("PDF: $pdfReport")
    println("Excel: $excelReport") 
    println("CSV: $csvReport")
}
```

### Exercise 5: Build Mini-Project Using Multiple Patterns

**Task:** Bangun mini aplikasi to-do list menggunakan berbagai pattern

```kotlin
// TODO: Implementasi mini project
// Gunakan: Repository, ViewModel, Factory, Strategy, Observer patterns
// Aplikasi harus bisa:
// - Menambah task
// - Menghapus task  
// - Mengupdate status task
// - Menyimpan data (gunakan in-memory untuk sekarang)
// - Menampilkan list task

data class Task(
    val id: String,
    val title: String,
    val description: String,
    val isCompleted: Boolean = false,
    val createdAt: Long = System.currentTimeMillis()
)

// Jawaban:
class TodoAppExercise {
    // Implementasi lengkap di sini
}
```

**Solution:**
```kotlin
// Model
data class Task(
    val id: String,
    val title: String,
    val description: String,
    val isCompleted: Boolean = false,
    val createdAt: Long = System.currentTimeMillis()
)

// Factory Pattern
interface TaskFactory {
    fun createTask(title: String, description: String): Task
}

class DefaultTaskFactory : TaskFactory {
    override fun createTask(title: String, description: String): Task {
        return Task(
            id = "task_${System.currentTimeMillis()}",
            title = title,
            description = description,
            isCompleted = false
        )
    }
}

// Strategy Pattern untuk sorting
interface TaskSortStrategy {
    fun sort(tasks: List<Task>): List<Task>
}

class SortByDateStrategy : TaskSortStrategy {
    override fun sort(tasks: List<Task>): List<Task> {
        return tasks.sortedBy { it.createdAt }
    }
}

class SortByStatusStrategy : TaskSortStrategy {
    override fun sort(tasks: List<Task>): List<Task> {
        return tasks.sortedBy { it.isCompleted }
    }
}

class SortByTitleStrategy : TaskSortStrategy {
    override fun sort(tasks: List<Task>): List<Task> {
        return tasks.sortedBy { it.title }
    }
}

// Repository Pattern
interface TaskRepository {
    suspend fun getAllTasks(): List<Task>
    suspend fun getTaskById(id: String): Task?
    suspend fun saveTask(task: Task)
    suspend fun deleteTask(id: String)
    suspend fun updateTask(task: Task)
}

class InMemoryTaskRepository : TaskRepository {
    private val tasks = mutableListOf<Task>()
    
    override suspend fun getAllTasks(): List<Task> = tasks.toList()
    
    override suspend fun getTaskById(id: String): Task? = tasks.find { it.id == id }
    
    override suspend fun saveTask(task: Task) {
        tasks.add(task)
    }
    
    override suspend fun deleteTask(id: String) {
        tasks.removeIf { it.id == id }
    }
    
    override suspend fun updateTask(task: Task) {
        val index = tasks.indexOfFirst { it.id == task.id }
        if (index != -1) {
            tasks[index] = task
        }
    }
}

// Use Case
class GetTasksUseCase(
    private val repository: TaskRepository,
    private val sortStrategy: TaskSortStrategy
) {
    suspend operator fun invoke(): List<Task> {
        val tasks = repository.getAllTasks()
        return sortStrategy.sort(tasks)
    }
}

class CreateTaskUseCase(
    private val repository: TaskRepository,
    private val factory: TaskFactory
) {
    suspend operator fun invoke(title: String, description: String): Task {
        val task = factory.createTask(title, description)
        repository.saveTask(task)
        return task
    }
}

class UpdateTaskUseCase(
    private val repository: TaskRepository
) {
    suspend operator fun invoke(task: Task) {
        repository.updateTask(task)
    }
}

// Observer Pattern untuk UI state
interface Observer<T> {
    fun onChanged(data: T)
}

class TaskObserver : Observer<List<Task>> {
    var lastUpdated: List<Task> = emptyList()
    
    override fun onChanged(data: List<Task>) {
        lastUpdated = data
        println("Tasks updated: ${data.size} tasks")
    }
}

// Testing the complete implementation
@OptIn(ExperimentalCoroutinesApi::class)
class TodoAppSolution {
    
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()
    
    @Test
    fun `Complete todo app should work with all patterns`() = runTest {
        // Setup
        val repository = InMemoryTaskRepository()
        val factory = DefaultTaskFactory()
        val sortStrategy = SortByDateStrategy()
        
        val getTasksUseCase = GetTasksUseCase(repository, sortStrategy)
        val createTaskUseCase = CreateTaskUseCase(repository, factory)
        
        // Create tasks
        val task1 = createTaskUseCase("Task 1", "Description 1")
        val task2 = createTaskUseCase("Task 2", "Description 2")
        
        // Get and verify tasks
        val tasks = getTasksUseCase()
        assertEquals(2, tasks.size)
        assertTrue(tasks.any { it.title == "Task 1" })
        assertTrue(tasks.any { it.title == "Task 2" })
        
        // Test sorting
        val sortedTasks = sortStrategy.sort(tasks)
        assertEquals(2, sortedTasks.size)
    }
}
```

### Exercise 6: Code Review - Pattern Usage

**Task:** Review kode berikut dan tentukan pattern yang digunakan serta kualitasnya

```kotlin
// Analisis kode ini
class DataManager {
    private val cache = mutableMapOf<String, Any>()
    private val database = DatabaseHelper.getInstance()
    private val apiService = RetrofitClient.create(ApiService::class.java)
    
    suspend fun getData(id: String): DataModel? {
        // Cek cache dulu
        val cached = cache[id]
        if (cached is DataModel) return cached
        
        // Cek database
        var data = database.findById(id)
        if (data == null) {
            // Ambil dari API
            data = apiService.fetchData(id)
            // Simpan ke database
            database.save(data)
        }
        
        // Cache hasilnya
        cache[id] = data
        return data
    }
}
```

**Analysis:**
```kotlin
// Pola yang digunakan:
// 1. Singleton (DatabaseHelper.getInstance())
// 2. Strategy (? - tergantung bagaimana DatabaseHelper diimplementasi)
// 3. Cache pattern (manual implementation)

// Issues:
// 1. God object - terlalu banyak tanggung jawab
// 2. Tidak ada abstraksi - langsung ke implementasi konkret
// 3. Coupling tinggi - tergantung implementasi spesifik
// 4. Tidak testable - sulit mock implementasi

// Improvement suggestion:
interface DataSource<T> {
    suspend fun findById(id: String): T?
    suspend fun save(item: T)
}

class Repository<T>(
    private val localSource: DataSource<T>,
    private val remoteSource: DataSource<T>,
    private val cache: MutableMap<String, T> = mutableMapOf()
) {
    suspend fun findById(id: String): T? {
        // Cek cache dulu
        val cached = cache[id]
        if (cached != null) return cached
        
        // Cek local
        var data = localSource.findById(id)
        if (data == null) {
            // Ambil dari remote
            data = remoteSource.findById(id)
            data?.let { localSource.save(it) }
        }
        
        data?.let { cache[id] = it }
        return data
    }
}
```

### Exercise 7: Pattern Anti-Pattern Detection

**Task:** Temukan anti-pattern dalam kode berikut:

```kotlin
class UserProcessor {
    fun processUser(user: User): String {
        if (user.type == "admin") {
            if (user.role == "superadmin") {
                if (user.permissions.contains("all_access")) {
                    // 20 baris logika kompleks
                    return "superadmin_processed"
                } else {
                    // lebih banyak nested if
                    return "admin_limited"
                }
            } else {
                return "admin_basic"
            }
        } else if (user.type == "regular") {
            // lebih banyak nested logic
            if (user.subscription == "premium") {
                return "premium_user"
            } else {
                return "basic_user"
            }
        } else {
            return "unknown_user"
        }
    }
}
```

**Solution:**
```kotlin
// Anti-patterns ditemukan:
// 1. Spaghetti code - nested if yang dalam
// 2. God object - terlalu banyak logika dalam satu method
// 3. Magic strings - string literals langsung

// Refactored using Strategy Pattern:
interface UserProcessingStrategy {
    fun canProcess(user: User): Boolean
    fun process(user: User): String
}

class SuperAdminStrategy : UserProcessingStrategy {
    override fun canProcess(user: User) = 
        user.type == "admin" && user.role == "superadmin" && "all_access" in user.permissions
    
    override fun process(user: User) = "superadmin_processed"
}

class AdminStrategy : UserProcessingStrategy {
    override fun canProcess(user: User) = user.type == "admin"
    override fun process(user: User) = "admin_processed"
}

class UserProcessorRefactored {
    private val strategies = listOf(
        SuperAdminStrategy(),
        AdminStrategy(),
        // tambahkan strategy lain
    )
    
    fun processUser(user: User): String {
        return strategies
            .firstOrNull { it.canProcess(user) }
            ?.process(user)
            ?: "unknown_user"
    }
}
```

### üéì Penjelasan Konsep:
**Hands-on Exercises seperti Laboratorium:**
- **Praktis**: Langsung mengimplementasikan
- **Problem-solving**: Menghadapi masalah nyata
- **Learning by doing**: Belajar dari pengalaman langsung
- **Mastery**: Mencapai penguasaan melalui latihan

**Manfaat Hands-on Exercises:**
- **Deep Understanding**: Pemahaman mendalam tentang pattern
- **Practical Skills**: Kemampuan implementasi nyata
- **Problem Recognition**: Mengenali masalah dan solusi
- **Confidence Building**: Percaya diri dalam penggunaan pattern

---

## 1Ô∏è‚É£2Ô∏è‚É£ Resources & Further Learning üìö

### Konsep Dasar
Resources & Further Learning seperti perpustakaan digital üìñ - tempat untuk terus belajar dan mengembangkan pemahaman tentang Design Patterns!

### 1. Books & Publications:

**Essential Reading:**
```
üìñ Gang of Four - "Design Patterns: Elements of Reusable Object-Oriented Software"
   - Buku asli yang memperkenalkan 23 design patterns klasik
   - Penulis: Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides
   - Tahun: 1994
   - Bahasa: English
   - Relevansi: Sangat tinggi untuk pemahaman dasar

üìñ Martin Fowler - "Patterns of Enterprise Application Architecture"
   - Fokus pada pattern untuk arsitektur enterprise
   - Membahas lebih dalam tentang layering dan arsitektur
   - Sangat berguna untuk aplikasi skala besar

üìñ Robert C. Martin - "Clean Code: A Handbook of Agile Software Craftsmanship"
   - Tidak hanya tentang pattern, tapi juga prinsip clean code
   - Membahas bagaimana pattern digunakan dalam konteks clean code
```

**Android-Specific Books:**
```
üìñ Jake Wharton - "Effective Android"
   - Membahas best practices dan pattern khusus Android
   - Fokus pada efisiensi dan performa aplikasi Android

üìñ Dan Lew - "Android Development Patterns"
   - Kumpulan pattern dan praktik terbaik Android
   - Membahas MVVM, Repository, dan arsitektur Android modern
```

### 2. Online Resources:

**Free Resources:**
```
üåê Refactoring.Guru (https://refactoring.guru)
   - Website lengkap tentang design patterns
   - Diagram UML dan contoh kode dalam berbagai bahasa
   - Penjelasan dengan analogi yang mudah dipahami
   - Cocok untuk pemula dan menengah

üåê Sourcemaking (https://sourcemaking.com)
   - Koleksi design patterns dengan contoh kode
   - Diagram dan penjelasan komprehensif
   - Termasuk anti-patterns

üåê Android Developer Documentation
   - Official documentation dari Google
   - Membahas arsitektur Android dan pattern yang direkomendasikan
   - Updated secara berkala
```

**Interactive Learning:**
```
üåê Design Patterns Game (Various Online Platforms)
   - Game edukatif untuk belajar pattern
   - Membuat pembelajaran lebih menyenangkan
   - Cocok untuk pemahaman visual

üåê Udemy/Pluralsight Courses
   - Kursus video tentang design patterns
   - Banyak fokus pada implementasi praktis
   - Cocok untuk pembelajaran berbasis proyek
```

### 3. Code Examples & Open Source:

**Studi Kasus dari Open Source Apps:**
```
üì± GitHub Projects:
   - Square's Cash App: https://github.com/square/cash-app
     * Contoh arsitektur modular dan dependency injection
     * Pattern: Repository, MVVM, Dependency Injection
   
   - Google's Now In Android: https://github.com/android/nowinandroid
     * Contoh arsitektur modern Android
     * Pattern: Repository, Use Cases, State Management, Dependency Injection
   
   - JetBrains Exposed Framework
     * Contoh implementasi pattern dalam framework
     * Pattern: Builder, Chain of Responsibility, Strategy
```

**Sample Projects:**
```kotlin
// Contoh proyek sederhana
class SampleProjectStructure {
    /*
    app/
    ‚îú‚îÄ‚îÄ data/
    ‚îÇ   ‚îú‚îÄ‚îÄ local/          # Room database
    ‚îÇ   ‚îú‚îÄ‚îÄ remote/         # API services  
    ‚îÇ   ‚îî‚îÄ‚îÄ repository/     # Repository implementations
    ‚îú‚îÄ‚îÄ domain/
    ‚îÇ   ‚îú‚îÄ‚îÄ model/          # Data classes
    ‚îÇ   ‚îú‚îÄ‚îÄ repository/     # Repository interfaces
    ‚îÇ   ‚îî‚îÄ‚îÄ usecase/        # Use cases
    ‚îî‚îÄ‚îÄ presentation/
        ‚îú‚îÄ‚îÄ ui/             # Composables/Activities/Fragments
        ‚îú‚îÄ‚îÄ viewmodel/      # ViewModels
        ‚îî‚îÄ‚îÄ theme/          # Compose themes
    */
}
```

### 4. Video Tutorials & Courses:

**YouTube Channels:**
```
üì∫ Derek Banas - Programming Design Patterns
   - Video tutorial tentang berbagai design pattern
   - Penjelasan visual yang mudah dipahami
   - Kode contoh dalam beberapa bahasa

üì∫ Christopher Okhravi
   - Fokus pada software engineering concepts
   - Penjelasan mendalam tentang pattern dan arsitektur
   - Cocok untuk pemahaman teori dan praktik

üì∫ Android Developers Official Channel
   - Tutorial resmi dari Google
   - Fokus pada Android-specific patterns
   - Arsitektur dan best practices
```

**Online Courses:**
```
üéì Coursera - Design Patterns in Object Oriented Programming
   - Kursus dari universitas ternama
   - Pendekatan akademis dan praktis
   - Sertifikasi tersedia

üéì Udemy - Android Architecture Masterclass
   - Fokus pada arsitektur Android modern
   - Membahas banyak pattern secara praktis
   - Proyek hands-on
```

### 5. Communities & Forums:

**Active Communities:**
```
üë• Reddit - r/androiddev, r/java, r/kotlin
   - Diskusi aktif tentang design patterns
   - Sharing pengalaman implementasi
   - Update terbaru dan best practices

üë• Stack Overflow
   - Kumpulan pertanyaan dan jawaban
   - Banyak contoh kasus nyata
   - Solusi untuk masalah spesifik

üë• Kotlin Slack, Discord Developer Servers
   - Komunitas aktif untuk diskusi
   - Banyak expert yang berbagi pengetahuan
   - Update terbaru tentang teknologi
```

### 6. Practice Platforms:

**Coding Practice:**
```
üíª LeetCode - Design Problems
   - Problem design pattern dalam konteks algoritma
   - Latihan implementasi pattern
   - Cocok untuk persiapan interview

üíª Exercism - Kotlin Track
   - Latihan dengan mentor feedback
   - Fokus pada best practices
   - Termasuk design patterns

üíª Codewars
   - Katas (exercise) untuk latihan pattern
   - Berbagai tingkat kesulitan
   - Komunitas aktif
```

### 7. Blog & Articles:

**Quality Blogs:**
```
üìù Martin Fowler's Blog (https://martinfowler.com)
   - Artikel mendalam tentang arsitektur dan pattern
   - Update terus tentang praktik terbaru
   - Sangat direkomendasikan

üìù Medium - Android Developers Publication
   - Artikel dari developer Android
   - Pattern dan best practices
   - Update terbaru tentang Android

üìù Kotlin Blog (https://blog.jetbrains.com/kotlin/)
   - Update tentang Kotlin dan pattern
   - Best practices dan fitur baru
   - Contoh implementasi
```

### 8. Tools & IDE Support:

**Development Tools:**
```
üõ†Ô∏è IntelliJ IDEA / Android Studio
   - Support untuk refactoring pattern
   - Plugin untuk UML diagram
   - Detection anti-patterns

üõ†Ô∏è SonarQube
   - Static analysis untuk code quality
   - Detection pattern violations
   - Metrics untuk complexity

üõ†Ô∏è Detekt
   - Static analysis tool untuk Kotlin
   - Built-in rules untuk design patterns
   - Customizable rules
```

### 9. Certification & Advanced Learning:

**Advanced Learning Paths:**
```kotlin
class LearningPath {
    fun getLearningPath(): List<LearningStage> {
        return listOf(
            LearningStage.Basic("Understand Gang of Four Patterns", 2.weeks),
            LearningStage.Intermediate("Practice with Android Projects", 4.weeks),
            LearningStage.Advanced("Study Clean Architecture & SOLID", 3.weeks),
            LearningStage.Expert("Contribute to Open Source", ongoing)
        )
    }
}

data class LearningStage(
    val level: String,
    val topic: String,
    val duration: Int // dalam weeks
)

fun Int.weeks() = this * 7.days
fun Int.days() = this * 24.hours  
fun Int.hours() = this * 60.minutes
fun Int.minutes() = this.toLong()
```

### 10. Continuous Learning:

**Staying Updated:**
```
üîÑ Android Developer Newsletter
   - Update bulanan dari Google
   - Best practices dan pattern baru
   - Tips dan trik

üîÑ Kotlin Newsletter  
   - Update tentang Kotlin dan pattern
   - Fitur baru dan best practices
   - Contoh dan tutorial

üîÑ Conference Recordings
   - Android Dev Summit
   - KotlinConf
   - DroidCon series
```

### üéì Penjelasan Konsep:
**Resources & Further Learning sebagai Perpustakaan Digital:**
- **Always Available**: Akses 24/7 ke pengetahuan
- **Diverse Content**: Berbagai format dan pendekatan
- **Updated**: Informasi terbaru dan tren
- **Community Supported**: Dikelola oleh komunitas aktif

**Strategi Belajar Efektif:**
- **Start with Basics**: Pahami dulu konsep dasar
- **Practice Regularly**: Terapkan dalam proyek nyata
- **Learn from Experts**: Ikuti tutorial dan kursus
- **Contribute**: Share knowledge dan code di komunitas

---

## üéØ Kesimpulan

Design Patterns adalah fondasi penting dalam pengembangan software, terutama dalam konteks Android Development. Melalui dokumentasi ini, kita telah membahas berbagai aspek penting:

### 1. Pengenalan Design Patterns:
- **Apa itu Design Patterns**: Solusi umum untuk masalah umum dalam desain perangkat lunak
- **Gang of Four (GoF)**: 23 pattern klasik yang menjadi dasar
- **Klasifikasi**: Creational, Structural, dan Behavioral patterns
- **Relevansi dalam Android**: Banyak pattern diimplementasikan secara alami dalam framework Android

### 2. Creational Patterns:
- **Factory Pattern**: Mengatur pembuatan objek dengan fleksibilitas
- **Builder Pattern**: Membangun objek kompleks secara bertahap
- **Singleton Pattern**: Memastikan hanya satu instance dari sebuah kelas
- **Penerapan dalam Android**: ViewModelFactory, Retrofit Builder, Shared Preferences

### 3. Structural Patterns:
- **Adapter Pattern**: Menghubungkan interface yang tidak kompatibel
- **Decorator Pattern**: Menambah fungsionalitas tanpa merusak struktur asli
- **Facade Pattern**: Menyederhanakan antarmuka sistem kompleks
- **Penerapan dalam Android**: RecyclerView.Adapter, Image loading, Database operations

### 4. Behavioral Patterns:
- **Observer Pattern**: Menangani notifikasi otomatis antar objek
- **Strategy Pattern**: Memungkinkan perubahan algoritma saat runtime  
- **Command Pattern**: Merekam instruksi sebagai objek
- **Penerapan dalam Android**: LiveData, Flow, Callbacks, Event handling

### 5. Android-Specific Patterns:
- **ViewHolder Pattern**: Optimasi kinerja RecyclerView
- **Repository Pattern**: Abstraksi akses data
- **MVVM Pattern**: Separation of concerns dalam arsitektur
- **MVI Pattern**: State management yang reaktif

### 6. Pattern Combinations:
- **Kombinasi efektif**: Factory + Singleton, Strategy + Factory, Observer + Singleton
- **Penerapan dalam Clean Architecture**: MVVM + Repository + Use Cases
- **Integration dalam aplikasi nyata**: Retrofit + Builder + Factory + Adapter

### 7. Praktik Terbaik:
- **Kapan menggunakan pattern**: Ketika memecahkan masalah nyata
- **Kapan tidak menggunakan**: Hindari over-engineering
- **Anti-patterns**: God Object, Spaghetti Code, Lava Flow, Golden Hammer
- **Testing dengan pattern**: Memudahkan mock dan unit testing

### 8. Testing dan Quality:
- **Testability**: Pattern membuat kode lebih mudah diuji
- **Mock implementations**: Repository pattern sangat membantu
- **Verification**: Setiap pattern bisa diuji secara terpisah
- **Integration testing**: Kombinasi pattern bisa diuji bersama

### 9. Resources dan Pembelajaran Lanjutan:
- **Buku dan literatur**: Sumber teori yang komprehensif
- **Kode sumber terbuka**: Studi kasus nyata
- **Komunitas**: Tempat berdiskusi dan belajar
- **Platform praktik**: Tempat melatih keterampilan

### Manfaat Utama:
1. **Maintainability**: Kode lebih mudah dipelihara dan dimodifikasi
2. **Reusability**: Komponen bisa digunakan kembali
3. **Scalability**: Aplikasi bisa berkembang dengan baik
4. **Testability**: Kode lebih mudah diuji
5. **Communication**: Developer bisa berkomunikasi menggunakan istilah umum
6. **Quality**: Kode lebih kualitas tinggi dan kurang bug

### Prinsip Kunci:
- **Start Simple**: Mulai dari solusi sederhana
- **Refactor When Needed**: Gunakan pattern saat diperlukan
- **Team Understanding**: Pastikan tim memahami pattern yang digunakan
- **Avoid Over-Engineering**: Jangan gunakan pattern untuk segalanya
- **Focus on Problems**: Fokus menyelesaikan masalah, bukan menggunakan pattern

Dengan memahami dan menerapkan Design Patterns secara bijak, developer Android bisa menciptakan aplikasi yang lebih baik, lebih mudah dipelihara, dan lebih siap untuk pertumbuhan di masa depan. Kunci keberhasilannya adalah memahami kapan dan bagaimana menggunakan pattern yang tepat untuk masalah yang tepat.