# üé® Panduan Lengkap: Offline-First Architecture di Android

## üöÄ Pengantar: Aplikasi yang Bekerja Tanpa Internet

Bayangkan kamu adalah seorang perpustakaan digital üìö:
- **Offline-First** seperti buku yang selalu tersedia di rak
- **Cache** seperti memori jangka pendek
- **Sync** seperti pembaruan katalog berkala
- **Network** seperti pengiriman buku baru

Dengan menguasai Offline-First Architecture, kamu bisa membangun aplikasi yang responsif, handal, dan memberikan pengalaman pengguna yang konsisten!

## üìö Daftar Isi Pembelajaran
1. [üåü Offline-First Architecture Principles](#1Ô∏è‚É£-offline-first-architecture-principles-üåü)
2. [üîÑ Offline-First Data Flow](#2Ô∏è‚É£-offline-first-data-flow-üîÑ)
3. [üåê Network-Bound Resource Pattern](#3Ô∏è‚É£-network-bound-resource-pattern-üåê)
4. [üíæ Caching Strategies](#4Ô∏è‚É£-caching-strategies-üíæ)
5. [üì∂ Network State Monitoring](#5Ô∏è‚É£-network-state-monitoring-üì∂)
6. [‚è∞ Background Sync dengan WorkManager](#6Ô∏è‚É£-background-sync-dengan-workmanager-‚è∞)
7. [üìù Pending Operations Queue](#7Ô∏è‚É£-pending-operations-queue-üìù)
8. [‚öîÔ∏è Conflict Resolution](#8Ô∏è‚É£-conflict-resolution-‚öîÔ∏è)
9. [‚è≥ Cache Expiration & Invalidation](#9Ô∏è‚É£-cache-expiration--invalidation-‚è≥)
10. [üé≠ Optimistic Updates](#1Ô∏è‚É£0Ô∏è‚É£-optimistic-updates-üé≠)
11. [üìä Offline Indicators in UI](#1Ô∏è‚É£1Ô∏è‚É£-offline-indicators-in-ui-üìä)
12. [‚úÖ Best Practices](#1Ô∏è‚É£2Ô∏è‚É£-best-practices-‚úÖ)
13. [üß™ Testing Offline-First](#1Ô∏è‚É£3Ô∏è‚É£-testing-offline-first-üß™)
14. [üî® Hands-on Project](#1Ô∏è‚É£4Ô∏è‚É£-hands-on-project-üî®)

---

## 1Ô∏è‚É£ Offline-First Architecture Principles üåü

### Konsep Dasar
Offline-First Architecture seperti perpustakaan pribadi üìö - selalu memiliki akses ke buku-buku favorit Anda bahkan ketika tidak terhubung ke internet!

### Prinsip Utama Offline-First:
1. **Local database sebagai single source of truth**
   - Database lokal adalah sumber data utama
   - UI selalu membaca dari database lokal
   - Jaringan hanya untuk sinkronisasi

2. **UI reads from local database**
   - UI tidak pernah menunggu data dari jaringan
   - Responsif dan cepat
   - Memberikan pengalaman pengguna yang konsisten

3. **Network updates local database**
   - Data dari jaringan disimpan ke database lokal
   - UI secara otomatis diperbarui melalui observer
   - Tidak ada pembaruan UI langsung dari jaringan

4. **App works offline by default**
   - Aplikasi berfungsi penuh tanpa koneksi internet
   - Fungsionalitas dasar tetap tersedia
   - Pengguna dapat melihat dan berinteraksi dengan data yang ada

5. **Sync ketika online**
   - Sinkronisasi terjadi di latar belakang
   - Pengguna tidak perlu menunggu
   - Data diperbarui secara otomatis

6. **Conflict resolution strategy**
   - Menangani konflik antara data lokal dan server
   - Strategi yang jelas untuk menyelesaikan perbedaan
   - Memberikan kontrol kepada pengguna jika diperlukan

### Manfaat Offline-First:
- ‚úÖ **Better user experience**: Aplikasi responsif dan cepat
- ‚úÖ **Faster app performance**: Tidak ada penundaan jaringan
- ‚úÖ **Works without internet**: Fungsionalitas penuh offline
- ‚úÖ **Reduced server load**: Permintaan jaringan yang lebih sedikit
- ‚úÖ **Better perceived performance**: UI langsung merespons

### Implementasi Dasar:
**data/local/AppDatabase.kt**
```kotlin
package com.example.offlinefirst.data.local

import androidx.room.Database
import androidx.room.RoomDatabase
import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.local.dao.UserDao
import com.example.offlinefirst.data.local.entity.PostEntity
import com.example.offlinefirst.data.local.entity.UserEntity

/**
 * Database lokal sebagai single source of truth
 */
@Database(
    entities = [
        PostEntity::class,
        UserEntity::class
    ],
    version = 1,
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun postDao(): PostDao
    abstract fun userDao(): UserDao
}
```

**data/local/entity/PostEntity.kt**
```kotlin
package com.example.offlinefirst.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import com.example.offlinefirst.domain.model.Post

/**
 * Entity untuk tabel posts di database lokal
 */
@Entity(tableName = "posts")
data class PostEntity(
    @PrimaryKey
    val id: String,
    val title: String,
    val body: String,
    val userId: String,
    val userName: String,
    val likes: Int = 0,
    val comments: Int = 0,
    val isLiked: Boolean = false,
    val createdAt: Long,
    val updatedAt: Long,
    val lastSyncTime: Long = System.currentTimeMillis()
)

/**
 * Extension function untuk konversi Entity ke Domain Model
 */
fun PostEntity.toDomainModel(): Post {
    return Post(
        id = this.id,
        title = this.title,
        body = this.body,
        userId = this.userId,
        userName = this.userName,
        likes = this.likes,
        comments = this.comments,
        isLiked = this.isLiked,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt
    )
}

/**
 * Extension function untuk konversi Domain Model ke Entity
 */
fun Post.toEntity(): PostEntity {
    return PostEntity(
        id = this.id,
        title = this.title,
        body = this.body,
        userId = this.userId,
        userName = this.userName,
        likes = this.likes,
        comments = this.comments,
        isLiked = this.isLiked,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt
    )
}
```

### üéì Penjelasan Konsep:
**Offline-First seperti Perpustakaan Pribadi:**
- **Local Database**: Rak buku pribadi (selalu tersedia)
- **Network**: Pengiriman buku baru (hanya untuk pembaruan)
- **Sync**: Proses memperbarui katalog (terjadi di latar belakang)
- **UI**: Pembaca (selalu memiliki akses ke buku)

**Single Source of Truth:**
- Database lokal adalah satu-satunya sumber data yang valid
- UI selalu membaca dari database lokal
- Jaringan hanya untuk memperbarui database lokal

**Prinsip Offline-First:**
- Aplikasi harus berfungsi tanpa koneksi internet
- Responsivitas adalah prioritas utama
- Sinkronisasi terjadi di latar belakang

---

## 2Ô∏è‚É£ Offline-First Data Flow üîÑ

### Konsep Dasar
Data Flow Offline-First seperti sistem distribusi air üíß - selalu ada air di keran, bahkan ketika pompa utama sedang maintenance!

### Alur Data Offline-First:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    UI    ‚îÇ ‚Üê Always reads from local
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Database   ‚îÇ ‚Üê Single source of truth
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Repository  ‚îÇ ‚Üê Manages sync
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Network    ‚îÇ ‚Üê Background sync
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Implementasi Repository:
**data/repository/PostRepository.kt**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.local.entity.PostEntity
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.repository.PostRepository
import com.example.offlinefirst.domain.util.Resource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flow
import javax.inject.Inject

/**
 * Repository yang mengimplementasikan Offline-First
 */
class PostRepositoryImpl @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService,
    private val networkMonitor: NetworkMonitor
) : PostRepository {
    
    override fun getPosts(): Flow<Resource<List<Post>>> {
        return flow {
            // Emit loading state with cached data
            emit(Resource.Loading(postDao.getAllPosts().first().map { it.toDomainModel() }))
            
            if (networkMonitor.isConnected.value) {
                try {
                    // Fetch from network
                    val posts = postApiService.getPosts()
                    
                    // Save to local database
                    postDao.insertAll(posts.map { it.toEntity() })
                    
                    // Emit success with new data
                    postDao.getAllPosts().collect { entities ->
                        emit(Resource.Success(entities.map { it.toDomainModel() }))
                    }
                } catch (e: Exception) {
                    // On error, emit error with cached data
                    postDao.getAllPosts().collect { entities ->
                        emit(Resource.Error(e.message ?: "Unknown error", entities.map { it.toDomainModel() }))
                    }
                }
            } else {
                // Offline, use cached data
                postDao.getAllPosts().collect { entities ->
                    emit(Resource.Success(entities.map { it.toDomainModel() }))
                }
            }
        }
    }
    
    override fun getPostById(postId: String): Flow<Resource<Post>> {
        return flow {
            // Emit loading state with cached data
            val cachedPost = postDao.getPostById(postId)?.toDomainModel()
            emit(Resource.Loading(cachedPost))
            
            if (networkMonitor.isConnected.value) {
                try {
                    // Fetch from network
                    val post = postApiService.getPostById(postId)
                    
                    // Save to local database
                    postDao.insert(post.toEntity())
                    
                    // Emit success with new data
                    postDao.getPostById(postId)?.let { entity ->
                        emit(Resource.Success(entity.toDomainModel()))
                    }
                } catch (e: Exception) {
                    // On error, emit error with cached data
                    postDao.getPostById(postId)?.let { entity ->
                        emit(Resource.Error(e.message ?: "Unknown error", entity.toDomainModel()))
                    }
                }
            } else {
                // Offline, use cached data
                postDao.getPostById(postId)?.let { entity ->
                    emit(Resource.Success(entity.toDomainModel()))
                }
            }
        }
    }
    
    override suspend fun refreshPosts() {
        if (networkMonitor.isConnected.value) {
            try {
                val posts = postApiService.getPosts()
                postDao.deleteAll()
                postDao.insertAll(posts.map { it.toEntity() })
            } catch (e: Exception) {
                throw e
            }
        } else {
            throw Exception("No internet connection")
        }
    }
    
    override suspend fun createPost(post: Post): Post {
        // Save to local database immediately
        val localId = postDao.insert(post.toEntity())
        val localPost = post.copy(id = localId.toString())
        
        // Try to sync with server
        if (networkMonitor.isConnected.value) {
            try {
                val serverPost = postApiService.createPost(post)
                // Update local post with server ID
                postDao.updatePost(serverPost.toEntity())
                return serverPost
            } catch (e: Exception) {
                // Add to pending operations queue
                pendingOperationDao.insert(
                    PendingOperationEntity(
                        operationType = OperationType.CREATE,
                        entityType = "Post",
                        entityId = localId.toString(),
                        jsonData = Gson().toJson(localPost)
                    )
                )
                return localPost
            }
        } else {
            // Add to pending operations queue
            pendingOperationDao.insert(
                PendingOperationEntity(
                    operationType = OperationType.CREATE,
                    entityType = "Post",
                    entityId = localId.toString(),
                    jsonData = Gson().toJson(localPost)
                )
            )
            return localPost
        }
    }
    
    override suspend fun updatePost(post: Post): Post {
        // Update local database immediately
        postDao.updatePost(post.toEntity())
        
        // Try to sync with server
        if (networkMonitor.isConnected.value) {
            try {
                val serverPost = postApiService.updatePost(post.id, post)
                // Update local post with server response
                postDao.updatePost(serverPost.toEntity())
                return serverPost
            } catch (e: Exception) {
                // Add to pending operations queue
                pendingOperationDao.insert(
                    PendingOperationEntity(
                        operationType = OperationType.UPDATE,
                        entityType = "Post",
                        entityId = post.id,
                        jsonData = Gson().toJson(post)
                    )
                )
                return post
            }
        } else {
            // Add to pending operations queue
            pendingOperationDao.insert(
                PendingOperationEntity(
                    operationType = OperationType.UPDATE,
                    entityType = "Post",
                    entityId = post.id,
                    jsonData = Gson().toJson(post)
                )
            )
            return post
        }
    }
    
    override suspend fun deletePost(postId: String) {
        // Delete from local database immediately
        postDao.deletePostById(postId)
        
        // Try to sync with server
        if (networkMonitor.isConnected.value) {
            try {
                postApiService.deletePost(postId)
            } catch (e: Exception) {
                // Add to pending operations queue
                pendingOperationDao.insert(
                    PendingOperationEntity(
                        operationType = OperationType.DELETE,
                        entityType = "Post",
                        entityId = postId,
                        jsonData = ""
                    )
                )
            }
        } else {
            // Add to pending operations queue
            pendingOperationDao.insert(
                PendingOperationEntity(
                    operationType = OperationType.DELETE,
                    entityType = "Post",
                    entityId = postId,
                    jsonData = ""
                )
            )
        }
    }
}
```

### Domain Layer:
**domain/repository/PostRepository.kt**
```kotlin
package com.example.offlinefirst.domain.repository

import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.util.Resource
import kotlinx.coroutines.flow.Flow

/**
 * Interface untuk Post Repository
 */
interface PostRepository {
    fun getPosts(): Flow<Resource<List<Post>>>
    fun getPostById(postId: String): Flow<Resource<Post>>
    suspend fun refreshPosts()
    suspend fun createPost(post: Post): Post
    suspend fun updatePost(post: Post): Post
    suspend fun deletePost(postId: String)
}
```

### Resource Wrapper:
**domain/util/Resource.kt**
```kotlin
package com.example.offlinefirst.domain.util

/**
 * Sealed class untuk mengelola state data
 */
sealed class Resource<T>(
    val data: T? = null,
    val message: String? = null
) {
    class Success<T>(data: T) : Resource<T>(data)
    class Loading<T>(data: T? = null) : Resource<T>(data)
    class Error<T>(message: String, data: T? = null) : Resource<T>(data, message)
}
```

### üéì Penjelasan Konsep:
**Data Flow Offline-First seperti Sistem Distribusi Air:**
- **UI**: Keran air (selalu mengalir)
- **Database**: Reservoir air (penyimpanan utama)
- **Repository**: Sistem kontrol (mengatur aliran)
- **Network**: Pompa air (mengisi reservoir)

**Alur Data Offline-First:**
1. UI selalu membaca dari database lokal
2. Repository mengelola sinkronisasi antara lokal dan jaringan
3. Jaringan hanya untuk memperbarui database lokal
4. UI secara otomatis diperbarui melalui observer

**Keuntungan Offline-First:**
- Responsif dan cepat
- Bekerja tanpa koneksi internet
- Pengalaman pengguna yang konsisten
- Mengurangi beban server

---

## 3Ô∏è‚É£ Network-Bound Resource Pattern üåê

### Konsep Dasar
Network-Bound Resource Pattern seperti perpustakaan dengan sistem reservasi üìö - selalu cek ketersediaan lokal sebelum menghubungi gudang pusat!

### Pengertian Network-Bound Resource:
Network-Bound Resource adalah pola yang:
- Menggunakan database lokal sebagai cache
- Menampilkan data dari cache jika tersedia
- Memperbarui cache dari jaringan jika diperlukan
- Menangani loading dan error states dengan baik

### Implementasi Network-Bound Resource:
**data/util/NetworkBoundResource.kt**
```kotlin
package com.example.offlinefirst.data.util

import com.example.offlinefirst.domain.util.Resource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart

/**
 * Implementasi Network-Bound Resource Pattern
 */
inline fun <ResultType, RequestType> networkBoundResource(
    crossinline query: () -> Flow<ResultType>,
    crossinline fetch: suspend () -> RequestType,
    crossinline saveFetchResult: suspend (RequestType) -> Unit,
    crossinline shouldFetch: (ResultType) -> Boolean = { true }
): Flow<Resource<ResultType>> = flow {
    
    // 1. Emit loading state with cached data
    emit(Resource.Loading(query().first()))
    
    // 2. Get data from cache
    val data = query().first()
    
    // 3. Check if we should fetch from network
    if (shouldFetch(data)) {
        try {
            // 4. Fetch from network
            val apiResponse = fetch()
            
            // 5. Save to database
            saveFetchResult(apiResponse)
            
            // 6. Emit success with new data
            query().collect { newData ->
                emit(Resource.Success(newData))
            }
        } catch (e: Exception) {
            // 7. On error, emit error with cached data
            query().collect { cachedData ->
                emit(Resource.Error(e.message ?: "Unknown error", cachedData))
            }
        }
    } else {
        // 8. No need to fetch, use cached data
        query().collect { cachedData ->
            emit(Resource.Success(cachedData))
        }
    }
}

/**
 * Implementasi Network-Bound Resource dengan Flow
 */
inline fun <ResultType, RequestType> networkBoundResourceFlow(
    crossinline query: () -> Flow<ResultType>,
    crossinline fetch: suspend () -> RequestType,
    crossinline saveFetchResult: suspend (RequestType) -> Unit,
    crossinline shouldFetch: (ResultType) -> Boolean = { true }
): Flow<Resource<ResultType>> {
    return query()
        .map { Resource.Success(it) as Resource<ResultType> }
        .onStart { emit(Resource.Loading(query().first())) }
        .catch { emit(Resource.Error(it.message ?: "Unknown error")) }
        .flowOn(Dispatchers.IO)
}
```

### Implementasi dengan Repository:
**data/repository/PostRepositoryImpl.kt**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.data.util.networkBoundResource
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.repository.PostRepository
import com.example.offlinefirst.domain.util.Resource
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject

/**
 * Repository dengan Network-Bound Resource Pattern
 */
class PostRepositoryImpl @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService
) : PostRepository {
    
    override fun getPosts(): Flow<Resource<List<Post>>> {
        return networkBoundResource(
            query = { 
                postDao.getAllPosts().map { entities ->
                    entities.map { it.toDomainModel() }
                }
            },
            fetch = { postApiService.getPosts() },
            saveFetchResult = { posts ->
                postDao.deleteAll()
                postDao.insertAll(posts.map { it.toEntity() })
            },
            shouldFetch = { cachedPosts ->
                // Fetch if cache is empty or stale
                cachedPosts.isEmpty() || isCacheStale()
            }
        )
    }
    
    override fun getPostById(postId: String): Flow<Resource<Post>> {
        return networkBoundResource(
            query = { 
                postDao.getPostById(postId)?.toDomainModel()
                    ?: throw Exception("Post not found")
            },
            fetch = { postApiService.getPostById(postId) },
            saveFetchResult = { post ->
                postDao.insert(post.toEntity())
            },
            shouldFetch = { cachedPost ->
                // Fetch if cache is empty or stale
                isCacheStale()
            }
        )
    }
    
    private fun isCacheStale(): Boolean {
        // Implementasi pengecekan cache stale
        // Bisa berdasarkan waktu atau kondisi lainnya
        return true
    }
}
```

### Implementasi dengan ViewModel:
**presentation/viewmodel/PostListViewModel.kt**
```kotlin
package com.example.offlinefirst.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.repository.PostRepository
import com.example.offlinefirst.domain.util.Resource
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel dengan Network-Bound Resource Pattern
 */
@HiltViewModel
class PostListViewModel @Inject constructor(
    private val postRepository: PostRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<PostListUiState>(PostListUiState.Loading)
    val uiState: StateFlow<PostListUiState> = _uiState.asStateFlow()
    
    init {
        loadPosts()
    }
    
    fun loadPosts() {
        viewModelScope.launch {
            postRepository.getPosts().collect { resource ->
                when (resource) {
                    is Resource.Loading -> {
                        _uiState.value = PostListUiState.Loading(resource.data ?: emptyList())
                    }
                    is Resource.Success -> {
                        _uiState.value = PostListUiState.Success(resource.data ?: emptyList())
                    }
                    is Resource.Error -> {
                        _uiState.value = PostListUiState.Error(
                            resource.message ?: "Unknown error",
                            resource.data ?: emptyList()
                        )
                    }
                }
            }
        }
    }
    
    fun refreshPosts() {
        viewModelScope.launch {
            try {
                postRepository.refreshPosts()
            } catch (e: Exception) {
                _uiState.value = PostListUiState.Error(
                    e.message ?: "Failed to refresh",
                    (_uiState.value as? PostListUiState.Success)?.posts ?: emptyList()
                )
            }
        }
    }
}

/**
 * UI State untuk PostList
 */
sealed class PostListUiState {
    data class Loading(val posts: List<Post> = emptyList()) : PostListUiState()
    data class Success(val posts: List<Post>) : PostListUiState()
    data class Error(val message: String, val posts: List<Post>) : PostListUiState()
}
```

### üéì Penjelasan Konsep:
**Network-Bound Resource seperti Perpustakaan dengan Sistem Reservasi:**
- **Local Database**: Koleksi buku di perpustakaan lokal
- **Network**: Gudang pusat dengan semua buku
- **Query**: Memeriksa ketersediaan buku di perpustakaan lokal
- **Fetch**: Memesan buku dari gudang pusat jika tidak tersedia
- **Save**: Menambahkan buku baru ke koleksi lokal

**Alur Network-Bound Resource:**
1. Tampilkan loading state dengan data cache
2. Periksa apakah perlu fetch dari jaringan
3. Jika ya, fetch dari jaringan
4. Simpan hasil ke database lokal
5. Tampilkan data baru
6. Jika error, tampilkan error dengan data cache
7. Jika tidak perlu fetch, gunakan data cache

**Keuntungan Network-Bound Resource:**
- Responsif dengan data cache
- Menghemat bandwidth
- Bekerja offline
- Pengalaman pengguna yang konsisten

---

## 4Ô∏è‚É£ Caching Strategies üíæ

### Konsep Dasar
Caching Strategies seperti strategi penyimpanan makanan üç± - berbagai cara untuk menyimpan dan mengelola makanan agar tetap segar dan tersedia!

### Jenis-Jenis Caching Strategy:

#### 1. Cache-First Strategy
**Konsep:** Selalu baca dari cache terlebih dahulu, perbarui di latar belakang

**Implementasi:**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.domain.model.Post
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * Repository dengan Cache-First Strategy
 */
class PostRepositoryCacheFirst @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService
) {
    
    fun getPosts(): Flow<List<Post>> {
        // Update cache in background
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val freshPosts = postApiService.getPosts()
                postDao.insertAll(freshPosts.map { it.toEntity() })
            } catch (e: Exception) {
                // Silent fail, user already has cached data
            }
        }
        
        // Return cached data immediately
        return postDao.getAllPosts().map { entities ->
            entities.map { it.toDomainModel() }
        }
    }
}
```

#### 2. Network-First with Cache Fallback Strategy
**Konsep:** Coba jaringan terlebih dahulu, gunakan cache jika gagal

**Implementasi:**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.util.Resource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject

/**
 * Repository dengan Network-First with Cache Fallback Strategy
 */
class PostRepositoryNetworkFirst @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService
) {
    
    fun getPosts(): Flow<Resource<List<Post>>> = flow {
        try {
            // Try network first
            val posts = postApiService.getPosts()
            
            // Update cache
            postDao.insertAll(posts.map { it.toEntity() })
            
            emit(Resource.Success(posts))
        } catch (e: Exception) {
            // Network failed, use cache
            val cachedPosts = postDao.getAllPosts().first().map { it.toDomainModel() }
            if (cachedPosts.isNotEmpty()) {
                emit(Resource.Error("Using cached data", cachedPosts))
            } else {
                emit(Resource.Error(e.message ?: "No data available", null))
            }
        }
    }
}
```

#### 3. Cache-Only (True Offline-First) Strategy
**Konsep:** UI selalu membaca dari cache, sinkronisasi terjadi secara independen

**Implementasi:**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.domain.model.Post
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * Repository dengan Cache-Only Strategy
 */
class PostRepositoryCacheOnly @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService
) {
    
    // UI always reads from cache
    fun getUsersFlow(): Flow<List<Post>> = postDao.getAllPosts().map { entities ->
        entities.map { it.toDomainModel() }
    }
    
    // Sync happens independently
    fun syncUsers() {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val posts = postApiService.getPosts()
                postDao.insertAll(posts.map { it.toEntity() })
                updateLastSyncTime()
            } catch (e: Exception) {
                // Log error, retry later
            }
        }
    }
    
    private fun updateLastSyncTime() {
        // Implementasi update last sync time
    }
}
```

#### 4. Stale-While-Revalidate Strategy
**Konsep:** Tampilkan data cache (meskipun stale), perbarui di latar belakang

**Implementasi:**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.util.Resource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject

/**
 * Repository dengan Stale-While-Revalidate Strategy
 */
class PostRepositoryStaleWhileRevalidate @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService
) {
    
    fun getStaleWhileRevalidate(): Flow<Resource<List<Post>>> = flow {
        // Emit cached data immediately (even if stale)
        val cached = postDao.getAllPosts().first().map { it.toDomainModel() }
        if (cached.isNotEmpty()) {
            emit(Resource.Success(cached))
        }
        
        // Fetch fresh data in background
        try {
            val fresh = postApiService.getPosts()
            postDao.insertAll(fresh.map { it.toEntity() })
            
            // Emit fresh data
            emit(Resource.Success(fresh))
        } catch (e: Exception) {
            // Keep showing cached data
            if (cached.isEmpty()) {
                emit(Resource.Error(e.message, null))
            }
        }
    }
}
```

### Cache Metadata Management:
**data/local/entity/CacheMetadataEntity.kt**
```kotlin
package com.example.offlinefirst.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Entity untuk metadata cache
 */
@Entity(tableName = "cache_metadata")
data class CacheMetadataEntity(
    @PrimaryKey
    val key: String,
    val lastFetchTime: Long,
    val expirationTime: Long
)
```

**data/local/dao/CacheMetadataDao.kt**
```kotlin
package com.example.offlinefirst.data.local.dao

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.example.offlinefirst.data.local.entity.CacheMetadataEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO untuk cache metadata
 */
@Dao
interface CacheMetadataDao {
    @Query("SELECT * FROM cache_metadata WHERE key = :key")
    suspend fun getMetadata(key: String): CacheMetadataEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(metadata: CacheMetadataEntity)
    
    @Query("DELETE FROM cache_metadata WHERE key = :key")
    suspend fun delete(key: String)
    
    @Query("SELECT * FROM cache_metadata")
    fun getAllMetadata(): Flow<List<CacheMetadataEntity>>
}
```

**data/util/CacheManager.kt**
```kotlin
package com.example.offlinefirst.data.util

import com.example.offlinefirst.data.local.dao.CacheMetadataDao
import kotlinx.coroutines.flow.first
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Manager untuk cache metadata
 */
@Singleton
class CacheManager @Inject constructor(
    private val cacheMetadataDao: CacheMetadataDao
) {
    suspend fun isCacheValid(key: String, maxAgeMillis: Long): Boolean {
        val metadata = cacheMetadataDao.getMetadata(key) ?: return false
        val now = System.currentTimeMillis()
        return (now - metadata.lastFetchTime) < maxAgeMillis
    }
    
    suspend fun updateCacheTime(key: String, expirationMillis: Long = TimeUnit.HOURS.toMillis(1)) {
        val metadata = CacheMetadataEntity(
            key = key,
            lastFetchTime = System.currentTimeMillis(),
            expirationTime = System.currentTimeMillis() + expirationMillis
        )
        cacheMetadataDao.insert(metadata)
    }
    
    suspend fun invalidateCache(key: String) {
        cacheMetadataDao.delete(key)
    }
    
    suspend fun isCacheExpired(key: String): Boolean {
        val metadata = cacheMetadataDao.getMetadata(key) ?: return true
        return System.currentTimeMillis() > metadata.expirationTime
    }
}
```

### üéì Penjelasan Konsep:
**Caching Strategies seperti Strategi Penyimpanan Makanan:**
- **Cache-First**: Makanan di kulkas (selalu tersedia, diperbarui secara berkala)
- **Network-First**: Membeli makanan segar (coba dapur dulu, baru ke pasar)
- **Cache-Only**: Makanan kaleng (hanya mengandalkan stok, sinkronisasi terpisah)
- **Stale-While-Revalidate**: Makanan yang masih layak (dimakan dulu, baru cek kedaluwarsa)

**Pemilihan Strategi:**
- **Cache-First**: Untuk data yang jarang berubah
- **Network-First**: Untuk data yang harus selalu up-to-date
- **Cache-Only**: Untuk aplikasi yang benar-benar offline-first
- **Stale-While-Revalidate**: Untuk keseimbangan antara kecepatan dan kesegaran data

**Best Practices:**
- Gunakan metadata untuk melacak usia cache
- Implementasikan cache expiration
- Berikan opsi untuk refresh manual
- Gunakan strategi yang sesuai dengan kebutuhan aplikasi

---

## 5Ô∏è‚É£ Network State Monitoring üì∂

### Konsep Dasar
Network State Monitoring seperti sistem peringatan cuaca ‚õàÔ∏è - memberi tahu aplikasi ketika "cuaca" jaringan berubah!

### Pengertian Network State Monitoring:
Network State Monitoring adalah kemampuan aplikasi untuk:
- Mendeteksi status koneksi jaringan
- Bereaksi terhadap perubahan status koneksi
- Menyesuaikan perilaku aplikasi berdasarkan status
- Memberikan informasi kepada pengguna

### Implementasi Network Monitor:
**data/util/NetworkMonitor.kt**
```kotlin
package com.example.offlinefirst.data.util

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.receiveAsFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Monitor untuk status koneksi jaringan
 */
@Singleton
class NetworkMonitor @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val connectivityManager = context.getSystemService(
        Context.CONNECTIVITY_SERVICE
    ) as ConnectivityManager
    
    private val _isConnected = Channel<Boolean>(Channel.BUFFERED)
    val isConnected: Flow<Boolean> = _isConnected.receiveAsFlow()
    
    private val networkCallback = object : ConnectivityManager.NetworkCallback() {
        override fun onAvailable(network: Network) {
            _isConnected.trySend(true)
        }
        
        override fun onLost(network: Network) {
            _isConnected.trySend(false)
        }
        
        override fun onCapabilitiesChanged(
            network: Network,
            networkCapabilities: NetworkCapabilities
        ) {
            val isConnected = networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) &&
                    networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
            _isConnected.trySend(isConnected)
        }
    }
    
    init {
        registerNetworkCallback()
        // Emit current state
        CoroutineScope(Dispatchers.IO).launch {
            _isConnected.trySend(isNetworkAvailable())
        }
    }
    
    private fun registerNetworkCallback() {
        val networkRequest = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()
        
        connectivityManager.registerNetworkCallback(networkRequest, networkCallback)
    }
    
    fun isNetworkAvailable(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network)
        return capabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) == true &&
                capabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED) == true
    }
    
    fun unregisterNetworkCallback() {
        connectivityManager.unregisterNetworkCallback(networkCallback)
    }
}
```

### Implementasi dengan StateFlow:
**data/util/NetworkMonitorStateFlow.kt**
```kotlin
package com.example.offlinefirst.data.util

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Monitor untuk status koneksi jaringan dengan StateFlow
 */
@Singleton
class NetworkMonitorStateFlow @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val connectivityManager = context.getSystemService(
        Context.CONNECTIVITY_SERVICE
    ) as ConnectivityManager
    
    private val _isConnected = MutableStateFlow(false)
    val isConnected: StateFlow<Boolean> = _isConnected.asStateFlow()
    
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    
    private val networkCallback = object : ConnectivityManager.NetworkCallback() {
        override fun onAvailable(network: Network) {
            _isConnected.value = true
        }
        
        override fun onLost(network: Network) {
            _isConnected.value = false
        }
        
        override fun onCapabilitiesChanged(
            network: Network,
            networkCapabilities: NetworkCapabilities
        ) {
            val isConnected = networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) &&
                    networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
            _isConnected.value = isConnected
        }
    }
    
    init {
        registerNetworkCallback()
        // Set initial state
        scope.launch {
            _isConnected.value = isNetworkAvailable()
        }
    }
    
    private fun registerNetworkCallback() {
        val networkRequest = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()
        
        connectivityManager.registerNetworkCallback(networkRequest, networkCallback)
    }
    
    fun isNetworkAvailable(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network)
        return capabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) == true &&
                capabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED) == true
    }
    
    fun onCleared() {
        connectivityManager.unregisterNetworkCallback(networkCallback)
        scope.cancel()
    }
}
```

### Implementasi dengan Repository:
**data/repository/PostRepositoryImpl.kt**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.data.util.NetworkMonitor
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.repository.PostRepository
import com.example.offlinefirst.domain.util.Resource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart
import javax.inject.Inject

/**
 * Repository dengan Network State Monitoring
 */
class PostRepositoryImpl @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService,
    private val networkMonitor: NetworkMonitor
) : PostRepository {
    
    override fun getPosts(): Flow<Resource<List<Post>>> = flow {
        // Emit loading state with cached data
        emit(Resource.Loading(postDao.getAllPosts().first().map { it.toDomainModel() }))
        
        // Check network status
        if (networkMonitor.isNetworkAvailable()) {
            try {
                // Fetch from network
                val posts = postApiService.getPosts()
                
                // Save to local database
                postDao.insertAll(posts.map { it.toEntity() })
                
                // Emit success with new data
                postDao.getAllPosts().collect { entities ->
                    emit(Resource.Success(entities.map { it.toDomainModel() }))
                }
            } catch (e: Exception) {
                // On error, emit error with cached data
                postDao.getAllPosts().collect { entities ->
                    emit(Resource.Error(e.message ?: "Unknown error", entities.map { it.toDomainModel() }))
                }
            }
        } else {
            // Offline, use cached data
            postDao.getAllPosts().collect { entities ->
                emit(Resource.Success(entities.map { it.toDomainModel() }))
            }
        }
    }
    
    override suspend fun refreshPosts() {
        if (networkMonitor.isNetworkAvailable()) {
            try {
                val posts = postApiService.getPosts()
                postDao.deleteAll()
                postDao.insertAll(posts.map { it.toEntity() })
            } catch (e: Exception) {
                throw Exception("Failed to refresh: ${e.message}")
            }
        } else {
            throw Exception("No internet connection")
        }
    }
    
    override suspend fun syncPosts() {
        if (networkMonitor.isNetworkAvailable()) {
            try {
                val posts = postApiService.getPosts()
                postDao.insertAll(posts.map { it.toEntity() })
            } catch (e: Exception) {
                throw Exception("Failed to sync: ${e.message}")
            }
        } else {
            throw Exception("No internet connection")
        }
    }
}
```

### Implementasi dengan ViewModel:
**presentation/viewmodel/PostListViewModel.kt**
```kotlin
package com.example.offlinefirst.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.offlinefirst.data.util.NetworkMonitor
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.repository.PostRepository
import com.example.offlinefirst.domain.util.Resource
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel dengan Network State Monitoring
 */
@HiltViewModel
class PostListViewModel @Inject constructor(
    private val postRepository: PostRepository,
    private val networkMonitor: NetworkMonitor
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<PostListUiState>(PostListUiState.Loading)
    val uiState: StateFlow<PostListUiState> = _uiState.asStateFlow()
    
    private val _isConnected = MutableStateFlow(false)
    val isConnected: StateFlow<Boolean> = _isConnected.asStateFlow()
    
    init {
        loadPosts()
        monitorNetworkState()
    }
    
    private fun loadPosts() {
        viewModelScope.launch {
            postRepository.getPosts().collect { resource ->
                when (resource) {
                    is Resource.Loading -> {
                        _uiState.value = PostListUiState.Loading(resource.data ?: emptyList())
                    }
                    is Resource.Success -> {
                        _uiState.value = PostListUiState.Success(resource.data ?: emptyList())
                    }
                    is Resource.Error -> {
                        _uiState.value = PostListUiState.Error(
                            resource.message ?: "Unknown error",
                            resource.data ?: emptyList()
                        )
                    }
                }
            }
        }
    }
    
    private fun monitorNetworkState() {
        viewModelScope.launch {
            networkMonitor.isConnected.collect { isConnected ->
                _isConnected.value = isConnected
                
                // If we just came online and have an error state, try to refresh
                if (isConnected && _uiState.value is PostListUiState.Error) {
                    refreshPosts()
                }
            }
        }
    }
    
    fun refreshPosts() {
        viewModelScope.launch {
            try {
                postRepository.refreshPosts()
            } catch (e: Exception) {
                _uiState.value = PostListUiState.Error(
                    e.message ?: "Failed to refresh",
                    (_uiState.value as? PostListUiState.Success)?.posts ?: emptyList()
                )
            }
        }
    }
}

/**
 * UI State untuk PostList
 */
sealed class PostListUiState {
    data class Loading(val posts: List<Post> = emptyList()) : PostListUiState()
    data class Success(val posts: List<Post>) : PostListUiState()
    data class Error(val message: String, val posts: List<Post>) : PostListUiState()
}
```

### üéì Penjelasan Konsep:
**Network State Monitoring seperti Sistem Peringatan Cuaca:**
- **Network Monitor**: Stasiun pemantau cuaca
- **ConnectivityManager**: Alat pengukur
- **NetworkCallback**: Sistem peringatan dini
- **Status Changes**: Perubahan kondisi cuaca

**Implementasi Network Monitoring:**
1. Mendaftarkan callback untuk perubahan jaringan
2. Mendeteksi status koneksi saat ini
3. Memberi tahu aplikasi ketika status berubah
4. Menyesuaikan perilaku berdasarkan status

**Best Practices:**
- Gunakan dependency injection untuk memudahkan testing
- Bersihkan callback ketika tidak diperlukan
- Gunakan Flow atau StateFlow untuk reactive programming
- Berikan informasi yang jelas kepada pengguna

---

## 6Ô∏è‚É£ Background Sync dengan WorkManager ‚è∞

### Konsep Dasar
Background Sync dengan WorkManager seperti asisten pribadi ü§ñ - mengerjakan tugas sinkronisasi di latar belakang bahkan ketika aplikasi tidak berjalan!

### Pengertian WorkManager:
WorkManager adalah komponen Android yang:
- Menjalankan tugas yang dijamin akan selesai
- Bekerja bahkan ketika aplikasi tidak berjalan
- Mendukung batasan (constraints) seperti jaringan atau daya
- Mendukung tugas berulang (periodic)
- Mendukung rantai tugas (work chains)

### Implementasi Sync Worker:
**data/work/SyncWorker.kt**
```kotlin
package com.example.offlinefirst.data.work

import android.content.Context
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.example.offlinefirst.domain.repository.PostRepository
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject

/**
 * Worker untuk sinkronisasi data
 */
@HiltWorker
class SyncWorker @AssistedInject constructor(
    @Assisted context: Context,
    @Assisted workerParams: WorkerParameters,
    private val postRepository: PostRepository
) : CoroutineWorker(context, workerParams) {
    
    override suspend fun doWork(): Result {
        return try {
            // Sync posts
            postRepository.syncPosts()
            
            // Sync pending operations
            postRepository.syncPendingOperations()
            
            Result.success()
        } catch (e: Exception) {
            // Log error
            if (runAttemptCount < 3) {
                // Retry with exponential backoff
                Result.retry()
            } else {
                // Fail after 3 attempts
                Result.failure()
            }
        }
    }
}
```

### Implementasi Pending Operations Worker:
**data/work/PendingOperationsWorker.kt**
```kotlin
package com.example.offlinefirst.data.work

import android.content.Context
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.example.offlinefirst.domain.repository.PostRepository
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject

/**
 * Worker untuk sinkronisasi operasi yang tertunda
 */
@HiltWorker
class PendingOperationsWorker @AssistedInject constructor(
    @Assisted context: Context,
    @Assisted workerParams: WorkerParameters,
    private val postRepository: PostRepository
) : CoroutineWorker(context, workerParams) {
    
    override suspend fun doWork(): Result {
        return try {
            // Sync pending operations
            postRepository.syncPendingOperations()
            
            Result.success()
        } catch (e: Exception) {
            // Log error
            if (runAttemptCount < 3) {
                // Retry with exponential backoff
                Result.retry()
            } else {
                // Fail after 3 attempts
                Result.failure()
            }
        }
    }
}
```

### Implementasi WorkManager Scheduler:
**data/work/WorkManagerScheduler.kt**
```kotlin
package com.example.offlinefirst.data.work

import android.content.Context
import androidx.work.*
import com.example.offlinefirst.data.work.PendingOperationsWorker
import com.example.offlinefirst.data.work.SyncWorker
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Scheduler untuk WorkManager
 */
@Singleton
class WorkManagerScheduler @Inject constructor(
    private val context: Context
) {
    
    fun schedulePeriodicSync() {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .setRequiresBatteryNotLow(true)
            .build()
        
        val syncRequest = PeriodicWorkRequestBuilder<SyncWorker>(
            repeatInterval = 1,
            repeatIntervalTimeUnit = TimeUnit.HOURS
        )
            .setConstraints(constraints)
            .setBackoffCriteria(
                BackoffPolicy.EXPONENTIAL,
                WorkRequest.MIN_BACKOFF_MILLIS,
                TimeUnit.MILLISECONDS
            )
            .build()
        
        WorkManager.getInstance(context)
            .enqueueUniquePeriodicWork(
                "periodic_sync",
                ExistingPeriodicWorkPolicy.KEEP,
                syncRequest
            )
    }
    
    fun scheduleImmediateSync() {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()
        
        val syncRequest = OneTimeWorkRequestBuilder<SyncWorker>()
            .setConstraints(constraints)
            .setBackoffCriteria(
                BackoffPolicy.EXPONENTIAL,
                WorkRequest.MIN_BACKOFF_MILLIS,
                TimeUnit.MILLISECONDS
            )
            .build()
        
        WorkManager.getInstance(context)
            .enqueueUniqueWork(
                "immediate_sync",
                ExistingWorkPolicy.KEEP,
                syncRequest
            )
    }
    
    fun schedulePendingOperationsSync() {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()
        
        val pendingOpsRequest = OneTimeWorkRequestBuilder<PendingOperationsWorker>()
            .setConstraints(constraints)
            .setBackoffCriteria(
                BackoffPolicy.EXPONENTIAL,
                WorkRequest.MIN_BACKOFF_MILLIS,
                TimeUnit.MILLISECONDS
            )
            .build()
        
        WorkManager.getInstance(context)
            .enqueueUniqueWork(
                "pending_operations_sync",
                ExistingWorkPolicy.KEEP,
                pendingOpsRequest
            )
    }
    
    fun cancelAllWork() {
        WorkManager.getInstance(context).cancelAllWork()
    }
}
```

### Implementasi dengan Repository:
**data/repository/PostRepositoryImpl.kt**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.local.dao.PendingOperationDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.data.work.WorkManagerScheduler
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.repository.PostRepository
import com.example.offlinefirst.domain.util.Resource
import com.google.gson.Gson
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.onStart
import javax.inject.Inject

/**
 * Repository dengan Background Sync
 */
class PostRepositoryImpl @Inject constructor(
    private val postDao: PostDao,
    private val pendingOperationDao: PendingOperationDao,
    private val postApiService: PostApiService,
    private val workManagerScheduler: WorkManagerScheduler
) : PostRepository {
    
    override fun getPosts(): Flow<Resource<List<Post>>> = flow {
        // Emit loading state with cached data
        emit(Resource.Loading(postDao.getAllPosts().first().map { it.toDomainModel() }))
        
        try {
            // Fetch from network
            val posts = postApiService.getPosts()
            
            // Save to local database
            postDao.insertAll(posts.map { it.toEntity() })
            
            // Emit success with new data
            postDao.getAllPosts().collect { entities ->
                emit(Resource.Success(entities.map { it.toDomainModel() }))
            }
        } catch (e: Exception) {
            // On error, emit error with cached data
            postDao.getAllPosts().collect { entities ->
                emit(Resource.Error(e.message ?: "Unknown error", entities.map { it.toDomainModel() }))
            }
        }
    }
    
    override suspend fun createPost(post: Post): Post {
        // Save to local database immediately
        val localId = postDao.insert(post.toEntity())
        val localPost = post.copy(id = localId.toString())
        
        // Add to pending operations queue
        pendingOperationDao.insert(
            PendingOperationEntity(
                operationType = OperationType.CREATE,
                entityType = "Post",
                entityId = localId.toString(),
                jsonData = Gson().toJson(localPost)
            )
        )
        
        // Schedule background sync
        workManagerScheduler.schedulePendingOperationsSync()
        
        return localPost
    }
    
    override suspend fun updatePost(post: Post): Post {
        // Update local database immediately
        postDao.updatePost(post.toEntity())
        
        // Add to pending operations queue
        pendingOperationDao.insert(
            PendingOperationEntity(
                operationType = OperationType.UPDATE,
                entityType = "Post",
                entityId = post.id,
                jsonData = Gson().toJson(post)
            )
        )
        
        // Schedule background sync
        workManagerScheduler.schedulePendingOperationsSync()
        
        return post
    }
    
    override suspend fun deletePost(postId: String) {
        // Delete from local database immediately
        postDao.deletePostById(postId)
        
        // Add to pending operations queue
        pendingOperationDao.insert(
            PendingOperationEntity(
                operationType = OperationType.DELETE,
                entityType = "Post",
                entityId = postId,
                jsonData = ""
            )
        )
        
        // Schedule background sync
        workManagerScheduler.schedulePendingOperationsSync()
    }
    
    override suspend fun syncPosts() {
        try {
            val posts = postApiService.getPosts()
            postDao.insertAll(posts.map { it.toEntity() })
        } catch (e: Exception) {
            throw Exception("Failed to sync posts: ${e.message}")
        }
    }
    
    override suspend fun syncPendingOperations() {
        val pending = pendingOperationDao.getAllPending().first()
        
        pending.forEach { operation ->
            try {
                when (operation.operationType) {
                    OperationType.CREATE -> {
                        val post = Gson().fromJson(operation.jsonData, Post::class.java)
                        val response = postApiService.createPost(post)
                        
                        // Update local post with server ID
                        postDao.updatePost(response.toEntity())
                        
                        // Remove from pending
                        pendingOperationDao.delete(operation)
                    }
                    OperationType.UPDATE -> {
                        val post = Gson().fromJson(operation.jsonData, Post::class.java)
                        postApiService.updatePost(post.id, post)
                        
                        // Remove from pending
                        pendingOperationDao.delete(operation)
                    }
                    OperationType.DELETE -> {
                        postApiService.deletePost(operation.entityId)
                        
                        // Remove from pending
                        pendingOperationDao.delete(operation)
                    }
                }
            } catch (e: Exception) {
                // Handle error, maybe retry later
                // Increment retry count
                pendingOperationDao.updateRetryCount(operation.id, operation.retryCount + 1)
            }
        }
    }
}
```

### Implementasi dengan Application:
**ui/MyApplication.kt**
```kotlin
package com.example.offlinefirst.ui

import android.app.Application
import androidx.hilt.work.HiltWorkerFactory
import androidx.work.Configuration
import com.example.offlinefirst.data.work.WorkManagerScheduler
import dagger.hilt.android.HiltAndroidApp
import javax.inject.Inject

/**
 * Application class untuk inisialisasi WorkManager
 */
@HiltAndroidApp
class MyApplication : Application(), Configuration.Provider {
    
    @Inject
    lateinit var workerFactory: HiltWorkerFactory
    
    @Inject
    lateinit var workManagerScheduler: WorkManagerScheduler
    
    override fun onCreate() {
        super.onCreate()
        
        // Schedule periodic sync
        workManagerScheduler.schedulePeriodicSync()
    }
    
    override val workManagerConfiguration: Configuration
        get() = Configuration.Builder()
            .setWorkerFactory(workerFactory)
            .build()
}
```

### üéì Penjelasan Konsep:
**Background Sync dengan WorkManager seperti Asisten Pribadi:**
- **WorkManager**: Asisten pribadi
- **Worker**: Tugas yang dikerjakan asisten
- **Constraints**: Syarat untuk mengerjakan tugas
- **Periodic Work**: Tugas rutin harian

**Implementasi WorkManager:**
1. Membuat Worker untuk tugas tertentu
2. Mendefinisikan constraints (jaringan, daya, dll)
3. Menjadwalkan tugas (one-time atau periodic)
4. Menangani retry dan error

**Best Practices:**
- Gunakan Hilt untuk dependency injection di Worker
- Implementasikan retry dengan exponential backoff
- Gunakan constraints untuk menghemat daya
- Pisahkan tugas sinkronisasi dan operasi pending

---

## 7Ô∏è‚É£ Pending Operations Queue üìù

### Konsep Dasar
Pending Operations Queue seperti antrian di kantor pos üìÆ - menyimpan surat-surat (operasi) yang akan dikirim ketika pengantar (jaringan) tersedia!

### Pengertian Pending Operations Queue:
Pending Operations Queue adalah sistem yang:
- Menyimpan operasi (create, update, delete) yang belum disinkronkan
- Mengeksekusi operasi secara berurutan ketika jaringan tersedia
- Menangani retry untuk operasi yang gagal
- Memastikan semua perubahan pengguna akhirnya tersimpan di server

### Implementasi Pending Operations Entity:
**data/local/entity/PendingOperationEntity.kt**
```kotlin
package com.example.offlinefirst.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Entity untuk operasi yang tertunda
 */
@Entity(tableName = "pending_operations")
data class PendingOperationEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val operationType: OperationType,
    val entityType: String,
    val entityId: String,
    val jsonData: String,
    val timestamp: Long = System.currentTimeMillis(),
    val retryCount: Int = 0
)

/**
 * Enum untuk jenis operasi
 */
enum class OperationType {
    CREATE, UPDATE, DELETE
}
```

### Implementasi Pending Operations DAO:
**data/local/dao/PendingOperationDao.kt**
```kotlin
package com.example.offlinefirst.data.local.dao

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.offlinefirst.data.local.entity.PendingOperationEntity
import kotlinx.coroutines.flow.Flow

/**
 * DAO untuk operasi yang tertunda
 */
@Dao
interface PendingOperationDao {
    @Query("SELECT * FROM pending_operations ORDER BY timestamp ASC")
    fun getAllPending(): Flow<List<PendingOperationEntity>>
    
    @Query("SELECT * FROM pending_operations WHERE entityType = :entityType AND entityId = :entityId ORDER BY timestamp DESC LIMIT 1")
    suspend fun getLatestOperation(entityType: String, entityId: String): PendingOperationEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(operation: PendingOperationEntity)
    
    @Update
    suspend fun update(operation: PendingOperationEntity)
    
    @Query("UPDATE pending_operations SET retryCount = :retryCount WHERE id = :id")
    suspend fun updateRetryCount(id: Long, retryCount: Int)
    
    @Delete
    suspend fun delete(operation: PendingOperationEntity)
    
    @Query("DELETE FROM pending_operations WHERE entityType = :entityType AND entityId = :entityId")
    suspend fun deleteByEntity(entityType: String, entityId: String)
    
    @Query("DELETE FROM pending_operations")
    suspend fun deleteAll()
    
    @Query("SELECT COUNT(*) FROM pending_operations")
    suspend fun getPendingCount(): Int
}
```

### Implementasi Pending Operations Manager:
**data/util/PendingOperationsManager.kt**
```kotlin
package com.example.offlinefirst.data.util

import com.example.offlinefirst.data.local.dao.PendingOperationDao
import com.example.offlinefirst.data.local.entity.OperationType
import com.example.offlinefirst.data.local.entity.PendingOperationEntity
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.data.remote.api.UserApiService
import com.example.offlinefirst.data.work.WorkManagerScheduler
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.model.User
import com.google.gson.Gson
import kotlinx.coroutines.flow.first
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Manager untuk operasi yang tertunda
 */
@Singleton
class PendingOperationsManager @Inject constructor(
    private val pendingOperationDao: PendingOperationDao,
    private val postApiService: PostApiService,
    private val userApiService: UserApiService,
    private val workManagerScheduler: WorkManagerScheduler
) {
    
    suspend fun addCreateOperation(entity: Any) {
        val operation = when (entity) {
            is Post -> PendingOperationEntity(
                operationType = OperationType.CREATE,
                entityType = "Post",
                entityId = entity.id, // Will be a temporary local ID
                jsonData = Gson().toJson(entity)
            )
            is User -> PendingOperationEntity(
                operationType = OperationType.CREATE,
                entityType = "User",
                entityId = entity.id,
                jsonData = Gson().toJson(entity)
            )
            else -> throw IllegalArgumentException("Unsupported entity type")
        }
        
        pendingOperationDao.insert(operation)
        workManagerScheduler.schedulePendingOperationsSync()
    }
    
    suspend fun addUpdateOperation(entity: Any) {
        val operation = when (entity) {
            is Post -> PendingOperationEntity(
                operationType = OperationType.UPDATE,
                entityType = "Post",
                entityId = entity.id,
                jsonData = Gson().toJson(entity)
            )
            is User -> PendingOperationEntity(
                operationType = OperationType.UPDATE,
                entityType = "User",
                entityId = entity.id,
                jsonData = Gson().toJson(entity)
            )
            else -> throw IllegalArgumentException("Unsupported entity type")
        }
        
        pendingOperationDao.insert(operation)
        workManagerScheduler.schedulePendingOperationsSync()
    }
    
    suspend fun addDeleteOperation(entityType: String, entityId: String) {
        val operation = PendingOperationEntity(
            operationType = OperationType.DELETE,
            entityType = entityType,
            entityId = entityId,
            jsonData = "" // No data needed for delete
        )
        
        pendingOperationDao.insert(operation)
        workManagerScheduler.schedulePendingOperationsSync()
    }
    
    suspend fun processPendingOperations() {
        val pendingOperations = pendingOperationDao.getAllPending().first()
        
        for (operation in pendingOperations) {
            try {
                when (operation.operationType) {
                    OperationType.CREATE -> processCreateOperation(operation)
                    OperationType.UPDATE -> processUpdateOperation(operation)
                    OperationType.DELETE -> processDeleteOperation(operation)
                }
            } catch (e: Exception) {
                // Increment retry count
                val newRetryCount = operation.retryCount + 1
                pendingOperationDao.updateRetryCount(operation.id, newRetryCount)
                
                // If max retries reached, remove operation
                if (newRetryCount >= 3) {
                    pendingOperationDao.delete(operation)
                }
            }
        }
    }
    
    private suspend fun processCreateOperation(operation: PendingOperationEntity) {
        when (operation.entityType) {
            "Post" -> {
                val post = Gson().fromJson(operation.jsonData, Post::class.java)
                val createdPost = postApiService.createPost(post)
                // Here you would update the local database with the new server ID
                // For example: postDao.updateServerId(operation.entityId, createdPost.id)
                pendingOperationDao.delete(operation)
            }
            "User" -> {
                val user = Gson().fromJson(operation.jsonData, User::class.java)
                val createdUser = userApiService.createUser(user)
                // Update local DB with server ID
                pendingOperationDao.delete(operation)
            }
        }
    }
    
    private suspend fun processUpdateOperation(operation: PendingOperationEntity) {
        when (operation.entityType) {
            "Post" -> {
                val post = Gson().fromJson(operation.jsonData, Post::class.java)
                postApiService.updatePost(post.id, post)
                pendingOperationDao.delete(operation)
            }
            "User" -> {
                val user = Gson().fromJson(operation.jsonData, User::class.java)
                userApiService.updateUser(user.id, user)
                pendingOperationDao.delete(operation)
            }
        }
    }
    
    private suspend fun processDeleteOperation(operation: PendingOperationEntity) {
        when (operation.entityType) {
            "Post" -> {
                postApiService.deletePost(operation.entityId)
                pendingOperationDao.delete(operation)
            }
            "User" -> {
                userApiService.deleteUser(operation.entityId)
                pendingOperationDao.delete(operation)
            }
        }
    }
}
```

### Implementasi dengan Repository:
**data/repository/PostRepositoryImpl.kt**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.local.entity.PostEntity
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.data.util.PendingOperationsManager
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.repository.PostRepository
import com.example.offlinefirst.domain.util.Resource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject

/**
 * Repository dengan Pending Operations Queue
 */
class PostRepositoryImpl @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService,
    private val pendingOperationsManager: PendingOperationsManager
) : PostRepository {
    
    override fun getPosts(): Flow<Resource<List<Post>>> {
        // Implementasi Network-Bound Resource Pattern
        // ...
    }
    
    override suspend fun createPost(post: Post): Post {
        // Generate temporary local ID (e.g., negative ID or UUID)
        val localPost = post.copy(id = "temp_${System.currentTimeMillis()}")
        
        // Save to local database immediately
        val localId = postDao.insert(localPost.toEntity())
        
        // Add to pending operations queue
        pendingOperationsManager.addCreateOperation(localPost.copy(id = localId.toString()))
        
        return localPost.copy(id = localId.toString())
    }
    
    override suspend fun updatePost(post: Post): Post {
        // Update local database immediately
        postDao.updatePost(post.toEntity())
        
        // Add to pending operations queue
        pendingOperationsManager.addUpdateOperation(post)
        
        return post
    }
    
    override suspend fun deletePost(postId: String) {
        // Delete from local database immediately
        postDao.deletePostById(postId)
        
        // Add to pending operations queue
        pendingOperationsManager.addDeleteOperation("Post", postId)
    }
}
```

### üéì Penjelasan Konsep:
**Pending Operations Queue seperti Antrian Kantor Pos:**
- **Pending Operations**: Surat-surat yang akan dikirim
- **Local Database**: Kotak pos sementara
- **Network**: Pengantar pos
- **Manager**: Petugas pos yang mengatur antrian

**Alur Pending Operations:**
1. Pengguna melakukan aksi (create/update/delete)
2. Aksi langsung diterapkan ke database lokal (optimistic update)
3. Operasi ditambahkan ke antrian pending
4. Background worker memproses antrian ketika jaringan tersedia
5. Operasi yang berhasil dihapus dari antrian
6. Operasi yang gagal dicoba kembali dengan batas maksimal

**Keuntungan Pending Operations:**
- Aplikasi tetap responsif offline
- Semua perubahan pengguna disimpan
- Sinkronisasi terjadi secara otomatis
- Tidak ada data yang hilang

---

## 8Ô∏è‚É£ Conflict Resolution ‚öîÔ∏è

### Konsep Dasar
Conflict Resolution seperti wasit dalam pertandingan ‚öΩ - menyelesaikan perselisihan antara data lokal dan data server!

### Pengertian Conflict Resolution:
Conflict Resolution adalah strategi untuk menangani konflik ketika:
- Data diubah secara offline dan online secara bersamaan
- Versi data lokal dan server berbeda
- Multiple users mengubah data yang sama

### Strategi Conflict Resolution:

#### 1. Last-Write-Wins (LWW)
**Konsep:** Perubahan terakhir berdasarkan timestamp akan menang.

**Implementasi:**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.domain.model.Post
import javax.inject.Inject

/**
 * Conflict Resolution dengan Last-Write-Wins
 */
class ConflictResolutionRepository @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService
) {
    
    suspend fun resolveConflict(local: Post, remote: Post): Post {
        return if (local.updatedAt > remote.updatedAt) {
            // Local is newer, upload to server
            try {
                postApiService.updatePost(local.id, local)
                local
            } catch (e: Exception) {
                // If upload fails, keep local version
                local
            }
        } else {
            // Remote is newer, save to local
            postDao.updatePost(remote.toEntity())
            remote
        }
    }
}
```

#### 2. Manual Conflict Resolution
**Konsep:** Memberikan pilihan kepada pengguna untuk menyelesaikan konflik.

**Implementasi:**
```kotlin
package com.example.offlinefirst.domain.model

/**
 * Model untuk konflik data
 */
data class Conflict<T>(
    val local: T,
    val remote: T,
    val resolved: Boolean = false
)
```

**presentation/viewmodel/ConflictResolutionViewModel.kt**
```kotlin
package com.example.offlinefirst.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.domain.model.Conflict
import com.example.offlinefirst.domain.model.Post
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel untuk Conflict Resolution
 */
@HiltViewModel
class ConflictResolutionViewModel @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService
) : ViewModel() {
    
    private val _conflicts = MutableStateFlow<List<Conflict<Post>>>(emptyList())
    val conflicts: StateFlow<List<Conflict<Post>>> = _conflicts.asStateFlow()
    
    fun addConflict(local: Post, remote: Post) {
        val current = _conflicts.value.toMutableList()
        current.add(Conflict(local, remote))
        _conflicts.value = current
    }
    
    fun resolveConflict(conflict: Conflict<Post>, useLocal: Boolean) {
        viewModelScope.launch {
            val resolved = if (useLocal) {
                try {
                    postApiService.updatePost(conflict.local.id, conflict.local)
                    conflict.local
                } catch (e: Exception) {
                    // Handle error
                    conflict.local
                }
            } else {
                postDao.updatePost(conflict.remote.toEntity())
                conflict.remote
            }
            
            // Remove from conflicts list
            _conflicts.value = _conflicts.value.filter { it != conflict }
        }
    }
}
```

#### 3. Merge Strategy
**Konsep:** Menggabungkan perubahan dari lokal dan remote.

**Implementasi:**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.domain.model.Post

/**
 * Conflict Resolution dengan Merge Strategy
 */
class MergeConflictResolution {
    
    fun mergePosts(local: Post, remote: Post): Post {
        return Post(
            id = remote.id, // Use server ID
            title = if (local.updatedAt > remote.updatedAt) local.title else remote.title,
            body = if (local.updatedAt > remote.updatedAt) local.body else remote.body,
            userId = remote.userId, // Use server userId
            userName = remote.userName, // Use server userName
            likes = maxOf(local.likes, remote.likes), // Use max value
            comments = maxOf(local.comments, remote.comments), // Use max value
            isLiked = local.isLiked, // Use local preference
            createdAt = remote.createdAt, // Use server createdAt
            updatedAt = System.currentTimeMillis() // Update to now
        )
    }
}
```

### Implementasi dengan Repository:
**data/repository/ConflictAwareRepository.kt**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.util.Resource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject

/**
 * Repository dengan Conflict Resolution
 */
class ConflictAwareRepository @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService,
    private val conflictResolution: ConflictResolutionRepository
) {
    
    suspend fun syncPostWithConflictResolution(postId: String): Flow<Resource<Post>> = flow {
        try {
            // Get local version
            val localPost = postDao.getPostById(postId)?.toDomainModel()
            
            // Get remote version
            val remotePost = postApiService.getPostById(postId)
            
            if (localPost != null && localPost.updatedAt != remotePost.updatedAt) {
                // Conflict detected
                val resolvedPost = conflictResolution.resolveConflict(localPost, remotePost)
                emit(Resource.Success(resolvedPost))
            } else {
                // No conflict, use remote version
                postDao.updatePost(remotePost.toEntity())
                emit(Resource.Success(remotePost))
            }
        } catch (e: Exception) {
            // Handle error
            emit(Resource.Error(e.message ?: "Sync failed"))
        }
    }
}
```

### üéì Penjelasan Konsep:
**Conflict Resolution seperti Wasit Pertandingan:**
- **Local Data**: Tim tuan rumah
- **Remote Data**: Tim tamu
- **Conflict**: Perselisihan di lapangan
- **Resolution**: Keputusan wasit

**Strategi Conflict Resolution:**
- **Last-Write-Wins**: Tim yang mencetak gol terakhir menang
- **Manual Resolution**: Wasit meminta bantuan VAR (pengguna)
- **Merge Strategy**: Menggabungkan statistik terbaik dari kedua tim

**Best Practices:**
- Gunakan timestamp untuk mendeteksi konflik
- Pilih strategi yang sesuai dengan kebutuhan aplikasi
- Berikan feedback yang jelas kepada pengguna
- Implementasikan fallback untuk kasus ekstrem

---

## 9Ô∏è‚É£ Cache Expiration & Invalidation ‚è≥

### Konsep Dasar
Cache Expiration & Invalidation seperti tanggal kadaluarsa pada makanan ü•õ - memastikan data yang dikonsumsi masih segar dan valid!

### Pengertian Cache Expiration & Invalidation:
Cache Expiration & Invalidation adalah mekanisme untuk:
- Menentukan kapan cache tidak lagi valid
- Membersihkan cache yang sudah kadaluarsa
- Memperbarui cache dengan data segar
- Mengelola ukuran cache agar tidak membengkak

### Implementasi Cache Metadata:
**data/local/entity/CacheMetadataEntity.kt**
```kotlin
package com.example.offlinefirst.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Entity untuk metadata cache
 */
@Entity(tableName = "cache_metadata")
data class CacheMetadataEntity(
    @PrimaryKey
    val key: String,
    val lastFetchTime: Long,
    val expirationTime: Long,
    val size: Long = 0 // Optional: track cache size
)
```

### Implementasi Cache Manager:
**data/util/CacheManager.kt**
```kotlin
package com.example.offlinefirst.data.util

import com.example.offlinefirst.data.local.dao.CacheMetadataDao
import kotlinx.coroutines.flow.first
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Manager untuk cache metadata
 */
@Singleton
class CacheManager @Inject constructor(
    private val cacheMetadataDao: CacheMetadataDao
) {
    
    suspend fun isCacheValid(key: String, maxAgeMillis: Long): Boolean {
        val metadata = cacheMetadataDao.getMetadata(key) ?: return false
        val now = System.currentTimeMillis()
        return (now - metadata.lastFetchTime) < maxAgeMillis
    }
    
    suspend fun isCacheExpired(key: String): Boolean {
        val metadata = cacheMetadataDao.getMetadata(key) ?: return true
        return System.currentTimeMillis() > metadata.expirationTime
    }
    
    suspend fun updateCacheTime(key: String, expirationMillis: Long = TimeUnit.HOURS.toMillis(1)) {
        val metadata = CacheMetadataEntity(
            key = key,
            lastFetchTime = System.currentTimeMillis(),
            expirationTime = System.currentTimeMillis() + expirationMillis
        )
        cacheMetadataDao.insert(metadata)
    }
    
    suspend fun invalidateCache(key: String) {
        cacheMetadataDao.delete(key)
    }
    
    suspend fun invalidateAllCache() {
        cacheMetadataDao.deleteAll()
    }
    
    suspend fun cleanupExpiredCache() {
        val expiredCache = cacheMetadataDao.getExpiredCache().first()
        expiredCache.forEach { metadata ->
            // Here you would also delete the actual cached data
            // For example, if it's a list of posts:
            // postDao.deleteAll()
            cacheMetadataDao.delete(metadata)
        }
    }
}
```

### Implementasi dengan Repository:
**data/repository/CacheAwareRepository.kt**
```kotlin
package com.example.offlinefirst.data.repository

import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.data.util.CacheManager
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.util.Resource
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject

/**
 * Repository dengan Cache Expiration & Invalidation
 */
class CacheAwareRepository @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService,
    private val cacheManager: CacheManager
) {
    
    fun getPosts(cacheKey: String = "posts"): Flow<Resource<List<Post>>> = flow {
        // Check if cache is valid
        val isCacheValid = cacheManager.isCacheValid(cacheKey, TimeUnit.MINUTES.toMillis(5))
        
        // Emit cached data
        val cachedPosts = postDao.getAllPosts().first().map { it.toDomainModel() }
        emit(Resource.Loading(cachedPosts))
        
        if (!isCacheValid) {
            try {
                // Fetch fresh data
                val freshPosts = postApiService.getPosts()
                
                // Update cache
                postDao.deleteAll()
                postDao.insertAll(freshPosts.map { it.toEntity() })
                cacheManager.updateCacheTime(cacheKey)
                
                // Emit fresh data
                emit(Resource.Success(freshPosts))
            } catch (e: Exception) {
                // On error, emit error with cached data
                emit(Resource.Error(e.message ?: "Network error", cachedPosts))
            }
        } else {
            // Cache is valid, use cached data
            emit(Resource.Success(cachedPosts))
        }
    }
    
    suspend fun refreshPosts(cacheKey: String = "posts") {
        try {
            // Invalidate cache
            cacheManager.invalidateCache(cacheKey)
            
            // Fetch fresh data
            val freshPosts = postApiService.getPosts()
            
            // Update cache
            postDao.deleteAll()
            postDao.insertAll(freshPosts.map { it.toEntity() })
            cacheManager.updateCacheTime(cacheKey)
        } catch (e: Exception) {
            throw Exception("Failed to refresh: ${e.message}")
        }
    }
    
    suspend fun clearAllCache() {
        cacheManager.invalidateAllCache()
        postDao.deleteAll()
    }
}
```

### Implementasi dengan ViewModel:
**presentation/viewmodel/CacheAwareViewModel.kt**
```kotlin
package com.example.offlinefirst.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.offlinefirst.data.util.CacheManager
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.repository.PostRepository
import com.example.offlinefirst.domain.util.Resource
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel dengan Cache Expiration & Invalidation
 */
@HiltViewModel
class CacheAwareViewModel @Inject constructor(
    private val postRepository: PostRepository,
    private val cacheManager: CacheManager
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<PostListUiState>(PostListUiState.Loading)
    val uiState: StateFlow<PostListUiState> = _uiState.asStateFlow()
    
    private val _isCacheExpired = MutableStateFlow(false)
    val isCacheExpired: StateFlow<Boolean> = _isCacheExpired.asStateFlow()
    
    init {
        loadPosts()
        checkCacheStatus()
    }
    
    private fun loadPosts() {
        viewModelScope.launch {
            postRepository.getPosts().collect { resource ->
                when (resource) {
                    is Resource.Loading -> {
                        _uiState.value = PostListUiState.Loading(resource.data ?: emptyList())
                    }
                    is Resource.Success -> {
                        _uiState.value = PostListUiState.Success(resource.data ?: emptyList())
                    }
                    is Resource.Error -> {
                        _uiState.value = PostListUiState.Error(
                            resource.message ?: "Unknown error",
                            resource.data ?: emptyList()
                        )
                    }
                }
            }
        }
    }
    
    private fun checkCacheStatus() {
        viewModelScope.launch {
            _isCacheExpired.value = cacheManager.isCacheExpired("posts")
        }
    }
    
    fun refreshPosts() {
        viewModelScope.launch {
            try {
                _uiState.value = PostListUiState.Loading((_uiState.value as? PostListUiState.Success)?.posts ?: emptyList())
                postRepository.refreshPosts()
                checkCacheStatus()
            } catch (e: Exception) {
                _uiState.value = PostListUiState.Error(
                    e.message ?: "Failed to refresh",
                    (_uiState.value as? PostListUiState.Success)?.posts ?: emptyList()
                )
            }
        }
    }
    
    fun clearCache() {
        viewModelScope.launch {
            try {
                postRepository.clearAllCache()
                loadPosts()
            } catch (e: Exception) {
                _uiState.value = PostListUiState.Error(
                    e.message ?: "Failed to clear cache",
                    emptyList()
                )
            }
        }
    }
}

/**
 * UI State untuk PostList
 */
sealed class PostListUiState {
    data class Loading(val posts: List<Post> = emptyList()) : PostListUiState()
    data class Success(val posts: List<Post>) : PostListUiState()
    data class Error(val message: String, val posts: List<Post>) : PostListUiState()
}
```

### üéì Penjelasan Konsep:
**Cache Expiration & Invalidation seperti Tanggal Kadaluarsa:**
- **Cache Data**: Makanan di kulkas
- **Expiration Time**: Tanggal kadaluarsa
- **Cache Manager**: Sistem manajemen persediaan
- **Invalidation**: Membuang makanan kadaluarsa

**Strategi Cache Expiration:**
- **Time-based Expiration**: Berdasarkan waktu (misalnya, 5 menit)
- **Event-based Invalidation**: Berdasarkan event (misalnya, user logout)
- **Size-based Eviction**: Berdasarkan ukuran cache (LRU, LFU)

**Best Practices:**
- Gunakan metadata untuk melacak usia cache
- Implementasikan cache expiration yang wajar
- Berikan opsi untuk refresh manual
- Bersihkan cache yang tidak perlu

---

## 1Ô∏è‚É£0Ô∏è‚É£ Optimistic Updates üé≠

### Konsep Dasar
Optimistic Updates seperti sulap üé© - mengubah UI secara instan sebelum operasi benar-benar selesai di server!

### Pengertian Optimistic Updates:
Optimistic Updates adalah teknik yang:
- Memperbarui UI segera setelah aksi pengguna
- Mengasumsikan operasi akan berhasil
- Menangani rollback jika operasi gagal
- Memberikan pengalaman pengguna yang sangat responsif

### Implementasi Optimistic Updates:
**presentation/viewmodel/OptimisticUpdateViewModel.kt**
```kotlin
package com.example.offlinefirst.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.util.Resource
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel dengan Optimistic Updates
 */
@HiltViewModel
class OptimisticUpdateViewModel @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<OptimisticUpdateUiState>(OptimisticUpdateUiState.Idle)
    val uiState: StateFlow<OptimisticUpdateUiState> = _uiState.asStateFlow()
    
    private val _posts = MutableStateFlow<List<Post>>(emptyList())
    val posts: StateFlow<List<Post>> = _posts.asStateFlow()
    
    init {
        loadPosts()
    }
    
    private fun loadPosts() {
        viewModelScope.launch {
            _posts.value = postDao.getAllPosts().first().map { it.toDomainModel() }
        }
    }
    
    fun likePost(postId: String) {
        viewModelScope.launch {
            // 1. Get current post
            val currentPost = _posts.value.find { it.id == postId } ?: return@launch
            
            // 2. Create optimistic post (with incremented likes)
            val optimisticPost = currentPost.copy(
                likes = currentPost.likes + 1,
                isLiked = true
            )
            
            // 3. Update UI immediately
            updatePostInList(optimisticPost)
            _uiState.value = OptimisticUpdateUiState.Success("Post liked!")
            
            try {
                // 4. Sync with server
                postApiService.likePost(postId)
                
                // 5. Update local database with server response (if needed)
                // postDao.updatePost(optimisticPost.toEntity())
            } catch (e: Exception) {
                // 6. Rollback on failure
                updatePostInList(currentPost)
                _uiState.value = OptimisticUpdateUiState.Error("Failed to like post")
            }
        }
    }
    
    fun unlikePost(postId: String) {
        viewModelScope.launch {
            // 1. Get current post
            val currentPost = _posts.value.find { it.id == postId } ?: return@launch
            
            // 2. Create optimistic post (with decremented likes)
            val optimisticPost = currentPost.copy(
                likes = currentPost.likes - 1,
                isLiked = false
            )
            
            // 3. Update UI immediately
            updatePostInList(optimisticPost)
            _uiState.value = OptimisticUpdateUiState.Success("Post unliked!")
            
            try {
                // 4. Sync with server
                postApiService.unlikePost(postId)
                
                // 5. Update local database with server response (if needed)
                // postDao.updatePost(optimisticPost.toEntity())
            } catch (e: Exception) {
                // 6. Rollback on failure
                updatePostInList(currentPost)
                _uiState.value = OptimisticUpdateUiState.Error("Failed to unlike post")
            }
        }
    }
    
    private fun updatePostInList(updatedPost: Post) {
        val currentPosts = _posts.value.toMutableList()
        val index = currentPosts.indexOfFirst { it.id == updatedPost.id }
        if (index != -1) {
            currentPosts[index] = updatedPost
            _posts.value = currentPosts
        }
    }
}

/**
 * UI State untuk Optimistic Updates
 */
sealed class OptimisticUpdateUiState {
    object Idle : OptimisticUpdateUiState()
    data class Success(val message: String) : OptimisticUpdateUiState()
    data class Error(val message: String) : OptimisticUpdateUiState()
}
```

### Implementasi dengan Undo:
**presentation/viewmodel/UndoViewModel.kt**
```kotlin
package com.example.offlinefirst.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.domain.model.Post
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel dengan Optimistic Updates dan Undo
 */
@HiltViewModel
class UndoViewModel @Inject constructor(
    private val postDao: PostDao,
    private val postApiService: PostApiService
) : ViewModel() {
    
    private val _posts = MutableStateFlow<List<Post>>(emptyList())
    val posts: StateFlow<List<Post>> = _posts.asStateFlow()
    
    private val _snackbarMessage = MutableStateFlow<String?>(null)
    val snackbarMessage: StateFlow<String?> = _snackbarMessage.asStateFlow()
    
    private val undoStack = mutableListOf<suspend () -> Unit>()
    private var deleteJob: Job? = null
    
    init {
        loadPosts()
    }
    
    private fun loadPosts() {
        viewModelScope.launch {
            _posts.value = postDao.getAllPosts().first().map { it.toDomainModel() }
        }
    }
    
    fun deletePost(post: Post) {
        // 1. Delete locally
        viewModelScope.launch {
            postDao.deletePostById(post.id)
            updatePostInList(post, deleted = true)
            
            // 2. Add undo action
            undoStack.add {
                postDao.insert(post.toEntity())
                updatePostInList(post, deleted = false)
            }
            
            // 3. Show snackbar with undo option
            _snackbarMessage.value = "Post deleted"
            
            // 4. Schedule actual server delete
            deleteJob = viewModelScope.launch {
                delay(5000) // Wait 5 seconds for undo
                if (undoStack.isNotEmpty()) {
                    try {
                        postApiService.deletePost(post.id)
                        undoStack.clear()
                        _snackbarMessage.value = null
                    } catch (e: Exception) {
                        // Rollback on failure
                        undoStack.lastOrNull()?.invoke()
                        undoStack.clear()
                        _snackbarMessage.value = "Failed to delete post"
                    }
                }
            }
        }
    }
    
    fun undo() {
        deleteJob?.cancel()
        viewModelScope.launch {
            undoStack.lastOrNull()?.invoke()
            undoStack.removeLastOrNull()
            _snackbarMessage.value = "Post restored"
        }
    }
    
    private fun updatePostInList(updatedPost: Post, deleted: Boolean) {
        val currentPosts = _posts.value.toMutableList()
        if (deleted) {
            currentPosts.removeIf { it.id == updatedPost.id }
        } else {
            val index = currentPosts.indexOfFirst { it.id == updatedPost.id }
            if (index != -1) {
                currentPosts[index] = updatedPost
            } else {
                currentPosts.add(updatedPost)
            }
        }
        _posts.value = currentPosts
    }
}
```

### Implementasi dengan UI:
**presentation/ui/component/OptimisticPostItem.kt**
```kotlin
package com.example.offlinefirst.presentation.ui.component

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.FavoriteBorder
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.example.offlinefirst.domain.model.Post

@Composable
fun OptimisticPostItem(
    post: Post,
    onLike: (String) -> Unit,
    onUnlike: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = post.title,
                style = MaterialTheme.typography.titleMedium
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text(
                text = post.body,
                style = MaterialTheme.typography.bodyMedium
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Like button
                IconButton(
                    onClick = {
                        if (post.isLiked) {
                            onUnlike(post.id)
                        } else {
                            onLike(post.id)
                        }
                    }
                ) {
                    Icon(
                        imageVector = if (post.isLiked) Icons.Default.Favorite else Icons.Default.FavoriteBorder,
                        contentDescription = if (post.isLiked) "Unlike" else "Like",
                        tint = if (post.isLiked) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurface
                    )
                }
                
                Text(
                    text = "${post.likes} likes",
                    style = MaterialTheme.typography.bodySmall
                )
                
                Text(
                    text = "${post.comments} comments",
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}
```

### üéì Penjelasan Konsep:
**Optimistic Updates seperti Sulap:**
- **UI Update**: Sulap yang terlihat instan
- **Server Sync**: Trik di balik layar
- **Rollback**: Mengembalikan keadaan asli jika gagal
- **Undo**: Memberi kesempatan kedua

**Implementasi Optimistic Updates:**
1. Lakukan perubahan di UI secara instan
2. Simpan state sebelum perubahan untuk rollback
3. Kirim perubahan ke server di background
4. Jika berhasil, biarkan perubahan tetap ada
5. Jika gagal, rollback ke state semula

**Best Practices:**
- Selalu sediakan mekanisme rollback
- Berikan feedback visual yang jelas
- Gunakan untuk operasi yang kemungkinan besar berhasil
- Implementasikan undo untuk operasi destruktif

---

## 1Ô∏è‚É£1Ô∏è‚É£ Offline Indicators in UI üìä

### Konsep Dasar
Offline Indicators seperti papan penanda jalan üö¶ - memberi tahu pengguna tentang status koneksi dan sinkronisasi!

### Pengertian Offline Indicators:
Offline Indicators adalah elemen UI yang:
- Menunjukkan status koneksi jaringan
- Menampilkan jumlah operasi yang pending
- Memberikan informasi tentang status sinkronisasi
- Membantu pengguna memahami state aplikasi

### Implementasi Network Status Banner:
**presentation/ui/component/NetworkStatusBanner.kt**
```kotlin
package com.example.offlinefirst.presentation.ui.component

import androidx.compose.animation.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CloudOff
import androidx.compose.material.icons.filled.Sync
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.unit.dp

@Composable
fun NetworkStatusBanner(
    isConnected: Boolean,
    modifier: Modifier = Modifier
) {
    AnimatedVisibility(
        visible = !isConnected,
        enter = slideInVertically(initialOffsetY = { -it }) + fadeIn(),
        exit = slideOutVertically(targetOffsetY = { -it }) + fadeOut(),
        modifier = modifier
    ) {
        Surface(
            color = MaterialTheme.colorScheme.errorContainer,
            modifier = Modifier.fillMaxWidth()
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    imageVector = Icons.Default.CloudOff,
                    contentDescription = "Offline",
                    tint = MaterialTheme.colorScheme.onErrorContainer
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "You're offline. Changes will sync when connected.",
                    color = MaterialTheme.colorScheme.onErrorContainer,
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }
    }
}

@Composable
fun SyncStatusBanner(
    isSyncing: Boolean,
    modifier: Modifier = Modifier
) {
    AnimatedVisibility(
        visible = isSyncing,
        enter = slideInVertically(initialOffsetY = { -it }) + fadeIn(),
        exit = slideOutVertically(targetOffsetY = { -it }) + fadeOut(),
        modifier = modifier
    ) {
        Surface(
            color = MaterialTheme.colorScheme.primaryContainer,
            modifier = Modifier.fillMaxWidth()
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                CircularProgressIndicator(
                    modifier = Modifier.size(16.dp),
                    strokeWidth = 2.dp,
                    color = MaterialTheme.colorScheme.onPrimaryContainer
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "Syncing changes...",
                    color = MaterialTheme.colorScheme.onPrimaryContainer,
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }
    }
}
```

### Implementasi Pending Sync Indicator:
**presentation/ui/component/PendingSyncIndicator.kt**
```kotlin
package com.example.offlinefirst.presentation.ui.component

import androidx.compose.animation.*
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Sync
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun PendingSyncIndicator(
    pendingCount: Int,
    modifier: Modifier = Modifier
) {
    AnimatedVisibility(
        visible = pendingCount > 0,
        enter = expandVertically() + fadeIn(),
        exit = shrinkVertically() + fadeOut(),
        modifier = modifier
    ) {
        Card(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.secondaryContainer
            )
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                CircularProgressIndicator(
                    modifier = Modifier.size(24.dp),
                    strokeWidth = 2.dp,
                    color = MaterialTheme.colorScheme.onSecondaryContainer
                )
                Spacer(modifier = Modifier.width(12.dp))
                Column {
                    Text(
                        text = "$pendingCount changes pending sync",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSecondaryContainer
                    )
                    Text(
                        text = "Changes will sync when connection is available",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSecondaryContainer
                    )
                }
            }
        }
    }
}
```

### Implementasi dengan Activity/Fragment:
**presentation/ui/OfflineAwareActivity.kt**
```kotlin
package com.example.offlinefirst.presentation.ui

import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.example.offlinefirst.presentation.ui.component.NetworkStatusBanner
import com.example.offlinefirst.presentation.ui.component.PendingSyncIndicator
import com.example.offlinefirst.presentation.ui.component.PostList
import com.example.offlinefirst.presentation.viewmodel.OfflineAwareViewModel
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class OfflineAwareActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MaterialTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    OfflineAwareScreen()
                }
            }
        }
    }
}

@Composable
fun OfflineAwareScreen(
    viewModel: OfflineAwareViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val isConnected by viewModel.isConnected.collectAsStateWithLifecycle()
    val pendingCount by viewModel.pendingCount.collectAsStateWithLifecycle()
    val isSyncing by viewModel.isSyncing.collectAsStateWithLifecycle()
    
    Box(modifier = Modifier.fillMaxSize()) {
        // Main content
        Column(modifier = Modifier.fillMaxSize()) {
            // Top bar
            TopAppBar(
                title = { Text("Offline-First Posts") },
                actions = {
                    // Sync status icon
                    IconButton(onClick = { viewModel.syncNow() }) {
                        if (isSyncing) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(24.dp),
                                strokeWidth = 2.dp
                            )
                        } else {
                            Icon(
                                imageVector = Icons.Default.Sync,
                                contentDescription = "Sync"
                            )
                        }
                    }
                }
            )
            
            // Post list
            when (val state = uiState) {
                is OfflineAwareViewModel.UiState.Loading -> {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        CircularProgressIndicator()
                    }
                }
                is OfflineAwareViewModel.UiState.Success -> {
                    PostList(
                        posts = state.posts,
                        onPostClick = { /* Handle post click */ }
                    )
                }
                is OfflineAwareViewModel.UiState.Error -> {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        Column {
                            Text(
                                text = "Error: ${state.message}",
                                color = MaterialTheme.colorScheme.error
                            )
                            Spacer(modifier = Modifier.height(16.dp))
                            Button(onClick = { viewModel.loadPosts() }) {
                                Text("Retry")
                            }
                        }
                    }
                }
            }
        }
        
        // Overlay indicators
        Column(
            modifier = Modifier.fillMaxSize(),
            verticalArrangement = Arrangement.Top
        ) {
            NetworkStatusBanner(isConnected = isConnected)
            SyncStatusBanner(isSyncing = isSyncing)
        }
        
        // Pending sync indicator at bottom
        PendingSyncIndicator(
            pendingCount = pendingCount,
            modifier = Modifier.align(Alignment.BottomCenter)
        )
    }
}
```

### Implementasi dengan ViewModel:
**presentation/viewmodel/OfflineAwareViewModel.kt**
```kotlin
package com.example.offlinefirst.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.offlinefirst.data.local.dao.PendingOperationDao
import com.example.offlinefirst.data.util.NetworkMonitor
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.repository.PostRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel dengan Offline Indicators
 */
@HiltViewModel
class OfflineAwareViewModel @Inject constructor(
    private val postRepository: PostRepository,
    private val networkMonitor: NetworkMonitor,
    private val pendingOperationDao: PendingOperationDao
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<UiState>(UiState.Loading)
    val uiState: StateFlow<UiState> = _uiState.asStateFlow()
    
    val isConnected = networkMonitor.isConnected
    
    private val _isSyncing = MutableStateFlow(false)
    val isSyncing: StateFlow<Boolean> = _isSyncing.asStateFlow()
    
    val pendingCount = pendingOperationDao.getPendingCount()
    
    init {
        loadPosts()
        monitorNetworkAndSync()
    }
    
    private fun loadPosts() {
        viewModelScope.launch {
            postRepository.getPosts().collect { resource ->
                when (resource) {
                    is Resource.Loading -> {
                        _uiState.value = UiState.Loading
                    }
                    is Resource.Success -> {
                        _uiState.value = UiState.Success(resource.data ?: emptyList())
                    }
                    is Resource.Error -> {
                        _uiState.value = UiState.Error(
                            resource.message ?: "Unknown error"
                        )
                    }
                }
            }
        }
    }
    
    private fun monitorNetworkAndSync() {
        viewModelScope.launch {
            combine(
                isConnected,
                pendingCount
            ) { isConnected, pendingCount ->
                isConnected to pendingCount
            }.collect { (isConnected, pendingCount) ->
                if (isConnected && pendingCount > 0) {
                    syncNow()
                }
            }
        }
    }
    
    fun syncNow() {
        viewModelScope.launch {
            _isSyncing.value = true
            try {
                postRepository.syncPendingOperations()
            } catch (e: Exception) {
                _uiState.value = UiState.Error("Sync failed: ${e.message}")
            } finally {
                _isSyncing.value = false
            }
        }
    }
    
    sealed class UiState {
        object Loading : UiState()
        data class Success(val posts: List<Post>) : UiState()
        data class Error(val message: String) : UiState()
    }
}
```

### üéì Penjelasan Konsep:
**Offline Indicators seperti Papan Penanda Jalan:**
- **Network Status Banner**: Tanda "jalan tertutup" atau "jalan terbuka"
- **Sync Status**: Tanda "sedang ada perbaikan"
- **Pending Indicator**: Tanda "ada antrian"

**Implementasi Offline Indicators:**
1. Monitor status jaringan secara real-time
2. Tampilkan banner ketika offline
3. Tampilkan indikator sinkronisasi
4. Tampilkan jumlah operasi pending
5. Berikan opsi untuk refresh manual

**Best Practices:**
- Gunakan animasi untuk transisi yang halus
- Berikan informasi yang jelas dan bermanfaat
- Jangan mengganggu pengalaman pengguna
- Gunakan warna yang sesuai dengan tema aplikasi

---

## 1Ô∏è‚É£2Ô∏è‚É£ Best Practices ‚úÖ

### Konsep Dasar
Best Practices seperti aturan main dalam permainan ‚öΩ - memastikan semua pemain bermain dengan adil dan efektif!

### Daftar Best Practices untuk Offline-First:

#### ‚úÖ Local Database as Single Source of Truth
- Database lokal adalah satu-satunya sumber data yang valid
- UI selalu membaca dari database lokal
- Jangan pernah menyimpan state di UI atau ViewModel

#### ‚úÖ UI Always Reads from Local Database
- UI tidak pernah menunggu data dari jaringan
- Gunakan Flow untuk reactive UI updates
- Tampilkan data cache segera

#### ‚úÖ Sync in Background
- Gunakan WorkManager untuk sinkronisasi background
- Implementasikan retry dengan exponential backoff
- Sinkronisasi harus transparan untuk pengguna

#### ‚úÖ Show Cached Data While Fetching
- Jangan pernah menampilkan loading screen kosong
- Tampilkan data cache sambil mengambil data segar
- Berikan indikator bahwa data sedang diperbarui

#### ‚úÖ Implement Conflict Resolution
- Gunakan timestamp untuk mendeteksi konflik
- Pilih strategi yang sesuai dengan kebutuhan
- Berikan opsi untuk menyelesaikan konflik secara manual

#### ‚úÖ Queue Pending Operations
- Simpan semua operasi yang belum disinkronkan
- Proses antrian ketika jaringan tersedia
- Implementasikan retry untuk operasi yang gagal

#### ‚úÖ Use WorkManager for Periodic Sync
- Jadwalkan sinkronisasi berkala
- Gunakan constraints untuk menghemat daya
- Implementasikan unique work untuk mencegah duplikasi

#### ‚úÖ Indicate Offline Status to Users
- Tampilkan banner atau indikator status
- Berikan informasi tentang operasi pending
- Berikan opsi untuk refresh manual

#### ‚úÖ Handle Sync Failures Gracefully
- Implementasikan retry dengan batas maksimal
- Log error untuk debugging
- Berikan feedback yang jelas kepada pengguna

#### ‚úÖ Test Offline Scenarios Thoroughly
- Uji aplikasi tanpa koneksi internet
- Uji perubahan status jaringan
- Uji konflik data dan resolusinya

### Implementasi Best Practices Checklist:
**presentation/ui/component/BestPracticesChecklist.kt**
```kotlin
package com.example.offlinefirst.presentation.ui.component

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.RadioButtonUnchecked
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
fun BestPracticesChecklist(
    items: List<ChecklistItem>,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Offline-First Best Practices",
                style = MaterialTheme.typography.titleMedium
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            items.forEach { item ->
                ChecklistItemRow(item = item)
                Spacer(modifier = Modifier.height(8.dp))
            }
        }
    }
}

@Composable
private fun ChecklistItemRow(item: ChecklistItem) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Icon(
            imageVector = if (item.isChecked) Icons.Default.CheckCircle else Icons.Default.RadioButtonUnchecked,
            contentDescription = null,
            tint = if (item.isChecked) Color.Green else Color.Gray
        )
        
        Spacer(modifier = Modifier.width(8.dp))
        
        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = item.title,
                style = MaterialTheme.typography.bodyMedium
            )
            Text(
                text = item.description,
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

data class ChecklistItem(
    val title: String,
    val description: String,
    val isChecked: Boolean
)

@Composable
fun BestPracticesScreen() {
    val checklistItems = listOf(
        ChecklistItem(
            title = "Local Database as Single Source of Truth",
            description = "Database lokal adalah satu-satunya sumber data yang valid",
            isChecked = true
        ),
        ChecklistItem(
            title = "UI Always Reads from Local Database",
            description = "UI tidak pernah menunggu data dari jaringan",
            isChecked = true
        ),
        ChecklistItem(
            title = "Sync in Background",
            description = "Gunakan WorkManager untuk sinkronisasi background",
            isChecked = true
        ),
        ChecklistItem(
            title = "Show Cached Data While Fetching",
            description = "Tampilkan data cache sambil mengambil data segar",
            isChecked = true
        ),
        ChecklistItem(
            title = "Implement Conflict Resolution",
            description = "Gunakan timestamp untuk mendeteksi konflik",
            isChecked = false
        ),
        ChecklistItem(
            title = "Queue Pending Operations",
            description = "Simpan semua operasi yang belum disinkronkan",
            isChecked = true
        ),
        ChecklistItem(
            title = "Use WorkManager for Periodic Sync",
            description = "Jadwalkan sinkronisasi berkala",
            isChecked = true
        ),
        ChecklistItem(
            title = "Indicate Offline Status to Users",
            description = "Tampilkan banner atau indikator status",
            isChecked = true
        ),
        ChecklistItem(
            title = "Handle Sync Failures Gracefully",
            description = "Implementasikan retry dengan batas maksimal",
            isChecked = false
        ),
        ChecklistItem(
            title = "Test Offline Scenarios Thoroughly",
            description = "Uji aplikasi tanpa koneksi internet",
            isChecked = false
        )
    )
    
    Column(
        modifier = Modifier.fillMaxSize()
    ) {
        BestPracticesChecklist(items = checklistItems)
    }
}
```

### üéì Penjelasan Konsep:
**Best Practices seperti Aturan Main:**
- **Rules**: Aturan yang harus diikuti
- **Fair Play**: Memastikan semua berjalan adil
- **Strategy**: Strategi untuk menang
- **Referee**: Sistem yang memastikan aturan dipatuhi

**Implementasi Best Practices:**
- Buat checklist untuk memastikan semua best practices diikuti
- Review code secara berkala
- Gunakan static analysis tools
- Lakukan code review dengan fokus pada offline-first patterns

**Benefits:**
- Aplikasi yang lebih handal
- Pengalaman pengguna yang lebih baik
- Code yang lebih mudah dipelihara
- Mengurangi bugs di produksi

---

## 1Ô∏è‚É£3Ô∏è‚É£ Testing Offline-First üß™

### Konsep Dasar
Testing Offline-First seperti simulasi keadaan darurat üö® - memastikan aplikasi tetap berfungsi dalam kondisi terburuk!

### Pengertian Testing Offline-First:
Testing Offline-First adalah proses memastikan aplikasi:
- Berfungsi dengan baik tanpa koneksi internet
- Menangani perubahan status jaringan dengan benar
- Menyimpan data secara lokal saat offline
- Mensinkronkan data dengan benar saat kembali online
- Menampilkan indikator status yang tepat kepada pengguna

### Jenis-Jenis Testing untuk Offline-First:

#### 1. Unit Testing
**Fokus:** Menguji logika bisnis di lapisan Repository dan ViewModel.

**Implementasi:**
**test/repository/PostRepositoryTest.kt**
```kotlin
package com.example.offlinefirst.data.repository

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.offlinefirst.data.local.dao.PostDao
import com.example.offlinefirst.data.remote.api.PostApiService
import com.example.offlinefirst.data.util.NetworkMonitor
import com.example.offlinefirst.domain.model.Post
import com.example.offlinefirst.domain.util.Resource
import io.mockk.*
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import java.io.IOException

/**
 * Unit Test untuk PostRepository
 */
class PostRepositoryTest {
    
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()
    
    private lateinit var repository: PostRepositoryImpl
    private val mockApiService: PostApiService = mockk()
    private val mockPostDao: PostDao = mockk()
    private val mockNetworkMonitor: NetworkMonitor = mockk()
    
    private val testPost = Post(
        id = "1",
        title = "Test Post",
        body = "This is a test post",
        userId = "user1",
        userName = "Test User",
        likes = 10,
        comments = 2,
        isLiked = false,
        createdAt = System.currentTimeMillis(),
        updatedAt = System.currentTimeMillis()
    )
    
    @Before
    fun setup() {
        // Mock behavior for DAO
        every { mockPostDao.getAllPosts() } returns flowOf(listOf(testPost.toEntity()))
        every { mockPostDao.getPostById(any()) } returns flowOf(testPost.toEntity())
        every { mockPostDao.insertAll(any()) } returns listOf(1L)
        every { mockPostDao.insert(any()) } returns 1L
        every { mockPostDao.updatePost(any()) } just Runs
        every { mockPostDao.deletePostById(any()) } just Runs
        
        // Mock behavior for Network Monitor
        every { mockNetworkMonitor.isNetworkAvailable() } returns true
        
        repository = PostRepositoryImpl(mockPostDao, mockApiService, mockNetworkMonitor)
    }
    
    @Test
    fun `getPosts when online should fetch from network and update cache`() = runTest {
        // Given
        val freshPosts = listOf(testPost.copy(title = "Fresh Post"))
        coEvery { mockApiService.getPosts() } returns freshPosts
        
        // When
        val result = repository.getPosts().first()
        
        // Then
        assert(result is Resource.Success)
        assert((result as Resource.Success).data!!.first().title == "Fresh Post")
        
        // Verify API was called and cache was updated
        coVerify { mockApiService.getPosts() }
        coVerify { mockPostDao.deleteAll() }
        coVerify { mockPostDao.insertAll(any()) }
    }
    
    @Test
    fun `getPosts when offline should return cached data`() = runTest {
        // Given
        every { mockNetworkMonitor.isNetworkAvailable() } returns false
        
        // When
        val result = repository.getPosts().first()
        
        // Then
        assert(result is Resource.Success)
        assert((result as Resource.Success).data!!.first().title == "Test Post")
        
        // Verify API was NOT called
        coVerify(exactly = 0) { mockApiService.getPosts() }
    }
    
    @Test
    fun `getPosts when network error should return error with cached data`() = runTest {
        // Given
        coEvery { mockApiService.getPosts() } throws IOException("Network error")
        
        // When
        val result = repository.getPosts().first()
        
        // Then
        assert(result is Resource.Error)
        assert((result as Resource.Error).message == "Network error")
        assert(result.data!!.first().title == "Test Post") // Should still have cached data
    }
    
    @Test
    fun `refreshPosts should throw exception when offline`() = runTest {
        // Given
        every { mockNetworkMonitor.isNetworkAvailable() } returns false
        
        // When & Then
        try {
            repository.refreshPosts()
            assert(false) { "Should have thrown an exception" }
        } catch (e: Exception) {
            assert(e.message == "No internet connection")
        }
    }
}
```

#### 2. Integration Testing
**Fokus:** Menguji interaksi antar komponen, seperti Repository dan Database Room.

**Implementasi:**
**androidTest/integration/PostDaoTest.kt**
```kotlin
package com.example.offlinefirst.data.local.dao

import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.offlinefirst.data.local.AppDatabase
import com.example.offlinefirst.data.local.entity.PostEntity
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.Assert.*

/**
 * Integration Test untuk PostDao
 */
@RunWith(AndroidJUnit4::class)
class PostDaoTest {
    
    private lateinit var database: AppDatabase
    private lateinit var postDao: PostDao
    
    @Before
    fun createDb() {
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            AppDatabase::class.java
        ).allowMainThreadQueries().build()
        postDao = database.postDao()
    }
    
    @After
    fun closeDb() {
        database.close()
    }
    
    @Test
    fun insertAndGetPost() = runTest {
        // Given
        val post = PostEntity(
            id = "1",
            title = "Test Post",
            body = "This is a test",
            userId = "user1",
            userName = "Test User",
            createdAt = System.currentTimeMillis(),
            updatedAt = System.currentTimeMillis()
        )
        
        // When
        postDao.insert(post)
        val retrievedPost = postDao.getPostById("1")
        
        // Then
        assertNotNull(retrievedPost)
        assertEquals(post.title, retrievedPost?.title)
    }
    
    @Test
    fun getAllPosts_returnsFlowOfPosts() = runTest {
        // Given
        val posts = listOf(
            PostEntity("1", "Post 1", "Body 1", "user1", "User 1", 1, 0, false, 1, 1),
            PostEntity("2", "Post 2", "Body 2", "user2", "User 2", 1, 0, false, 2, 2)
        )
        postDao.insertAll(posts)
        
        // When
        val retrievedPosts = postDao.getAllPosts().first()
        
        // Then
        assertEquals(2, retrievedPosts.size)
        assertEquals("Post 1", retrievedPosts[0].title)
        assertEquals("Post 2", retrievedPosts[1].title)
    }
    
    @Test
    fun deletePostById_deletesPost() = runTest {
        // Given
        val post = PostEntity("1", "Post 1", "Body 1", "user1", "User 1", 1, 0, false, 1, 1)
        postDao.insert(post)
        var retrievedPost = postDao.getPostById("1")
        assertNotNull(retrievedPost)
        
        // When
        postDao.deletePostById("1")
        retrievedPost = postDao.getPostById("1")
        
        // Then
        assertNull(retrievedPost)
    }
}
```

#### 3. UI/Instrumentation Testing
**Fokus:** Menguji alur pengguna secara keseluruhan, termasuk interaksi UI dan perubahan jaringan.

**Implementasi:**
**androidTest/ui/OfflineFirstUiTest.kt**
```kotlin
package com.example.offlinefirst.ui

import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.example.offlinefirst.MainActivity
import com.example.offlinefirst.presentation.ui.component.PostList
import com.example.offlinefirst.presentation.viewmodel.OptimisticUpdateViewModel
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.flow.MutableStateFlow
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

/**
 * UI Test untuk Offline-First features
 */
@HiltAndroidTest
@RunWith(AndroidJUnit4::class)
class OfflineFirstUiTest {
    
    @get:Rule
    val composeTestRule = createAndroidComposeRule<MainActivity>()
    
    @get:Rule
    val hiltRule = HiltAndroidRule(this)
    
    private lateinit var viewModel: OptimisticUpdateViewModel
    
    @Before
    fun setup() {
        // Mock ViewModel for isolated UI testing
        viewModel = mockk(relaxed = true)
        val postsFlow = MutableStateFlow(
            listOf(
                Post(id = "1", title = "Test Post 1", body = "Body 1", userId = "1", userName = "User 1", likes = 10, comments = 5, isLiked = false, createdAt = 0, updatedAt = 0),
                Post(id = "2", title = "Test Post 2", body = "Body 2", userId = "2", userName = "User 2", likes = 20, comments = 10, isLiked = true, createdAt = 0, updatedAt = 0)
            )
        )
        every { viewModel.posts } returns postsFlow
        every { viewModel.uiState } returns MutableStateFlow(OptimisticUpdateViewModel.OptimisticUpdateUiState.Idle)
        
        composeTestRule.setContent {
            PostList(
                posts = viewModel.posts.value,
                onPostClick = {},
                onLike = { viewModel.likePost(it) },
                onUnlike = { viewModel.unlikePost(it) }
            )
        }
    }
    
    @Test
    fun postList_displaysPosts() {
        composeTestRule.onNodeWithText("Test Post 1").assertIsDisplayed()
        composeTestRule.onNodeWithText("Test Post 2").assertIsDisplayed()
        composeTestRule.onNodeWithText("10 likes").assertIsDisplayed()
        composeTestRule.onNodeWithText("20 likes").assertIsDisplayed()
    }
    
    @Test
    fun likeButton_updatesOptimistically() {
        // Check initial state
        composeTestRule.onNodeWithContentDescription("Like").assertIsDisplayed()
        composeTestRule.onNodeWithText("10 likes").assertIsDisplayed()
        
        // Click like button
        composeTestRule.onNodeWithContentDescription("Like").performClick()
        
        // Verify ViewModel method was called
        verify { viewModel.likePost("1") }
        
        // Note: Testing the actual UI update after the click would require
        // the ViewModel to be a real instance or a more complex mock setup.
        // This test focuses on verifying the interaction.
    }
    
    @Test
    fun networkStatusBanner_displaysWhenOffline() {
        // This test would require toggling network state,
        // which is complex and often done with a separate test utility.
        // For example, using `adb svc wifi disable` or a library like
        // `network-test-utils`.
        
        // The test would:
        // 1. Set network to offline.
        // 2. Launch the activity.
        // 3. Assert that the NetworkStatusBanner is displayed.
        // 4. Set network to online.
        // 5. Assert that the banner is gone.
    }
}
```

### üéì Penjelasan Konsep:
**Testing Offline-First seperti Simulasi Bencana:**
- **Unit Tests**: Tes evakuasi individu (menguji komponen satu per satu)
- **Integration Tests**: Tes koordinasi tim (menguji interaksi komponen)
- **UI Tests**: Simulasi bencana penuh (menguji alur pengguna)

**Strategi Testing:**
1. **Mock Eksternal Dependencies**: Mock API dan Database untuk unit test.
2. **Gunakan In-Memory Database**: Untuk integration test yang cepat dan bersih.
3. **Simulasikan Perubahan Jaringan**: Gunakan alat seperti `adb` untuk testing UI.
4. **Verifikasi State Offline dan Online**: Pastikan aplikasi berperilaku benar di kedua kondisi.
5. **Uji Sinkronisasi**: Pastikan data yang diubah offline tersinkronisasi dengan benar.

**Pentingnya Testing Offline-First:**
- Menjamin pengalaman pengguna yang konsisten.
- Mencegah kehilangan data.
- Memastikan aplikasi handal dalam berbagai kondisi jaringan.
- Meningkatkan kepercayaan diri saat melakukan deployment.

---

## 1Ô∏è‚É£4Ô∏è‚É£ Hands-on Project üî®

### Konsep Dasar
Hands-on Project seperti membangun jembatan üåâ - menerapkan semua teori untuk menciptakan sesuatu yang kokoh dan fungsional!

### Tujuan Proyek:
Membangun aplikasi blog sederhana yang sepenuhnya Offline-First dengan fitur:
- Menampilkan daftar post
- Membaca detail post
- Menyukai/membatalkan suka post (optimistic update)
- Membuat post baru (pending operation)
- Sinkronisasi data di background
- Indikator status offline dan pending sync

### Langkah-Langkah Implementasi:

#### Langkah 1: Setup Proyek
1. Buat proyek baru di Android Studio dengan template "Empty Activity".
2. Tambahkan dependensi berikut di `build.gradle.kts` (Module: app):

```kotlin
// Hilt for Dependency Injection
implementation("com.google.dagger:hilt-android:2.48")
kapt("com.google.dagger:hilt-compiler:2.48")

// Room for Local Database
implementation("androidx.room:room-runtime:2.6.1")
implementation("androidx.room:room-ktx:2.6.1")
kapt("androidx.room:room-compiler:2.6.1")

// Retrofit for Network
implementation("com.squareup.retrofit2:retrofit:2.9.0")
implementation("com.squareup.retrofit2:converter-gson:2.9.0")
implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")

// Coroutines & Flow
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")

// ViewModel & LiveData
implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0")
implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")

// WorkManager
implementation("androidx.work:work-runtime-ktx:2.9.0")

// Jetpack Compose
implementation("androidx.activity:activity-compose:1.8.2")
implementation(platform("androidx.compose:compose-bom:2023.08.00"))
implementation("androidx.compose.ui:ui")
implementation("androidx.compose.ui:ui-graphics")
implementation("androidx.compose.ui:ui-tooling-preview")
implementation("androidx.compose.material3:material3")
```

3. Buat class Application dan anotasi dengan `@HiltAndroidApp`.

#### Langkah 2: Database Lokal (Room)
1. Buat `PostEntity.kt` (sudah ada di materi).
2. Buat `PendingOperationEntity.kt` (sudah ada di materi).
3. Buat `PostDao.kt` dan `PendingOperationDao.kt` (sudah ada di materi).
4. Buat `AppDatabase.kt` dan anotasi dengan `@Database`.

#### Langkah 3: Lapisan Jaringan (Retrofit)
1. Buat `PostApiService.kt` dengan endpoint untuk mendapatkan, membuat, dan memperbarui post.
2. Buat `PostDto.kt` untuk respons dari API.

```kotlin
// data/remote/api/PostApiService.kt
interface PostApiService {
    @GET("posts")
    suspend fun getPosts(): List<PostDto>
    
    @GET("posts/{id}")
    suspend fun getPostById(@Path("id") id: String): PostDto
    
    @POST("posts")
    suspend fun createPost(@Body post: PostDto): PostDto
    
    @PUT("posts/{id}")
    suspend fun updatePost(@Path("id") id: String, @Body post: PostDto): PostDto
    
    @POST("posts/{id}/like")
    suspend fun likePost(@Path("id") id: String): Response<Unit>
}
```

#### Langkah 4: Repository
1. Buat `PostRepositoryImpl.kt` yang mengimplementasikan `PostRepository`.
2. Gunakan `networkBoundResource` untuk `getPosts()`.
3. Implementasikan logika `createPost`, `updatePost`, dan `deletePost` dengan antrian `PendingOperation`.
4. Implementasikan `syncPendingOperations`.

#### Langkah 5: ViewModel
1. Buat `PostListViewModel.kt` yang mengamati `PostRepository`.
2. Kelola state UI (Loading, Success, Error).
3. Implementasikan fungsi untuk like/unlike post dengan optimistic update.
4. Implementasikan fungsi untuk refresh data.

#### Langkah 6: UI (Jetpack Compose)
1. Buat `MainActivity.kt` untuk mengatur navigasi.
2. Buat `PostListScreen.kt` yang menampilkan daftar post.
3. Gunakan `NetworkStatusBanner` dan `PendingSyncIndicator`.
4. Buat `PostListItem.kt` yang menampilkan post individual dengan tombol like.
5. Buat `CreatePostScreen.kt` untuk membuat post baru.

#### Langkah 7: Background Sync (WorkManager)
1. Buat `SyncWorker.kt` yang mewarisi `CoroutineWorker`.
2. Implementasikan `doWork()` untuk memanggil `repository.syncPendingOperations()`.
3. Buat `WorkManagerScheduler.kt` untuk menjadwalkan sync.
4. Panggil scheduler dari `Application` class untuk memulai sync periodik.

#### Langkah 8: Testing
1. Tulis unit test untuk `PostRepositoryImpl` (sudah ada di materi).
2. Tulis integration test untuk `PostDao` (sudah ada di materi).
3. Tulis UI test untuk memverifikasi tampilan daftar post dan interaksi like.

### üéì Penjelasan Konsep:
**Hands-on Project seperti Membangun Jembatan:**
- **Blueprint**: Arsitektur Offline-First (panduan ini).
- **Foundation**: Database dan API (lapisan data).
- **Pillars**: Repository dan ViewModel (logika bisnis).
- **Deck**: UI (tampilan).
- **Traffic Control**: WorkManager dan Network Monitor (sinkronisasi).
- **Safety Inspections**: Testing (memastikan kualitas).

**Kunci Keberhasilan Proyek:**
- **Mulai dari Data**: Definisikan Entity dan DAO terlebih dahulu.
- **Pisahkan Tanggung Jawab**: Jangan campur aduk logika UI, bisnis, dan data.
- **Uji Secara Iteratif**: Tulis test saat mengembangkan fitur, bukan di akhir.
- **Pikirkan Pengguna**: Bagaimana pengguna merasakan aplikasi saat offline?

---

## üéØ Kesimpulan

Selamat! üéâ Anda telah menempuh perjalanan panjang untuk memahami **Offline-First Architecture**. Anda telah belajar:

- **Filosofi Offline-First**: Mengapa ini penting di era mobile.
- **Pola Network-Bound Resource**: Cara elegan mengelola cache dan jaringan.
- **Strategi Caching**: Memilih pendekatan terbaik untuk kebutuhan Anda.
- **Antrian Operasi Tertunda**: Memastikan tidak ada perubahan pengguna yang hilang.
- **Sinkronisasi Latar Belakang**: Menjaga data tetap segar dengan WorkManager.
- **Resolusi Konflik**: Menangani masalah saat data bertabrakan.
- **Update Optimis**: Memberikan pengalaman pengguna yang sangat responsif.
- **Indikator Offline**: Memberikan transparansi kepada pengguna.
- **Pengujian yang Komprehensif**: Membangun aplikasi yang andal.

Dengan menguasai konsep-konsep ini, Anda sekarang mampu membangun aplikasi Android yang tidak hanya cepat dan responsif, tetapi juga andal dan memberikan pengalaman pengguna yang luar biasa, terlepas dari kondisi jaringan. Teruslah berlatih, bereksperimen dengan proyek tangan, dan bangun aplikasi yang dapat diandalkan oleh pengguna Anda di mana saja dan kapan saja