## **5.2 Retrofit** (1 minggu) ⭐⭐⭐

### **Teknologi Modern:**
- Retrofit 2
- OkHttp
- Interceptors

### **Teknologi yang Ditinggalkan:**
- Volley
- AsyncTask

### **Sub-topik Detail:**

#### 1. Pengenalan Retrofit
- Apa itu Retrofit
- Type-safe HTTP client
- Built on top of OkHttp
- Mengapa Retrofit populer
- Retrofit vs Volley vs Ktor
- Retrofit architecture overview

#### 2. Setup & Dependencies
**Gradle Dependencies:**
```kotlin
dependencies {
    // Retrofit
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
    
    // OkHttp (optional, for interceptors)
    implementation("com.squareup.okhttp3:okhttp:4.11.0")
    implementation("com.squareup.okhttp3:logging-interceptor:4.11.0")
}
```

**Permissions:**
```xml
<uses-permission android:name="android.permission.INTERNET"/>
```

#### 3. Building Retrofit Instance
```kotlin
object RetrofitClient {
    private const val BASE_URL = "https://api.example.com/"
    
    val instance: Retrofit by lazy {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
}
```

**With OkHttp Client:**
```kotlin
private val okHttpClient = OkHttpClient.Builder()
    .connectTimeout(30, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .writeTimeout(30, TimeUnit.SECONDS)
    .build()

val retrofit = Retrofit.Builder()
    .baseUrl(BASE_URL)
    .client(okHttpClient)
    .addConverterFactory(GsonConverterFactory.create())
    .build()
```

#### 4. API Interface Definition
```kotlin
interface ApiService {
    // GET request
    @GET("users")
    suspend fun getUsers(): List<User>
    
    // GET with path parameter
    @GET("users/{id}")
    suspend fun getUserById(@Path("id") userId: Int): User
    
    // GET with query parameters
    @GET("users")
    suspend fun searchUsers(
        @Query("name") name: String,
        @Query("page") page: Int
    ): List<User>
    
    // POST request
    @POST("users")
    suspend fun createUser(@Body user: User): User
    
    // PUT request
    @PUT("users/{id}")
    suspend fun updateUser(
        @Path("id") userId: Int,
        @Body user: User
    ): User
    
    // DELETE request
    @DELETE("users/{id}")
    suspend fun deleteUser(@Path("id") userId: Int): Response<Unit>
    
    // Multipart file upload
    @Multipart
    @POST("upload")
    suspend fun uploadImage(
        @Part image: MultipartBody.Part,
        @Part("description") description: RequestBody
    ): UploadResponse
}
```

#### 5. Annotations Explained
**@GET, @POST, @PUT, @DELETE, @PATCH:**
- HTTP method annotations
- Relative URL path

**@Path:**
- URL path parameter
- Example: `/users/{id}` → `@Path("id")`

**@Query:**
- Query string parameter
- Example: `/users?name=john`

**@QueryMap:**
- Multiple query parameters as Map
```kotlin
@GET("users")
suspend fun getUsers(@QueryMap filters: Map<String, String>): List<User>
```

**@Body:**
- Request body untuk POST/PUT
- Auto-converted to JSON

**@Header:**
- Single header
```kotlin
@GET("users")
suspend fun getUsers(@Header("Authorization") token: String): List<User>
```

**@HeaderMap:**
- Multiple headers as Map

**@Headers:**
- Static headers
```kotlin
@Headers("Cache-Control: max-age=640000")
@GET("users")
suspend fun getUsers(): List<User>
```

**@Field & @FormUrlEncoded:**
- Form-encoded data
```kotlin
@FormUrlEncoded
@POST("login")
suspend fun login(
    @Field("email") email: String,
    @Field("password") password: String
): LoginResponse
```

**@Multipart & @Part:**
- Multipart file upload

**@Url:**
- Dynamic URL
```kotlin
@GET
suspend fun getDynamicUrl(@Url url: String): ResponseBody
```

#### 6. Data Models (POJOs)
```kotlin
data class User(
    @SerializedName("id")
    val id: Int,
    
    @SerializedName("name")
    val name: String,
    
    @SerializedName("email")
    val email: String,
    
    @SerializedName("created_at")
    val createdAt: String
)

// Response wrapper
data class ApiResponse<T>(
    @SerializedName("success")
    val success: Boolean,
    
    @SerializedName("data")
    val data: T?,
    
    @SerializedName("message")
    val message: String?
)
```

#### 7. Making API Calls
**Creating Service Instance:**
```kotlin
val apiService = RetrofitClient.instance.create(ApiService::class.java)
```

**Calling with Coroutines:**
```kotlin
// In ViewModel
viewModelScope.launch {
    try {
        val users = apiService.getUsers()
        _uiState.value = UiState.Success(users)
    } catch (e: Exception) {
        _uiState.value = UiState.Error(e.message ?: "Unknown error")
    }
}
```

**With Response wrapper:**
```kotlin
val response = apiService.createUser(user)
if (response.isSuccessful) {
    val createdUser = response.body()
    // Handle success
} else {
    val errorBody = response.errorBody()?.string()
    // Handle error
}
```

#### 8. Coroutines Integration
**Suspend Functions:**
- Retrofit natively supports suspend
- No callback needed
- Call dalam coroutine scope

**Call Adapters (Legacy):**
```kotlin
// Old way (avoid)
interface ApiService {
    @GET("users")
    fun getUsers(): Call<List<User>>
}

// Usage
apiService.getUsers().enqueue(object : Callback<List<User>> {
    override fun onResponse(call: Call<List<User>>, response: Response<List<User>>) {
        // Handle success
    }
    
    override fun onFailure(call: Call<List<User>>, t: Throwable) {
        // Handle error
    }
})
```

**Modern Way (Preferred):**
```kotlin
interface ApiService {
    @GET("users")
    suspend fun getUsers(): List<User>
}

// Usage in coroutine
val users = apiService.getUsers()
```

#### 9. Error Handling
**HTTP Errors:**
```kotlin
try {
    val response = apiService.getUsers()
    // Success
} catch (e: HttpException) {
    // HTTP error (4xx, 5xx)
    when (e.code()) {
        401 -> // Unauthorized
        404 -> // Not found
        500 -> // Server error
    }
} catch (e: IOException) {
    // Network error
} catch (e: Exception) {
    // Unknown error
}
```

**Custom Error Handling:**
```kotlin
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()
}

suspend fun <T> safeApiCall(apiCall: suspend () -> T): Result<T> {
    return try {
        Result.Success(apiCall())
    } catch (e: Exception) {
        Result.Error(e)
    }
}

// Usage
val result = safeApiCall { apiService.getUsers() }
when (result) {
    is Result.Success -> // Handle success
    is Result.Error -> // Handle error
}
```

#### 10. Interceptors
**Logging Interceptor:**
```kotlin
val loggingInterceptor = HttpLoggingInterceptor().apply {
    level = HttpLoggingInterceptor.Level.BODY
}

val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(loggingInterceptor)
    .build()
```

**Authentication Interceptor:**
```kotlin
class AuthInterceptor(private val tokenProvider: () -> String?) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val original = chain.request()
        val token = tokenProvider()
        
        val request = if (token != null) {
            original.newBuilder()
                .header("Authorization", "Bearer $token")
                .build()
        } else {
            original
        }
        
        return chain.proceed(request)
    }
}

// Usage
val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(AuthInterceptor { getToken() })
    .build()
```

**Network Interceptor:**
```kotlin
class NetworkConnectionInterceptor(
    private val context: Context
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        if (!isNetworkAvailable(context)) {
            throw NoInternetException()
        }
        return chain.proceed(chain.request())
    }
    
    private fun isNetworkAvailable(context: Context): Boolean {
        val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        return cm.activeNetworkInfo?.isConnected == true
    }
}
```

#### 11. Gson Converter
**Custom Gson Configuration:**
```kotlin
val gson = GsonBuilder()
    .setLenient()
    .setDateFormat("yyyy-MM-dd'T'HH:mm:ss")
    .create()

val retrofit = Retrofit.Builder()
    .baseUrl(BASE_URL)
    .addConverterFactory(GsonConverterFactory.create(gson))
    .build()
```

**@SerializedName:**
- Map JSON keys to Kotlin properties
- Handle different naming conventions

**Custom Deserializers:**
```kotlin
class DateDeserializer : JsonDeserializer<Date> {
    override fun deserialize(
        json: JsonElement,
        typeOfT: Type,
        context: JsonDeserializationContext
    ): Date {
        return Date(json.asLong)
    }
}
```

#### 12. File Upload & Download
**Upload:**
```kotlin
@Multipart
@POST("upload")
suspend fun uploadImage(
    @Part image: MultipartBody.Part,
    @Part("title") title: RequestBody
): UploadResponse

// Usage
val file = File(imagePath)
val requestFile = file.asRequestBody("image/*".toMediaTypeOrNull())
val body = MultipartBody.Part.createFormData("image", file.name, requestFile)
val title = "My Image".toRequestBody("text/plain".toMediaTypeOrNull())

val response = apiService.uploadImage(body, title)
```

**Download:**
```kotlin
@GET("files/{filename}")
@Streaming
suspend fun downloadFile(@Path("filename") filename: String): ResponseBody

// Usage
val responseBody = apiService.downloadFile("document.pdf")
val file = File(context.filesDir, "document.pdf")
responseBody.byteStream().use { input ->
    file.outputStream().use { output ->
        input.copyTo(output)
    }
}
```

#### 13. Response Caching
```kotlin
val cacheSize = 10 * 1024 * 1024L // 10 MB
val cache = Cache(context.cacheDir, cacheSize)

val okHttpClient = OkHttpClient.Builder()
    .cache(cache)
    .addInterceptor { chain ->
        var request = chain.request()
        request = if (hasNetwork())
            request.newBuilder()
                .header("Cache-Control", "public, max-age=60")
                .build()
        else
            request.newBuilder()
                .header("Cache-Control", "public, only-if-cached, max-stale=86400")
                .build()
        chain.proceed(request)
    }
    .build()
```

#### 14. Retrofit with Hilt
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .addInterceptor(loggingInterceptor)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
```

#### 15. Best Practices
- Use suspend functions dengan coroutines
- Implement proper error handling
- Use interceptors untuk common logic
- Enable logging only in debug builds
- Cache responses when appropriate
- Use timeout configurations
- Implement retry logic untuk failed requests
- Separate API models dari domain models
- Use sealed classes untuk API responses
- Mock API responses untuk testing

#### 16. Hands-on Project
- Setup Retrofit dalam project
- Create API service interface
- Implement CRUD operations
- Add interceptors (auth, logging)
- Error handling
- File upload/download
- Integration dengan Repository pattern
- Testing dengan MockWebServer

---
