## **7.4 Flow Operators** (4 hari) ⭐⭐⭐

### **Teknologi Modern:**
- map, filter, combine
- collectLatest
- Transformation operators
- Terminal operators

### **Teknologi yang Ditinggalkan:**
- RxJava operators
- Manual callback chains

### **Sub-topik Detail:**

#### **1. Transformation Operators**

**map:**
```kotlin
// Transform each value
val prices: Flow<Double> = productsFlow
    .map { product -> product.price }

val upperCaseNames: Flow<String> = usersFlow
    .map { user -> user.name.uppercase() }

// Complex mapping
data class UserUi(val displayName: String, val avatar: String)

val userUiFlow: Flow<UserUi> = userFlow
    .map { user ->
        UserUi(
            displayName = "${user.firstName} ${user.lastName}",
            avatar = user.avatarUrl ?: DEFAULT_AVATAR
        )
    }
```

**mapNotNull:**
```kotlin
// Filter out nulls while transforming
val validEmails: Flow<String> = usersFlow
    .mapNotNull { user ->
        user.email.takeIf { it.contains("@") }
    }

val parsedDates: Flow<Date> = dateStringsFlow
    .mapNotNull { dateString ->
        try {
            dateFormat.parse(dateString)
        } catch (e: Exception) {
            null
        }
    }
```

**transform:**
```kotlin
// Emit multiple values or skip values
val eventsFlow: Flow<String> = numbersFlow
    .transform { number ->
        if (number % 2 == 0) {
            emit("Even: $number")
            emit("Half: ${number / 2}")
        }
    }

// Progress tracking
fun downloadFile(url: String): Flow<DownloadEvent> = flow {
    emit(DownloadEvent.Started)
    
    val bytes = downloadBytes(url)
    bytes.forEachIndexed { index, byte ->
        if (index % 1000 == 0) {
            emit(DownloadEvent.Progress(index, bytes.size))
        }
    }
    
    emit(DownloadEvent.Completed(bytes))
}
```

**scan:**
```kotlin
// Accumulate values
val runningSum: Flow<Int> = numbersFlow
    .scan(0) { accumulator, value ->
        accumulator + value
    }
// Input: 1, 2, 3, 4
// Output: 1, 3, 6, 10

val cartTotal: Flow<Double> = cartItemsFlow
    .scan(0.0) { total, item ->
        total + item.price * item.quantity
    }
```

**runningReduce:**
```kotlin
// Like scan but without initial value
val product: Flow<Int> = numbersFlow
    .runningReduce { accumulator, value ->
        accumulator * value
    }
// Input: 2, 3, 4
// Output: 2, 6, 24
```

#### **2. Filtering Operators**

**filter:**
```kotlin
// Keep only matching values
val adults: Flow<User> = usersFlow
    .filter { user -> user.age >= 18 }

val expensiveProducts: Flow<Product> = productsFlow
    .filter { it.price > 100.0 }

// Multiple conditions
val activeAdmins: Flow<User> = usersFlow
    .filter { user ->
        user.isActive && user.role == Role.ADMIN
    }
```

**filterNot:**
```kotlin
// Keep values that DON'T match
val nonEmptyStrings: Flow<String> = stringsFlow
    .filterNot { it.isEmpty() }

val availableProducts: Flow<Product> = productsFlow
    .filterNot { it.isOutOfStock }
```

**filterIsInstance:**
```kotlin
// Filter by type
sealed class Message {
    data class Text(val content: String) : Message()
    data class Image(val url: String) : Message()
    data class Video(val url: String) : Message()
}

val textMessages: Flow<Message.Text> = messagesFlow
    .filterIsInstance<Message.Text>()

val mediaMessages: Flow<Message> = messagesFlow
    .filter { it is Message.Image || it is Message.Video }
```

**filterNotNull:**
```kotlin
// Remove null values
val nonNullUsers: Flow<User> = nullableUsersFlow
    .filterNotNull()

val validAvatars: Flow<String> = usersFlow
    .map { it.avatarUrl }
    .filterNotNull()
```

**distinctUntilChanged:**
```kotlin
// Emit only when value changes
val searchQuery = MutableStateFlow("")
val uniqueQueries: Flow<String> = searchQuery
    .distinctUntilChanged()
// Input: "a", "a", "ab", "ab", "abc"
// Output: "a", "ab", "abc"

// With custom comparison
val uniqueUsers: Flow<User> = usersFlow
    .distinctUntilChanged { old, new ->
        old.id == new.id
    }
```

**distinctUntilChangedBy:**
```kotlin
// Distinct by specific property
val uniqueByName: Flow<User> = usersFlow
    .distinctUntilChangedBy { it.name }

val uniquePriceRanges: Flow<Product> = productsFlow
    .distinctUntilChangedBy { product ->
        (product.price / 10).toInt() * 10 // Group by $10 ranges
    }
```

**drop:**
```kotlin
// Skip first N values
val afterWarmup: Flow<Int> = sensorFlow
    .drop(10) // Skip first 10 readings

val withoutHeaders: Flow<String> = csvFlow
    .drop(1) // Skip header row
```

**dropWhile:**
```kotlin
// Drop until condition becomes false
val afterThreshold: Flow<Int> = numbersFlow
    .dropWhile { it < 5 }
// Input: 1, 2, 3, 6, 2, 8
// Output: 6, 2, 8

val afterLogin: Flow<Event> = eventsFlow
    .dropWhile { it !is Event.LoginSuccess }
```

**take:**
```kotlin
// Take only first N values
val firstFive: Flow<Int> = numbersFlow
    .take(5)

val preview: Flow<Product> = productsFlow
    .take(3)
```

**takeWhile:**
```kotlin
// Take until condition becomes false
val belowLimit: Flow<Int> = numbersFlow
    .takeWhile { it < 100 }

val beforeError: Flow<Result> = resultsFlow
    .takeWhile { it.isSuccess }
```

#### **3. Combining Operators**

**combine:**
```kotlin
// Combine latest values from multiple flows
val userProfile: Flow<UserProfile> = combine(
    userFlow,
    settingsFlow,
    preferencesFlow
) { user, settings, preferences ->
    UserProfile(user, settings, preferences)
}

// Two flows
val filteredProducts: Flow<List<Product>> = combine(
    productsFlow,
    searchQueryFlow
) { products, query ->
    products.filter { it.name.contains(query, ignoreCase = true) }
}

// With index
val combined: Flow<Pair<Int, String>> = combine(
    flow { emit(1); delay(100); emit(2) },
    flow { emit("A"); delay(150); emit("B") }
) { number, letter ->
    number to letter
}
// Emits: (1, "A"), (2, "A"), (2, "B")
```

**zip:**
```kotlin
// Pair values in order (waits for both)
val pairs: Flow<Pair<Int, String>> = numbersFlow.zip(lettersFlow) { num, letter ->
    num to letter
}
// Flow1: 1, 2, 3
// Flow2: A, B
// Result: (1, A), (2, B) - stops when shortest completes

val users WithAvatars: Flow<UserWithAvatar> = 
    usersFlow.zip(avatarsFlow) { user, avatar ->
        UserWithAvatar(user, avatar)
    }
```

**merge:**
```kotlin
// Merge multiple flows into one
val allNotifications: Flow<Notification> = merge(
    pushNotificationsFlow,
    emailNotificationsFlow,
    smsNotificationsFlow
)

// Emissions from all flows are combined
// Flow1: 1 ----3----5
// Flow2: --2----4----6
// Merged: 1-2--3-4--5-6
```

**flatMapConcat:**
```kotlin
// Sequential flattening (wait for inner flow to complete)
val allPosts: Flow<Post> = userIdsFlow
    .flatMapConcat { userId ->
        getPostsForUser(userId)
    }
// Processes users one by one

fun getPostsForUser(userId: String): Flow<Post> = flow {
    val posts = api.getUserPosts(userId)
    posts.forEach { emit(it) }
}
```

**flatMapMerge:**
```kotlin
// Concurrent flattening (concurrency limit)
val allPosts: Flow<Post> = userIdsFlow
    .flatMapMerge(concurrency = 3) { userId ->
        getPostsForUser(userId)
    }
// Processes up to 3 users concurrently

val searchResults: Flow<SearchResult> = searchQueriesFlow
    .flatMapMerge { query ->
        searchRepository.search(query)
    }
```

**flatMapLatest:**
```kotlin
// Cancel previous inner flow when new value arrives
val searchResults: Flow<List<Product>> = searchQueryFlow
    .flatMapLatest { query ->
        if (query.length >= 3) {
            searchRepository.search(query)
        } else {
            flowOf(emptyList())
        }
    }
// Perfect for search - cancels old searches

val userDetails: Flow<UserDetails> = selectedUserIdFlow
    .flatMapLatest { userId ->
        repository.getUserDetails(userId)
    }
```

**combineTransform:**
```kotlin
// Combine with transformation
val filtered = combineTransform(
    productsFlow,
    filtersFlow
) { products, filters ->
    val filtered = products.filter { filters.matches(it) }
    if (filtered.isNotEmpty()) {
        emit(filtered)
    }
}
```

#### **4. Timing Operators**

**debounce:**
```kotlin
// Wait for specified time after last emission
val searchResults: Flow<List<Item>> = searchQueryFlow
    .debounce(300) // Wait 300ms after typing stops
    .flatMapLatest { query ->
        repository.search(query)
    }

val saveChanges: Flow<Document> = documentChangesFlow
    .debounce(1000) // Auto-save 1s after last change
    .flatMapLatest { doc ->
        repository.save(doc)
    }
```

**sample/throttleLatest:**
```kotlin
// Emit most recent value at specified intervals
val locationUpdates: Flow<Location> = gpsFlow
    .sample(5000) // Every 5 seconds

val scrollPosition: Flow<Int> = scrollEventsFlow
    .map { it.position }
    .sample(16) // ~60fps
```

**delay:**
```kotlin
// Delay each emission
val delayed: Flow<Int> = flow {
    emit(1)
    emit(2)
    emit(3)
}.map { value ->
    delay(1000)
    value
}
```

**timeout:**
```kotlin
// Timeout if no emission within specified time
val result: Flow<Data> = dataFlow
    .timeout(5.seconds)
    .catch { e ->
        if (e is TimeoutCancellationException) {
            emit(Data.timeout())
        }
    }
```

#### **5. Size-limiting Operators**

**take + drop combinations:**
```kotlin
// Pagination pattern
fun getPage(pageNumber: Int, pageSize: Int): Flow<Item> {
    return allItemsFlow
        .drop(pageNumber * pageSize)
        .take(pageSize)
}

// Skip and take
val middleItems: Flow<Item> = itemsFlow
    .drop(10)
    .take(20)
```

**first/firstOrNull:**
```kotlin
// Get first emission
lifecycleScope.launch {
    val firstUser = usersFlow.first()
    
    val maybeUser = usersFlow.firstOrNull()
    
    val firstAdmin = usersFlow.first { it.role == Role.ADMIN }
}
```

**last:**
```kotlin
// Get last emission
lifecycleScope.launch {
    val lastValue = numbersFlow.last()
    
    val lastEven = numbersFlow.last { it % 2 == 0 }
}
```

**single:**
```kotlin
// Expects exactly one emission
lifecycleScope.launch {
    val user = getUserFlow(userId).single()
    // Throws if zero or multiple emissions
    
    val maybeUser = getUserFlow(userId).singleOrNull()
}
```

#### **6. Terminal Operators**

**collect:**
```kotlin
// Basic collection
lifecycleScope.launch {
    dataFlow.collect { value ->
        updateUI(value)
    }
}
```

**collectLatest:**
```kotlin
// Cancel previous collection when new value arrives
lifecycleScope.launch {
    searchQueryFlow.collectLatest { query ->
        // Previous search is cancelled
        val results = searchRepository.search(query)
        updateUI(results)
    }
}
```

**collectIndexed:**
```kotlin
lifecycleScope.launch {
    dataFlow.collectIndexed { index, value ->
        println("Item $index: $value")
    }
}
```

**toList/toSet:**
```kotlin
lifecycleScope.launch {
    val list = numbersFlow.toList()
    val uniqueNumbers = numbersFlow.toSet()
}
```

**reduce/fold:**
```kotlin
// reduce (no initial value)
lifecycleScope.launch {
    val sum = numbersFlow.reduce { acc, value ->
        acc + value
    }
    
    // fold (with initial value)
    val product = numbersFlow.fold(1) { acc, value ->
        acc * value
    }
}
```

**count:**
```kotlin
lifecycleScope.launch {
    val totalItems = itemsFlow.count()
    
    val expensiveItems = itemsFlow.count { it.price > 100 }
}
```

#### **7. Error Handling Operators**

**catch:**
```kotlin
// Catch and handle exceptions
val safeData: Flow<Data> = dataFlow
    .catch { exception ->
        when (exception) {
            is IOException -> emit(Data.cached())
            is HttpException -> emit(Data.error(exception.message))
            else -> throw exception
        }
    }

// Catch and log
dataFlow
    .catch { e ->
        Log.e("Flow", "Error occurred", e)
        emit(emptyList())
    }
    .collect { data ->
        updateUI(data)
    }
```

**retry:**
```kotlin
// Simple retry
val dataWithRetry: Flow<Data> = flow {
    emit(api.getData())
}.retry(3) // Retry up to 3 times

// Conditional retry
flow {
    emit(api.getData())
}.retry(3) { cause ->
    cause is IOException // Only retry on network errors
}
```

**retryWhen:**
```kotlin
// Advanced retry with backoff
flow {
    emit(api.getData())
}.retryWhen { cause, attempt ->
    when {
        cause is IOException && attempt < 3 -> {
            delay(1000 * (attempt + 1)) // Exponential backoff
            true
        }
        else -> false
    }
}
```

#### **8. Lifecycle Operators**

**onStart:**
```kotlin
dataFlow
    .onStart {
        emit(LoadingState)
        println("Flow started")
    }
    .collect { data ->
        updateUI(data)
    }
```

**onCompletion:**
```kotlin
dataFlow
    .onCompletion { cause ->
        when {
            cause == null -> println("Completed successfully")
            cause is CancellationException -> println("Cancelled")
            else -> println("Failed: $cause")
        }
    }
    .collect { data ->
        processData(data)
    }
```

**onEach:**
```kotlin
// Perform action on each emission
dataFlow
    .onEach { data ->
        Log.d("Flow", "Received: $data")
    }
    .collect { data ->
        updateUI(data)
    }
```

**onEmpty:**
```kotlin
// Emit default value if flow is empty
val dataWithDefault: Flow<List<Item>> = itemsFlow
    .onEmpty {
        emit(getDefaultItems())
    }
```

#### **9. Buffering Operators**

**buffer:**
```kotlin
// Buffer emissions (suspend emit, don't wait for collect)
flow {
    repeat(10) {
        emit(it)
        delay(100)
    }
}
    .buffer(capacity = 5)
    .collect { value ->
        delay(300)
        println(value)
    }
```

**conflate:**
```kotlin
// Keep only latest value, skip intermediate
flow {
    repeat(10) {
        emit(it)
        delay(100)
    }
}
    .conflate()
    .collect { value ->
        delay(300)
        println(value) // Might print: 0, 3, 6, 9
    }
```

#### **10. Advanced Patterns**

**Search with Debounce:**
```kotlin
class SearchViewModel : ViewModel() {
    private val _query = MutableStateFlow("")
    
    val searchResults: StateFlow<SearchState> = _query
        .debounce(300)
        .filter { it.length >= 3 }
        .distinctUntilChanged()
        .flatMapLatest { query ->
            flow {
                emit(SearchState.Loading)
                val results = repository.search(query)
                emit(SearchState.Success(results))
            }.catch { e ->
                emit(SearchState.Error(e.message))
            }
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = SearchState.Idle
        )
    
    fun onQueryChanged(query: String) {
        _query.value = query
    }
}
```

**Pagination:**
```kotlin
class PaginationViewModel : ViewModel() {
    private val _page = MutableStateFlow(0)
    
    val items: StateFlow<List<Item>> = _page
        .flatMapLatest { page ->
            repository.getItems(page, PAGE_SIZE)
        }
        .scan(emptyList<Item>()) { accumulated, newItems ->
            accumulated + newItems
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.Lazily,
            initialValue = emptyList()
        )
    
    fun loadMore() {
        _page.value += 1
    }
}
```

**Combining Multiple Sources:**
```kotlin
val dashboard: Flow<Dashboard> = combine(
    userRepository.getCurrentUser(),
    postsRepository.getRecentPosts(),
    statsRepository.getStats(),
    notificationsRepository.getUnreadCount()
) { user, posts, stats, unreadCount ->
    Dashboard(
        user = user,
        recentPosts = posts,
        stats = stats,
        unreadNotifications = unreadCount
    )
}
```

#### **11. Hands-on Exercises**
- Implement search dengan multiple operators
- Create pagination flow dengan scan
- Build real-time filter dengan combine
- Implement retry logic dengan exponential backoff
- Create form validation dengan combine
- Build auto-save dengan debounce
- Implement pull-to-refresh dengan merge
- Create complex data transformation pipeline

---
