## **8.3 Hilt Modules** (4 hari) ⭐⭐⭐

### **Teknologi Modern:**
- @Module
- @Provides
- @Binds
- Component hierarchy

### **Teknologi yang Ditinggalkan:**
- Manual factory
- Service locator
- Static singletons

### **Sub-topik Detail:**

#### **1. Module Structure**

**Feature-based Modules:**
```kotlin
// Network Module
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    @Provides
    @Singleton
    fun provideRetrofit(): Retrofit { /* ... */ }
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService { /* ... */ }
}

// Database Module
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase { /* ... */ }
}

// Repository Module
@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    @Binds
    abstract fun bindUserRepository(impl: UserRepositoryImpl): UserRepository
}
```

#### **2. Object vs Abstract Class**

**Object Module (for @Provides):**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton
    fun provideGson(): Gson {
        return GsonBuilder()
            .setLenient()
            .create()
    }
    
    @Provides
    fun provideCurrentTime(): Long {
        return System.currentTimeMillis()
    }
}
```

**Abstract Class (for @Binds):**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class DataSourceModule {
    
    @Binds
    @Singleton
    abstract fun bindRemoteDataSource(
        impl: RemoteDataSourceImpl
    ): RemoteDataSource
    
    @Binds
    @Singleton
    abstract fun bindLocalDataSource(
        impl: LocalDataSourceImpl
    ): LocalDataSource
}
```

**Mixing Both:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class MixedModule {
    
    @Binds
    abstract fun bindRepository(impl: UserRepositoryImpl): UserRepository
    
    companion object {
        @Provides
        fun provideDispatcher(): CoroutineDispatcher = Dispatchers.IO
    }
}
```

#### **3. Multi-module Support**

**Domain Module:**
```kotlin
// domain/build.gradle
dependencies {
    implementation("com.google.dagger:hilt-core:2.48")
}

// Domain layer module
@Module
@InstallIn(SingletonComponent::class)
abstract class DomainModule {
    
    @Binds
    abstract fun bindGetUserUseCase(
        impl: GetUserUseCaseImpl
    ): GetUserUseCase
}
```

**Data Module:**
```kotlin
// data/build.gradle
dependencies {
    implementation("com.google.dagger:hilt-core:2.48")
}

@Module
@InstallIn(SingletonComponent::class)
abstract class DataModule {
    
    @Binds
    @Singleton
    abstract fun bindUserRepository(
        impl: UserRepositoryImpl
    ): UserRepository
}
```

#### **4. Providing Context**

**Application Context:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton
    fun provideSharedPreferences(
        @ApplicationContext context: Context
    ): SharedPreferences {
        return context.getSharedPreferences("prefs", Context.MODE_PRIVATE)
    }
    
    @Provides
    fun provideResources(
        @ApplicationContext context: Context
    ): Resources {
        return context.resources
    }
}
```

**Activity Context:**
```kotlin
@Module
@InstallIn(ActivityComponent::class)
object ActivityModule {
    
    @Provides
    fun provideLayoutInflater(
        @ActivityContext context: Context
    ): LayoutInflater {
        return LayoutInflater.from(context)
    }
}
```

#### **5. Collections & Sets**

**Providing Lists:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object InterceptorModule {
    
    @Provides
    @Singleton
    fun provideInterceptors(): List<Interceptor> {
        return listOf(
            LoggingInterceptor(),
            AuthInterceptor(),
            CacheInterceptor()
        )
    }
    
    @Provides
    @Singleton
    fun provideOkHttpClient(interceptors: List<Interceptor>): OkHttpClient {
        return OkHttpClient.Builder().apply {
            interceptors.forEach { addInterceptor(it) }
        }.build()
    }
}
```

**Providing Sets:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class PluginModule {
    
    @Binds
    @IntoSet
    abstract fun bindPlugin1(impl: Plugin1): Plugin
    
    @Binds
    @IntoSet
    abstract fun bindPlugin2(impl: Plugin2): Plugin
}

// Usage
class PluginManager @Inject constructor(
    private val plugins: Set<Plugin>
) {
    fun initializeAll() {
        plugins.forEach { it.initialize() }
    }
}
```

**Providing Maps:**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class ViewModelModule {
    
    @Binds
    @IntoMap
    @ViewModelKey(UserViewModel::class)
    abstract fun bindUserViewModel(viewModel: UserViewModel): ViewModel
    
    @Binds
    @IntoMap
    @ViewModelKey(ProfileViewModel::class)
    abstract fun bindProfileViewModel(viewModel: ProfileViewModel): ViewModel
}

@MapKey
annotation class ViewModelKey(val value: KClass<out ViewModel>)
```

#### **6. Conditional Modules**

**Build Variant Modules:**
```kotlin
// debug/DebugModule.kt
@Module
@InstallIn(SingletonComponent::class)
object DebugModule {
    
    @Provides
    @Singleton
    fun provideLoggingInterceptor(): Interceptor {
        return HttpLoggingInterceptor().apply {
            level = HttpLoggingInterceptor.Level.BODY
        }
    }
}

// release/ReleaseModule.kt
@Module
@InstallIn(SingletonComponent::class)
object ReleaseModule {
    
    @Provides
    @Singleton
    fun provideLoggingInterceptor(): Interceptor {
        return Interceptor { chain ->
            // No logging in release
            chain.proceed(chain.request())
        }
    }
}
```

#### **7. Module Organization**

**Recommended Structure:**
```
app/
├── di/
│   ├── AppModule.kt           // App-wide dependencies
│   ├── NetworkModule.kt       // Retrofit, OkHttp
│   ├── DatabaseModule.kt      // Room
│   ├── RepositoryModule.kt    // Repositories
│   ├── UseCaseModule.kt       // Use cases
│   ├── DispatcherModule.kt    // Coroutine dispatchers
│   └── AnalyticsModule.kt     // Analytics
│
├── data/
│   ├── repository/
│   ├── remote/
│   └── local/
│
├── domain/
│   ├── usecase/
│   └── repository/
│
└── ui/
    ├── screen/
    └── viewmodel/
```

#### **8. Advanced Patterns**

**Factory Pattern with Assisted Inject:**
```kotlin
class UserDetailsViewModel @AssistedInject constructor(
    @Assisted private val userId: String,
    private val repository: UserRepository
) : ViewModel() {
    
    @AssistedFactory
    interface Factory {
        fun create(userId: String): UserDetailsViewModel
    }
    
    fun loadUser() {
        viewModelScope.launch {
            repository.getUser(userId)
        }
    }
}

// Usage
@AndroidEntryPoint
class UserDetailsFragment : Fragment() {
    
    @Inject
    lateinit var viewModelFactory: UserDetailsViewModel.Factory
    
    private val viewModel by viewModels<UserDetailsViewModel> {
        object : ViewModelProvider.Factory {
            override fun <T : ViewModel> create(modelClass: Class<T>): T {
                @Suppress("UNCHECKED_CAST")
                return viewModelFactory.create(userId) as T
            }
        }
    }
}
```

#### **9. Best Practices**
✅ Organize modules by feature
✅ Use @Binds over @Provides when possible
✅ Keep modules small and focused
✅ Use proper scopes
✅ Don't create circular dependencies
✅ Use qualifiers untuk disambiguation
✅ Document complex dependencies
✅ Group related dependencies together

---
