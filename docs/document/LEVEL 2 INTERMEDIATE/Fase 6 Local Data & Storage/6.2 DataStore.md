## **6.2 DataStore** (4 hari) ⭐⭐⭐

### **Teknologi Modern:**
- Preferences DataStore
- Proto DataStore

### **Teknologi yang Ditinggalkan:**
- SharedPreferences

### **Sub-topik Detail:**

#### 1. Pengenalan DataStore
- Modern replacement untuk SharedPreferences
- Asynchronous API dengan Kotlin Coroutines & Flow
- Type-safe dengan Proto DataStore
- Transactional updates
- Data consistency guarantees
- Error handling

**DataStore vs SharedPreferences:**

**SharedPreferences Issues:**
❌ Synchronous API (blocks UI thread)
❌ No type safety
❌ No error handling
❌ Runtime exceptions
❌ No transactional updates

**DataStore Advantages:**
✅ Asynchronous (Coroutines & Flow)
✅ Type-safe (Proto DataStore)
✅ Handles errors gracefully
✅ Transactional
✅ Data consistency

#### 2. Setup DataStore

**Dependencies:**
```kotlin
dependencies {
    // Preferences DataStore
    implementation("androidx.datastore:datastore-preferences:1.0.0")
    
    // Proto DataStore (optional)
    implementation("androidx.datastore:datastore:1.0.0")
    implementation("com.google.protobuf:protobuf-javalite:3.21.12")
}

// For Proto DataStore
plugins {
    id("com.google.protobuf") version "0.9.4"
}

protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:3.21.12"
    }
    generateProtoTasks {
        all().forEach { task ->
            task.builtins {
                create("java") {
                    option("lite")
                }
            }
        }
    }
}
```

#### 3. Preferences DataStore

**Create DataStore:**
```kotlin
// Using delegate
val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "settings")

// Or manual creation
private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(
    name = "settings",
    produceMigrations = { context ->
        listOf(SharedPreferencesMigration(context, "old_prefs"))
    }
)
```

**Define Keys:**
```kotlin
object PreferencesKeys {
    val USER_NAME = stringPreferencesKey("user_name")
    val USER_EMAIL = stringPreferencesKey("user_email")
    val IS_LOGGED_IN = booleanPreferencesKey("is_logged_in")
    val THEME_MODE = intPreferencesKey("theme_mode")
    val NOTIFICATION_ENABLED = booleanPreferencesKey("notification_enabled")
    val LAST_SYNC_TIME = longPreferencesKey("last_sync_time")
}
```

**Write Data:**
```kotlin
class UserPreferencesRepository(
    private val dataStore: DataStore<Preferences>
) {
    suspend fun saveUserName(name: String) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.USER_NAME] = name
        }
    }
    
    suspend fun saveUserData(name: String, email: String) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.USER_NAME] = name
            preferences[PreferencesKeys.USER_EMAIL] = email
            preferences[PreferencesKeys.IS_LOGGED_IN] = true
        }
    }
    
    suspend fun setThemeMode(mode: Int) {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.THEME_MODE] = mode
        }
    }
    
    suspend fun clearAllData() {
        dataStore.edit { preferences ->
            preferences.clear()
        }
    }
}
```

**Read Data:**
```kotlin
class UserPreferencesRepository(
    private val dataStore: DataStore<Preferences>
) {
    // Read as Flow
    val userNameFlow: Flow<String> = dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.USER_NAME] ?: ""
        }
    
    val isLoggedInFlow: Flow<Boolean> = dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.IS_LOGGED_IN] ?: false
        }
    
    val themeModeFlow: Flow<Int> = dataStore.data
        .map { preferences ->
            preferences[PreferencesKeys.THEME_MODE] ?: 0 // 0 = system default
        }
    
    // Read once
    suspend fun getUserName(): String {
        val preferences = dataStore.data.first()
        return preferences[PreferencesKeys.USER_NAME] ?: ""
    }
    
    suspend fun isLoggedIn(): Boolean {
        val preferences = dataStore.data.first()
        return preferences[PreferencesKeys.IS_LOGGED_IN] ?: false
    }
}
```

**Complex Data Class:**
```kotlin
data class UserPreferences(
    val userName: String,
    val email: String,
    val isLoggedIn: Boolean,
    val themeMode: Int,
    val notificationEnabled: Boolean,
    val lastSyncTime: Long
)

val userPreferencesFlow: Flow<UserPreferences> = dataStore.data
    .catch { exception ->
        if (exception is IOException) {
            emit(emptyPreferences())
        } else {
            throw exception
        }
    }
    .map { preferences ->
        UserPreferences(
            userName = preferences[PreferencesKeys.USER_NAME] ?: "",
            email = preferences[PreferencesKeys.USER_EMAIL] ?: "",
            isLoggedIn = preferences[PreferencesKeys.IS_LOGGED_IN] ?: false,
            themeMode = preferences[PreferencesKeys.THEME_MODE] ?: 0,
            notificationEnabled = preferences[PreferencesKeys.NOTIFICATION_ENABLED] ?: true,
            lastSyncTime = preferences[PreferencesKeys.LAST_SYNC_TIME] ?: 0L
        )
    }
```

#### 4. Proto DataStore

**Define Proto Schema:**
```protobuf
// user_prefs.proto
syntax = "proto3";

option java_package = "com.example.app";
option java_multiple_files = true;

message UserPreferences {
  string user_name = 1;
  string email = 2;
  bool is_logged_in = 3;
  int32 theme_mode = 4;
  bool notification_enabled = 5;
  int64 last_sync_time = 6;
  repeated string favorite_categories = 7;
}
```

**Serializer:**
```kotlin
object UserPreferencesSerializer : Serializer<UserPreferences> {
    override val defaultValue: UserPreferences = UserPreferences.getDefaultInstance()
    
    override suspend fun readFrom(input: InputStream): UserPreferences {
        try {
            return UserPreferences.parseFrom(input)
        } catch (exception: InvalidProtocolBufferException) {
            throw CorruptionException("Cannot read proto.", exception)
        }
    }
    
    override suspend fun writeTo(t: UserPreferences, output: OutputStream) {
        t.writeTo(output)
    }
}
```

**Create Proto DataStore:**
```kotlin
val Context.userPreferencesDataStore: DataStore<UserPreferences> by dataStore(
    fileName = "user_prefs.pb",
    serializer = UserPreferencesSerializer
)
```

**Read & Write:**
```kotlin
class UserPreferencesRepository(
    private val dataStore: DataStore<UserPreferences>
) {
    val userPreferencesFlow: Flow<UserPreferences> = dataStore.data
        .catch { exception ->
            if (exception is IOException) {
                emit(UserPreferences.getDefaultInstance())
            } else {
                throw exception
            }
        }
    
    suspend fun updateUserName(name: String) {
        dataStore.updateData { currentPrefs ->
            currentPrefs.toBuilder()
                .setUserName(name)
                .build()
        }
    }
    
    suspend fun setLoggedIn(isLoggedIn: Boolean) {
        dataStore.updateData { currentPrefs ->
            currentPrefs.toBuilder()
                .setIsLoggedIn(isLoggedIn)
                .build()
        }
    }
    
    suspend fun addFavoriteCategory(category: String) {
        dataStore.updateData { currentPrefs ->
            currentPrefs.toBuilder()
                .addFavoriteCategories(category)
                .build()
        }
    }
    
    suspend fun clearPreferences() {
        dataStore.updateData {
            UserPreferences.getDefaultInstance()
        }
    }
}
```

#### 5. Migration from SharedPreferences

```kotlin
private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(
    name = "settings",
    produceMigrations = { context ->
        listOf(
            SharedPreferencesMigration(
                context = context,
                sharedPreferencesName = "old_preferences",
                keysToMigrate = setOf(
                    "user_name",
                    "user_email",
                    "is_logged_in"
                )
            ) { sharedPrefs: SharedPreferencesView, currentData: Preferences ->
                // Custom migration logic if needed
                if (currentData[PreferencesKeys.USER_NAME] == null) {
                    val name = sharedPrefs.getString("user_name", "")
                    currentData.toMutablePreferences().apply {
                        this[PreferencesKeys.USER_NAME] = name ?: ""
                    }.toPreferences()
                } else {
                    currentData
                }
            }
        )
    }
)
```

#### 6. Error Handling

```kotlin
val userPreferencesFlow: Flow<UserPreferences> = dataStore.data
    .catch { exception ->
        when (exception) {
            is IOException -> {
                Log.e("DataStore", "Error reading preferences", exception)
                emit(emptyPreferences())
            }
            else -> throw exception
        }
    }
    .map { preferences ->
        // Map to domain model
        UserPreferences(
            userName = preferences[PreferencesKeys.USER_NAME] ?: "",
            // ... other fields
        )
    }

suspend fun saveUserNameSafe(name: String): Result<Unit> {
    return try {
        dataStore.edit { preferences ->
            preferences[PreferencesKeys.USER_NAME] = name
        }
        Result.success(Unit)
    } catch (e: IOException) {
        Log.e("DataStore", "Error writing preferences", e)
        Result.failure(e)
    }
}
```

#### 7. Using DataStore with Hilt

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DataStoreModule {
    
    @Provides
    @Singleton
    fun providePreferencesDataStore(
        @ApplicationContext context: Context
    ): DataStore<Preferences> {
        return PreferenceDataStoreFactory.create(
            produceFile = {
                context.preferencesDataStoreFile("settings")
            }
        )
    }
    
    @Provides
    @Singleton
    fun provideUserPreferencesDataStore(
        @ApplicationContext context: Context
    ): DataStore<UserPreferences> {
return DataStoreFactory.create(
            serializer = UserPreferencesSerializer,
            produceFile = {
                context.dataStoreFile("user_prefs.pb")
            }
        )
    }
}
```

#### 8. Usage in ViewModel

```kotlin
class SettingsViewModel(
    private val preferencesRepository: UserPreferencesRepository
) : ViewModel() {
    
    val userPreferences: StateFlow<UserPreferences> = preferencesRepository
        .userPreferencesFlow
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = UserPreferences()
        )
    
    fun updateUserName(name: String) {
        viewModelScope.launch {
            preferencesRepository.saveUserName(name)
        }
    }
    
    fun setThemeMode(mode: Int) {
        viewModelScope.launch {
            preferencesRepository.setThemeMode(mode)
        }
    }
    
    fun toggleNotifications(enabled: Boolean) {
        viewModelScope.launch {
            preferencesRepository.setNotificationEnabled(enabled)
        }
    }
}
```

#### 9. UI Integration (Compose)

```kotlin
@Composable
fun SettingsScreen(
    viewModel: SettingsViewModel = hiltViewModel()
) {
    val userPrefs by viewModel.userPreferences.collectAsState()
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Theme selection
        Text("Theme Mode")
        RadioGroup(
            selected = userPrefs.themeMode,
            onSelected = { viewModel.setThemeMode(it) },
            options = listOf(
                0 to "System Default",
                1 to "Light",
                2 to "Dark"
            )
        )
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // Notification toggle
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text("Enable Notifications")
            Switch(
                checked = userPrefs.notificationEnabled,
                onCheckedChange = { viewModel.toggleNotifications(it) }
            )
        }
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // User info
        OutlinedTextField(
            value = userPrefs.userName,
            onValueChange = { viewModel.updateUserName(it) },
            label = { Text("User Name") },
            modifier = Modifier.fillMaxWidth()
        )
    }
}
```

#### 10. Best Practices
✅ Use Proto DataStore untuk complex data structures
✅ Use Preferences DataStore untuk simple key-value
✅ Always handle IOException
✅ Use Flow untuk reactive updates
✅ Migrate from SharedPreferences
✅ Don't store large datasets (use Room instead)
✅ Use Hilt untuk dependency injection
✅ Collect flows dalam proper lifecycle scope
✅ Handle default values gracefully
✅ Test DataStore operations

#### 11. Testing DataStore

```kotlin
@Test
fun testSaveAndReadUserName() = runTest {
    // Given
    val testDataStore = PreferenceDataStoreFactory.create(
        scope = TestScope(UnconfinedTestDispatcher()),
        produceFile = { testFile }
    )
    val repository = UserPreferencesRepository(testDataStore)
    
    // When
    repository.saveUserName("Test User")
    val userName = repository.userNameFlow.first()
    
    // Then
    assertEquals("Test User", userName)
}
```

#### 12. Hands-on Project
- Setup Preferences DataStore
- Implement settings screen
- Proto DataStore untuk complex data
- Migration from SharedPreferences
- Integration dengan ViewModel
- Error handling
- Testing
- UI reactive updates

---
